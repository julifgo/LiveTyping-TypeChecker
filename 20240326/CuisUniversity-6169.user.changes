

----STARTUP---- (26 February 2024 20:02:52) as C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!


----End fileIn of C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\LiveTypingGenerics.pck.st----!

----End fileIn of C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\LiveTypingTypeChecker.pck.st----!

----End fileIn of C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\LiveTypingTypeChecker.st----!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 2/26/2024 20:29:51'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 2/26/2024 20:29:52'!
PASSED!

----SNAPSHOT----(26 February 2024 20:29:58) CuisUniversity-6169.image priorSource: 6245038!
!VariableTypeInfo methodsFor: 'printing' stamp: 'JFGO 2/26/2024 20:38:17' prior: 50501099!
printTypesUpTo: aNumberOfTypes
	
	"^String streamContents: [ :stream | self printTypesOn: stream upTo: aNumberOfTypes]"
	^'Julian'.! !
!VariableTypeInfo methodsFor: 'printing' stamp: 'HAW 7/11/2019 16:42:32' prior: 50539294!
printTypesUpTo: aNumberOfTypes
	
	^String streamContents: [ :stream | self printTypesOn: stream upTo: aNumberOfTypes]! !

----SNAPSHOT----(26 February 2024 21:03:13) CuisUniversity-6169.image priorSource: 6644483!
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:25:50' prior: 50500765!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	"types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons."
	types := RawToLiveTypesAdapter new adapt: #('Julian') .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !

parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.!

RawToLiveTypesAdapter new adapt: #('Julian')!
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:28:20' prior: 50539312!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	"types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons."
	types := Set new add: (RawToLiveTypesAdapter new adapt: #('Julian')) .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:28:40' prior: 50539330!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	"types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons."
	types := Set new add: (RawToLiveTypesAdapter new adapt: #(SmallInteger)) .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:29:19' prior: 50539343!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	"types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons."
	types := Set new add: (RawToLiveTypesAdapter new adapt: #(FixedType for: SmallInteger)) .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !

String streamContents: [ :stream | self printTypesOn: stream upTo: aNumberOfTypes]!

self types!
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:30:47' prior: 50539357!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	"types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons."
	types := Set new add: (FixedType for: SmallInteger) .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:31:25' prior: 50539374!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	types := Set new add: (FixedType for: SmallInteger) .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:31:55' prior: 50539387!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	types := Set new add: (FixedType for: SmallInteger) .
	self shouldBeImplemented .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 2/27/2024 18:32:28'!
PASSED!

parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons!

self methodVariablesTypes!
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:43:55' prior: 50539400!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	"types := Set new add: (FixedType for: SmallInteger) .
	self shouldBeImplemented ."
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:45:18' prior: 50539484!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	types := Set new add: (FixedType for: SmallInteger) .
	self shouldBeImplemented .
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 2/27/2024 18:45:36' prior: 50539498!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	"types := Set new add: (FixedType for: SmallInteger) .
	self shouldBeImplemented ."
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 2/27/2024 18:47:12' prior: 50506957!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class
self halt.
	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !

model actualContents string!

model!

self codeProvider!
!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 2/27/2024 19:58:12' prior: 50539525!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 2/27/2024 20:11:25' prior: 50539541!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class
self halt.
	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !

----QUIT----(27 February 2024 20:26:30) CuisUniversity-6169.image priorSource: 6645048!

----STARTUP---- (5 March 2024 19:14:55) as C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!

!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 3/5/2024 19:19:14' prior: 50539555!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 3/5/2024 19:19:45' prior: 50539577!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class
self halt.
	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 3/5/2024 19:20:17' prior: 50539591!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !

sourceRanges!

self key!

self key class!

self key class!
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 19:47:52' prior: 16853845!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 19:48:31' prior: 50539621!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |
	
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

sourceRanges!

nodeAtRange!

self key!

self key!

sourceRanges!

nodeAtRange key!

nodeAtRange!

self key class!

sourceRanges!

self array!

self array first!

self array first key!

self array first key class!

self array first key!

self array detect:[:nodeRange | nodeRange key class = BlockNode]!

self array select:[:nodeRange | nodeRange key class = BlockNode]!

self array select:[:nodeRange | nodeRange key class = BlockNode]!

self array!

sourceRanges!

sourceRanges!

sourceRanges!

self select:[:nodeRange | nodeRange key class = BlockNode]!

self select:[:nodeRange | nodeRange isNil not and: [nodeRange key class = BlockNode]]!
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 20:22:43' prior: 50539644!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |
	
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key].
	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key].!
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 20:24:42' prior: 50539687!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition blockNodes |
	
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	blockNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = BlockNode ifTrue:[blockNodes add: nodeAtRange key.]].
	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

blockNodes!
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 20:26:16' prior: 50539714!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition blockNodes |
	
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	blockNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = BlockNode ifTrue:[blockNodes add: nodeAtRange.]].
	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

blockNodes!

sourceRanges!

blockNodes!

self third!

self third key!

nodeAtRange!

self key class!

blockNodes!
!Encoder methodsFor: 'source mapping' stamp: 'HAW 12/18/2018 19:03:40' prior: 50539743!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |

	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'HAW 12/1/2018 20:11:44' prior: 50539512!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 19:47:52' prior: 50539775!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 20:53:44' prior: 50539809!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |
	
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

sourceRanges!

self keys!

self keys at: 1!

self keys at: 2!

self keys at: 3!

self keys at: 4!

self keys at: 5!

self keys at: 6!

self keys at: 7!

self keys at: 8!

self keys at: 9!

self keys at: 10!

self keys at: 11!

self keys at: 12!

self keys at: 13!

self keys at: 13!

self arguments second!

self arguments second!

self arguments first!

self arguments first!
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 21:11:51' prior: 50539832!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition messageNodes |
	
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

messageNodes!
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/5/2024 21:17:53' prior: 50539867!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition messageNodes |
	"self halt".
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

----SNAPSHOT----(5 March 2024 21:18:57) CuisUniversity-6169.image priorSource: 6653367!

----QUIT----(5 March 2024 21:18:59) CuisUniversity-6169.image priorSource: 6664749!

----STARTUP---- (6 March 2024 17:18:15) as C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!

!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/6/2024 17:25:28' prior: 50539896!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition messageNodes |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/6/2024 17:25:41' prior: 50539935!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition messageNodes |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 3/6/2024 17:58:25'!
parseBlockNodeIncluding: aPosition

	| smallestRangeSize nodeWithRangeAtPosition messageNodes |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition
			! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 12/18/2018 19:03:40' prior: 50539964!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |

	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:00:09' prior: 50539992!
parseBlockNodeIncluding: aPosition

	| smallestRangeSize blockNodeWithRangeAtPosition messageNodes |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeWithRangeAtPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					blockNodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ blockNodeWithRangeAtPosition
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:02:57' prior: 50540041!
parseBlockNodeIncluding: aPosition

	| smallestRangeSize blockNodeWithRangeAtPosition messageNodes closestMessageNodeToPosition messageNodeWithRangeAtPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	messageNodeWithRangeAtPosition := nil.
	closestMessageNodeToPosition := nil.
	messageNodes := OrderedCollection new.
	sourceRanges associationsDo: [ :nodeAtRange | nodeAtRange key class = MessageNode ifTrue:[messageNodes add: nodeAtRange.]].

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					blockNodeWithRangeAtPosition := nodeAtRange key ]]].

	^ blockNodeWithRangeAtPosition
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:11:22' prior: 50540068!
parseBlockNodeIncluding: aPosition

	| smallestRangeSize blockNodeWithRangeAtPosition closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].

	^ closestMessageNodeToPosition
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:11:41' prior: 50540098!
parseBlockNodeIncluding: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].

	^ closestMessageNodeToPosition
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:13:42'!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].

	^ closestMessageNodeToPosition
			! !

!methodRemoval: Encoder #parseBlockNodeIncluding: stamp: 'JFGO 3/6/2024 18:13:42'!
parseBlockNodeIncluding: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].

	^ closestMessageNodeToPosition
			!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:19:41' prior: 50540149!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		
	]

	^ blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:20:49' prior: 50540199!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	]

	^ blockNodeClosestToPosition.
			! !
!MethodNode methodsFor: 'source mapping' stamp: 'JFGO 3/6/2024 18:26:40' prior: 16901923!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition .
	^aBlock value: nodeAndPosition key.! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:31:23' prior: 50540228!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	]

	^ blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:32:32' prior: 50540271!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	]

	^ blockNodeClosestToPosition.
			! !
!MethodNode methodsFor: 'source mapping' stamp: 'JFGO 3/6/2024 18:33:54'!
parseBlockNodeWhenBranchIsIn: aPosition
	
	^encoder parseBlockNodeWhenBranchIsIn: aPosition.
! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:34:06' prior: 50540301!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	]

	^ blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:34:20' prior: 50540337!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	]

	^ blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:35:06' prior: 50540367!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	]

	^blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 18:35:18' prior: 50540397!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	].

	^blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:04:01' prior: 50540427!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	].

	^blockNodeClosestToPosition.
			! !

self isNil!

self isNotNil!

self isNil not!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:04:43' prior: 50540457!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNotNil and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	].

	^blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:05:00' prior: 50540489!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	].

	^blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:05:04' prior: 50540519!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	self halt.
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	].

	^blockNodeClosestToPosition.
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:05:13' prior: 50540550!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | ].
	].

	^blockNodeClosestToPosition.
			! !

closestMessageNodeToPosition arguments!

self equivalentTo: BlockNode empty!

self equivalentTo: BlockNode empty!

self equivalentTo: BlockNode empty!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:09:58' prior: 50540580!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					
				]].
	].

	^blockNodeClosestToPosition.
			! !

closestMessageNodeToPosition arguments!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/6/2024 19:12:20' prior: 50540615!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	"self halt."
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition.
			! !

----SNAPSHOT----(6 March 2024 19:15:36) CuisUniversity-6169.image priorSource: 6664838!

----QUIT----(6 March 2024 19:15:38) CuisUniversity-6169.image priorSource: 6689086!

----STARTUP---- (7 March 2024 16:48:17) as C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!

!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 16:49:21' prior: 50540649!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition.
			! !
!MethodNode methodsFor: 'source mapping' stamp: 'JFGO 3/7/2024 16:57:52' prior: 50540258!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	self halt.
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition .
	^aBlock value: nodeAndPosition key.! !
!MethodNode methodsFor: 'source mapping' stamp: 'JFGO 3/7/2024 17:01:46' prior: 50540731!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	"self halt."
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition .
	^aBlock value: nodeAndPosition key.! !
!MethodNode methodsFor: 'source mapping' stamp: 'JFGO 3/7/2024 17:19:14'!
withParseNodeAndBlockNodeIncluding: aPosition do: aBlock ifBlockNodeAbsent: anAbsentBlockNodeBlock ifParseNodeAbsent: anAbsentParseNodeBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentParseNodeBlock value ].
	"self halt."
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition .
	^aBlock value: nodeAndPosition key.! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:56:13' prior: 50540744!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	^aBlock value: nodeAndPosition key.! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:22:05' prior: 50540695!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	"^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ]"
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:22:45'!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	"^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ]"
			! !

!methodRemoval: Encoder #parseBlockNodeWhenBranchIsIn: stamp: 'JFGO 3/7/2024 17:22:45'!
parseBlockNodeWhenBranchIsIn: aPosition

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	"^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ]"
			!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:22:52' prior: 50540820!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:23:37' prior: 50540757!
withParseNodeAndBlockNodeIncluding: aPosition do: aBlock ifBlockNodeAbsent: anAbsentBlockNodeBlock ifParseNodeAbsent: anAbsentParseNodeBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentParseNodeBlock value ].
	"self halt."
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: [^anAbsentBlockNodeBlock value ].
	^aBlock value: nodeAndPosition key.! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:23:55' prior: 50540935!
withParseNodeAndBlockNodeIncluding: aPosition do: aBlock ifBlockNodeAbsent: anAbsentBlockNodeBlock ifParseNodeAbsent: anAbsentParseNodeBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentParseNodeBlock value ].
	"self halt."
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: [^anAbsentBlockNodeBlock value ].
	^aBlock value: nodeAndPosition key value: blockNodeContext .! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:41:10' prior: 50506938!
balloonTypeInfoInMethodAt: mousePositionInText

	^self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class ]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 
					mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]]]
		ifErrorsParsing: [ :anError | '' ]


! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:42:46' prior: 50540952!
withParseNodeAndBlockNodeIncluding: aPosition do: aBlock ifBlockNodeAbsent: anAbsentBlockNodeBlock ifParseNodeAbsent: anAbsentParseNodeBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentParseNodeBlock value ].
	"self halt."
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: [^anAbsentBlockNodeBlock value:  nodeAndPosition key].
	^aBlock value: nodeAndPosition key value: blockNodeContext .! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:44:01'!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 
	
	^encoder parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure .
! !

!methodRemoval: MethodNode #parseBlockNodeWhenBranchIsIn: stamp: 'JFGO 3/7/2024 17:44:04'!
parseBlockNodeWhenBranchIsIn: aPosition
	
	^encoder parseBlockNodeWhenBranchIsIn: aPosition.
!
!SmalltalkEditor methodsFor: '*LiveTyping' stamp: 'JFGO 3/7/2024 17:54:55'!
balloonTypeInfoOf: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 17:57:28' prior: 50540970!
balloonTypeInfoInMethodAt: mousePositionInText

	^self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class ]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 
					mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]]]
		ifErrorsParsing: [ :anError | '' ]


! !
!ParseNodeTypesDisplay class methodsFor: 'instance creation' stamp: 'JFGO 3/7/2024 18:28:23'!
of: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass

	^self new initliazeOf: aParseNodeToAnalize in: aMethodNodeOwner definedAt: aClass
! !
!ParseNodeTypesDisplay methodsFor: 'initialization' stamp: 'JFGO 3/7/2024 18:28:37'!
initliazeOf: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass

	parseNodeToAnalize := aParseNodeToAnalize.
	methodNodeOwner := aMethodNodeOwner.
	definingClass := aClass.
	methodToAnalyze := definingClass 
		compiledMethodAt: methodNodeOwner selector 
		ifAbsent: [ NotImplementedMethod class: definingClass selector: methodNodeOwner selector ].
	
! !

!classDefinition: #ParseNodeTypesDisplay category: #LiveTyping stamp: 'JFGO 3/7/2024 18:30:27'!
Object subclass: #ParseNodeTypesDisplay
	instanceVariableNames: 'parseNodeToAnalize methodNodeOwner definingClass methodToAnalyze types incompleteTypeInfoReasons typeInfo labels lines selectedIndex icons typesIndexLimit actions contextBlockNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping'!
!ParseNodeTypesDisplay methodsFor: 'initialization' stamp: 'JFGO 3/7/2024 18:30:25' prior: 50541073!
initliazeOf: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass

	parseNodeToAnalize := aParseNodeToAnalize.
	contextBlockNode:=aBlockNode.
	methodNodeOwner := aMethodNodeOwner.
	definingClass := aClass.
	methodToAnalyze := definingClass 
		compiledMethodAt: methodNodeOwner selector 
		ifAbsent: [ NotImplementedMethod class: definingClass selector: methodNodeOwner selector ].
	
! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 3/7/2024 18:31:32'!
calculateTypesWithContext

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 3/7/2024 18:31:54' prior: 50541117!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 18:32:20' prior: 50541025!
balloonTypeInfoOf: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class) 
		calculateTypesWithContext; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 18:51:41' prior: 50540994!
withParseNodeAndBlockNodeIncluding: aPosition do: aBlock ifBlockNodeAbsent: anAbsentBlockNodeBlock ifParseNodeAbsent: anAbsentParseNodeBlock

	| nodeAndPosition blockNodeContext |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentParseNodeBlock value ].
	blockNodeContext := self parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: [^anAbsentBlockNodeBlock value:  nodeAndPosition key].
	^aBlock value: nodeAndPosition key value: blockNodeContext .! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 3/7/2024 19:09:38' prior: 50541128!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'showing - private' stamp: 'JFGO 3/7/2024 19:10:23' prior: 50541177!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay class methodsFor: 'instance creation' stamp: 'JFGO 3/7/2024 19:10:51' prior: 50541065!
of: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass

	^self new initliazeOf: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass
! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:12:19' prior: 50541191!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:14:55' prior: 50541215!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:17:32' prior: 50541229!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:18:42' prior: 50541243!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:20:10' prior: 50540896!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:20:32' prior: 50541271!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:20:39' prior: 50541310!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:20:48' prior: 50541349!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

closestMessageNodeToPosition isAnyKindOfIf!

closestMessageNodeToPosition arguments!
!TypeCheckerDragonTestMethods methodsFor: 'with context filters' stamp: 'JFGO 3/7/2024 19:25:43'!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNAN
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: [v1 isEmpty] ifTrue: [v1 factorial] .! !
!TypeCheckerDragonTestMethods methodsFor: 'with context filters' stamp: 'JFGO 3/7/2024 19:26:19' prior: 50541430!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNAN
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: 	[ v1 isEmpty ] 	ifTrue: [ v1 factorial ] .! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:26:25' prior: 50541388!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:26:33' prior: 50541450!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

closestMessageNodeToPosition arguments!
!TypeCheckerDragonTestMethods methodsFor: 'with context filters' stamp: 'JFGO 3/7/2024 19:28:51'!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNANVERSION2
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: 	[ v1 isEmpty ] 	ifTrue: [ v1 factorial ] .! !
!TypeCheckerDragonTestMethods methodsFor: 'with context filters' stamp: 'JFGO 3/7/2024 19:29:18' prior: 50541529!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNANVERSION2
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger 
						ifFalse: 	[ v1 isEmpty ] 	
						ifTrue: [ v1 factorial ] .! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:29:27' prior: 50541489!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:29:36' prior: 50541549!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

closestMessageNodeToPosition arguments!
!TypeCheckerDragonTestMethods methodsFor: 'with context filters' stamp: 'JFGO 3/7/2024 19:30:57' prior: 50541539!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNANVERSION2
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: 	[ 
								v1 isEmpty 
							     ] 	
						 ifTrue: [ 
								v1 factorial 
							    ] .! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:32:06' prior: 50541588!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/7/2024 19:32:14' prior: 50541640!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

closestMessageNodeToPosition arguments!

----SNAPSHOT----(7 March 2024 19:33:42) CuisUniversity-6169.image priorSource: 6689175!

----SNAPSHOT----(7 March 2024 19:34:48) CuisUniversity-6169.image priorSource: 6722172!

----SNAPSHOT----(7 March 2024 19:35:04) CuisUniversity-6169.image priorSource: 6722261!
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:41:55' prior: 50541257!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:42:37' prior: 50541728!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:44:04' prior: 50541679!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:44:21' prior: 50541756!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

closestMessageNodeToPosition arguments!

sourceRanges!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:47:21' prior: 50541795!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:47:27' prior: 50541836!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

closestMessageNodeToPosition!

self isNil!

self notNil!

sourceRanges!

sourceRanges!

sourceRanges!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 09:53:13' prior: 50541875!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	"self completeSourceRangesBasedOn: sourceCode"
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

----SNAPSHOT----(8 March 2024 09:56:29) CuisUniversity-6169.image priorSource: 6722350!

----QUIT----(8 March 2024 10:08:30) CuisUniversity-6169.image priorSource: 6729793!

----STARTUP---- (8 March 2024 18:10:46) as C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!

!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:29:23' prior: 50541917!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:34:17' prior: 50541968!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:35:40'!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure withSourceRanges: aSourceRanges

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:35:46' prior: 50542048!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure withSourceRanges: aSourceRanges

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	aSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:36:17' prior: 50541012!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 
	
	^encoder parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure withSourceRanges: self completeSourceRanges .
! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:37:20' prior: 50542130!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 
	
	self completeSourceRanges .
	^encoder parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure .
! !

!methodRemoval: Encoder #parseBlockNodeWhenBranchIsIn:ifAbsent:withSourceRanges: stamp: 'JFGO 3/8/2024 18:37:26'!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure withSourceRanges: aSourceRanges

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	aSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:37:35' prior: 50542008!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:48:45' prior: 50542190!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:48:52' prior: 50542230!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

completeSourceRanges!
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:51:07' prior: 50542270!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	self halt.
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:51:14' prior: 50542311!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeClosestToPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeClosestToPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeClosestToPosition:= blockNode.]
				]].
	].

	^blockNodeClosestToPosition ifNil: aBlockClosure ifNotNil: [ blockNodeClosestToPosition ].
			! !

completeSourceRanges!
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:52:19' prior: 50542140!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 
	"Load complete source ranges to detect block nodes properly. Julian"
	self completeSourceRanges .
	^encoder parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure .
! !
!MethodNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:52:33' prior: 50542392!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 
	
	self completeSourceRanges ."Load complete source ranges to detect block nodes properly. Julian"
	^encoder parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure .
! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:53:41' prior: 50542351!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize closestMessageNodeToPosition blockNodeWrappingAPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeWrappingAPosition := nil.
	closestMessageNodeToPosition := nil.
	"self halt."
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = MessageNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						closestMessageNodeToPosition := nodeAtRange key ]]
			]
		].
	self completeSourceRangesBasedOn: ''.
	(closestMessageNodeToPosition isNil not and: [closestMessageNodeToPosition isAnyKindOfIf]) ifTrue:[
		closestMessageNodeToPosition arguments do: [:blockNode | (blockNode equivalentTo: BlockNode empty) ifFalse:[
					(aPosition between: blockNode tempsMark and: blockNode startOfLastStatement ) ifTrue:[blockNodeWrappingAPosition:= blockNode.]
				]].
	].

	^blockNodeWrappingAPosition ifNil: aBlockClosure ifNotNil: [ blockNodeWrappingAPosition ].
			! !
!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:54:37' prior: 50542414!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize blockNodeWrappingAPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeWrappingAPosition := nil.
	
	"self halt."
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = BlockNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						blockNodeWrappingAPosition := nodeAtRange key ]]
			]
		].
	
	^blockNodeWrappingAPosition ifNil: aBlockClosure ifNotNil: [ blockNodeWrappingAPosition ].
			! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:57:08' prior: 50541040!
balloonTypeInfoInMethodAt: mousePositionInText

	^self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| 
					self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class 
				]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 	mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]
				]]
		ifErrorsParsing: [ :anError | '' ]


! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:57:13' prior: 50542480!
balloonTypeInfoInMethodAt: mousePositionInText

	^self withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| 
					self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class 
				]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 	mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]
				]]
		ifErrorsParsing: [ :anError | '' ]


! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 18:58:46' prior: 50541742!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 19:00:37' prior: 50542532!
calculateTypesWithContext
"TODO. Here, we should have the contextBlockNode of the node...Julian"
	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 19:00:43' prior: 50542546!
calculateTypesWithContext

	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNAN stamp: 'JFGO 3/8/2024 19:00:55'!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNAN
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: 	[ v1 isEmpty ] 	ifTrue: [ v1 factorial ] .!

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNANVERSION2 stamp: 'JFGO 3/8/2024 19:00:57'!
typeCastIfFalseIfTrueDELETEJUSTTODEBUGANDSHOWHERNANVERSION2
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: 	[ 
								v1 isEmpty 
							     ] 	
						 ifTrue: [ 
								v1 factorial 
							    ] .!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/8/2024 19:01:08'!
PASSED!
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 19:02:44' prior: 50542560!
calculateTypesWithContext

	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/8/2024 19:03:09' prior: 50542660!
calculateTypesWithContext

	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !

----QUIT----(8 March 2024 19:04:43) CuisUniversity-6169.image priorSource: 6729882!

----STARTUP---- (12 March 2024 18:00:53) as C:\Users\julian.gutierrez\OneDrive - HEXACTA S.A\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!


----QUIT----(12 March 2024 18:01:44) CuisUniversity-6169.image priorSource: 6753026!

----STARTUP---- (12 March 2024 18:08:07) as H:\My Drive\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!

!Encoder methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/12/2024 18:25:33' prior: 50542454!
parseBlockNodeWhenBranchIsIn: aPosition ifAbsent: aBlockClosure 

	| smallestRangeSize blockNodeWrappingAPosition |
	smallestRangeSize := SmallInteger maxVal.
	blockNodeWrappingAPosition := nil.
	
	completeSourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = BlockNode ifTrue: [
				self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
					currentNodeRangeSize := aRange size.
					currentNodeRangeSize < smallestRangeSize ifTrue: [
						smallestRangeSize := currentNodeRangeSize.
						blockNodeWrappingAPosition := nodeAtRange key ]]
			]
		].
	
	^blockNodeWrappingAPosition ifNil: aBlockClosure ifNotNil: [ blockNodeWrappingAPosition ].
			! !

!testRun: #InstanceVariableTypeInfoTest #test01TypeCollectionOfInstanceVariableDefinedInLeafClassDoesNotTraverseHierarchy stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test02TypeCollectionIncludesSubclasses stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test03TypeCollectionDoesNotIncludeSuperclassesAndSiblings stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test05TypeCollectionIncludesAllSubclasses stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test06IsNotMegamorphicIfTypesSizeIsLessToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test07IsMegamorphicIfTypesSizeIsEqualToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test08IsNotMegamorphicIfDoesNotFillRawTypesForLocalTypeInfo stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test09IsMegamorphicIfFillsRawTypesOfDefiningClassForLocalTypeInfo stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test10IsMegamorphicIfFillsRawTypesOfNotDefiningClassForLocalTypeInfo stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test11IsTypesEmptyOfNonLocalTypeInfoTakesCareOfHierarchy stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test12IsTypesEmptyForLocalTypeInfoOnlyCheckOnLocalRawTypes stamp: 'JFGO 3/12/2024 18:43:47'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 3/12/2024 18:43:47'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 3/12/2024 18:43:48'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #InstanceVariableTypeInfoTest #test13RemovingAClassRemovesItAndItsClassFromInstanceVariableRawTypes stamp: 'JFGO 3/12/2024 18:43:48'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test14InstVarAtPutKeepTypeInfo stamp: 'JFGO 3/12/2024 18:43:48'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test01InstanceVariablesTypesIsInitializedWithAnArrayOfClassInstSize stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test02InitializeInstanceVariablesTypesWithAllInstancesStoreCurrentClassInstancesTypes stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test03TypesOfDifferentInstVarsAreStoredCorrectly stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test04MoreThanOneTypeAreStoredCorrectlyInDifferentInstVars stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test05TypesAreStoredUpToInstVarTypesSize stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test06NoTypesAreStoredWhenInstVarTypesIsNil stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test07CommonSupertypeOfReturnsSupertypeOfStoredTypes stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test08CommonSupertypeIfNoTypesEvaluatesAlternativeBlockWhenNoTypeHasBeenStore stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test09EvaluatesIfAbsentBlockWhenAskTypeInfoForNonExistingInstVar stamp: 'JFGO 3/12/2024 18:43:51'!
PASSED!

TestCase subclass: #TypesWithContextAppliersTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers-Tests'!

!classDefinition: #TypesWithContextAppliersTest category: #'LiveTypingTypeChecker-ContextAppliers-Tests' stamp: 'JFGO 3/12/2024 18:47:42'!
TestCase subclass: #TypesWithContextAppliersTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers-Tests'!

Object subclass: #TypesWithContextAppliersTestMethods
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers-Tests'!

!classDefinition: #TypesWithContextAppliersTestMethods category: #'LiveTypingTypeChecker-ContextAppliers-Tests' stamp: 'JFGO 3/12/2024 18:54:09'!
Object subclass: #TypesWithContextAppliersTestMethods
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers-Tests'!
!TypesWithContextAppliersTest methodsFor: 'nil' stamp: 'JFGO 3/12/2024 18:56:28'!
test01XX! !

compiledMethod := TypeCheckerDragonTestMethods >> #typeCastIfFalseIfTrue.!

compiledMethod decompile !

compiledMethod!

compiledMethod embeddedBlockClosures!

compiledMethod scanner!

compiledMethod getSource!

compiledMethod literals!

compiledMethod scanner!

compiledMethod node !

compiledMethod methodNode !

mNode:=compiledMethod methodNode.!

mNode completeSourceRanges .!

mEncoder := mNode encoder.!

mEncoder completeSourceRangesBasedOn: mNode sourceText.!
!TypesWithContextAppliersTestMethods methodsFor: 'nil' stamp: 'JFGO 3/12/2024 19:31:23'!
typeCastIfTrueIfFalse
! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:31:51' prior: 50542869!
test01XX

| compiledMethod mEncoder mNode |
compiledMethod := TypeCheckerDragonTestMethods >> #typeCastIfFalseIfTrue.
mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
mEncoder completeSourceRangesBasedOn: mNode sourceText.
self assert:true.! !
!TypesWithContextAppliersTestMethods methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:32:44' prior: 50542887!
typeCastIfTrueIfFalse
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: [v1 isEmpty] ifTrue: [v1 factorial] .! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:33:44' prior: 50542892!
test01XX

| compiledMethod mEncoder mNode equivalentBlockNodeToCheck |

compiledMethod := TypeCheckerDragonTestMethods >> #typeCastIfFalseIfTrue.
equivalentBlockNodeToCheck := [nil factorial].
mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
mEncoder completeSourceRangesBasedOn: mNode sourceText.

self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:42:53' prior: 50542913!
test01XX

| compiledMethod mEncoder mNode equivalentBlockNodeToCheck sourceRanges |

compiledMethod := TypeCheckerDragonTestMethods >> #typeCastIfFalseIfTrue.

mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = BlockNode ifTrue: [
				
			]
		].


self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:43:11' prior: 50542927!
test01XX

| compiledMethod mEncoder mNode equivalentBlockNodeToCheck sourceRanges |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfFalseIfTrue.

mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = BlockNode ifTrue: [
				
			]
		].


self assert:true.! !

!testRun: #TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/12/2024 19:43:19'!
ERROR!
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:43:40' prior: 50542944!
test01XX

| compiledMethod mEncoder mNode equivalentBlockNodeToCheck sourceRanges |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.

mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		nodeAtRange key class = BlockNode ifTrue: [
				
			]
		].


self assert:true.! !

sourceRanges!

self code!

self sourceCodeRange !

nodeAtRange key!

self code !

self!

self class!

self code!

self printSourceCode !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:49:12' prior: 50542964!
test01XX

| compiledMethod mEncoder mNode equivalentBlockNodeToCheck sourceRanges blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest:=nil.
mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockToTestString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].


self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:52:31' prior: 50542986!
test01XX

| compiledMethod mEncoder mNode sourceRanges blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest:=nil.
mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockToTestString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].


self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:54:33'!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

| compiledMethod mEncoder mNode sourceRanges blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest:=nil.
mNode:=compiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockToTestString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].


self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:55:43' prior: 50543031!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

|  mEncoder mNode sourceRanges blockToTest  |


blockToTest:=nil.
mNode:=aCompiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].

blockToTest isNil ifTrue: [self failWith: ''].

self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:56:41' prior: 50543055!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

|  mEncoder mNode sourceRanges blockToTest  |


blockToTest:=nil.
mNode:=aCompiledMethod methodNode.
mEncoder := mNode encoder.
sourceRanges := mEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].

blockToTest isNotNil ifTrue: [^blockToTest].

self failWith: 'Block node not found'! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:57:21' prior: 50543076!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

|  nodeEncoder mNode sourceRanges blockToTest  |


blockToTest:=nil.
mNode:=aCompiledMethod methodNode.
nodeEncoder := mNode encoder.
sourceRanges := nodeEncoder completeSourceRangesBasedOn: mNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].

blockToTest isNotNil ifTrue: [^blockToTest].

self failWith: 'Block node not found'! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:57:33' prior: 50543097!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

|  nodeEncoder methodNode sourceRanges blockToTest  |


blockToTest:=nil.
methodNode:=aCompiledMethod methodNode.
nodeEncoder := methodNode encoder.
sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].

blockToTest isNotNil ifTrue: [^blockToTest].

self failWith: 'Block node not found'! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 19:58:37' prior: 50543009!
test01XX

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.


self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 20:01:50' prior: 50543141!
test01XX

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:true.! !

!testRun: #TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/12/2024 20:02:01'!
FAILURE!

nodeAtRange key printSourceCode = blockNodeCodeString!

!testRun: #TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/12/2024 20:04:06'!
FAILURE!

self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod!

blockToTest isNotNil!

blockToTest!

self isNil!

self isNotNil!

self notNil!
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/12/2024 20:05:52' prior: 50543119!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

|  nodeEncoder methodNode sourceRanges blockToTest  |


blockToTest:=nil.
methodNode:=aCompiledMethod methodNode.
nodeEncoder := methodNode encoder.
sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].

blockToTest notNil ifTrue: [^blockToTest].

self failWith: 'Block node not found'! !

----QUIT----(12 March 2024 20:06:14) CuisUniversity-6169.image priorSource: 6753260!

----STARTUP---- (13 March 2024 17:15:26) as H:\My Drive\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!

!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:15:40' prior: 50543154!
test01XX

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

"compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest."

self assert:true.! !

!testRun: #TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/13/2024 17:15:43'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/13/2024 17:15:43'!
PASSED!

compiledMethod typesOfVariableNamed: 'v1'!
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:18:48' prior: 50543210!
test01XX

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

"compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest."

self assert:true.! !

compiledMethod typesOfVariableNamed: 'v1'!
!TypesWithContextAppliersTestMethods methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:20:46'!
typeCastIfTrue
	|v1|
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 := 5.
	v1 class = SmallInteger ifTrue: [v1 factorial].! !
!TypesWithContextAppliersTestMethods methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:21:04'!
typeCastIfFalse
	|v1|
	v1 := 5.
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 class = SmallInteger ifFalse:[v1 isEmpty.]! !
!TypesWithContextAppliersTestMethods methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:21:29' prior: 50542904!
typeCastIfTrueIfFalse
	|v1|
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 := 5.
	v1 class = SmallInteger ifTrue: [v1 factorial] ifFalse: [v1 isEmpty].! !
!TypesWithContextAppliersTestMethods methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:21:51'!
typeCastIfFalseIfTrue
	|v1|
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 := 5.
	v1 class = SmallInteger ifFalse: [v1 isEmpty] ifTrue: [v1 factorial] .! !
!TypesWithContextAppliersTestMethods methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:22:15'!
typeCastIfFalseNested

	|v1|
	v1:= OrderedCollection new.
	v1 := Date today.
	v1 := 5.
	v1 := true.
	
	v1 class = SmallInteger ifFalse: [
		v1 class = OrderedCollection ifFalse: 		[
				v1 class = Date ifFalse:[
					v1 not.
				].
			].
		].! !
!TypeCheckerDragonTest methodsFor: 'assertions' stamp: 'JFGO 3/13/2024 17:24:05'!
performMethodWithClass: aClass andSelector: aSelector typeCheckAndAssert: anAssertionBlock
	
	| methodToCheck |
	methodToCheck := TypeCheckerDragonTestMethods >> aSelector.
	TypeCheckerDragonTestMethods new perform: aSelector.
	
	self typeCheckOn: methodToCheck andAssert: anAssertionBlock .
	
! !
!TypeCheckerDragonTest methodsFor: 'assertions' stamp: 'JFGO 3/13/2024 17:24:16' prior: 50543297!
performMethodWithClass: aClass andSelector: aSelector typeCheckAndAssert: anAssertionBlock
	
	| methodToCheck |
	methodToCheck := aClass >> aSelector.
	aClass new perform: aSelector.
	
	self typeCheckOn: methodToCheck andAssert: anAssertionBlock .
	
! !
!TypeCheckerDragonTest methodsFor: 'tests for methods with branches' stamp: 'JFGO 3/13/2024 17:24:53' prior: 50538567!
test13TypeCastIfTrueCorrectlyAppliesCastedType
	self performMethodWithClass: TypesWithContextAppliersTestMethods andSelector: #typeCastIfTrue typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].
	! !

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/13/2024 17:24:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/13/2024 17:24:56'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/13/2024 17:24:56'!
PASSED!
!TypeCheckerDragonTest methodsFor: 'tests for methods with branches' stamp: 'JFGO 3/13/2024 17:25:07' prior: 50538577!
test14TypeCastIfFalseCorrectlyRejectsCastedType
	self performMethodWithClass: TypesWithContextAppliersTestMethods andSelector: #typeCastIfFalse typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].
	! !

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/13/2024 17:25:08'!
PASSED!
!TypeCheckerDragonTest methodsFor: 'tests for methods with branches' stamp: 'JFGO 3/13/2024 17:25:23' prior: 50538587!
test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType

	self performMethodWithClass: TypesWithContextAppliersTestMethods andSelector: #typeCastIfTrueIfFalse typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].
	self performMethodWithSelector: #typeCastIfFalseIfTrue typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].
	! !
!TypeCheckerDragonTest methodsFor: 'tests for methods with branches' stamp: 'JFGO 3/13/2024 17:25:30' prior: 50543486!
test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType

	self performMethodWithClass: TypesWithContextAppliersTestMethods andSelector: #typeCastIfTrueIfFalse typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].
	self performMethodWithClass: TypesWithContextAppliersTestMethods andSelector: #typeCastIfFalseIfTrue typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].
	! !
!TypeCheckerDragonTest methodsFor: 'tests for methods with branches' stamp: 'JFGO 3/13/2024 17:25:42' prior: 50538603!
test16TypeCastNestedRejectionsRejectsEachLevelCastedType

	self performMethodWithClass: TypesWithContextAppliersTestMethods andSelector: #typeCastIfFalseNested typeCheckAndAssert: [:typeChecker :methodChecked | 
		self deny: typeChecker hasIssues.
	].

	! !

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/13/2024 17:25:44'!
PASSED!

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfFalse stamp: 'JFGO 3/13/2024 17:25:50'!
typeCastIfFalse
	|v1|
	v1 := 5.
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 class = SmallInteger ifFalse:[v1 isEmpty.]!

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfFalseNested stamp: 'JFGO 3/13/2024 17:25:53'!
typeCastIfFalseNested

	|v1|
	v1:= OrderedCollection new.
	v1 := Date today.
	v1 := 5.
	v1 := true.
	
	v1 class = SmallInteger ifFalse: [
		v1 class = OrderedCollection ifFalse: 		[
				v1 class = Date ifFalse:[
					v1 not.
				].
			].
		].!

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfTrue stamp: 'JFGO 3/13/2024 17:25:55'!
typeCastIfTrue
	|v1|
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 := 5.
	v1 class = SmallInteger ifTrue: [v1 factorial].!

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfTrueIfFalse stamp: 'JFGO 3/13/2024 17:25:57'!
typeCastIfTrueIfFalse
	|v1|
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 := 5.
	v1 class = SmallInteger ifTrue: [v1 factorial] ifFalse: [v1 isEmpty].!

!methodRemoval: TypeCheckerDragonTestMethods #typeCastIfFalseIfTrue stamp: 'JFGO 3/13/2024 17:25:59'!
typeCastIfFalseIfTrue
	|v1|
	v1:= OrderedCollection new.
	v1 := 5.
	v1 := 'true'.
	
	v1 class = SmallInteger ifFalse: [v1 isEmpty] ifTrue: [v1 factorial] .!

!testRun: #TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/13/2024 17:26:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/13/2024 17:26:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/13/2024 17:26:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/13/2024 17:26:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/13/2024 17:26:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/13/2024 17:26:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/13/2024 17:26:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/13/2024 17:26:09'!
PASSED!

----SNAPSHOT----(13 March 2024 17:26:12) CuisUniversity-6169.image priorSource: 6769670!
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:27:13'!
test01MethodCastToTypeReturnsJustCastedType

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

"compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest."

self assert:true.! !

!methodRemoval: TypesWithContextAppliersTest #test01XX stamp: 'JFGO 3/13/2024 17:27:17'!
test01XX

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrueIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrueIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

"compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest."

self assert:true.!
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:27:31' prior: 50543717!
test01MethodCastToTypeReturnsJustCastedType

| compiledMethod blockToTest blockToTestString |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrue.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

"compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest."

self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:28:05' prior: 50543752!
test01MethodCastToTypeReturnsJustCastedType

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrue.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:true.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:28:23' prior: 50543770!
test01MethodCastToTypeReturnsJustCastedType

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrue.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 1.! !
!TypesWithContextAppliersTest methodsFor: 'as yet unclassified' stamp: 'JFGO 3/13/2024 17:28:41' prior: 50543789!
test01MethodCastToTypeReturnsJustCastedType

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrue.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 factorial. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 1.! !
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:29:14' prior: 50543182!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

|  nodeEncoder methodNode sourceRanges blockToTest  |


blockToTest:=nil.
methodNode:=aCompiledMethod methodNode.
nodeEncoder := methodNode encoder.
sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
sourceRanges associationsDo: [ :nodeAtRange |
		(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
				blockToTest:= nodeAtRange key.
			]
		].

blockToTest notNil ifTrue: [^blockToTest].

self failWith: 'Block node not found'.! !
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:29:42' prior: 50543827!
getBlockNodeWithSourceCode: blockNodeCodeString on: aCompiledMethod

	|  nodeEncoder methodNode sourceRanges blockToTest  |

	blockToTest:=nil.
	
	methodNode:=aCompiledMethod methodNode.
	nodeEncoder := methodNode encoder.
	sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
	sourceRanges associationsDo: [ :nodeAtRange |
			(nodeAtRange key class = BlockNode and: [nodeAtRange key printSourceCode = blockNodeCodeString])ifTrue: [
					blockToTest:= nodeAtRange key.
				]
			].

	blockToTest notNil ifTrue: [^blockToTest].

	self failWith: 'Block node not found'.! !

----SNAPSHOT----(13 March 2024 17:30:45) CuisUniversity-6169.image priorSource: 6786002!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:39:33'!
ERROR!
!CompiledMethod methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/13/2024 17:39:49'!
typesOfVariableNamed: aRenameMe1 withinBlockNode: blockToTest 
	self shouldBeImplemented.! !
!CompiledMethod methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/13/2024 17:40:34' prior: 50543878!
typesOfVariableNamed: aVariableName withinBlockNode: blockToTest 
	^ #(SmallInteger).! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:40:37'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:40:40'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:40:40'!
PASSED!
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:41:01' prior: 50543808!
test01MethodCastToTypeReturnsJustCastedType

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrue.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 factorial. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 1.
self assert: types first equals: SmallInteger.! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:41:02'!
FAILURE!

anArrayOfRawTypes at: variableIndex!

self!

self = SmallInteger!

self class!

self !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:45:40'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:45:40'!
FAILURE!

BlockNode!

BlockNode = BlockNode!

BlockNode = BlockNode class!

SmallInteger!

#(SmallInteger) first!

#(SmallInteger class) first!

#(SmallInteger) = #(SmallInteger)!

#((SmallInteger)) first!

SmallInteger!

Class!

#(SmallInteger class) first!

c = SmallInteger.!

c = SmallInteger.!

#(c) first!

#(c) first!

c := SmallInteger.!

#(c) first!

(Array with: SmallInteger) first!
!CompiledMethod methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/13/2024 17:49:41' prior: 50543885!
typesOfVariableNamed: aVariableName withinBlockNode: blockToTest 
	^ Array with: SmallInteger.! !

!testRun: #CompiledMethodTest #test01isGetterWhenSameSelectorAsInstanceVariableAndOnlyReturnsThatVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test01withPropertiesDoIfSelectorEvaluatesFirstBlockWhenMethodHasProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test02isNotGetterWhenDifferentSelectorAsInstanceVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test02removePropertiesRestoresPenultimalLiteralToSelector stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test03isNotGetterWhenSameSelectorAsInstanceVariableButDoesOtherThingBesidesReturningVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test03removePropertiesKeepsSelectorIfMethodDoesNotHaveProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test04isSetterWhenSameKeywordSelectorAsInstanceVariableAndOnlySetsTheVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test04withPropertiesDoIfSelectorEvaluatesSecondBlockWhenMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test05hasLiteralSuchThatTravelsListeralsWhenMethodHasProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test05isNotSetterWhenDifferentKeywordSelectorAsInstanceVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test06hasLiteralSuchThatTravelsListeralsWhenMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test06isNotSetterWhenSameKeywordSelectorAsInstanceVariableButDoesNotAssignParameter stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test0701withPropertiesDoReturnsNilIfMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test07AccessorDescriptionIsGetterForAGetter stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test07withPropertiesDoEvaluatesBlockOnlyWhenMethodHasProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test08AccessorDescriptionIsSetterForASetter stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test08hasLiteralThoroughReturnTrueWhenMethodHasPropertiesAndHasLiteral stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test09AccessorDescriptionIsReadForMethodThatReadsInstanceVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test09hasLiteralThoroughReturnFalseWhenMethodHasPropertiesAndHasNoLiteral stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test10AccessorDescriptionIsWriteForMethodThatWritesInstanceVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test10hasLiteralThoroughReturnTrueWhenMethodHasNoPropertiesAndHasLiteral stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test11AccessorDescriptionIsWriteReadForMethodThatWritesAndReadInstanceVariable stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test11hasLiteralThoroughReturnFalseWhenMethodHasNoPropertiesAndHasNoLiteral stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test12pragmaAtReturnsPragmaIfExist stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test13pragmaAtReturnsNilIfPragmaDoesNotExist stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test14pragmasReturnsCollectionOfMethodPragmas stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test15pragmasReturnsEmptyCollectionWhenMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test16propertiesReturnsAnNewAdditionalMethodStateWhenNoPropertiesHasBeenSet stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test17propertiesReturnsTheAlreadySetAdditionalMethodStateWhenHasProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test18propertyKeysAndValuesDoIteratesOverProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test19propertyKeysAndValuesDoDoesNotEvaluateBlockWhenMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test20propertyValueAtReturnsPropertyValueWhenSetted stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test21propertyValueAtReturnsNilWhenPropertyIsNotFound stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test22propertyValueAtReturnsNilWhenMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test23propertyValueAtIfAbsetReturnsPropertyValueWhenFound stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test24propertyValueAtIfAbsetEvaluatesIfAbsentBlockWhenNotFound stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test25propertyValueAtIfAbsetEvaluatesIfAbsentBlockWhenMethodHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test26propertyValueAtPutCreatesPropertiesWithNewOne stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test27propertyValueAtPutReplacesPropertyIfAlreadyExisted stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test28propertyValueAtPutAddsNewPropertyIfPropertiesExisted stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test29selectorReturnsMethodSelectorWhenNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test30selectorReturnsMethodSelectorWhenHasProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test31SettingSelectorWhenHasNoProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #CompiledMethodTest #test32SettingSelectorWhenHasProperties stamp: 'JFGO 3/13/2024 17:49:47'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:49:54'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:49:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/13/2024 17:49:56'!
PASSED!
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:51:03'!
test02MethodCastToRejectReturnsAllTypesButRejected

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfTrue.
TypesWithContextAppliersTestMethods new perform: #typeCastIfTrue.
blockToTestString:= '[ v1 factorial. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 1.
self assert: types first equals: SmallInteger.! !
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:51:17' prior: 50544157!
test02MethodCastToRejectReturnsAllTypesButRejected

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfFalse.
blockToTestString:= '[ v1 factorial. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 1.
self assert: types first equals: SmallInteger.! !
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:51:30' prior: 50544178!
test02MethodCastToRejectReturnsAllTypesButRejected

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 1.
self assert: types first equals: SmallInteger.! !
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:51:40' prior: 50544199!
test02MethodCastToRejectReturnsAllTypesButRejected

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 2.
self assert: types first equals: SmallInteger.! !

----End fileIn of H:\My Drive\Tesis\TESIS-LAST\windows64\Packages\TerseGuide.pck.st----!
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/13/2024 17:52:21' prior: 50544220!
test02MethodCastToRejectReturnsAllTypesButRejected

| compiledMethod blockToTest blockToTestString types |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

types := compiledMethod typesOfVariableNamed: 'v1' withinBlockNode: blockToTest.

self assert:types size equals: 2.
self assert: types includes: OrderedCollection.
self assert: types includes: String.! !

ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 3/13/2024 18:03:49'!
ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!
!CompiledMethod methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/13/2024 18:05:24' prior: 50543951!
typesOfVariableNamed: aVariableName withinBlockNode: blockToTest 
	^ (ContextAppliersMethodVisitor for: self on: aVariableName within: blockToTest) types.! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/13/2024 18:13:01'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/13/2024 18:13:01'!
ERROR!
!ContextAppliersMethodVisitor class methodsFor: 'instance creation' stamp: 'JFGO 3/13/2024 18:13:09'!
for: aCompiledMethod on: aVariableName within: blockToTest 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeFor: aCompiledMethod on: aVariableName within: blockToTest ! !
!ContextAppliersMethodVisitor class methodsFor: 'instance creation' stamp: 'JFGO 3/13/2024 18:14:21' prior: 50547215!
for: aCompiledMethod on: aVariableName within: aBlockNode
	^self new initializeFor: aCompiledMethod on: aVariableName within: aBlockNode ! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/13/2024 18:14:22'!
ERROR!

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 3/13/2024 18:14:35'!
ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod variableName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 3/13/2024 18:14:35'!
ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod variableName blockNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!
!ContextAppliersMethodVisitor methodsFor: 'initialization' stamp: 'JFGO 3/13/2024 18:14:35'!
initializeFor: aCompiledMethod on: aVariableName within: aBlockNode 
	self shouldBeImplemented.
	compiledMethod := aCompiledMethod.
	variableName := aVariableName.
	blockNode := aBlockNode.! !
!ContextAppliersMethodVisitor methodsFor: 'initialization' stamp: 'JFGO 3/13/2024 18:14:42' prior: 50547261!
initializeFor: aCompiledMethod on: aVariableName within: aBlockNode 
	compiledMethod := aCompiledMethod.
	variableName := aVariableName.
	blockNode := aBlockNode.! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/13/2024 18:14:48'!
ERROR!
!ContextAppliersMethodVisitor methodsFor: 'evaluating' stamp: 'JFGO 3/13/2024 18:15:02'!
types
	self shouldBeImplemented.! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/13/2024 18:15:06'!
ERROR!

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 3/13/2024 18:16:43'!
ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod variableName blockNode methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!
!ContextAppliersMethodVisitor methodsFor: 'initialization' stamp: 'JFGO 3/13/2024 18:16:41' prior: 50547271!
initializeFor: aCompiledMethod on: aVariableName within: aBlockNode 
	compiledMethod := aCompiledMethod.
	variableName := aVariableName.
	blockNode := aBlockNode.
	methodNode := compiledMethod methodNode .! !

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 3/13/2024 18:18:22'!
ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod variableName blockNode methodNode types'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!
!ContextAppliersMethodVisitor methodsFor: 'evaluating' stamp: 'JFGO 3/13/2024 18:18:20' prior: 50547284!
types
	self visitMethodNode: methodNode .
	^types.! !
!ContextAppliersMethodVisitor methodsFor: 'initialization' stamp: 'JFGO 3/13/2024 18:18:36' prior: 50547305!
initializeFor: aCompiledMethod on: aVariableName within: aBlockNode 
	compiledMethod := aCompiledMethod.
	variableName := aVariableName.
	blockNode := aBlockNode.
	methodNode := compiledMethod methodNode .
	types:=Array new.! !
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:22:20' prior: 50537865 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	super visitBlockNode: aBlockNode.! !

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 3/13/2024 18:24:17'!
ParseNodeVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod variableName blockNode methodNode types contextApplier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:24:16' overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	super visitBlockNode: aBlockNode.! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:25:49' overrides: 16919345!
visitMessageNode: aMessageNode
	
	self visitMessageNodeArguments:aMessageNode.! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:26:32'!
visitMessageNodeArguments:aMessageNode.
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | | shouldRestore | 
		shouldRestore := self updateContextApplierFor: aMessageNode visiting: argumentBlock.
		argumentBlock accept: self.
		shouldRestore ifTrue: [self restorePreviousContext].
	].! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:27:05'!
restorePreviousContext
	contextApplier := contextApplier previous.! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:27:24' prior: 50547385 overrides: 16919345!
visitMessageNode: aMessageNode
	self visitMessageNodeArguments:aMessageNode.! !

self hasArguments !

aMessageNode!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:30:38' prior: 50547411 overrides: 16919345!
visitMessageNode: aMessageNode
	aMessageNode arguments  size > 0 ifTrue:[
		self visitMessageNodeArguments:aMessageNode.
	].! !
!ContextAppliersMethodVisitor methodsFor: 'context' stamp: 'JFGO 3/13/2024 18:33:35'!
updateContextApplierFor: aMessageNode visiting: aBlockNode
	
	| newContext contextUpdated|
	
	contextUpdated := false.
	aMessageNode isIfWithMessageNodeAsCondition ifTrue: [ | shouldReject |
		"TODO. Esto puede ser un mensaje bonito que se llame self shouldReject: aBlockNode. Pero todavia estamos muy temprano en TDD"
		shouldReject := aMessageNode selectorSymbol = #ifFalse: and: [aBlockNode = aMessageNode arguments second].
		shouldReject := shouldReject or: [aMessageNode selectorSymbol = #ifTrue:ifFalse: and: [aBlockNode = aMessageNode arguments second]].
		
		newContext := EqualsTypeContextApplier 
			to: aMessageNode receiver arguments first key value
			on: aMessageNode receiver receiver receiver
			shouldCast: shouldReject not
			withPreviousContext: contextApplier.
		contextApplier := newContext.
		contextUpdated := true.
				
	].
	^contextUpdated .
	

	! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/13/2024 18:34:55' prior: 50547371 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	"TODO. Si los bloques a comparar coinciden entonces aca preguntamos por el type?"
	super visitBlockNode: aBlockNode.! !

----QUIT----(13 March 2024 18:36:01) CuisUniversity-6169.image priorSource: 6791028!

----STARTUP---- (25 March 2024 15:31:49) as C:\Users\juli_\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!


----QUIT----(25 March 2024 15:47:12) CuisUniversity-6169.image priorSource: 6906312!

----STARTUP---- (26 March 2024 18:17:47) as C:\Users\juli_\Tesis\TESIS-LAST\windows64\CuisUniversity-6169.image!


!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 18:43:26'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 18:45:18'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 18:45:18'!
FAILURE!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 18:48:22' prior: 50547458 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	aBlockNode = blockNode ifTrue:[^Array with: SmallInteger].
	super visitBlockNode: aBlockNode.! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 18:48:39'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 18:48:39'!
FAILURE!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 18:52:48' prior: 50547499 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	aBlockNode = blockNode ifTrue:[types:= Array with: SmallInteger.].
	super visitBlockNode: aBlockNode.! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 18:52:53'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 18:52:53'!
FAILURE!

aBlockNode = blockNode!

aBlockNode == blockNode!

blockNode!

blockNode!

aBlockNode = blockNode!

aBlockNode = aBlockNode!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 18:58:47' prior: 50547523 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	aBlockNode = blockNode ifTrue:[types:= Array with: SmallInteger.].
	super visitBlockNode: aBlockNode.
	! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:10:43' prior: 50547551 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[types:= Array with: SmallInteger.].
	super visitBlockNode: aBlockNode.
	! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:10:49'!
PASSED!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:11:33' prior: 50547567 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[
		types:= Array with: SmallInteger.
	].
	super visitBlockNode: aBlockNode.
	! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:27:08' prior: 50547588 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[
		types:= contextApplier receiverLiveTypesFor: aBlockNode In: compiledMethod  addingIncompleteTypeInfoTo: OrderedCollection new.
	].
	super visitBlockNode: aBlockNode.
	! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:27:21' prior: 50547605 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[
		"TODO. Falta la variable".
		types:= contextApplier receiverLiveTypesFor: aBlockNode In: compiledMethod  addingIncompleteTypeInfoTo: OrderedCollection new.
	].
	super visitBlockNode: aBlockNode.
	! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:27:53'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:27:53'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/26/2024 19:28:34'!
PASSED!
!EqualsTypeContextApplier methodsFor: 'LiveTyping' stamp: 'JFGO 3/26/2024 19:30:00' prior: 50539087!
receiverLiveTypesCastingObjectFor: aMessageNode In:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo
	


	"^FixedType for: type ."
	^RawToLiveTypesAdapter new adapt: (Array with: type) .! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/26/2024 19:30:03'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:30:12'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:30:12'!
ERROR!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:31:04' prior: 50547625 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[
		"TODO. Falta la variable".
		self halt.
		types:= contextApplier receiverLiveTypesFor: aBlockNode In: compiledMethod  addingIncompleteTypeInfoTo: OrderedCollection new.
	].
	super visitBlockNode: aBlockNode.
	! !

RawToLiveTypesAdapter new adapt: (Array with: type)!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 19:33:08'!
ERROR!
!EqualsTypeContextApplier methodsFor: 'LiveTyping' stamp: 'JFGO 2/21/2024 20:36:40' prior: 50547719!
receiverLiveTypesCastingObjectFor: aMessageNode In:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo
	


	^FixedType for: type .! !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-MessageNodes' stamp: 'JFGO 3/26/2024 19:48:25'!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	


	self shouldCast 
	ifTrue: [  ]
! !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 19:49:05' prior: 50547838!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	


	self shouldCast 
	ifTrue: [  ^Array with: type.]
! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:49:43' prior: 50547804 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[
		"TODO. Falta la variable".
		self halt.
		types:= contextApplier receiverLiveTypesFor: variableName In: compiledMethod.
	].
	super visitBlockNode: aBlockNode.
	! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 3/26/2024 19:49:50' prior: 50547853 overrides: 16919312!
visitBlockNode: aBlockNode
	"TODO. Cuando inicializamos el visitor, podemos inicializar el contextApplier y ahorrar el ifNil. El blockNode no parece usarse.. sacarlo y correr tests"
	contextApplier isNil ifTrue: [contextApplier := GeneralContextApplier for: aBlockNode.].
	(aBlockNode equivalentTo: blockNode) ifTrue:[
		types:= contextApplier receiverLiveTypesFor: variableName In: compiledMethod.
	].
	super visitBlockNode: aBlockNode.
	! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:49:59'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/26/2024 19:50:30'!
PASSED!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 19:51:03' prior: 50547845!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	


	self shouldCast 
	ifTrue: [  ^Array with: type.]
	ifFalse: [^Array with: OrderedCollection with: String.]
! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:51:05'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 19:51:05'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/26/2024 19:51:07'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/26/2024 19:51:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/26/2024 19:51:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/26/2024 19:51:10'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:51:10'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 19:51:10'!
PASSED!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 19:58:18'!
receiverLiveTypesCastingObjectFor: aVariableNode In:  compiledMethod
	


	^Array with: type.
	
! !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 19:58:45' prior: 50547960!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	


	self shouldCast 
	ifTrue: [  ^self receiverLiveTypesCastingObjectFor: aVariableNode In: compiledMethod ]
	ifFalse: [^Array with: OrderedCollection with: String.]
! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 19:58:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 19:58:49'!
PASSED!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 19:59:10'!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	^Array with: type.
	
! !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 19:59:24' prior: 50548125!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	


	self shouldCast 
	ifTrue: [  ^self receiverLiveTypesCastingObjectFor: aVariableNode In: compiledMethod ]
	ifFalse: [^self receiverLiveTypesRejectingObjectFor: aVariableNode In: compiledMethod ]
! !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:00:19' prior: 50548144!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	^Array with: OrderedCollection with: String.
	
! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 20:00:21'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:00:21'!
PASSED!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:00:52' prior: 50548163!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	^RawToLiveTypesAdapter new adapt: filteredLiveTypes .
	
! !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:01:59' prior: 50548179!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	^filteredLiveTypes .
	
! !
!GeneralContextApplier methodsFor: 'LiveTyping-Message Nodes' stamp: 'JFGO 3/26/2024 20:11:38'!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	^ aVariableNode receiverLiveTypesIn:  compiledMethod.! !
!GeneralContextApplier methodsFor: 'LiveTyping-Variable Nodes' stamp: 'JFGO 3/26/2024 20:14:44' prior: 50548208!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	^ aVariableNode receiverTypesIn: compiledMethod addingIncompleteTypeInfoTo: OrderedCollection new.! !
!GeneralContextApplier methodsFor: 'LiveTyping-Variable Nodes' stamp: 'JFGO 3/26/2024 20:15:18' prior: 50548216!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	^ aVariableNode typesIn: aVariableNode addingIncompleteTypeInfoTo: OrderedCollection new.! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 20:15:53'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:16:03'!
ERROR!

self key!

sourceRanges associations!
!TypesWithContextAppliersTest methodsFor: 'methods and block nodes' stamp: 'JFGO 3/26/2024 20:25:40'!
getVariableNodeNamed: aVariableName on: aCompiledMethod

	|  nodeEncoder methodNode sourceRanges blockToTest  |

	blockToTest:=nil.
	
	methodNode:=aCompiledMethod methodNode.
	nodeEncoder := methodNode encoder.
	sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
	sourceRanges associationsDo: [ :nodeAtRange |
			nodeAtRange key name = aVariableName ifTrue: [
					blockToTest:= nodeAtRange key.
				]
			].

	blockToTest notNil ifTrue: [^blockToTest].

	self failWith: 'Block node not found'.! !
!TypesWithContextAppliersTest methodsFor: 'methods and block nodes' stamp: 'JFGO 3/26/2024 20:25:47' prior: 50548243!
getVariableNodeNamed: aVariableName on: aCompiledMethod

	|  nodeEncoder methodNode sourceRanges variableNode  |

	variableNode:=nil.
	
	methodNode:=aCompiledMethod methodNode.
	nodeEncoder := methodNode encoder.
	sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
	sourceRanges associationsDo: [ :nodeAtRange |
			nodeAtRange key name = aVariableName ifTrue: [
					variableNode:= nodeAtRange key.
				]
			].

	variableNode notNil ifTrue: [^variableNode].

	self failWith: 'Block node not found'.! !
!TypesWithContextAppliersTest methodsFor: 'methods and block nodes' stamp: 'JFGO 3/26/2024 20:26:02' prior: 50548264!
getVariableNodeNamed: aVariableName on: aCompiledMethod

	|  nodeEncoder methodNode sourceRanges variableNode  |

	variableNode:=nil.
	
	methodNode:=aCompiledMethod methodNode.
	nodeEncoder := methodNode encoder.
	sourceRanges := nodeEncoder completeSourceRangesBasedOn: methodNode sourceText.
	sourceRanges associationsDo: [ :nodeAtRange |
			nodeAtRange key name = aVariableName ifTrue: [
					variableNode:= nodeAtRange key.
				]
			].

	variableNode notNil ifTrue: [^variableNode].

	self failWith: 'Variable node not found'.! !
!TypesWithContextAppliersTest methodsFor: 'equals type context' stamp: 'JFGO 3/26/2024 20:26:55' prior: 50547160!
test02MethodCastToRejectReturnsAllTypesButRejected

| compiledMethod blockToTest blockToTestString types variableNode |

compiledMethod := TypesWithContextAppliersTestMethods >> #typeCastIfFalse.
TypesWithContextAppliersTestMethods new perform: #typeCastIfFalse.
blockToTestString:= '[ v1 isEmpty. ]'.
blockToTest := self getBlockNodeWithSourceCode: blockToTestString on: compiledMethod.

variableNode := self getVariableNodeNamed: 'v1' on: compiledMethod .

types := compiledMethod typesOfVariableNamed: variableNode withinBlockNode: blockToTest.

self assert:types size equals: 2.
self assert: types includes: OrderedCollection.
self assert: types includes: String.! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:27:19'!
ERROR!
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/26/2024 20:28:36' prior: 50542672!
calculateTypesWithContext

	self halt.
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 3/26/2024 20:28:48' prior: 50548335!
calculateTypesWithContext

	"self halt."
	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !

parseNodeToAnalize!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:29:46'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:29:46'!
ERROR!
!GeneralContextApplier methodsFor: 'LiveTyping-Variable Nodes' stamp: 'JFGO 3/26/2024 20:32:17' prior: 50548225!
receiverLiveTypesFor: aVariableNode In:  compiledMethod
	^ aVariableNode typesIn: compiledMethod addingIncompleteTypeInfoTo: OrderedCollection new.! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:32:22'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:32:22'!
FAILURE!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:33:18' prior: 50548194!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	self halt.
	^filteredLiveTypes .
	
! !

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 20:33:24'!
PASSED!

RawToLiveTypesAdapter new adapt: filteredLiveTypes.!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:35:51' prior: 50548385!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes lt |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	lt:= RawToLiveTypesAdapter new adapt: filteredLiveTypes.
	^lt .
	
! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:35:54'!
ERROR!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:36:11' prior: 50548406!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes lt |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	lt:= RawToLiveTypesAdapter new adapt: filteredLiveTypes.
	self halt.
	^lt .
	
! !

lt!

self asArray!

self types!

lt!

self first!

self first!

self first class!

self first typeName!

self first liveClass!

self second liveClass!

lt!

self first liveClass !

filteredLiveTypes!

self first liveClass !
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:44:33' prior: 50548426!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes filteredTypes |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	filteredTypes := OrderedCollection new.
	filteredLiveTypes classTypesDo: [:aClass | filteredTypes add:aClass]
	
	^filteredTypes asArray .
	
! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:44:41'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:44:53'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:44:53'!
ERROR!

filteredLiveTypes!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:46:26' prior: 50548449!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes filteredTypes |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	filteredTypes := OrderedCollection new.
	(RawToLiveTypesAdapter new adapt: filteredLiveTypes) classTypesDo: [:aClass | filteredTypes add:aClass]
	
	^filteredTypes asArray .
	
! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:46:34'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:46:34'!
ERROR!
!EqualsTypeContextApplier methodsFor: 'LiveTyping-VariableNodes' stamp: 'JFGO 3/26/2024 20:46:47' prior: 50548481!
receiverLiveTypesRejectingObjectFor: aVariableNode In:  compiledMethod
	


	| originalTypes filteredLiveTypes filteredTypes |
	originalTypes := previousContext receiverLiveTypesFor: aVariableNode In:  compiledMethod.
	
	filteredLiveTypes := originalTypes asArray reject: [:aLiveType | aLiveType typeName = type name].
	filteredTypes := OrderedCollection new.
	(RawToLiveTypesAdapter new adapt: filteredLiveTypes) classTypesDo: [:aClass | filteredTypes add:aClass].
	
	^filteredTypes asArray .
	
! !

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:46:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 20:46:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:46:50'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test14TypeCastIfFalseCorrectlyRejectsCastedType stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01MethodCastToTypeReturnsJustCastedType stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02MethodCastToRejectReturnsAllTypesButRejected stamp: 'JFGO 3/26/2024 20:47:03'!
PASSED!

----SNAPSHOT----(26 March 2024 20:47:11) CuisUniversity-6169.image priorSource: 6906513!

----QUIT----(26 March 2024 20:48:42) CuisUniversity-6169.image priorSource: 6942833!