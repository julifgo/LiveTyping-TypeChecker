

----QUIT----(13 August 2023 19:14:09) CuisUniversity-5981.image priorSource: 5713367!

----STARTUP---- (13 August 2023 19:14:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5981.image!


----QUIT----(13 August 2023 19:14:10) CuisUniversity-5981.image priorSource: 10197065!

----STARTUP---- (8 December 2023 18:52:21) as C:\Users\jgutierrez\Tesis\CUIS\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\jgutierrez\Tesis\CUIS\windows64\LiveTypingGenerics.pck.st----!

!testRun: #LiveTypeTests #test001SameType stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test002DifferentType stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test003SameHierarchy stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test004CommonSupertypeIsObject stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test005SameGeneric stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test006SameGenericDifferentOrder stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test007GenericsHandleSystemTypes stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test008NestedGenerics stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test009GenericSupertypeWithSameGenerics stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test010GenericSupertypeWithCommonGenerics stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test011FixedAgainstGenericType stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test012FixedAgainstGenericTypeInList stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test013GenericAgainstFixedTypeInList stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test014NestedGenerics stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test015NestedGenericsWithDifferentDepth stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test016EmptyTypeAgainstSelf stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test017EmptyTypeAgainstFixedType stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test018EmptyTypeAgainstGenericType stamp: 'JFGO 12/8/2023 19:18:47'!
PASSED!

!testRun: #LiveTypeTests #test019UnionTypeCollectsTypes stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test020UnionTypeAgainstSelf stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test021UnionTypeAgainstInnerElement stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test022ConvertionAccordingToReceiver stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test023ConvertionToArray stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test024EnumeratingClassTypes stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test025EnumeratingLiveTypes stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

!testRun: #LiveTypeTests #test026EnumeratingLiveAndClassTypes stamp: 'JFGO 12/8/2023 19:18:48'!
PASSED!

----End fileIn of C:\Users\jgutierrez\Tesis\LiveTyping-TypeChecker\20231130\LiveTypingTypeChecker.st----!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 19:21:30'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 19:21:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 19:21:57'!
ERROR!
!CompiledMethod methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 19:22:27'!
typeCheckDragon
	self shouldBeImplemented.! !
!CompiledMethod methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 19:25:49' prior: 50660475!
typeCheckDragon
	^(TypeCheckerDragon for: self) perform! !

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 19:25:50'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 19:25:55'!
PASSED!

TypeCheckerDragonTestMethods new methodWithCollectionWithErrorTypeOnIteration!

aMessageNode receiver!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 20:01:55'!
PASSED!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/8/2023 20:02:29' prior: 50659827 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverTypes |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverTypes:=aMessageNode receiverTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: NoTypeCastApplier new.
	
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypes isEmpty and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 20:02:42'!
PASSED!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/8/2023 20:11:25' prior: 50660584 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverTypes |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverTypes:=aMessageNode receiverLiveTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
	
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypes isEmpty and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 20:11:32'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 20:11:32'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 20:11:32'!
ERROR!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 20:11:44'!
ERROR!
!MessageNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 20:12:07'!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo 
	self shouldBeImplemented.! !
!MessageNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 20:13:27' prior: 50660732!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo 
	^self basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: NoTypeCastApplier new! !
!MessageNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 20:15:01'!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: aTypeCastApplier
	^self receiverOrCascadeReceiver basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: aTypeCastApplier ! !
!MessageNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 20:15:57' prior: 50660739!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo 
	^self receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: NoTypeCastApplier new.! !

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 20:16:17'!
PASSED!
!MessageNode methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 12/8/2023 20:17:06' prior: 50660749!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: aTypeCastApplier
	^self receiverOrCascadeReceiver typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: aTypeCastApplier ! !

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 20:59:17'!
ERROR!

receiverTypes!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/8/2023 21:04:00' prior: 50660657 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverTypes |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverTypes:=aMessageNode receiverLiveTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
	
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypes asArray isEmpty and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 21:04:47'!
ERROR!
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782005 overrides: 16906201!
printOn: aStream indent: level 
	variable printOn: aStream indent: level.
	aStream nextPutAll: ' _ '.
	value printOn: aStream indent: level! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781923!
emitCodeForValue: stack encoder: encoder

	variable emitCodeForLoad: stack forValue: true encoder: encoder.
	value emitCodeForValue: stack encoder: encoder.
	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".
	variable emitCodeForStore: stack encoder: encoder! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658280 overrides: 50658211!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage
	
	^value liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782059 overrides: 16906303!
isAssignmentToTemporary

	^ self isAssignmentNode and: [ variable isTemp ]! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782036 overrides: 16906269!
expandRanges: sourceRanges basedOn: allSourceRanges using: sourceCode

	^ self consolidateAsCollection: (self
		expandRange: (sourceRanges isInterval ifTrue: [ sourceRanges ] ifFalse: [ sourceRanges first ])
		basedOn: (allSourceRanges at: variable))! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782064 overrides: 16906320!
isComplex
	^ value isComplex! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781981 overrides: 16902254!
value
	^ value! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50370518 overrides: 50370511!
referencesSelf

	^variable referencesSelf or: [value referencesSelf]! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781969!
variable
	^variable! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658259 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^value basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons ! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781952!
analyseTempsWithin: scopeBlock "<BlockNode>"  rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	"N.B.  since assigment happens _after_ the value is evaluated the value is sent the message _first_."
	value analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools.
	variable beingAssignedToAnalyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782019 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level 
	variable printWithClosureAnalysisOn: aStream indent: level.
	aStream nextPutAll: ' _ '.
	value printWithClosureAnalysisOn: aStream indent: level! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782012 overrides: 16906207!
printOn: aStream indent: level precedence: p

	aStream nextPut: $(.
	self printOn: aStream indent: level.
	aStream nextPut: $)! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781944!
sizeCodeForValue: encoder

	^(variable sizeCodeForLoad: encoder forValue: true)
	+ (value sizeCodeForValue: encoder)
	+ (variable sizeCodeForStore: encoder)! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50370524 overrides: 50370514!
referencesSuper

	^variable referencesSuper or: [value referencesSuper]! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782055 overrides: 16906300!
isAssignmentNode
	^true! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782047 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isAssignmentNode
		and: [ self variable equivalentTo: aParseNode variable ]
		and: [ self value equivalentTo: aParseNode value ]! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782028 overrides: 16906238!
printWithClosureAnalysisOn: aStream indent: level precedence: p

	aStream nextPut: $(.
	self printWithClosureAnalysisOn: aStream indent: level.
	aStream nextPut: $)! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781910 overrides: 16906092!
emitCodeForEffect: stack encoder: encoder

	variable emitCodeForLoad: stack forValue: false encoder: encoder.
	value emitCodeForValue: stack encoder: encoder.
	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".
	variable emitCodeForStorePop: stack encoder: encoder! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658294 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  storingGenericsInfoIn: aStorage
	
	^value liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  storingGenericsInfoIn: aStorage! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781985!
variable: aVariable value: expression from: encoder

	"Case of remote temp vars"
	(aVariable isMemberOf: MessageAsTempNode) ifTrue: [ ^aVariable store: expression from: encoder].
	
	variable := aVariable.
	value := expression.
	
	^self
	
! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781973 overrides: 16906476!
toDoIncrement: var
	var = variable ifFalse: [^ nil].
	(value isMemberOf: MessageNode) 
		ifTrue: [^ value toDoIncrement: var]
		ifFalse: [^ nil]! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782073!
variable: aVariable value: expression 
	variable _ aVariable.
	value _ expression! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16782068 overrides: 16906485!
accept: aVisitor
	^aVisitor visitAssignmentNode: self! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658268 overrides: 50658200!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 

	^value basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781995!
variable: aVariable value: expression from: encoder sourceRange: range

	| realNode |
	
	realNode := self variable: aVariable value: expression from: encoder.
	encoder noteSourceRange: range forNode: realNode.
	
	^realNode! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16781936 overrides: 16906134!
sizeCodeForEffect: encoder

	^(variable sizeCodeForLoad: encoder forValue: false)
	+ (value sizeCodeForValue: encoder)
	+ (variable sizeCodeForStorePop: encoder)! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783934 overrides: 16906201!
printOn: aStream indent: level

	aStream nextPut: $`.
	expression printOn: aStream indent: level.
	aStream nextPut: $`.! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658328 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^self literalNode liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783947!
emitCodeForValue: aParseStack encoder: anEncoder

	^self literalNode emitCodeForValue: aParseStack encoder: anEncoder ! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783856!
evaluateBacktickSourceCode

	^[[[Compiler evaluate: sourceCode ]
		on: SyntaxErrorNotification
		do: [ :ex | parser notify: 'Can not compile: ', ex errorMessage at: range first ]]
		on: UndeclaredVariableReference
		do: [ :ex | parser notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: range first ]]
		on: Error
		do: [ :ex | parser notify: 'Can not evaluate code: ', ex description at: range first ].! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658305 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	"This for sure will compile the source code... it would be better to get the literal from the compiled method
	but theres is no way to map from here to the compiled method literals. To do it I would need to generate 
	the code wich means to compile the source code anyway.
	It could also happen that the compiled method does not exist yet...
	Compiling the source code could signal an exception - Hernan"
	^self literalNode basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783941!
analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools

	^self! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783833!
addSymbolsOfExpressionToParser

	expression nodesDo: [ :aNode |
		aNode isMessageNode ifTrue: [ parser addToSentInLiterals: aNode selector key ].
		aNode isLiteralNode ifTrue: [ (aNode literalValue isSymbol and: [ aNode literalValue ~= Scanner doItSelector ])
			ifTrue: [ parser addToSentInLiterals: aNode literalValue ]]]! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783880!
literalNode

	"The literalNode is initialize if really needed. There are situations when only the method node of a compiled method is needed
	and therefore the literal generated for the backtick is not necessary.
	The literal is needed when compiling the source code and sadly, when debugging because the debugger needs to regenerate
	the code for the temp bindings and the relationship between the bytecodes and the source ranges of the nodes.

	If some message of the backtick source code has changed since the time the method was compiled, the resulting literal
	could be different to the one generated when the method was originally compiled.
	The change could include signaling an exception. That could happen while debuggin. That would mean that the backtick
	code is not compliant with what currently should happen, so although it is a bothering solution, it is the more correct one
	since it shows the difference - Hernan"

	literalNode ifNil: [ self initializeLiteralNode ].
	^literalNode! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783919!
visitExpressionWith: aVisitor

	expression accept: aVisitor! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783924!
visitLiteralWith: aVisitor

	"Remember that creating the literal can signal an exception if the message sent in the expression
	has changed since the method was compiled - Hernan"
	self literalNode accept: aVisitor ! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783954!
sizeCodeForValue: anEncoder

	^self literalNode sizeCodeForValue: anEncoder ! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783959!
expression

	^expression! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783846!
initializeExpression: anExpression source: aSourceCode parser: aParser range: aRange

	expression := anExpression.
	sourceCode := aSourceCode.
	parser := aParser.
	range := aRange.

	self addSymbolsOfExpressionToParser.! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783914 overrides: 16906485!
accept: aVisitor

	^ aVisitor visitBacktickNode: self.
	! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783969 overrides: 16906307!
isBacktickNode

	^true! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783963 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isBacktickNode
		and: [ expression equivalentTo: aParseNode expression ]! !
!BacktickNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783872!
initializeLiteralNode

	| backtickValue |

	backtickValue := self evaluateBacktickSourceCode.
	literalNode := parser encoder encodeLiteral: backtickValue range: range

! !
!BacktickNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16784012!
canNotReferencePseudoVarInsideBacktickErrorDescriptionFor: pseudoVariable

	^ 'Can not reference ', pseudoVariable, ' inside backtick'! !
!BacktickNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783991!
assertNodesIn: anExpression canBeReferencedInsideBacktickUsing: aParser startingAt: aPosition

	^ anExpression nodesDo: [ :aNode |
		(self canNotBeReferencedInsideBacktick: aNode) ifTrue: [
			aParser
				notify: (self canNotReferencePseudoVarInsideBacktickErrorDescriptionFor: aNode key)
				at: aPosition ]]! !
!BacktickNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16784004!
canNotBeReferencedInsideBacktick: aNode

	^ aNode isSelfPseudoVariable
		or: [ aNode isSuperPseudoVariable
		or: [ aNode isThisContextPseudoVariable ]]! !
!BacktickNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16783979!
expression: anExpression source: aSourceCode parser: aParser range: aRange

	self assertNodesIn: anExpression canBeReferencedInsideBacktickUsing: aParser startingAt: aRange first.

	^self new initializeExpression: anExpression source: aSourceCode parser: aParser range: aRange ! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792897!
sizeCodeForClosureValue: encoder
	"Compute the size for the creation of the block and its code."
	"If we have the closure bytecodes constructClosureCreationNode: will note
	 the copied values in the copiedValues inst var and answer #pushCopiedValues."
	closureCreationNode := self constructClosureCreationNode: encoder.
	"Remember size of body for emit time so we know the size of the jump around it."
	size := self sizeCodeForEvaluatedClosureValue: encoder.
	^encoder supportsClosureOpcodes
		ifTrue:
			[(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
			 + (encoder sizePushClosureCopyNumCopiedValues: copiedValues size numArgs: arguments size jumpSize: size)
			 + size]
		ifFalse:
			["closureCreationSupportNode is send closureCopy:copiedValues:"
			(closureCreationNode sizeCodeForValue: encoder)
			 + (encoder sizeJumpLong: size)
			 + size]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50400592 overrides: 16906201!
printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines _ (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(Preferences at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~= $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792277 overrides: 16818698!
arguments
	^arguments ifNil: [#()]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792382 overrides: 16818724!
temporariesDeclaration: aTemporariesDeclarationNode
	"RNG: after removing all the usages of the temporaries inst var, the last line can be removed"

	temporariesDeclaration := aTemporariesDeclarationNode.
	self temporaries: aTemporariesDeclarationNode allDeclaredVariableNodes! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792665!
deoptimize
	optimized := false.
	optimizedMessageNode := nil! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792670!
emitCodeForClosureValue: stack encoder: encoder
	"if not supportsClosureOpcodes closureCreationSupportNode is the
	 node for thisContext closureCopy: numArgs [ copiedValues: { values } ]"
	encoder supportsClosureOpcodes
		ifTrue:
			[copiedValues do:
				[:copiedValue| copiedValue emitCodeForValue: stack encoder: encoder].
			 closureCreationNode pc: encoder methodStreamPosition + 1.
			 encoder
				genPushClosureCopyNumCopiedValues: copiedValues size
				numArgs: arguments size
				jumpSize: size.
			 stack
				pop: copiedValues size;
				push: 1]
		ifFalse:
			[closureCreationNode emitCodeForValue: stack encoder: encoder.
			 encoder genJumpLong: size]. "Force a two byte jump."
	"Emit the body of the block"
	self emitCodeForEvaluatedClosureValue: stack encoder: encoder! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792272!
addArgument: aTempVariableNode
	temporaries := temporaries copyWith: aTempVariableNode! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50370530 overrides: 50370511!
referencesSelf

	^self statements anySatisfy: [:aParseNode | aParseNode referencesSelf]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792751!
nilReadBeforeWrittenTemps
	| visitor readBeforeWritten |
	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).
	readBeforeWritten := visitor readBeforeWritten.
	temporaries reverseDo:
		[:temp|
		((readBeforeWritten includes: temp)
		 and: [temp isRemote not]) ifTrue:
			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658398 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^`{ BlockClosure }`! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792869!
remoteTempNodeName
	"Answer a useful name for a RemoteTempVectorNode in the receiver."
	| prefix scope extent |
	prefix := actualScopeIfOptimized ifNil: ['<'] ifNotNil: [ '<...'].
	scope := self.
	[extent := scope blockExtent.
	 extent == nil
	 and: [scope actualScope ~~ scope]] whileTrue:
		[scope := scope actualScope].
	^extent
		ifNil: [prefix, '?-?>']
		ifNotNil:
			[prefix, extent first printString, '-',
				(extent last isZero
					ifTrue: ['?']
					ifFalse: [extent last printString]), '>']! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792341!
startOfLastStatement
	^startOfLastStatement! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793037!
arguments: argNodes statements: statementsCollection returns: returnBool from: encoder
	"Compile."
	arguments _ argNodes.
	statements _ statementsCollection size > 0
		ifTrue: [ statementsCollection ]
		ifFalse: [ Array with: NodeNil ].
	optimized _ false.
	returns _ returnBool! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793354!
isQuick
	^ statements size = 1
		and: [statements first isVariableReference
				or: [statements first isSpecialConstant]]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793095!
printArgumentsOn: aStream indent: level
	(arguments isNil or: [arguments isEmpty]) ifTrue: [^ self].
	aStream space.
	arguments do:
		[ :arg | aStream nextPut: $:; nextPutAll: arg key; space ].
	aStream nextPut: $|! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792399!
tempsMark: anInteger
	"Index of the end of the temporaries declarations in the containing MethodNode sourceText"
	tempsMark := anInteger! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793019!
sizeCodeForValue: encoder
	^self sizeCodeForClosureValue: encoder! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793241 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level
	aStream nextPut: $[; space.
	blockExtent ifNotNil: [aStream print: blockExtent].
	self printWithClosureAnalysisArgumentsOn: aStream indent: level.
	self printWithClosureAnalysisTemporariesOn: aStream indent: level.
	self printWithClosureAnalysisStatementsOn: aStream indent: level.
	aStream space; nextPut: $]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792410!
actualScope
	"Answer the actual scope for the receiver.  If this is an unoptimized block then it is its
	 actual scope, but if this is an optimized block then the actual scope is some outer block."
	^actualScopeIfOptimized ifNil: [self]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793347!
isJustCaseError

	^ statements size = 1 and:
		[statements first
			isMessage: #caseError
			receiver: [:r | r==NodeSelf]
			arguments: nil]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793024!
statementsDo: aBlock

	statements do: aBlock! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792318!
returnLast
	self returns
		ifFalse: 
			[returns _ true.
			statements at: statements size put: statements last asReturnNode]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50658405 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^`FixedType for: BlockClosure`! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792634!
computeCopiedValues: rootNode
	| referencedValues |
	referencedValues := rootNode referencedValuesWithinBlockExtent: blockExtent.
	^(referencedValues reject: [:temp| temp isDefinedWithinBlockExtent: blockExtent])
		asArray sort: ParseNode tempSortBlock! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50650236 overrides: 50650227!
sendsMessageToSelf: aSelector

	^ self statements anySatisfy: [ :statementNode | statementNode sendsMessageToSelf: aSelector ]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793048!
noteSourceRangeStart: start end: end encoder: encoder
	"Note two source ranges for this node.  One is for the debugger
	 and is of the last expression, the result of the block.  One is for
	 source analysis and is for the entire block."
	encoder
		noteSourceRange: (start to: end)
		forNode: self closureCreationNode.
	startOfLastStatement
		ifNil:
			[encoder
				noteSourceRange: (start to: end)
				forNode: self]
		ifNotNil:
			[encoder
				noteSourceRange: (startOfLastStatement to: end - 1)
				forNode: self]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792288!
closureCreationNode
	closureCreationNode ifNil:
		[closureCreationNode := LeafNode new
									key: #closureCreationNode
									code: nil].
	^closureCreationNode! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793368!
returns
	^returns or: [statements last isReturningIf]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793341 overrides: 16906339!
isJust: node 
	returns ifTrue: [^false].
	^statements size = 1 and: [statements first == node]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792393!
tempsMark
	"Index of the end of the temporaries declarations in the containing MethodNode sourceText"
	^tempsMark! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792482!
analyseArguments: methodArguments temporaries: methodTemporaries rootNode: rootNode "<MethodNode>" "^<Sequence of: <TempVarNade>>"
	"Top level entry-point for analysing temps within the hierarchy of blocks in the receiver's method.
	 Answer the (possibly modified) sequence of temp vars.
	 Need to hoist temps out of macro-optimized blocks into their actual blocks.
	 Need to note reads and writes to temps from blocks other than their actual blocks to determine
	 whether blocks can be local (simple slots within a block/method context) or remote (slots in
	 indirection vectors that are shared between contexts by sharing indirection vectors).

	 The algorithm is based on numbering temporary reads and writes and block extents.
	 The index used for numbering starts at zero and is incremented on every block entry
	 and block exit.  So the following
		| a b blk r1 r2 t |
		a := 1. b := 2. t := 0.
		blk := [ | s | s := a + b. t := t + s].
		r1 := blk value.
		b := -100.
		r2 := blk value.
		r1 -> r2 -> t
	is numbered as
		method block 0 to: 6:
		| a b blk r1 r2 t |
		a w@1 := 1. b w@1 := 2. t w@1 := 0.
		blk w@5 := [entry@2 | s |
					 t  w@3 := t r@3 + a r@3 + b r@3
					] exit@4.
		r1 w@5 := blk r@5 value.
		b w@5 := nil.
		r2 w@5 := blk r@5 value.
		r1 r@5 -> r2 r@5 -> t r@5
	So:
		b and blk cannot be copied because for both there exists a write @5 that follows a
			read @4 within block 2 through 4
		t must be remote because there exists a write @3 within block (2 to: 4)
	Complications are introduced by optimized blocks.  In the following temp is written to
	after it is closed over by [ temp ] since the inlined block is executed more than once.
		| temp coll |
		coll := OrderedCollection new.
		1 to: 5 do: [ :index | 
			temp := index. 
			coll add: [ temp ] ].
		self assert: (coll collect: [:ea| ea value]) asArray = #(5 5 5 5 5)
	In the following i is local to the block and must be initialized each time around the loop
	but if the block is inlined it must be declared at method level.
		| col |
		col := OrderedCollection new.
		1 to: 3 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
		self assert: (col collect: [ :each | each value ]) asArray = #(2 3 4)"
	self assert: (arguments isEmpty or: [arguments hasEqualElements: methodArguments]).
	arguments := methodArguments asArray. "won't change"
	self assert: (temporaries isNil or: [temporaries isEmpty or: [temporaries hasEqualElements: methodTemporaries]]).
	temporaries := OrderedCollection withAll: methodTemporaries.

	self assert: optimized not. "the top-level block should not be optimized."
	self analyseTempsWithin: self rootNode: rootNode assignmentPools: Dictionary new.

	"The top-level block needs to reindex temporaries since analysis may have rearranged them.
	 This happens when temps are made remote and/or a remote node is added."
	temporaries withIndexDo:
		[:temp :offsetPlusOne| temp index: arguments size + offsetPlusOne - 1].

	"Answer the (possibly modified) sequence of temps."
	^temporaries asArray! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792370 overrides: 16818715!
temporaries: aCollectionOfTemporaries
	"Collection of TempVariableNodes"
	"RNG: deprecated, try to use #temporariesDeclaration: instead"
	
	temporaries := aCollectionOfTemporaries! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792281 overrides: 16818702!
arguments: argNodes 
	"decompile"

	arguments _ argNodes! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792439!
addRemoteTemp: aTempVariableNode rootNode: rootNode "<MethodNode>"
	"Add aTempVariableNode to my actualScope's sequence of
	 remote temps.  If I am an optimized block then the actual
	 scope is my actualScopeIfOptimized, otherwise it is myself."
	remoteTempNode == nil ifTrue:
		[remoteTempNode := RemoteTempVectorNode new
								name: self remoteTempNodeName
								index: arguments size + temporaries size
								type: LdTempType
								scope: 0.
		 actualScopeIfOptimized
			ifNil:
				[self addTempNode: remoteTempNode.
				 remoteTempNode definingScope: self]
			ifNotNil: [actualScopeIfOptimized addHoistedTemps: { remoteTempNode }]].
	remoteTempNode addRemoteTemp: aTempVariableNode encoder: rootNode encoder.
	"use remove:ifAbsent: because the deferred analysis for optimized
	 loops can result in the temp has already been hoised into the root."
	self removeTempNode: aTempVariableNode ifAbsent: [
		self actualScope removeTempNode: aTempVariableNode ifAbsent: [self shouldNotHappen ]].
	^remoteTempNode! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792828!
reindexingLocalsDo: aBlock encoder: encoderOrNil
	"Evaluate aBlock wih arguments, temporaries and copiedValues reindexed for
	 their positions within the receiver's block, restoring the correct indices afterwards.
	 If encoder is not nil remember the temps for this block's extent."
	| tempIndices result tempsToReindex |
	self assert: copiedValues notNil.
	tempsToReindex := arguments asArray, copiedValues, temporaries.
	tempIndices := tempsToReindex collect: [:temp| temp index].
	tempsToReindex withIndexDo:
		[:temp :newIndex| temp index: newIndex - 1. self assert: temp index + 1 = newIndex].
	encoderOrNil ifNotNil:
		[encoderOrNil noteBlockExtent: blockExtent hasLocals: tempsToReindex].
	result := aBlock ensure:
				["Horribly pragmatic hack.  The copiedValues will have completely
				  unrelated indices within the closure method and sub-method.
				  Avoiding the effort of rebinding temps in the inner scope simply
				  update the indices to their correct ones during the generation of
				  the closure method and restore the indices immedately there-after."
				 tempsToReindex with: tempIndices do:
					[:temp :oldIndex| temp index: oldIndex. self assert: temp index = oldIndex]].
	^result! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792992!
sizeCodeExceptLast: encoder
	| codeSize statement |
	codeSize := 0.
	1 to: statements size - 1 do: [ :i |
		 statement := statements at: i.
		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].
	^codeSize! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792356 overrides: 16818711!
temporaries
	"Collection of TempVariableNodes"
	
	"RNG: implementation can be changed after adopting the use of temporariesDeclaration inst var.
	After that, the implementation for this message can be changed to:
	^ temporariesDeclaration allDeclaredVariableNodes
	
	Or we can analyze the senders and change the way we request the temporaries"
	
	^temporaries ifNil: [#()]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792345!
startOfLastStatement: anInteger
	"Note the source index of the start of the last full statement.  The
	 last full statement is the value answered by a block and hence the
	 expression the debugger should display as the value of the block."
	startOfLastStatement := anInteger! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793067!
statements: statementsCollection returns: returnBool 
	"Decompile."

	| returnLast |
	returnLast := returnBool.
	returns := false.
	statements := 
		(statementsCollection size > 1 
			and: [(statementsCollection at: statementsCollection size - 1) 
					isReturningIf])
				ifTrue: 
					[returnLast := false.
					statementsCollection allButLast]
				ifFalse: [statementsCollection size = 0
						ifTrue: [Array with: NodeNil]
						ifFalse: [statementsCollection]].
	arguments := #().
	temporaries := #().
	optimized := false.
	returnLast ifTrue: [self returnLast]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792766!
noteOptimizedIn: anOptimizedMessageNode
	optimized := true.
	optimizedMessageNode := anOptimizedMessageNode! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792986!
emitCodeForValue: stack encoder: encoder

	^self emitCodeForClosureValue: stack encoder: encoder! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792474!
addTempNode: aTempVariableNode
	"Utilities for when we want to add some temporaries."
	
	self makeTemporariesRemovable.
	^temporaries add: aTempVariableNode! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50366878!
printTemporaries: tempSequence on: aStream doPrior: aBlock
	"Print any in-scope temporaries.  If there are any evaluate aBlock
	 prior to printing.  Answer whether any temporaries were printed."
	| tempStream seen |
	tempSequence ifNil:
		[^false].
	tempStream := String writeStream.
	"This is for the decompiler which canmot work out which optimized block a particular temp is
	 local to and hence may produce diplicates as in
		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"
	seen := Set new.
	tempSequence do:
		[:tempNode |
		tempNode isIndirectTempVector
			ifTrue:
				[tempNode remoteTemps do:
					[:tempVariableNode|
					 (tempVariableNode scope >= 0
					  and: [(seen includes: tempNode key) not]) ifTrue:
						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]
			ifFalse:
				[(tempNode scope >= -1
				  and: ["This is for the decompiler which may create a block arg when converting
						a while into a to:do: but won't remove it form temporaries"
					   tempNode isBlockArg not
				  and: [(seen includes: tempNode key) not]]) ifTrue:
					[tempStream space; nextPutAll: (seen add: tempNode key)]]].
	tempStream position = 0 ifTrue:
		[^false].
	aBlock value.
	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.
	^true! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793255!
printWithClosureAnalysisStatementsOn: aStream indent: levelOrZero
	| len shown thisStatement level |
	level := 1 max: levelOrZero.
	comment ifNotNil: [
		self printCommentOn: aStream indent: level.
		aStream newLineTab: level].
	len := shown := statements size.
	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])
		ifTrue: [shown := 1 max: shown - 1]
		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])
					ifTrue: [shown := shown - 1]].
	1 to: shown do: 
		[:i | 
		thisStatement := statements at: i.
		thisStatement printWithClosureAnalysisOn: aStream indent: level.
		i < shown ifTrue: [aStream nextPut: $.; newLineTab: level].
		(thisStatement comment notNil and: [thisStatement comment size > 0])
			ifTrue: [
				i = shown ifTrue: [aStream newLineTab: level].
				thisStatement printCommentOn: aStream indent: level.
				i < shown ifTrue: [aStream newLineTab: level]]]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792285 overrides: 16818707!
block
	^ self! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793139!
printStatementsOn: aStream indent: levelOrZero
	| len shown thisStatement level |
	level _ 1 max: levelOrZero.
	comment ifNotNil: [
		self printCommentOn: aStream indent: level.
		aStream newLineTab: level].
	statements isNil ifTrue: [^0].
	len _ shown _ statements size.
	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])
		ifTrue: [ shown _ 1 max: shown - 1]
		ifFalse: ["should a trailing nil be printed or not? Not if it is an implicit result."
				(arguments size = 0
				and: [ len >= 1
				and: [ (statements at: len) == NodeNil
				and: [ len = 1
					or: [ len > 1
						and: [(statements at: len - 1) isMessageNode
						and: [(statements at: len - 1) isNilIf ]]]]]])
					ifTrue: [ shown _ shown - 1 ]].
	1 to: shown do: 
		[ :i |
		thisStatement _ statements at: i.
		thisStatement printOn: aStream indent: level.
		i < shown ifTrue: [ aStream nextPut: $.; newLineTab: level ].
		"Add a final period. This helps when pretty-diffing a method and a version of it that adds stuff after the end."
		(i = shown and: [ levelOrZero = 0 ]) ifTrue: [ aStream nextPut: $. ].
		(thisStatement comment notNil and: [ thisStatement comment size > 0 ])
			ifTrue: [
				i = shown ifTrue: [ aStream newLineTab: level ].
				thisStatement printCommentOn: aStream indent: level.
				i < shown ifTrue: [ aStream newLineTab: level ]]].
	^shown! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792975!
emitCodeForEvaluatedValue: stack encoder: encoder
	| position |
	position := stack position.
	self emitCodeExceptLast: stack encoder: encoder.
	statements last emitCodeForBlockValue: stack encoder: encoder.
	self assert: stack position - 1 = position! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793331 overrides: 16906320!
isComplex
	(statements isNil or: [arguments isNil or: [temporaries isNil]]) ifTrue: [^false].
	^ statements size > 1 or:
		[ (statements size = 1 and: [ statements first isComplex ]) or:
			[ arguments size > 0 or: [ temporaries notEmpty ] ] ]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792300!
nArgsSlot
	"Private for the Encoder to use in bindArg"
	^nArgsNode! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793002!
sizeCodeForEvaluatedEffect: encoder

	^self returns
		ifTrue: [self sizeCodeForEvaluatedValue: encoder]
		ifFalse: [(self sizeCodeExceptLast: encoder)
				+ (statements last sizeCodeForEffect: encoder)]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793302 overrides: 16906269!
expandRanges: sourceRanges basedOn: allSourceRanges using: sourceCode
	"the closure creation node already contains the source ranges including the [ ] and arguments declaration"

	^ self consolidateAsCollection: (allSourceRanges at: closureCreationNode)! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792630!
blockExtent "^<Interval>"
	^blockExtent! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793227!
printWithClosureAnalysisArgumentsOn: aStream indent: level
	arguments size = 0 ifTrue: [^self].
	arguments do: [ :tempNode |
		aStream space; nextPut: $:.
		tempNode printDefinitionForClosureAnalysisOn: aStream].
	aStream nextPut: $|; space.
	"If >0 args and >1 statement, put all statements on separate lines"
	statements size > 1 ifTrue: [
		aStream newLineTab: level]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792579!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	| effectiveScope blockStart |
	effectiveScope := optimized
						ifTrue: [actualScopeIfOptimized := scopeBlock]
						ifFalse: [self].

	arguments ifNotNil:
		[arguments do: [:temp| temp definingScope: self]].
	temporaries ifNotNil:
		[temporaries do: [:temp| temp definingScope: self]].

	optimized ifFalse: "if optimized this isn't an actual scope"
		[rootNode noteBlockEntry:
			[:entryNumber|
			 blockExtent := (blockStart := entryNumber) to: 0]].

	"Need to enumerate a copy because closure analysis can add a statement
	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."
	statements copy do:
		[:statement|
		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].

	optimized
		ifTrue: "if optimized loop need to add nils for any temps read before written"
			[optimizedMessageNode isOptimizedLoop ifTrue:
				[self nilReadBeforeWrittenTemps]]
		ifFalse: "if optimized this isn't an actual scope"
			[rootNode noteBlockExit:
				[:exitNumber|
				 blockExtent := blockStart to: exitNumber]].

	"Now that the analysis is done move any temps that need to be moved."
	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.

	"This is simply a nicety for compiler developers..."
	temporaries do:
		[:temp|
		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:
			[temp name: temp definingScope remoteTempNodeName]]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793328 overrides: 16906310!
isBlockNode
	^true! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792888!
removeTempNode: aTempVariableNode ifAbsent: aBlock
	"Utilities for when we want to remove some temporaries."
	
	self makeTemporariesRemovable.
	^temporaries remove: aTempVariableNode ifAbsent: aBlock
	! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792773 overrides: 16906067!
optimizedBlockHoistTempsInto: scopeBlock "<BlockNode>"
	"This is a No-op for all nodes except non-optimized BlockNodes."
	"Let's assume the special > 0 guard in MessageNode>>analyseTempsWithin:forValue:encoder: is correct.
	 Then we can simply hoist our temps up."
	self assert: (arguments isNil or: [arguments size <= 1]).
	(arguments notNil and: [arguments notEmpty]) ifTrue:
		[scopeBlock addHoistedTemps: arguments.
		arguments := #()].
	temporaries notEmpty ifTrue:
		[scopeBlock addHoistedTemps: temporaries.
		temporaries := #()]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792715!
ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode
	"If a remoteTempNode has been added ensure a statement exists to initialize it."
	remoteTempNode ~~ nil ifTrue:
		[(statements notEmpty
		  and: [statements first isAssignmentNode
		  and: [statements first variable isTemp
		  and: [statements first variable isIndirectTempVector]]])
			ifTrue: "If this is a decompiled tree, or if a temporary has been added later in
					the analysis then there already is a temp vector initialization node."
				[(statements first variable ~~ remoteTempNode) ifTrue:
					[statements first variable become: remoteTempNode].
				 statements first value numElements: remoteTempNode remoteTemps size]
			ifFalse:
				[statements addFirst: (remoteTempNode nodeToInitialize: rootNode encoder)]].! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50370536 overrides: 50370514!
referencesSuper

	^self statements anySatisfy: [:aParseNode | aParseNode referencesSuper]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793029!
statements
	^statements! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792406!
code
	^statements first code! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793313 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isBlockNode
		and: [ self hasEquivalentArgumentsWith: aParseNode ]
		and: [ self hasEquivalentTemporariesDeclarationWith: aParseNode ]
		and: [ self hasEquivalentStatementsWith: aParseNode ]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793012!
sizeCodeForEvaluatedValue: encoder

	^(self sizeCodeExceptLast: encoder)
		+ (statements last sizeCodeForBlockValue: encoder)! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792305!
nArgsSlot: anInteger
	"Private for the Encoder to use in bindArg"
	nArgsNode := anInteger! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792315!
optimized
	^optimized! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792947!
emitCodeExceptLast: stack encoder: encoder
	| position nextToLast statement |
	position := stack position.
	nextToLast := statements size - 1.
	1 to: nextToLast do: [ :i |
		statement := statements at: i.
		statement emitCodeForEffect: stack encoder: encoder.
		self assert: stack position = position].! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792311!
numberOfArguments
	^arguments size! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792698!
emitCodeForEvaluatedClosureValue: stack encoder: encoder
	| position |
	position := stack position.
	stack position: arguments size + temporaries size + copiedValues size.
	encoder genPushNClosureTemps: temporaries size.
	self
		reindexingLocalsDo: [self emitCodeForEvaluatedValue: stack encoder: encoder]
		encoder: encoder.
	self returns ifFalse:
		[encoder genReturnTopToCaller.
		 pc := encoder methodStreamPosition].
	stack position: position! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 50400628 overrides: 16906470!
printsInNewLine
	"Used for pretty printing to determine whether to start a new line"

	(Preferences at: #prettyPrintRectangularBlocks) ifFalse: [ ^false ].
	^super printsInNewLine! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792928!
sizeCodeForEvaluatedClosureValue: encoder
	"The closure value primitives push the arguments and the copied values.
	 The compiler guarantees that any copied values come before all local temps.
	 So on closure activation we only need to push nils for the remaining temporaries."
	^(encoder sizePushNClosureTemps: temporaries size)
	+ (self
		reindexingLocalsDo: [self sizeCodeForEvaluatedValue: encoder]
		encoder: nil "don't store temps yet")
	+ (self returns ifTrue: [0] ifFalse: [encoder sizeReturnTopToCaller])! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792645!
constructClosureCreationNode: encoder
	copiedValues := self computeCopiedValues: encoder rootNode.
	encoder supportsClosureOpcodes ifTrue:
		[^self closureCreationNode].
	"Without the bytecode we can still get by."
	^MessageNode new
		receiver: (encoder encodeVariable: 'thisContext')
		selector: #closureCopy:copiedValues:
		arguments: (Array
						with: (encoder encodeLiteral: arguments size)
						with: (copiedValues isEmpty
								ifTrue: [NodeNil]
								ifFalse: [BraceNode new elements: copiedValues]))
		precedence: 3
		from: encoder! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792378 overrides: 16818720!
temporariesDeclaration

	^ temporariesDeclaration! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16792793!
postNumberingProcessTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"
	"A temp can be local (and copied) if it is not written to after it is captured.
	 A temp cannot be local if it is written to remotely.
	 Need to enumerate a copy of the temporaries because any temps becoming remote
	 will be removed from temporaries in analyseClosure: (and a single remote temp node
	 will get added)"
	temporaries copy do:
		[:each|
		each isIndirectTempVector ifFalse:
			[each analyseClosure: rootNode]].

	"If this is an optimized node we need to hoist temporaries up into the relevant block scope."
	optimized ifTrue:
		[self optimizedBlockHoistTempsInto: scopeBlock].

	"Now we may have added a remoteTempNode.  So we need a statement to initialize it."
	self ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode.

	"Now add all arguments and locals to the pool so that copiedValues can be computed during sizing."
	rootNode
		addLocalsToPool: arguments;
		addLocalsToPool: temporaries! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793286!
printWithClosureAnalysisTemporariesOn: aStream indent: level

	(temporaries == nil or: [temporaries size = 0]) ifFalse: [
		aStream nextPut: $|.
		temporaries do: [ :tempNode |
			aStream space.
			tempNode printDefinitionForClosureAnalysisOn: aStream].
		aStream nextPutAll: ' | '.
		"If >0 args and >1 statement, put all statements on separate lines"
		statements size > 1 ifTrue: [aStream newLineTab: level]]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:32' prior: 16793087 overrides: 16818729!
decompileString 
	"Answer a string description of the parse tree whose root is the receiver."

	^ String streamContents: [:strm | self printOn: strm indent: 0]
! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16792325!
returnNilIfNoOther

	self returns
		ifFalse: 
			[statements last == NodeNil ifFalse: [statements add: NodeNil].
			self returnLast]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16792960!
emitCodeForEvaluatedEffect: stack encoder: encoder
	| position |
	position := stack position.
	self returns
		ifTrue: 
			[self emitCodeForEvaluatedValue: stack encoder: encoder.
			stack pop: 1]
		ifFalse: 
			[self emitCodeExceptLast: stack encoder: encoder.
			statements last emitCodeForEffect: stack encoder: encoder].
	self assert: stack position = position! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16792421!
addHoistedTemps: additionalTemporaries "<SequenceableCollection>"
	additionalTemporaries do:
		[:temp|
		temp definingScope ifNil:
			[temp definingScope: self]].
	temporaries := (temporaries isNil or: [temporaries isEmpty])
					ifTrue: [additionalTemporaries copy]
					ifFalse:
						[temporaries last isIndirectTempVector
							ifTrue: [temporaries allButLast, additionalTemporaries, { temporaries last }]
							ifFalse: [temporaries, additionalTemporaries]]! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16792332!
returnSelfIfNoOther: encoder

	self returns ifTrue:[^self].
	statements last == NodeSelf ifFalse: [
		statements := statements copyWith: (encoder encodeVariable: 'self').
	].
	self returnLast.
! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16793372 overrides: 16906485!
accept: aVisitor
	^aVisitor visitBlockNode: self! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16793033!
statements: val
	statements _ val! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16792296!
firstArgument
	^ arguments first! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16793323!
hasArgumentOrTemporaryNamed: aName

	^ self hasLocallyArgumentOrTemporaryNamed: aName! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16792743!
makeTemporariesRemovable
	"Utilities for when we want to remove some temporaries."
	
	temporaries isArray ifTrue:
		[temporaries := temporaries asOrderedCollection].! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16793376!
hasEquivalentStatementsWith: aBlockNode

	statements size ~= aBlockNode statements size ifTrue: [ ^ false ].

	statements with: aBlockNode statements do: [ :myStatement :otherBlockNodeStatement |
		(myStatement equivalentTo: otherBlockNodeStatement) ifFalse: [ ^ false ] ].
	^ true! !
!BlockNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16793393!
statements: statements returns: returns
	^ self new statements: statements returns: returns! !
!BlockNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629705!
empty

	^ self statements: #() returns: false! !
!BlockNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16793399!
withJust: aNode
	^ self new statements: (Array with: aNode) returns: false! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794726 overrides: 16906201!
printOn: aStream indent: level
	| isComplex useLevel |
	useLevel := level.
	isComplex := elements anySatisfy: [ :ea |
		ea isComplex ].
	isComplex ifTrue: [ useLevel := useLevel + 1 ].
	aStream nextPut: ${.
	1
		to: elements size
		do: [ :i |
			isComplex ifTrue: [ aStream newLineTab: (1 max: useLevel) ].
			(elements at: i)
				printOn: aStream
				indent: useLevel.
			i < elements size ifTrue: [ aStream nextPutAll: '. ' ]].
	isComplex ifTrue: [ aStream newLineTab: (1 max: level) ].
	aStream nextPut: $}.! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794595!
emitCodeForValue: stack encoder: encoder

	(encoder supportsClosureOpcodes
		"Hack; we have no way of knowing how much stack space is available"
	 and: [elements size <= self maxElementsForConsArray]) ifTrue:
		[ self elementsDo: [:node| node emitCodeForValue: stack encoder: encoder].
		 encoder genPushConsArray: elements size.
		 stack
			pop: elements size;
			push: 1.
		 ^self].
	^emitNode emitCodeForValue: stack encoder: encoder! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794692!
elements: collection sourceLocations: locations
	"Compile."

	elements _ collection.
	sourceLocations _ locations! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794787 overrides: 16906320!
isComplex
	^ true.! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794790!
numElements

	^ elements size! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658339 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^{ Array }
	"elements 
		inject: Set new
		addingAll: [ :aParseNode | aParseNode typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons ]"! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794588!
maxElementsForConsArray
	"Hack; we have no way of knowing how much stack space is available during sizing"
	^8! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794573!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"

	self elementsDo: [ :node |
		node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools ]! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794584!
elements
	^elements! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794745 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level

	aStream nextPut: ${.
	1 to: elements size do: 
		[:i | (elements at: i) printWithClosureAnalysisOn: aStream indent: level.
		i < elements size ifTrue: [aStream nextPutAll: '. ']].
	aStream nextPut: $}! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794612!
sizeCodeForValue: encoder

	(encoder supportsClosureOpcodes
		"Hack; we have no way of knowing how much stack space is available"
	 and: [elements size <= self maxElementsForConsArray]) ifTrue:
		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
		  + (encoder sizePushConsArray: elements size)].
	emitNode := elements size <= 4
		ifTrue: ["Short form: Array braceWith: a with: b ... "
				MessageNode new
					receiver: (encoder encodeVariable: #Array)
					selector: (self selectorForShortForm: elements size)
					arguments: elements precedence: 3 from: encoder]
		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"
				CascadeNode new
					receiver: (MessageNode new
								receiver: (encoder encodeVariable: #Array)
								selector: #braceStream:
								arguments: (Array with: (encoder encodeLiteral: elements size))
								precedence: 3 from: encoder)
					messages: ((elements collect: [:elt | MessageNode new receiver: nil
														selector: #nextPut:
														arguments: (Array with: elt)
														precedence: 3 from: encoder])
								copyWith: (MessageNode new receiver: nil
														selector: #braceArray
														arguments: (Array new)
														precedence: 1 from: encoder))].
	^emitNode sizeCodeForValue: encoder! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794756!
blockAssociationCheck: encoder
	"If all elements are MessageNodes of the form [block]->[block], and there is at
	 least one element, answer true.
	 Otherwise, notify encoder of an error."

	elements size = 0
		ifTrue: [^encoder notify: 'At least one case required'].
	elements with: sourceLocations do:
			[:x :loc |
			(x 	isMessage: #->
				receiver:
					[:rcvr |
					rcvr isBlockNode and: [rcvr numberOfArguments = 0]]
				arguments:
					[:arg |
					arg isBlockNode and: [arg numberOfArguments = 0]])
			  ifFalse:
				[^encoder notify: 'Association between 0-argument blocks required' at: loc]].
	^true! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794657!
casesForwardDo: aBlock
	"For each case in forward order, evaluate aBlock with three arguments:
	 the key block, the value block, and whether it is the last case."

	| numCases case |
	1 to: (numCases _ elements size) do:
		[:i |
		case _ elements at: i.
		aBlock value: case receiver value: case arguments first value: i=numCases]! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794778 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isBraceNode and: [ self hasEquivalentElementsTo: aParseNode ]! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658351 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  storingGenericsInfoIn: aStorage
	
	aStorage initializeAnalysisForTypes: {Array}.
	elements do: [:aParseNode | 
		aStorage 
			addType:  (aParseNode liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  storingGenericsInfoIn: aStorage)
			to:  1
			for: Array.
	].
	^aStorage inferredTypes.! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794687!
elements: collection
	"Decompile."

	elements _ collection! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794564!
selectorForShortForm: nElements

	nElements > 4 ifTrue: [^ nil].
	^ #(braceWithNone braceWith: braceWith:with:
			braceWith:with:with: braceWith:with:with:with:) at: nElements + 1! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794670!
casesReverseDo: aBlock
	"For each case in reverse order, evaluate aBlock with three arguments:
	 the key block, the value block, and whether it is the last case."

	| numCases case |
	(numCases _ elements size) to: 1 by: -1 do:
		[:i |
		case _ elements at: i.
		aBlock value: case receiver value: case arguments first value: i=numCases]! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794784 overrides: 16906313!
isBraceNode

	^ true! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794798!
hasEquivalentElementsTo: aBraceNode

	elements size ~= aBraceNode elements size ifTrue: [ ^ false ]. 

	elements with: aBraceNode elements do: [ :myElement :otherElement |
		(myElement equivalentTo: otherElement) ifFalse: [ ^ false ] ].
	^ true! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794698!
matchBraceStreamReceiver: receiver messages: messages

	((receiver isMessage: #braceStream: receiver: nil arguments: [:arg | arg isConstantNumber])
		and: [messages last isMessage: #braceArray receiver: nil arguments: nil])
		ifFalse: [^ nil "no match"].

	"Appears to be a long form brace construct"
	self elements: (messages allButLast collect:
		[:msg | (msg isMessage: #nextPut: receiver: nil arguments: nil)
					ifFalse: [^ nil "not a brace element"].
		msg arguments first])! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794683!
elementsDo: aBlock

	elements do: aBlock! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794794 overrides: 16906485!
accept: aVisitor
	^aVisitor visitBraceNode: self! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794716!
matchBraceWithReceiver: receiver selector: selector arguments: arguments

	selector = (self selectorForShortForm: arguments size)
		ifFalse: [^ nil "no match"].

	"Appears to be a short form brace construct"
	self elements: arguments! !
!BraceNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16794814!
example
	"Test the {a. b. c} syntax."

	| x |
	x := {1. {2. 3}. 4}.
	^ {x first. x second first. x second last. x last. 5} as: Set

"BraceNode example Set (0 1 2 3 4 5 )"
! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800495 overrides: 16906201!
printOn: aStream indent: level
	self printOn: aStream indent: level precedence: 0! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658382 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage

	| lastMessage |
	
	lastMessage := messages last.
	lastMessage receiver: receiver.
	
	^[ lastMessage liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage ]
		ensure: [ lastMessage receiver: nil ]
	! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800465!
emitCodeForValue: stack encoder: encoder
	receiver emitCodeForValue: stack encoder: encoder.
	1 to: messages size - 1 do: 
		[:i | 
		encoder genDup.
		stack push: 1.
		(messages at: i) emitCodeForValue: stack encoder: encoder.
		encoder genPop.
		stack pop: 1].
	messages last emitCodeForValue: stack encoder: encoder! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800564!
receiver: receivingObject messages: msgs
	" Transcript show: 'abc'; cr; show: 'def' "

	receiver _ receivingObject.
	messages _ msgs! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800571 overrides: 16906269!
expandRanges: aSourceRange basedOn: sourceRanges using: sourceCode

	| receiverExpandedRanges expandedRangeWithReceiver |
	receiverExpandedRanges _ receiver expandRanges: (sourceRanges at: receiver) basedOn: sourceRanges using: sourceCode.
	expandedRangeWithReceiver _ self
		expandRange: (aSourceRange isInterval ifTrue: [ aSourceRange ] ifFalse: [ aSourceRange first ])
		basedOn: receiverExpandedRanges.
	^ super
		expandRanges: expandedRangeWithReceiver
		basedOn: expandedRangeWithReceiver
		using: sourceCode! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800560 overrides: 16906320!
isComplex
	^ true! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800491!
receiver
	^receiver! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800546!
hasEquivalentMessagesWith: aCascadeNode

	messages size ~= aCascadeNode messages size ifTrue: [ ^ false ].

	messages with: aCascadeNode messages do: [ :myMessage :otherNodeMessage |
		(myMessage equivalentTo: otherNodeMessage) ifFalse: [ ^ false ] ].
	^ true! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658368 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  

	| lastMessage |
	
	lastMessage := messages last.
	lastMessage receiver: receiver.
	
	^[ lastMessage basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons ]
		ensure: [ lastMessage receiver: nil ]
	! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800454!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	{ receiver }, messages do:
		[:node| node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629681 overrides: 50629476!
receiverOrCascadeReceiver
	
	^receiver ! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800488!
messages
	^messages! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800515 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level
	self printWithClosureAnalysisOn: aStream indent: level precedence: 0! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800500 overrides: 16906207!
printOn: aStream indent: level precedence: p
	p > 0 ifTrue: [ aStream nextPut: $( ].
	messages first
		printReceiver: receiver
		on: aStream
		indent: level.
	1
		to: messages size
		do: [ :i | 
			aStream newLineTab: level + 1.
			(messages at: i)
				printOn: aStream
				indent: level+1.
			i < messages size ifTrue: [ aStream nextPut:$; ] ].
	p > 0 ifTrue: [ aStream nextPut: $) ]! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800478!
sizeCodeForValue: encoder
	| size |
	size := (receiver sizeCodeForValue: encoder)
			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).
	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].
	^size! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800557 overrides: 16906316!
isCascadeNode

	^ true! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800449 overrides: 16906485!
accept: aVisitor
	^aVisitor visitCascadeNode: self! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800521 overrides: 16906238!
printWithClosureAnalysisOn: aStream indent: level precedence: p 

	p > 0 ifTrue: [aStream nextPut: $(].
	messages first printWithClosureAnalysisReceiver: receiver on: aStream indent: level.
	1 to: messages size do: 
		[:i | (messages at: i) printWithClosureAnalysisOn: aStream indent: level.
		i < messages size ifTrue: 
				[aStream nextPut: $;.
				messages first precedence >= 2 ifTrue: [aStream newLineTab: level + 1]]].
	p > 0 ifTrue: [aStream nextPut: $)]! !
!CascadeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16800538 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isCascadeNode
		and: [ receiver equivalentTo: aParseNode receiver ]
		and: [ self hasEquivalentMessagesWith: aParseNode ]! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818698!
arguments

	self subclassResponsibility ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818805!
isLocalArgumentOrTemporary: aParseNode

	"Looks only in this scope - Hernan"
	^(self temporaries includes: aParseNode) or: [ self arguments includes: aParseNode ]
	! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818707!
block

	self subclassResponsibility ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818724!
temporariesDeclaration: aTemporariesDeclarationNode

	self subclassResponsibility! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818800!
hasTemporaryVariables

	^ self temporariesDeclaration declaresAnyVariable! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818720!
temporariesDeclaration

	self subclassResponsibility! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818767!
hasLocallyArgumentOrTemporaryNamed: aVariableName

	"- hasArgumentOrTemporaryNamed: returns true if there is a temp or variable in this scope or subscopes 
	   named aVariableName
	- hasLocalName: returns true if there is a variable in the scopeTable name aVariableName. That includes 
	  temps, arguments, instance variables and pseudo-variables
	- hasLocallyArgumentOrTemporaryNamed: returns true if ony this scope defines a temp or argument 
	  named aVariableName. - Hernan" 
	
	^(self hasLocallyArgumentNamed: aVariableName)
		or: [self hasLocallyTemporaryNamed: aVariableName]! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818794!
hasNodeIn: aCollectionOfNodes named: aName

	^aCollectionOfNodes anySatisfy: [ :tempNode | tempNode isNamed: aName ]! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818715!
temporaries: aCollectionOfTemporaries

	self subclassResponsibility ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818729!
decompileString

	self subclassResponsibility ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818761!
hasLocallyArgumentNamed: aVariableName
		
	^self hasNodeIn: self arguments named: aVariableName! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818702!
arguments: aCollectionOfArguments

	self subclassResponsibility ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818788!
hasLocallyTemporaryNamed: aVariableName

	^self hasNodeIn: self temporaries named: aVariableName ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818744!
hasEquivalentTemporariesDeclarationWith: aCodeNode

	(self temporariesDeclaration isNil and: [ aCodeNode temporariesDeclaration isNil ]) ifTrue: [ ^true ].
	(self temporariesDeclaration isNil and: [ aCodeNode temporariesDeclaration notNil ]) ifTrue: [ ^false ].
	(self temporariesDeclaration notNil and: [ aCodeNode temporariesDeclaration isNil ]) ifTrue: [ ^false ].
	
	^self temporariesDeclaration equivalentTo: aCodeNode temporariesDeclaration ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818711!
temporaries

	self subclassResponsibility ! !
!CodeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16818733!
hasEquivalentArgumentsWith: aCodeNode

	self arguments size ~= aCodeNode arguments size ifTrue: [ ^ false ].

	self arguments with: aCodeNode arguments do: [ :myArgument :otherCodeNodeArgument |
		(myArgument equivalentTo: otherCodeNodeArgument) ifFalse: [ ^ false ] ].
	^ true! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872649 overrides: 16906335!
isInstanceVariableNode

	^true! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872621 overrides: 16977795!
emitCodeForValue: stack encoder: encoder
	stack push: 1.
	^encoder genPushInstVar: index! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872608 overrides: 16977782!
emitCodeForStore: stack encoder: encoder
	encoder genStoreInstVar: index! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872632 overrides: 16977816!
sizeCodeForStorePop: encoder
	^encoder sizeStorePopInstVar: index! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872614 overrides: 16977787!
emitCodeForStorePop: stack encoder: encoder
	encoder genStorePopInstVar: index.
	stack pop: 1! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658570 overrides: 50658464!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^ aCompiledMethod typesOfInstanceVariableNamed: name ifAbsent: [ #() ]! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872643!
name: varName index: varIndex
	^self name: varName index: varIndex-1 type: LdInstType! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629921 overrides: 50629841!
nodeTypePrintString

	^'inst var'! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872638 overrides: 16977821!
sizeCodeForValue: encoder
	^encoder sizePushInstVar: index! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872603 overrides: 16977633!
accept: aVisitor
	^aVisitor visitInstanceVariableNode: self! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16872627 overrides: 16977811!
sizeCodeForStore: encoder
	^encoder sizeStoreInstVar: index! !
!InstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658579 overrides: 50658540!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^aCompiledMethod liveTypesOfInstanceVariableNamed: name storingGenericsInfoIn: aStorage ifAbsent: [`EmptyType new`].! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880725 overrides: 16906092!
emitCodeForEffect: stack encoder: encoder

	^self! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880730 overrides: 16906134!
sizeCodeForEffect: encoder

	^0! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880751 overrides: 16906293!
equivalentTo: aParseNode

	^ self class = aParseNode class and: [ self key = aParseNode key ]! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658440 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: anStorage

	^`EmptyType new`.! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880762!
name: ignored key: object code: byte 
	key _ object.
	code _ byte! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880710!
sizeCodeForLoad: encoder forValue: forValue
	"Default is to do nothing.
	 Subclasses may need to override."
	^0! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880695!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	"Default is to do nothing.
	 Subclasses may need to override."! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658433 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  

	^#()! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880745!
key: object index: i type: type

	key := object.
	code := (self code: i type: type).
	index := i! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880683!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	"This is a no-op except in TempVariableNode"
	^self! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880757!
key: object code: byte 
	key _ object.
	code _ byte! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880716!
code: idx type: type
	"Warning: index would be shadowed"
	idx ifNil: [
		^type negated].
	(CodeLimits at: type) > idx 
		ifTrue: [^(CodeBases at: type) + idx].
	^type * 256 + idx! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880741!
key: aKey

	key := aKey ! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629808 overrides: 50629447!
isSameAs: aParseNode

	^(super isSameAs: aParseNode) 
		or: [ (aParseNode isKindOf: self class) and: [ key = aParseNode key ]]! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880734!
sizeCodeForValue: encoder
	self subclassResponsibility! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880702!
reserve: encoder 
	"If this is a yet unused literal of type -code, reserve it."

	code < 0 ifTrue: [code := self code: (index := encoder litIndex: key) type: 0 - code]! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880738!
key
	^key! !
!LeafNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16880692!
code
	^code! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881214 overrides: 16906342!
isLiteralNode

	^ true! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881226 overrides: 16906201!
printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea storeOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key storeOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]]! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881177!
emitCodeForValue: stack encoder: encoder
	stack push: 1.
	(encoder
		if: code
		isSpecialLiteralForPush:
			[:specialLiteral|
			 encoder genPushSpecialLiteral: specialLiteral])
		ifFalse:
			[encoder genPushLiteral: index]! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881274!
name: literal key: object index: i type: type
	"For compatibility with Encoder>>name:key:class:type:set:"
	^self key: object index: i type: type! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50368390 overrides: 50361580!
isConstantCharacter
	^ key isCharacter! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881210 overrides: 16906326!
isConstantNumber
	^ key isNumber! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881223!
literalValue

	^key! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881197!
eval
	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"

	^ key! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881218 overrides: 16906415!
isSpecialConstant
	^ code between: LdTrue and: LdMinus1+3! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658448 overrides: 50663336!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^Array with: self literalValue class! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629821 overrides: 50629472!
nodeTypePrintString

	^'literal'! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881262 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level

	key isVariableBinding
		ifTrue:
			[key key isNil
				ifTrue:
					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]
				ifFalse:
					[aStream nextPutAll: '##'; nextPutAll: key key]]
		ifFalse:
			[key storeOn: aStream]! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881187 overrides: 50663384!
sizeCodeForValue: encoder
	self reserve: encoder.
	(encoder
		if: code
		isSpecialLiteralForPush:
			[:specialLiteral|
			 ^encoder sizePushSpecialLiteral: specialLiteral])
		ifFalse:
			[^encoder sizePushLiteral: index]! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881172 overrides: 16906485!
accept: aVisitor
	^aVisitor visitLiteralNode: self! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881281 overrides: 50663389!
reserve: encoder 
	"If this is a yet unused literal of type -code, reserve it."

	code < 0 ifTrue:
		[index := key isVariableBinding "true if sending value[:] to a special binding"
					ifTrue: [encoder sharableLitIndex: key]
					ifFalse: [encoder litIndex: key].
		 code := self code: index type: 0 - code]! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881204 overrides: 50663300!
equivalentTo: aParseNode

	^ aParseNode isLiteralNode and: [ super equivalentTo: aParseNode ]! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658456 overrides: 50663307!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^self literalValue asLiveType.! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881361 overrides: 16977795!
emitCodeForValue: stack encoder: encoder
	^readNode
		ifNil: [stack push: 1.
			encoder genPushLiteralVar: index]
		ifNotNil: [readNode emitCodeForValue: stack encoder: encoder]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881323 overrides: 16977782!
emitCodeForStore: stack encoder: encoder
	| exprOffset |
	writeNode ifNil: [^encoder genStoreLiteralVar: index].
	"On entry the stack has only the expression.  Push the binding,
	 duplicate the expression, send #value: and pop.
	 The various value: methods on Association ReadOnlyVariableBinding
	 etc _do not_ return the value assigned; they return the receiver.  If they
	 did we could generate much simpler code, e.g.
		encoder genPushLiteral: index.
		stack push: 1.
		writeNode emitCode: stack args: 1 encoder: encoder super: false"
	exprOffset := stack position - 1.
	encoder genPushLiteral: index.
	stack push: 1.
	encoder genPushTempLong: exprOffset.
	stack push: 1.
	writeNode
		emitCode: stack
		args: 1
		encoder: encoder
		super: false.
	stack pop: 1.
	encoder genPop! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881399 overrides: 16977816!
sizeCodeForStorePop: encoder
	self reserve: encoder.
	^(key isVariableBinding and: [key isSpecialWriteBinding])
		ifTrue: [	writeNode := encoder encodeSelector: #value:.
				^ (writeNode sizeCode: encoder args: 1 super: false)
	  			+ encoder sizePop]
		ifFalse: [encoder sizeStorePopLiteralVar: index]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881433 overrides: 16906345!
isLiteralVariableNode

	^ true! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881370 overrides: 50663321!
sizeCodeForLoad: encoder forValue: forValue
	self reserve: encoder.
	^(key isVariableBinding and: [key isSpecialWriteBinding and: [forValue not]])
		ifTrue: [encoder sizePushLiteral: index]
		ifFalse: [0]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881441!
isReferencingGlobal
	
	^(Smalltalk bindingOf: key name) notNil  ! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881351 overrides: 16977787!
emitCodeForStorePop: stack encoder: encoder
	writeNode ifNil:
		[stack pop: 1.
		 ^encoder genStorePopLiteralVar: index].
	writeNode
		emitCode: stack
		args: 1
		encoder: encoder
		super: false.
	stack pop: 1.
	encoder genPop! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881306 overrides: 16977838!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	"If a normal literal variable (not sending value:), do nothing.
	 If for value (e.g. v := Binding := expr) do nothing; the work will be done in emitCodeForStore:encoder:.
	 If not for value then indeed load.  The rest of the work will be done in  emitCodeForStorePop:encoder:."
	(writeNode isNil or: [forValue]) ifTrue: [^self].
	encoder genPushLiteral: index.
	stack push: 1! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881437!
isReferencingBehavior
	
	^key value isBehavior! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629935 overrides: 50629841!
nodeTypePrintString

	^'literal var'! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658590 overrides: 50658464!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^ Array with: key value class! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881426 overrides: 16977637!
assignmentCheck: encoder at: location
	^(key isVariableBinding and: [key canAssign not])
		ifTrue: [location]
		ifFalse: [-1]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881412 overrides: 16977821!
sizeCodeForValue: encoder
	self reserve: encoder.
	(key isVariableBinding and: [key isSpecialReadBinding]) 
		ifFalse:
			[^encoder sizePushLiteralVar: index].
	readNode := MessageNode new 
		receiver: (encoder encodeLiteral: key)
		selector: (encoder encodeSelector: #value)
		arguments: #()
		precedence: #value precedence.
	^readNode sizeCodeForValue: encoder! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881301 overrides: 16977633!
accept: aVisitor
	^aVisitor visitLiteralVariableNode: self! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881380 overrides: 16977811!
sizeCodeForStore: encoder
	self reserve: encoder.
	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:
		[^encoder sizeStoreLiteralVar: index].
	writeNode := encoder encodeSelector: #value:.
	"On entry the stack has only the expression.  Push the binding,
	 duplicate the expression, send #value: and pop."
	^(encoder sizePushLiteral: index)
	  + (encoder sizePushTempLong: 0) "we don't know yet, hence long, sigh..."
	  + (writeNode sizeCode: encoder args: 1 super: false)
	  + encoder sizePop! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658598 overrides: 50658540!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  storingGenericsInfoIn: aStorage
	
	^FixedType for: key value class
	
	
	
	
! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881870 overrides: 50663210!
emitCodeForValue: stack encoder: encoder
	stack push: 1.
	^encoder genPushInstVarLong: index! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881857 overrides: 50663217!
emitCodeForStore: stack encoder: encoder
	encoder genStoreInstVarLong: index! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881883 overrides: 50663224!
sizeCodeForStorePop: encoder
	^encoder sizeStorePopInstVarLong: index! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881889 overrides: 50663260!
sizeCodeForValue: encoder
	^encoder sizePushInstVarLong: index! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881877 overrides: 50663272!
sizeCodeForStore: encoder
	^encoder sizeStoreInstVarLong: index! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881850 overrides: 50663402!
code
	"Answer a bogus code to avoid creating quick methods.
	 See MethodNode>>generate:ifQuick:"
	^LoadLong! !
!MaybeContextInstanceVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16881863 overrides: 50663231!
emitCodeForStorePop: stack encoder: encoder
	encoder genStorePopInstVarLong: index.
	stack pop: 1! !
!MessageAsTempNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16883828!
sizeCodeForStorePop: encoder
	"This node has the form {expr storeAt: offset inTempFrame: homeContext},
	where the expr, the block argument, is already on the stack."
	^self sizeCodeForEffect: encoder! !
!MessageAsTempNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16883801!
store: expr from: encoder 
	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).
	For assigning into temps of a context being debugged."

	selector key ~= #namedTempAt: ifTrue: [^self error: 'cant transform this message'].
	
	^ MessageAsTempNode new
		receiver: receiver
		selector: #namedTempAt:put:
		arguments: (arguments copyWith: expr)
		precedence: precedence
		from: encoder! !
!MessageAsTempNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16883817!
emitCodeForStorePop: stack encoder: encoder
	"This node has the form {expr storeAt: offset inTempFrame: homeContext},
	where the expr, the block argument, is already on the stack."
	^self emitCodeForEffect: stack encoder: encoder! !
!MessageAsTempNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16883771!
asStorableNode: encoder
	"This node is a message masquerading as a temporary variable.
	It currently has the form {homeContext tempAt: offset}.
	We need to generate code for {expr storeAt: offset inTempFrame: homeContext},
	where the expr, the block argument, is already on the stack.
	This, in turn will get turned into {homeContext tempAt: offset put: expr}
	at runtime if nobody disturbs storeAt:inTempFrame: in Object (not clean)"
	^ MessageAsTempNode new
		receiver: nil  "suppress code generation for receiver already on stack"
		selector: #storeAt:inTempFrame:
		arguments: (arguments copyWith: receiver)
		precedence: precedence
		from: encoder! !
!MessageAsTempNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16883795!
code
	"Allow synthetic temp nodes to be sorted by code"
	^ arguments first literalValue! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884296!
originalReceiver

	^ originalReceiver! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884271!
arguments
	^arguments! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630037!
isIfNotNil
	
	^self selectorSymbol = #ifNotNil:! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884994!
compare: myArguments with: othersArguments

	myArguments size ~= othersArguments size ifTrue: [ ^ false ].

	myArguments with: othersArguments do: [ :myArgument :otherArgument |
		(myArgument equivalentTo: otherArgument) ifFalse: [ ^ false ] ].
	^ true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884301!
receiver
	^receiver! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629986!
isClassEqualOrIdenticalToObjectClass
	
	^self isEqualOrIdentical and: [ self isReceiverLiteralBehavior and: [ self isFirstArgumentClassMessageSend ]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884500!
printRepeatOn: aStream indent: level

	self printReceiver: receiver on: aStream indent: level.

	^self printKeywords: selector key
		arguments: (Array new)
		on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630041!
isIfWithMessageNodeAsCondition
	
	^self isAnyKindOfIf and: [ self receiverOrCascadeReceiver isMessageNode ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884810!
keywordPositionAt: anIndex

	^keywordRanges at: anIndex ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50370661!
isUnaryMessageSend

	^self selectorSymbol isUnary ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630122 overrides: 50629472!
nodeTypePrintString

	^'message'! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884907 overrides: 16906362!
isMessageNode
	^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885354!
emitCodeForIf: stack encoder: encoder value: forValue
	| thenExpr thenSize elseExpr elseSize |
	thenSize := sizes at: 1.
	elseSize := sizes at: 2.
	(forValue not and: [elseSize * thenSize > 0]) ifTrue:
		"Two-armed IFs forEffect share a single pop"
		[^super emitCodeForEffect: stack encoder: encoder].
	thenExpr := arguments at: 1.
	elseExpr := arguments at: 2.
	receiver emitCodeForValue: stack encoder: encoder.
	forValue
		ifTrue:  "Code all forValue as two-armed"
			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.
			pc := encoder methodStreamPosition.
			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.
			stack pop: 1.  "then and else alternate; they don't accumulate"
			thenExpr returns not ifTrue:
				"...not ifTrue: avoids using ifFalse: alone during this compile)"
				"Elide jump over else after a return"
				[self emitCodeForJump: elseSize encoder: encoder].
			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]
		ifFalse:  "One arm is empty here (two-arms code forValue)"
			[thenSize > 0
				ifTrue:
					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.
					pc := encoder methodStreamPosition.
					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]
				ifFalse:
					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.
					pc := encoder methodStreamPosition.
					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884675 overrides: 16906231!
printWithClosureAnalysisOn: aStream indent: level
	"may not need this check anymore - may be fixed by the #receiver: change"
	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].

	special > 0 ifTrue:
		[^self perform: self macroPrinter with: aStream with: level].

	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.
	self printWithClosureAnalysisKeywords: selector key
		 arguments: arguments
		 on: aStream
		 indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884469 overrides: 16906207!
printOn: strm indent: level precedence: outerPrecedence

	| parenthesize |
	parenthesize := precedence > outerPrecedence
		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].
	parenthesize
		ifTrue: [strm nextPutAll: '('.
				self printOn: strm indent: level.
				strm nextPutAll: ')']
		ifFalse: [self printOn: strm indent: level]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885257!
sizeCodeForValue: encoder
	| total |
	special > 0 
		ifTrue: 
			[encoder noteOptimizedSelector: originalSelector.
			^self perform: (MacroSizers at: special) with: encoder with: true].
	receiver == NodeSuper
		ifTrue: [selector := selector copy "only necess for splOops"].
	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.
	receiver == nil 
		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].
	sizes := arguments collect: 
					[:arg | | argSize | 
					argSize := arg sizeCodeForValue: encoder.
					total := total + argSize.
					argSize].
	^total! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884482!
printParenReceiver: rcvr on: aStream indent: level
					
	rcvr isBlockNode ifTrue:
		[^rcvr printOn: aStream indent: level].
	aStream nextPut: $(.
	rcvr printOn: aStream indent: level.
	aStream nextPut: $)
! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50505552!
transformIfTrueIfFalse: encoder
	(Preferences at: #allowNonBooleanReceiversOfBooleanMessages) ifTrue: [
		(receiver == NodeTrue) | (receiver == NodeFalse) ifFalse: [
			^false ]].
	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder maxArgs: 0)
	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder maxArgs: 0)
	   and: [arguments do: [:arg| arg noteOptimizedIn: self].
			true]].! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885781!
transformRepeat: encoder
	"answer true if this #repeat message can be optimized"
	
	^(self checkBlock: receiver as: 'receiver' from: encoder maxArgs: 0)
	   and: [receiver noteOptimizedIn: self.
			true]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884540!
printWithClosureAnalysisCaseOn: aStream indent: level 
	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"
	| braceNode otherwise extra |
	braceNode := arguments first.
	otherwise := arguments last.
	(arguments size = 1 or: [otherwise isJustCaseError]) ifTrue:
		[otherwise := nil].
	receiver
		printWithClosureAnalysisOn: aStream
		indent: level
		precedence: 3.
	aStream nextPutAll: ' caseOf: '.
	braceNode isVariableReference
		ifTrue: [braceNode printWithClosureAnalysisOn: aStream indent: level]
		ifFalse: 
			[aStream nextPutAll: '{'; newLineTab: level + 1.
			 braceNode casesForwardDo:
				[:keyNode :valueNode :last | 
				keyNode printWithClosureAnalysisOn: aStream indent: level + 1.
				aStream nextPutAll: ' -> '.
				valueNode printsInNewLine
					ifTrue: 
						[aStream newLineTab: level + 2.
						extra := 1]
					ifFalse: [extra := 0].
				valueNode printWithClosureAnalysisOn: aStream indent: level + 1 + extra.
				last ifTrue: [aStream nextPut: $}]
					ifFalse: [aStream nextPut: $.;
							 newLineTab: level + 1]]].
	otherwise ifNotNil: [
		aStream newLineTab: level + 1; nextPutAll: ' otherwise: '.
		 extra := otherwise printsInNewLine
					ifTrue: [
						aStream newLineTab: level + 2.
						1]
					ifFalse: [0].
		 otherwise printWithClosureAnalysisOn: aStream indent: level + 1 + extra]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50370638!
isInfix

	^selector isInfix! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885791!
transformToDo: encoder
	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "
	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange limitIsAssignedTo |
	block := arguments last.
	"First check for valid arguments"
	(block notNil
	 and: [block isBlockNode
	 and: [block numberOfArguments = 1
	 and: [block firstArgument isVariableReference "As with debugger remote vars"]]]) ifFalse:
		[^false].
	arguments size = 3
		ifTrue: [increment := arguments at: 2.
				(increment isConstantNumber
				 and: [increment literalValue ~= 0]) ifFalse: [^false]]
		ifFalse: [increment := encoder encodeLiteral: 1].
	(limit := arguments at: 1) isVariableReference ifTrue:
		[limitIsAssignedTo := false.
		 block nodesDo:
			[:node|
			(node isAssignmentNode and: [node variable = limit]) ifTrue:
				[limitIsAssignedTo := true]].
		 limitIsAssignedTo ifTrue:
			[^false]].
	arguments size < 3 ifTrue:   "transform to full form"
		[selector := SelectorNode new key: #to:by:do: code: #macro].

	"Now generate auxiliary structures"
	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].
	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].
	blockVar := block firstArgument.
	initStmt := AssignmentNode new variable: blockVar value: receiver.
	limit isVariableReference | limit isConstantNumber
		ifTrue: [limitInit := nil]
		ifFalse:  "Need to store limit in a var"
			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.
			 limit scope: -2.  "Already done parsing block; flag so it won't print"
			 block addArgument: limit.
			 limitInit := AssignmentNode new
							variable: limit
							value: arguments first].
	test := MessageNode new
				receiver: blockVar
				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])
				arguments: {limit}
				precedence: precedence
				from: encoder
				sourceRange: (myRange first to: blockRange first).
	incStmt := AssignmentNode new
				variable: blockVar
				value: (MessageNode new
							receiver: blockVar selector: #+
							arguments: {increment}
							precedence: precedence
							from: encoder
							sourceRange: (myRange last to: (myRange last max: blockRange last)))
				from: encoder
				sourceRange: (myRange last to: (myRange last max: blockRange last)).
	arguments := {limit. increment. block. initStmt. test. incStmt. limitInit}.
	block noteOptimizedIn: self.
	^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884795!
keywordAndParameterPositionAt: anIndex encodedWith: anEncoder ifAbsent: aBlock

	| keywordPosition parameterLastPosition |

	keywordPosition := keywordRanges at: anIndex.
	parameterLastPosition := anIndex = arguments size
		ifTrue: [ (anEncoder rangeForNode: self ifAbsent: aBlock) last ]
		ifFalse: [ (keywordRanges at: anIndex + 1) first - 1].

	^keywordPosition first to: parameterLastPosition! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884419!
printKeywords: key arguments: args on: aStream indent: level
	| keywords indent arg kwd doCrTab |
	args size = 0 ifTrue: [
		receiver ifNotNil: [ aStream space ].
		aStream nextPutAll: key.
		^ self ].
	keywords _ key keywords.
	doCrTab _ args size > 1.
	1
		to: (args size min: keywords size)
		do: [ :i |
			arg _ args at: i.
			kwd _ keywords at: i.
			doCrTab
				ifTrue: [
					aStream newLineTab: level + 1.
					indent _ 1
					"newline after big args" ]
				ifFalse: [
					receiver ifNotNil: [ aStream space ].
					indent _ 0 ].
			aStream nextPutAll: kwd.
			arg printsInNewLine
				ifTrue: [
					aStream newLineTab: level + indent + 1 ]
				ifFalse: [
					aStream space ].
			arg
				printOn: aStream
				indent: level + 1 + indent
				precedence:
					(precedence = 2
						ifTrue: [ 1 ]
						ifFalse: [ precedence ]) ].! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630015!
isFirstArgumentClassMessageSend
	
	^ arguments first isMessageNode and: [ arguments first isClassMessageSend ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630081 overrides: 50629444!
isNotNil
	
	^self selectorSymbol = #notNil! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630105!
isReceiverClassMessageSend
	
	^receiver isMessageNode and: [ receiver isClassMessageSend ]
! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885540!
toDoFromWhileWithInit: initStmt
	"Return nil, or a to:do: expression equivalent to this whileTrue:"
	| variable increment limit toDoBlock body test |
	(selector key == #whileTrue:
	 and: [initStmt isAssignmentNode
	 and: [initStmt variable isTemp]]) ifFalse:
		[^nil].
	body := arguments last statements.
	variable := initStmt variable.
	increment := body last toDoIncrement: variable.
	(increment == nil
	 or: [receiver statements size ~= 1]) ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test chould really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])
		ifTrue: [^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: (Array with: variable).
	variable scope: -1.
	variable beBlockArg.
	^MessageNode new
		receiver: initStmt value
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: (Array with: limit with: increment with: toDoBlock)
		precedence: precedence! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50650291 overrides: 50650227!
sendsMessageToSelf: aSelector

	^ self receiver referencesSelf and: [ self selector isNamed: aSelector ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885592!
transformBoolean: encoder
	^self
		checkBlock: (arguments at: 1)
		as: 'argument'
		from: encoder
		maxArgs: 0! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884322!
printCaseOn: aStream indent: level 
	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"
	| braceNode otherwise extra |
	braceNode := arguments first.
	otherwise := arguments last.
	(arguments size = 1 or: [otherwise isJustCaseError]) ifTrue:
		[otherwise := nil].
	receiver
		printOn: aStream
		indent: level
		precedence: 3.
	aStream nextPutAll: ' caseOf: '.
	braceNode isVariableReference
		ifTrue: [braceNode printOn: aStream indent: level]
		ifFalse: [
			aStream nextPutAll: '{'; newLineTab: level + 1.
			braceNode casesForwardDo: [ :keyNode :valueNode :last | 
				keyNode printOn: aStream indent: level + 1.
				aStream nextPutAll: ' -> '.
				valueNode printsInNewLine
					ifTrue: [
						aStream newLineTab: level + 2.
						extra := 1]
					ifFalse: [extra := 0].
				valueNode printOn: aStream indent: level + 1 + extra.
				last ifTrue: [aStream nextPut: $}]
					ifFalse: [aStream nextPut: $.;
							 newLineTab: level + 1]]].
	otherwise ifNotNil: [
		aStream newLineTab: level + 1; nextPutAll: ' otherwise: '.
		 extra := otherwise printsInNewLine
					ifTrue: [
						aStream newLineTab: level + 2.
						1]
					ifFalse: [0].
		 otherwise printOn: aStream indent: level + 1 + extra]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884595!
printWithClosureAnalysisIfNilNotNil: aStream indent: level

	self printWithClosureAnalysisReceiver: receiver ifNilReceiver on: aStream indent: level.

	(arguments first isJust: NodeNil) ifTrue:
		[^self printWithClosureAnalysisKeywords: #ifNotNil:
				arguments: { arguments second }
				on: aStream indent: level].
	(arguments second isJust: NodeNil) ifTrue:
		[^self printWithClosureAnalysisKeywords: #ifNil:
				arguments: { arguments first }
				on: aStream indent: level].
	^self printWithClosureAnalysisKeywords: #ifNil:ifNotNil:
			arguments: arguments
			on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630074!
isNotEqualOrNotIdenticalToNil
	
	^self isNotEqualOrNotIdentical and: [ self isFirstArgumentNil ]	
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630111!
isReceiverLiteralBehavior
	
	^receiver isLiteralVariableNode and: [ receiver isReferencingBehavior ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884910!
isNilIf

	^(special between: 3 and: 4)
	   and: [(arguments first returns or: [arguments first isJust: NodeNil])
	   and: [(arguments last returns or: [arguments last isJust: NodeNil])]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658860 overrides: 50658235!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^self typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: NoTypeCastApplier new! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630101!
isOr

	^self selectorSymbol = #or:! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885085!
emitCodeForToDo: stack encoder: encoder value: forValue 
	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "
	| loopSize initStmt limitInit test block incStmt blockSize |
	initStmt := arguments at: 4.
	limitInit := arguments at: 7.
	test := arguments at: 5.
	block := arguments at: 3.
	incStmt := arguments at: 6.
	blockSize := sizes at: 1.
	loopSize := sizes at: 2.
	limitInit == nil
		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].
		
	"This will return the receiver of to:do: which is the initial value of the loop"
	forValue
		ifTrue: [initStmt emitCodeForValue: stack encoder: encoder.]
		ifFalse: [initStmt emitCodeForEffect: stack encoder: encoder].
	test emitCodeForValue: stack encoder: encoder.
	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.
	pc := encoder methodStreamPosition.
	block emitCodeForEvaluatedEffect: stack encoder: encoder.
	incStmt emitCodeForEffect: stack encoder: encoder.
	self emitCodeForJump: 0 - loopSize encoder: encoder.! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50505516!
transformIfFalseIfTrue: encoder
	(Preferences at: #allowNonBooleanReceiversOfBooleanMessages) ifTrue: [
		(receiver == NodeTrue) | (receiver == NodeFalse) ifFalse: [
			^false ]].
	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder maxArgs: 0)
	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder maxArgs: 0)
	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
			arguments swap: 1 with: 2.
			arguments do: [:arg| arg noteOptimizedIn: self].
			true]].! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884937 overrides: 16906401!
isSelfBasicNewMessageSend
	"Answer if this ParseNode represents the 'self new'' message send."

	^ receiver isSelfPseudoVariable and: [ self selectorSymbol == #basicNew ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630068!
isNotEqualOrNotIdentical
	
	^self selectorSymbol = #~~ or: [ self selectorSymbol = #~= ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885120!
emitCodeForValue: stack encoder: encoder
	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."
	special > 0
		ifTrue: 
			[pc := 0.
			self perform: (MacroEmitters at: special) with: stack with: encoder with: true]
		ifFalse: 
			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].
			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].
			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".
			selector
				emitCode: stack
				args: arguments size
				encoder: encoder
				super: receiver == NodeSuper]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658700 overrides: 50658211!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage
	
	| messageReturnTypes sentSelector receiverTypes  |

	sentSelector := self selectorSymbol.
	receiverTypes := aTypeCastApplier receiverLiveTypesFor: self in: aCompiledMethod addingIncompleteTypeInfoTo:  incompleteTypeInfoReasons storingGenericsInfoIn: aStorage.
	
	messageReturnTypes := Set new.
	receiverTypes liveTypesDo: [:aReceiverType | | currentReceiverClass currentMethodRef | 								
			currentReceiverClass := aReceiverType liveClass.
			currentMethodRef := (MethodReference class: currentReceiverClass selector: sentSelector).
			(aStorage genericTypeConstructorFrom: currentMethodRef) 
				ifNil: [
					(currentReceiverClass lookupSelector: sentSelector) 
						ifNil: [ incompleteTypeInfoReasons add: (
							IncompleteTypeInfoError dueToMissingImplementationOf: currentMethodRef) ]
						ifNotNil: [ :implementor |
							self returnTypesOf: implementor 
								from: aReceiverType 
								receiving: sentSelector 
								in: aCompiledMethod
								addingReturnTypesTo: messageReturnTypes 
								addingIncompleteTypeInfoTo: incompleteTypeInfoReasons 
								storingGenericsInfoIn: aStorage
							].
				] 
				ifNotNil: [:aGenericTypeConstructor | 
					messageReturnTypes add: (aGenericTypeConstructor in: aCompiledMethod forArguments: self argumentsInEvaluationOrder storingGenericsInfoIn: aStorage).
				].
			
			].
		
	^RawToLiveTypesAdapter new adapt: messageReturnTypes.! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884772 overrides: 16906269!
expandRanges: aSourceRange basedOn: sourceRanges using: sourceCode

	| receiverExpandedRanges expandedRangeWithReceiver |
	receiverExpandedRanges _ self isCascade
		ifTrue: [ aSourceRange ] "not expanded because expansion is handled in CascadeNode"
		ifFalse: [ receiver expandRanges: (self receiverSourceRangesFrom: sourceRanges) basedOn: sourceRanges using: sourceCode ].
	expandedRangeWithReceiver _ self
		expandRange: (aSourceRange isInterval ifTrue: [ aSourceRange ] ifFalse: [ aSourceRange first ])
		basedOn: receiverExpandedRanges.
	^ super
		expandRanges: expandedRangeWithReceiver
		basedOn: expandedRangeWithReceiver
		using: sourceCode! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50658779!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^self receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: NoTypeCastApplier new storingGenericsInfoIn: aStorage! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50505484!
transformAnd: encoder
	(Preferences at: #allowNonBooleanReceiversOfBooleanMessages) ifTrue: [
		(receiver == NodeTrue) | (receiver == NodeFalse) ifFalse: [
			^false ]].
	(self transformBoolean: encoder)
		ifTrue: 
			[arguments := 
				Array 
					with: ((arguments at: 1) noteOptimizedIn: self)
					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).
			^true]
		ifFalse: 
			[^false]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884977!
checkBlock: node as: nodeName from: encoder maxArgs: maxArgs
	"Answer true if node is a BlockNode with at most maxArgs arguments.
	This check is required in order to inline some special messages.
	Notify some undue usage of these special messages."

	node isBlockNode ifFalse: [ ^false ].
	node numberOfArguments <= maxArgs ifTrue: [ ^true ].
	^encoder notify: '<- ', nodeName , ' of ' , (MacroSelectors at: special) , ' has too many arguments'! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50506772!
transform: encoder
	optimizeSpecialSends == false ifTrue: [ special := 0 ].
	special = 0 ifTrue: [^false].

	(self perform: (MacroTransformers at: special) with: encoder)
		ifTrue:
			[^true]
		ifFalse:
			[special := 0. ^false]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630053!
isIsNil
	
	^self selectorSymbol = #isNil! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884753!
printWithClosureAnalysisWhileOn: aStream indent: level

	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.
	(arguments isEmpty not
	 and: [arguments first isJust: NodeNil]) ifTrue:
			[selector := SelectorNode new
							key:
									(selector key == #whileTrue:
										ifTrue: [#whileTrue]
										ifFalse: [#whileFalse])
							code: #macro.
			arguments := Array new].
	self printWithClosureAnalysisKeywords: selector key arguments: arguments
		on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885890!
receiver: rcvr selector: selNode arguments: args precedence: p 
	"Decompile."

	self receiver: rcvr
		arguments: args
		precedence: p.
	originalSelector := selNode key.
	selNode code == #macro
		ifTrue: [self noteSpecialSelector: selNode key]
		ifFalse: [special := 0].
	selector := selNode.
	"self pvtCheckForPvtSelector: encoder"
	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50370642!
isKeywordMessageSend

	^self selectorSymbol isKeyword! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884718!
printWithClosureAnalysisReceiver: rcvr on: aStream indent: level
					
	rcvr ifNil: [^self].

	"Force parens around keyword receiver of kwd message"
	rcvr printWithClosureAnalysisOn: aStream indent: level precedence: precedence! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629993!
isClassMessageSend
	
	^self selectorSymbol = #class! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630093!
isObjectClassNotEqualOrNotIdenticalToClass
	
	^self isNotEqualOrNotIdentical and: [ self isReceiverClassMessageSend and: [ self isFirstArgumentLiteralBehavior ]]
		
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885073!
emitCodeForRepeat: stack encoder: encoder value: forValue 
	" L1: ... Jmp(L1)"
	| loopSize |
	loopSize := sizes at: 1.
	receiver emitCodeForEvaluatedEffect: stack encoder: encoder.
	self emitCodeForJump: 0 - loopSize encoder: encoder.
	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50660761!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo 
	^self receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: NoTypeCastApplier new.! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630010!
isEqualOrIdenticalToNil
	
	^self isEqualOrIdentical and: [ self isFirstArgumentNil ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630047!
isIsKindOfWithLiteralBehavior
	
	^self selectorSymbol = #isKindOf: and: [ self isFirstArgumentLiteralBehavior ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885948!
receiver: rcvr selector: selName arguments: args precedence: p from: encoder sourceRange: range 
	"compile"

	encoder noteSourceRange: range forNode: self.
	^self
		receiver: rcvr
		selector: selName
		arguments: args
		precedence: p
		from: encoder! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885940!
selector: sel
	selector := sel! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884927 overrides: 16906395!
isReturningIf

	^((special between: 3 and: 4) "ifTrue:ifFalse:/ifFalse:ifTrue:"
	    or: [special between: 17 and: 18]) "ifNil:ifNotNil:/ifNotNil:ifNil:"
		and: [arguments first returns and: [arguments last returns]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885677!
transformIfNilIfNotNil: encoder
	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we
	 transform the receiver to
		(var := receiver)
	 which is further transformed to
		(var := receiver) == nil ifTrue: .... ifFalse: ...
	 This does not allow the block variable to shadow an existing temp, but it's no different
	 from how to:do: is done."
	| ifNotNilArg |
	ifNotNilArg := arguments at: 2.
	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder maxArgs: 0)
	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:
		[^false].

	ifNotNilArg numberOfArguments = 1 ifTrue:
		[receiver := AssignmentNode new
						variable: ifNotNilArg firstArgument
						value: receiver].

	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
	receiver := MessageNode new
					receiver: receiver
					selector: #==
					arguments: (Array with: NodeNil)
					precedence: 2
					from: encoder.
	arguments do: [:arg| arg noteOptimizedIn: self].
	^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630028!
isFirstArgumentNil
	
	^ arguments first isNilPseudoVariable ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50630005!
isEqualOrIdentical
	
	^self selectorSymbol = #== or: [ self selectorSymbol = #= ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884953 overrides: 16906476!
toDoIncrement: variable
	(receiver = variable and: [selector key = #+]) 
		ifFalse: [^ nil].
	arguments first isConstantNumber
		ifTrue: [^ arguments first]
		ifFalse: [^ nil]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884491!
printReceiver: rcvr on: aStream indent: level
					
	rcvr ifNil: [^ self].

	"Force parens around keyword receiver of kwd message"
	rcvr printOn: aStream indent: level precedence: precedence! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884879 overrides: 16906349!
isMessage
	^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16884305!
receiver: val
	"14 feb 2001 - removed return arrow"

	receiver := val! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885453!
sizeCodeForIf: encoder value: forValue
	| thenExpr elseExpr branchSize thenSize elseSize |
	thenExpr := arguments at: 1.
	elseExpr := arguments at: 2.
	(forValue
	 or: [(thenExpr isJust: NodeNil)
	 or: [elseExpr isJust: NodeNil]]) not
			"(...not ifTrue: avoids using ifFalse: alone during this compile)"
		ifTrue:  "Two-armed IFs forEffect share a single pop"
			[^super sizeCodeForEffect: encoder].
	forValue
		ifTrue:  "Code all forValue as two-armed"
			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.
			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)
					+ (thenExpr returns
						ifTrue: [0]  "Elide jump over else after a return"
						ifFalse: [self sizeCode: encoder forJump: elseSize]).
			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]
		ifFalse:  "One arm is empty here (two-arms code forValue)"
			[(elseExpr isJust: NodeNil)
				ifTrue:
					[elseSize := 0.
					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.
					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]
				ifFalse:
					[thenSize := 0.
					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.
					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].
	sizes := Array with: thenSize with: elseSize.
	^(receiver sizeCodeForValue: encoder)
	+ branchSize + thenSize + elseSize! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885279!
sizeCodeForWhile: encoder value: forValue 
	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);
	justStmt, wholeLoop, justJump."
	| cond stmt stmtSize loopSize branchSize |
	cond := receiver.
	stmt := arguments at: 1.
	"We assume long backward branches are always maximal size branches."
	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: -1).
	branchSize := self
					sizeCode: encoder
					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"
					dist: stmtSize.
	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.
	sizes := Array with: stmtSize with: loopSize.
	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50629997!
isClassNotEqualOrNotIdenticalToObjectClass
	
	^self isNotEqualOrNotIdentical and: [ self isReceiverLiteralBehavior and: [ self isFirstArgumentClassMessageSend ]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:33' prior: 16885023 overrides: 16906508!
ifNilReceiver

	^receiver! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885645!
transformIfNil: encoder

	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."
	(MacroSelectors at: special) = #ifNotNil: ifTrue:
		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:
			[^false].

		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.
		Slightly better code and more consistent with decompilation."
		self noteSpecialSelector: #ifNil:ifNotNil:.
		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.
		arguments := Array
						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)
						with: (arguments first noteOptimizedIn: self).
		(self transform: encoder) ifFalse:
			[self error: 'compiler logic error'].
		^true].
	(self checkBlock: arguments first as: 'ifNil arg' from: encoder maxArgs: 0) ifFalse:
		[^false].
	arguments first noteOptimizedIn: self.
	^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50505500!
transformIfFalse: encoder
	(Preferences at: #allowNonBooleanReceiversOfBooleanMessages) ifTrue: [
		(receiver == NodeTrue) | (receiver == NodeFalse) ifFalse: [
			^false ]].
	(self transformBoolean: encoder)
		ifTrue: 
			[arguments := 
				Array 
					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)
					with: ((arguments at: 1) noteOptimizedIn: self).
			^true]
		ifFalse:
			[^false]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884448 overrides: 16906201!
printOn: aStream indent: level
	"may not need this check anymore - may be fixed by the #receiver: change"
	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].

	special > 0 ifTrue:
		[^self perform: self macroPrinter with: aStream with: level].

	self printReceiver: receiver on: aStream indent: level.
	selector isForFFICall
		ifTrue:
			[aStream space.
			 selector
				printAsFFICallWithArguments: arguments
				on: aStream
				indent: 0]
		ifFalse:
			[self printKeywords: selector key
				 arguments: arguments
				 on: aStream
				 indent: level]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884728!
printWithClosureAnalysisToDoOn: aStream indent: level

	| limitNode |
	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	limitNode := (arguments last == nil
				or: [arguments last isAssignmentNode not])
					ifTrue: [arguments first]
					ifFalse: [arguments last value].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printWithClosureAnalysisKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884584!
printWithClosureAnalysisIfNil: aStream indent: level

	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	^self printWithClosureAnalysisKeywords: selector key
		arguments: (Array with: arguments first)
		on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884390!
printIfOn: aStream indent: level 
	receiver ifNotNil: 
		[ receiver
			printOn: aStream
			indent: level
			precedence: precedence ].
	(arguments last isJust: NodeNil) ifTrue: [ ^ self
			printKeywords: #ifTrue:
			arguments: (Array with: arguments first)
			on: aStream
			indent: level ].
	(arguments last isJust: NodeFalse) ifTrue: [ ^ self
			printKeywords: #and:
			arguments: (Array with: arguments first)
			on: aStream
			indent: level ].
	(arguments first isJust: NodeNil) ifTrue: [ ^ self
			printKeywords: #ifFalse:
			arguments: (Array with: arguments last)
			on: aStream
			indent: level ].
	(arguments first isJust: NodeTrue) ifTrue: [ ^ self
			printKeywords: #or:
			arguments: (Array with: arguments last)
			on: aStream
			indent: level ].
	self
		printKeywords: #ifTrue:ifFalse:
		arguments: arguments
		on: aStream
		indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884882 overrides: 16906352!
isMessage: selSymbol receiver: rcvrPred arguments: argsPred
	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred
	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or
	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs
	 arguments.  All block arguments are ParseNodes."

	^(selSymbol isNil or: [selSymbol==selector key]) and:
		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:
			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884279!
eval
	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"

	| rec args |
	receiver isVariableNode ifFalse: [^ #illegal].
	rec := receiver key value.
	args := arguments collect: [:each | each eval].
	^ rec perform: selector key withArguments: args! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884648!
printWithClosureAnalysisKeywords: key arguments: args on: aStream indent: level
	| keywords indent arg kwd doCrTab |
	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^self].
	keywords := key keywords.
	doCrTab := args size > 2
				or: [{receiver} , args anySatisfy:
						[:thisArg |
						thisArg isBlockNode
						or: [thisArg isMessageNode and: [thisArg precedence >= 3]]]].
	1 to: (args size min: keywords size) do:
		[:i |
		arg := args at: i.
		kwd := keywords at: i.
		doCrTab
			ifTrue: [aStream newLineTab: level+1. indent := 1] "newline after big args"
			ifFalse: [aStream space. indent := 0].
		aStream nextPutAll: kwd; space.
		arg printWithClosureAnalysisOn: aStream
			indent: level + 1 + indent
			precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence])]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884945 overrides: 16906406!
isSelfNewMessageSend
	"Answer if this ParseNode represents the 'self new'' message send."

	^ receiver isSelfPseudoVariable and: [ self selectorSymbol == #new ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884819!
receiverSourceRangesFrom: sourceRanges
	"we can't just do #at: because sometimes what it is on the source ranges map
	is not the exact same object than the receiver or the originalReceiver
	(like when optimizations are made), so we look for an 'equivalent' one
	(at least for using as a key in the source ranges)"

	^ sourceRanges at: receiver ifAbsent: [
		| parseNodeOfReceiver |
		parseNodeOfReceiver _ sourceRanges keys detect: [ :parseNode |
		(parseNode equivalentTo: receiver) or: [ parseNode equivalentTo: originalReceiver ] ].
		sourceRanges at: parseNodeOfReceiver
	]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884531!
printWhileOn: aStream indent: level
	self printReceiver: receiver on: aStream indent: level.
	self
		printKeywords: originalSelector
		arguments: originalArguments
		on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370647 overrides: 50370511!
referencesSelf

	^self receiver referencesSelf
		or: [self arguments anySatisfy: [:argument | argument referencesSelf]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884182!
argumentsInEvaluationOrder
	"Answer the receivers arguments in evaluation order.
	 If the receiver is a transformed to:do: node this will undo the misordering done by the transformation."
	^(special > 0
	   and: [(MacroTransformers at: special) == #transformToDo:
	   and: [arguments size >= 7]])
		"arguments are in a weid order and may be nil in a transformed to:do: loop.  sigh...
		 c.f. emitCodeForToDo:encoder:value:"
		ifTrue:
			[(arguments at: 7)	"limitInit"
				ifNil: [{	(arguments at: 4).	"initStmt"
						(arguments at: 5).	"test"
						(arguments at: 3).	"block"
						(arguments at: 6) 	"incStmt" }]
				ifNotNil: [:limitInit|
						{ limitInit.
						(arguments at: 4).	"initStmt"
						(arguments at: 5).	"test"
						(arguments at: 3).	"block"
						(arguments at: 6) 	"incStmt" }]]
		ifFalse:
			[arguments]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658653 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^self basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: NoTypeCastApplier new! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885403!
emitCodeForIfNil: stack encoder: encoder value: forValue

	| theNode theSize ifNotNilSelector |
	theNode := arguments first.
	theSize := sizes at: 1.
	ifNotNilSelector := #ifNotNil:.
	receiver emitCodeForValue: stack encoder: encoder.
	forValue ifTrue: [encoder genDup. stack push: 1].
	encoder genPushSpecialLiteral: nil. stack push: 1.
	equalNode emitCode: stack args: 1 encoder: encoder.
	self 
		emitCodeForBranchOn: (selector key == ifNotNilSelector)
		dist: theSize 
		pop: stack 
		encoder: encoder.
	pc := encoder methodStreamPosition.
	forValue 
		ifTrue: 
			[encoder genPop. stack pop: 1.
			theNode emitCodeForEvaluatedValue: stack encoder: encoder]	
		ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885959!
cascadeReceiver
	"nil out rcvr (to indicate cascade) and return what it had been"

	| rcvr |
	rcvr _ receiver.
	receiver _ nil.
	^rcvr! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884867!
isCascade

	^receiver isNil ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50505536!
transformIfTrue: encoder
	(Preferences at: #allowNonBooleanReceiversOfBooleanMessages) ifTrue: [
		(receiver == NodeTrue) | (receiver == NodeFalse) ifFalse: [
			^false ]].
	(self transformBoolean: encoder)
		ifTrue: 
			[arguments := 
				Array 
					with: ((arguments at: 1) noteOptimizedIn: self)
					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).
			^true]
		ifFalse: 
			[^false]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630062!
isNilNotEqualOrNotIdenticalTo
	
	^self isNotEqualOrNotIdentical and: [ self isReceiverNil ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884692 overrides: 16906238!
printWithClosureAnalysisOn: strm indent: level precedence: outerPrecedence

	| parenthesize |
	parenthesize := precedence > outerPrecedence
		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].
	parenthesize
		ifTrue: [strm nextPutAll: '('.
				self printWithClosureAnalysisOn: strm indent: level.
				strm nextPutAll: ')']
		ifFalse: [self printWithClosureAnalysisOn: strm indent: level]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884707!
printWithClosureAnalysisParenReceiver: rcvr on: aStream indent: level
					
	rcvr isBlockNode ifTrue:
		[^rcvr printWithClosureAnalysisOn: aStream indent: level].
	aStream nextPut: $(.
	rcvr printWithClosureAnalysisOn: aStream indent: level.
	aStream nextPut: $)! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884815!
keywordRanges

	^keywordRanges! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629976!
isAnyKindOfIf
	
	| selectorSymbol |
	
	selectorSymbol := self selectorSymbol.
	
	^ selectorSymbol = #ifTrue:ifFalse: 
		or: [ selectorSymbol = #ifTrue: 
		or: [ selectorSymbol = #ifFalse: 
		or: [ selectorSymbol = #ifFalse:ifTrue ]]]
		! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658753 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: NoTypeCastApplier new storingGenericsInfoIn: aStorage! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629972!
isAnd
	
	^self selectorSymbol = #and:! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630021!
isFirstArgumentLiteralBehavior
	
	^arguments first isLiteralVariableNode and: [ arguments first isReferencingBehavior ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630085!
isObjectClassEqualOrIdenticalToClass
	
	^self isEqualOrIdentical and: [ self isReceiverClassMessageSend and: [ self isFirstArgumentLiteralBehavior ]]
		
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885927!
receiver: aReceiver selector: aSelector arguments: args precedence: aPrecedence from: anEncoder sourceRange: aSourceRange keywordsRanges: wordsRanges
	
	keywordRanges := wordsRanges.
	
	^self receiver: aReceiver selector: aSelector arguments: args precedence: aPrecedence from: anEncoder sourceRange: aSourceRange ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50506783!
noteSpecialSelector: selectorSymbol
	"special > 0 denotes specially treated (potentially inlined) messages. "

	special := optimizeSpecialSends == false
		ifTrue: [ 0 ]
		ifFalse: [ MacroSelectors indexOf: selectorSymbol ]
! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885712!
transformIfNotNilIfNil: encoder
	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we
	 transform the receiver to
		(var := receiver)
	 which is further transformed to
		(var := receiver) == nil ifTrue: .... ifFalse: ...
	 This does not allow the block variable to shadow an existing temp, but it's no different
	 from how to:do: is done."
	| ifNotNilArg |
	ifNotNilArg := arguments at: 1.
	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)
	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder maxArgs: 0]) ifFalse:
		[^false].

	ifNotNilArg numberOfArguments = 1 ifTrue:
		[receiver := AssignmentNode new
						variable: ifNotNilArg firstArgument
						value: receiver].

	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
	receiver := MessageNode new
					receiver: receiver
					selector: #==
					arguments: (Array with: NodeNil)
					precedence: 2
					from: encoder.
	arguments swap: 1 with: 2.
	arguments do: [:arg| arg noteOptimizedIn: self].
	^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630117!
isReceiverNil
	
	^receiver isNilPseudoVariable 
! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884844 overrides: 16906290!
ensureCanCascade: encoder

	special > 0 ifTrue: [
		special := 0.
		receiver := originalReceiver.
		selector := encoder encodeSelector: originalSelector.
		arguments := originalArguments.
		receiver isBlockNode ifTrue: [receiver deoptimize].
		arguments do:
			[:each|
			each isBlockNode ifTrue:
				[each deoptimize]]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884372!
printIfNilNotNil: aStream indent: level

	self printReceiver: receiver ifNilReceiver on: aStream indent: level.

	(arguments first isJust: NodeNil) ifTrue:
		[^ self printKeywords: #ifNotNil:
				arguments: { arguments second }
				on: aStream indent: level].
	(arguments second isJust: NodeNil) ifTrue:
		[^ self printKeywords: #ifNil:
				arguments: { arguments first }
				on: aStream indent: level].
	^ self printKeywords: #ifNil:ifNotNil:
			arguments: arguments
			on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884508!
printToDoOn: aStream indent: level

	| limitNode |
	self printReceiver: receiver on: aStream indent: level.

	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])
		ifTrue: [limitNode := arguments first]
		ifFalse: [limitNode := arguments last value].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885226!
sizeCodeForToDo: encoder value: forValue 
	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "
	| loopSize initStmt test block incStmt blockSize initSize limitInit |
	block := arguments at: 3.
	initStmt := arguments at: 4.
	test := arguments at: 5.
	incStmt := arguments at: 6.
	limitInit := arguments at: 7.
	initSize := forValue
		ifTrue: [initStmt sizeCodeForValue: encoder.]
		ifFalse: [initStmt sizeCodeForEffect: encoder].
	limitInit == nil ifFalse:
		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].
	blockSize := (block sizeCodeForEvaluatedEffect: encoder)
			+ (incStmt sizeCodeForEffect: encoder)
			+ (encoder sizeJumpLong: -1).
	loopSize := (test sizeCodeForValue: encoder)
			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)
			+ blockSize.
	sizes := Array with: blockSize with: loopSize.
	^initSize
	+ loopSize! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884275!
arguments: list
	arguments := list asArray! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884292!
originalArguments

	^ originalArguments! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658663 overrides: 50658200!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
	
	| types sentSelector receiverTypes  |

	sentSelector := self selectorSymbol.
	receiverTypes := aTypeCastApplier receiverTypesFor: self in: aCompiledMethod addingIncompleteTypeInfoTo:  incompleteTypeInfoReasons.
	
	types := receiverTypes
		inject: Set new
		into: [ :messageReturnTypes :aReceiverType | 								
			(aReceiverType lookupSelector: sentSelector) 
				ifNil: [ incompleteTypeInfoReasons add: (
					IncompleteTypeInfoError dueToMissingImplementationOf: (MethodReference class: aReceiverType selector: sentSelector)) ]
				ifNotNil: [ :implementor | | returnTypes |
					returnTypes := implementor returnTypes.
					returnTypes isEmpty
						ifTrue: [ incompleteTypeInfoReasons add: (IncompleteTypeInfoWarning dueToNoReturnTypeOf: implementor methodReference) ]
						ifFalse: [ messageReturnTypes addAll: (returnTypes collect: [ :aType | aType asTypeFor: aReceiverType])]].
			messageReturnTypes ].
		
	^types! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658765!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage
	
	^self receiverOrCascadeReceiver liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage.! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885202 overrides: 16906134!
sizeCodeForEffect: encoder

	special > 0 
		ifTrue:
			[encoder noteOptimizedSelector: originalSelector.
			^self perform: (MacroSizers at: special) with: encoder with: false].
	^super sizeCodeForEffect: encoder! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885870!
transformWhile: encoder
	(self checkBlock: receiver as: 'receiver' from: encoder maxArgs: 0) ifFalse:
		[^false].
	arguments size = 0 ifTrue:  "transform bodyless form to body form"
		[selector := SelectorNode new
						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])
						code: #macro.
		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).
		 receiver noteOptimizedIn: self.
		 ^true].
	^(self transformBoolean: encoder)
	   and: [receiver noteOptimizedIn: self.
			arguments first noteOptimizedIn: self.
			true]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884840 overrides: 16906287!
canCascade

	^receiver ~~ NodeSuper! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884921!
isOptimizedLoop
	^special > 0
	   and: [#(transformWhile: transformToDo:) includes: (MacroTransformers at: special)]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884616!
printWithClosureAnalysisIfOn: aStream indent: level

	receiver ifNotNil:
		[receiver printWithClosureAnalysisOn: aStream indent: level + 1 precedence: precedence].
	(arguments last isJust: NodeNil) ifTrue:
		[^self printWithClosureAnalysisKeywords: #ifTrue: arguments: (Array with: arguments first)
					on: aStream indent: level].
	(arguments last isJust: NodeFalse) ifTrue:
		[^self printWithClosureAnalysisKeywords: #and: arguments: (Array with: arguments first)
					on: aStream indent: level].
	(arguments first isJust: NodeNil) ifTrue:
		[^self printWithClosureAnalysisKeywords: #ifFalse: arguments: (Array with: arguments last)
					on: aStream indent: level].
	(arguments first isJust: NodeTrue) ifTrue:
		[^self printWithClosureAnalysisKeywords: #or: arguments: (Array with: arguments last)
					on: aStream indent: level].
	self printWithClosureAnalysisKeywords: #ifTrue:ifFalse: arguments: arguments
					on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884311!
selector
	^selector! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884871 overrides: 16906320!
isComplex
	^ (special
			between: 1
			and: 10)
		or: 
		[ arguments size > 1
			or: 
			[ receiver isComplex or: [ arguments anySatisfy: [ : each | each isComplex ] ] ] ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884918!
isOptimized
	^special > 0! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50505569!
transformOr: encoder
	(Preferences at: #allowNonBooleanReceiversOfBooleanMessages) ifTrue: [
		(receiver == NodeTrue) | (receiver == NodeFalse) ifFalse: [
			^false ]].
	(self transformBoolean: encoder)
		ifTrue: 
			[arguments := 
				Array 
					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)
					with: ((arguments at: 1) noteOptimizedIn: self).
			^true]
		ifFalse: 
			[^false]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885599!
transformCase: encoder

	| caseNode |
	caseNode := arguments first.
	(caseNode isMemberOf: BraceNode) ifFalse: [^false].
	(caseNode blockAssociationCheck: encoder) ifFalse: [^false].
	(arguments size = 1
	 or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder maxArgs: 0]) ifFalse:
		[^false].
	 caseNode elementsDo:
		[:messageNode |
		messageNode receiver noteOptimizedIn: self.
		messageNode arguments first noteOptimizedIn: self].
	 arguments size = 2 ifTrue:
		[arguments last noteOptimizedIn: self].
	 ^true! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50660817!
receiverLiveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: aTypeCastApplier
	^self receiverOrCascadeReceiver typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo castingWith: aTypeCastApplier ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884211!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	"Assignments within optimized loops are tricky.  Because a loop repeats a
	 write to a temporary in an optimized loop effectively occurs after the loop.
	 To handle this collect the set of temps assigned to in optimized loops and
	 add extra writes after traversing the optimized loop constituents."
	| writtenToTemps |
	self isOptimizedLoop ifTrue:
		[{ receiver }, arguments do:
			[:node|
			(node notNil and: [node isBlockNode and: [node optimized]]) ifTrue:
				[assignmentPools at: node put: Set new]]].
	"receiver is nil in cascades"
	receiver == nil ifFalse:
		[receiver analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools].
	arguments do:
		[:node|
		node == nil ifFalse: "last argument of optimized to:do: can be nil"
			[node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]].
	"Add assignments representing subsequent iterations
	 and redo the closure analysis for the written-to temps."
	self isOptimizedLoop ifTrue:
		[writtenToTemps := Set new.
		 { receiver }, arguments do:
			[:node|
			(node notNil and: [node isBlockNode and: [node optimized]]) ifTrue:
				[(assignmentPools removeKey: node) do:
					[:temp|
					temp isBlockArg ifFalse: "ignore added assignments to to:do: loop args"
						[writtenToTemps add: temp.
						 temp addWriteWithin: node at: rootNode locationCounter]]]].
		 writtenToTemps isEmpty ifFalse:
			[(writtenToTemps asSortedCollection: ParseNode tempSortBlock) do:
				[:each| each analyseClosure: rootNode].
			 (writtenToTemps collect: [:each| each definingScope]) do:
				[:blockNode|
				blockNode ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode]]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630126 overrides: 50629476!
receiverOrCascadeReceiver
	
	"When in cascade, receiver is nil and originalReceiver is the cascade receiver - Hernan"
	
	^receiver ifNil: [ originalReceiver ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884363!
printIfNil: aStream indent: level

	self printReceiver: receiver on: aStream indent: level.

	^self printKeywords: selector key
		arguments: (Array with: arguments first)
		on: aStream indent: level! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630033!
isIfNil
	
	^self selectorSymbol = #ifNil:! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884314!
macroPrinter

	special > 0 ifTrue: [^MacroPrinters at: special].
	^nil
! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658792!
receiverTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
	
	^self receiverOrCascadeReceiver basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370654 overrides: 50370514!
referencesSuper

	^self receiver referencesSuper
		or: [self arguments anySatisfy: [:argument | argument referencesSuper]]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630134!
receiverTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons
	
	^self receiverTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: NoTypeCastApplier new! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884857 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isMessageNode
		and: [ self hasEquivalentReceiverWith: aParseNode ]
		and: [ self selector equivalentTo: aParseNode selector ]
		and: [ self hasEquivalentArgumentsWith: aParseNode ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884319!
precedence
	^precedence! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885058 overrides: 16906092!
emitCodeForEffect: stack encoder: encoder
	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."
	special > 0
		ifTrue: 
			[pc := 0.
			self perform: (MacroEmitters at: special) with: stack with: encoder with: false]
		ifFalse: 
			[super emitCodeForEffect: stack encoder: encoder]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884968!
receiver: rcvr arguments: args precedence: p

	receiver := rcvr.
	originalReceiver := rcvr copy.
	arguments := args asArray.
	originalArguments := arguments copy.
	sizes := Array new: arguments size.
	precedence := p! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885499!
sizeCodeForIfNil: encoder value: forValue

	| theNode theSize theSelector |
	equalNode := encoder encodeSelector: #==.
	sizes := Array new: 1.
	theNode := arguments first.
	theSelector := #ifNotNil:.
	forValue
		ifTrue:
			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).
			 ^(receiver sizeCodeForValue: encoder)
			 + encoder sizeDup
			 + (encoder sizePushSpecialLiteral: nil)
			 + (equalNode sizeCode: encoder args: 1 super: false)
			 + (self 
					sizeCode: encoder forBranchOn: selector key == theSelector 
					dist: theSize)
			 + theSize]
		ifFalse:
			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).
			 ^(receiver sizeCodeForValue: encoder)
				+ (encoder sizePushSpecialLiteral: nil)
				+ (equalNode sizeCode: encoder args: 1 super: false)
				+ (self 
					sizeCode: encoder
					forBranchOn: selector key == theSelector 
					dist: theSize)
				+ theSize]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885305!
emitCodeForCase: stack encoder: encoder value: forValue

	| braceNode sizeStream allReturn |
	forValue ifFalse:
		[^super emitCodeForEffect: stack encoder: encoder].
	braceNode := arguments first.
	sizeStream := ReadStream on: sizes.
	receiver emitCodeForValue: stack encoder: encoder.
	"There must be at least one branch around the otherwise/caseError
	  so the decompiler can identify the end of the otherwise/caseError."
	allReturn := true. "assume every case ends with a return"
	braceNode casesForwardDo:
		[:keyNode :valueNode :last | | thenSize elseSize |
		thenSize := sizeStream next.
		elseSize := sizeStream next.
		last ifFalse: [encoder genDup. stack push: 1].
		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.
		equalNode emitCode: stack args: 1 encoder: encoder.
		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.
		last ifFalse: [encoder genPop. stack pop: 1].
		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.
		last ifTrue: [stack pop: 1].
		valueNode returns ifFalse:
			[self emitCodeForJump: elseSize encoder: encoder.
			 allReturn := false].
		(last and: [allReturn]) ifTrue:
			[self emitCodeForJump: elseSize encoder: encoder]].
	arguments size = 2
		ifTrue:
			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"
		ifFalse:
			[NodeSelf emitCodeForValue: stack encoder: encoder.
			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884902 overrides: 16906358!
isMessageNamed: aSelector

	^aSelector == self selectorSymbol ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885211!
sizeCodeForRepeat: encoder value: forValue 
	"L1: ... Jmp(L1) nil (nil for value only);"
	| loopSize |
	"We assume long backward branches are always maximal size branches."
	loopSize := (receiver sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: -1).
	sizes := Array with: loopSize.
	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885944!
selectorSymbol

	^selector key! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885014!
hasEquivalentReceiverWith: aMessageNode

	^ self isCascade
		ifTrue: [ originalReceiver equivalentTo: aMessageNode originalReceiver ]
		ifFalse: [ receiver equivalentTo: aMessageNode receiver ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50630057!
isNilEqualOrIdenticalTo
	
	^self isEqualOrIdentical and: [ self isReceiverNil ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658804!
returnTypesOf: implementor from: aReceiverType receiving: sentSelector in: aCompiledMethod addingReturnTypesTo: messageReturnTypes addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage

	| returnTypes |

	"generic getter case"
	((aReceiverType isGenericType) and: [aStorage getterMethodsFor: aReceiverType includes: sentSelector]) ifTrue: [
		| parameterIndex |
		parameterIndex := (aStorage getterMethodsFor: aReceiverType) at: sentSelector.
		messageReturnTypes addAll: (aReceiverType generics at: parameterIndex).
		^self.
	].
	
	"generic setter case"
	(((aStorage tracedMethodsFor: aReceiverType liveClass) includesKey: sentSelector)
		or: [(aStorage tracedMethodsFromParametersFor: aReceiverType liveClass) includesKey: sentSelector])
		ifTrue: [ | lastArgument argumentType |
		"setters need to receive the object from where the type will be set, then there's at least one argument - Adrian"
		lastArgument := self argumentsInEvaluationOrder last.
		argumentType := lastArgument 
						liveTypesIn: aCompiledMethod 
						addingIncompleteTypeInfoTo: incompleteTypeInfoReasons 
						storingGenericsInfoIn: aStorage.
						
		messageReturnTypes add: argumentType.
		^self.	
	].
	
	"general case"
	returnTypes := implementor returnLiveTypesForReceiver: aReceiverType liveClass usingStorage: aStorage.
	returnTypes isEmpty
		ifTrue: [ incompleteTypeInfoReasons add: (IncompleteTypeInfoWarning dueToNoReturnTypeOf: implementor methodReference) ]
		ifFalse: [
			returnTypes := returnTypes collect: [ :aType | aType asTypeFor: aReceiverType liveClass].
			messageReturnTypes addAll: returnTypes.
		].! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884961!
toDoLimit: variable
	(receiver = variable and: [selector key = #<= or: [selector key = #>=]]) 
		ifTrue: [^ arguments first]
		ifFalse: [^ nil]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885907!
receiver: rcvr selector: aSelector arguments: args precedence: p from: encoder 
	"Compile."

	self receiver: rcvr
		arguments: args
		precedence: p.
	originalSelector := aSelector.
	self noteSpecialSelector: aSelector.
	(self transform: encoder)
		ifTrue: 
			[selector isNil ifTrue:
				[selector := SelectorNode new 
								key: (MacroSelectors at: special)
								code: #macro]]
		ifFalse: 
			[selector := encoder encodeSelector: aSelector.
			rcvr == NodeSuper ifTrue: [encoder noteSuper]].
	self pvtCheckForPvtSelector: encoder! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658871 overrides: 50658246!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
	
	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: (LiveTyping getGenericsStorage).! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50505070!
optimizeSpecialSends: aBoolean
	optimizeSpecialSends := aBoolean! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629967 overrides: 50629438!
identifierPrintString
	
	^selector identifierPrintString ! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16884178 overrides: 16906485!
accept: aVisitor
	^aVisitor visitMessageNode: self! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885429!
emitCodeForWhile: stack encoder: encoder value: forValue 
	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "
	| cond stmt stmtSize loopSize |
	cond := receiver.
	stmt := arguments at: 1.
	stmtSize := sizes at: 1.
	loopSize := sizes at: 2.
	cond emitCodeForEvaluatedValue: stack encoder: encoder.
	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"
					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"
	pc := encoder methodStreamPosition.
	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.
	self emitCodeForJump: 0 - loopSize encoder: encoder.
	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885145!
sizeCodeForCase: encoder value: forValue

	| braceNode sizeIndex elseSize allReturn |
	forValue not ifTrue:
		[^super sizeCodeForEffect: encoder].
	equalNode := encoder encodeSelector: #=.
	braceNode := arguments first.
	sizes := Array new: 2 * braceNode numElements.
	sizeIndex := sizes size.
	elseSize := arguments size = 2
		ifTrue:
			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"
		ifFalse:
			[caseErrorNode := encoder encodeSelector: #caseError.
			 (NodeSelf sizeCodeForValue: encoder)
			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"
	"There must be at least one branch around the otherwise/caseError
	  so the decompiler can identify the end of the otherwise/caseError."
	allReturn := true. "assume every case ends with a return"
	braceNode casesForwardDo:
		[:keyNode :valueNode :last |
		valueNode returns ifFalse: [allReturn := false]].
	braceNode casesReverseDo:
		[:keyNode :valueNode :last | | thenSize |
		sizes at: sizeIndex put: elseSize.
		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.
		last ifFalse: [thenSize := thenSize + encoder sizePop].
		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].
		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].
		sizes at: sizeIndex-1 put: thenSize.
		last ifFalse: [elseSize := elseSize + encoder sizeDup].
		elseSize := elseSize
					+ (keyNode sizeCodeForEvaluatedValue: encoder)
					+ (equalNode sizeCode: encoder args: 1 super: false)
					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)
					+ thenSize.
		sizeIndex := sizeIndex - 2].
	^(receiver sizeCodeForValue: encoder) + elseSize! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885005!
hasEquivalentArgumentsWith: aMessageNode

	^ self isCascade
		ifTrue: [ self compare: originalArguments with: aMessageNode originalArguments ]
		ifFalse: [ self compare: arguments with: aMessageNode arguments ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16885027!
pvtCheckForPvtSelector: encoder
	"If the code being compiled is trying to send a private message (e.g. 'pvtCheckForPvtSelector:') to anyone other than self, then complain to encoder."

	selector isInitializePvtSelector ifTrue: [
		(receiver isSelfNewMessageSend or: [receiver isSelfBasicNewMessageSend]) ifFalse: [
			encoder notify: 'Private instance initialization messages may only be sent to ''self new'' or "self basicNew" (by class instance creation methods)']].
	selector isPvtSelector ifTrue: [
		(receiver isSelfPseudoVariable or: [ receiver isSuperPseudoVariable ]) ifFalse: [
			encoder notify: 'Private messages may only be sent to self or super']].! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50454329 overrides: 16906624!
initialize
	"
	MessageNode initialize
	"
	self initClassCachedState! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50501444 overrides: 16906590!
initClassCachedState
	"
	MessageNode initialize
	"
	MacroSelectors := 
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:
			repeat ).
	MacroTransformers := 
		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:
			transformAnd: transformOr:
			transformWhile: transformWhile: transformWhile: transformWhile:
			transformToDo: transformToDo:
			transformCase: transformCase:
			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:
			transformRepeat: ).
	MacroEmitters := 
		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:
			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:
			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForRepeat:encoder:value:).
	MacroSizers := 
		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:
			sizeCodeForToDo:value: sizeCodeForToDo:value:
			sizeCodeForCase:value: sizeCodeForCase:value:
			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForRepeat:value:).
	MacroPrinters := 
		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:
			printIfOn:indent: printIfOn:indent:
			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:
			printToDoOn:indent: printToDoOn:indent:
			printCaseOn:indent: printCaseOn:indent:
			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:
			printRepeatOn:indent:).
	Preferences
		name: #allowNonBooleanReceiversOfBooleanMessages
		description: 'If set, do not optimize boolean selectors, allowing, for example, new Boolean classes.'
		category: #programming type: Boolean value: false! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16886049 overrides: 16906630!
releaseClassCachedState

	MacroSelectors _ nil.
	MacroTransformers _ nil.
	MacroEmitters _ nil.
	MacroSizers _ nil.
	MacroPrinters _ nil! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50454406!
enableNonBooleanReceiversOfBooleanMessages
	"
	Evaluate this to allow alternative Boolean classes.
	Boolean messages will be actual method sends.

	MessageNode enableNonBooleanReceiversOfBooleanMessages
	"
	Preferences at: #allowNonBooleanReceiversOfBooleanMessages put: true.
	Compiler recompileAll! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16886056 overrides: 16906642!
new
	MacroSelectors ifNil: [ self initClassCachedState ].
	^super new! !
!MessageNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50454392!
disableNonBooleanReceiversOfBooleanMessages
	"
	Evaluate this to disallow alternative Boolean classes.
	Boolean messages will be optimized by the Compiler, by assuming receiver is a Boolean.

	MessageNode disableNonBooleanReceiversOfBooleanMessages
	"
	Preferences at: #allowNonBooleanReceiversOfBooleanMessages put: false.
	Compiler recompileAll! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890156!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	^aBlock value: nodeAndPosition key.! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889292 overrides: 50663073!
arguments
	"For transformations etc, not used in compilation"
	^arguments! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889391 overrides: 50663092!
temporariesDeclaration: aTemporariesDeclarationNode
	"RNG: after removing all the usages of the temporaries inst var, the last line can be removed"

	temporariesDeclaration := aTemporariesDeclarationNode.
	self temporaries: aTemporariesDeclarationNode allDeclaredVariableNodes! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889307!
numberOfStatements

	^ block statements size! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890101!
selectorLastPosition

	"If #DoIt selector, returns 0 - Hernan"

	^self selector isUnary
		ifTrue: [ selectorKeywordsRanges ifNil: [ 0 ] ifNotNil: [ selectorKeywordsRanges last last ]]
		ifFalse: [
			(encoder 
				rangeForNode: arguments last
				ifAbsent: [ self shouldNotHappenBecause: 'arguments are part of the encoder'  ]) first last ]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889747!
methodClass

	^ encoder classEncoding! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889311!
primitiveErrorVariableName
	"Answer the primitive error code temp name, or nil if none."
	(primitive isInteger and: [primitive > 0]) ifTrue:
		[properties pragmas do:
			[:pragma| | kwds ecIndex |
			((kwds := pragma keyword keywords) first = 'primitive:'
			and: [(ecIndex := kwds indexOf: 'error:') > 0]) ifTrue:
				[^pragma argumentAt: ecIndex]]].
	^nil

	"(Parser new parse: (MethodNode sourceCodeAt: #primitiveErrorVariableName) class: Parser) primitiveErrorVariableName"

	"(Parser new parse: 'foo <primitive: 111 error: ''foo''> self primitiveFailed' class: Object) primitiveErrorVariableName"

	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"

	"(Parser new parse: 'foo <primitive: 111> self primitiveFailed' class: Object) primitiveErrorVariableName"

	"(Parser new parse: 'foo <primitive: ''foo'' error: foo module: ''bar''> self primitiveFailed' class: Object) primitiveErrorVariableName"

	"(Parser new parse: 'foo <primitive: ''foo'' module: ''bar'' error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"

	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) generate"! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890338!
selector: selOrFalse arguments: args precedence: p temporariesDeclaration: tempsDeclaration block: blk encoder: anEncoder primitive: prim properties: propDict selectorKeywordsRanges: range
	"RNG: this is the preferred initializer (with temporariesDeclaration) as opposed to the one with 'temporaries' that is going to be deprecated"

	selectorKeywordsRanges := range.

	^ self selector: selOrFalse arguments: args precedence: p temporariesDeclaration: tempsDeclaration block: blk encoder: anEncoder primitive: prim properties: propDict! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629768 overrides: 50629472!
nodeTypePrintString
	
	^'method'! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889757 overrides: 16906194!
printOn: aStream

	self 
		printSelectorAndArgumentsOn: aStream;
		printCommentOn: aStream;
		printTemporariesOn: aStream;
		ifPrimitivePrintOn: aStream;
		printPropertiesOn: aStream;
		printPragmasOn: aStream.
		
	aStream newLineTab: 1.
	block printStatementsOn: aStream indent: 0! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890362!
allParseNodesWithin: aSourceCodeInterval satisfy: aCondition

	self completeSourceRangesDo: [ :parseNode :sourceRanges |
		(aCondition value: parseNode) ifTrue: [
			(sourceRanges anySatisfy: [ :sourceRange | aSourceCodeInterval rangeIncludes: sourceRange first ])
				ifTrue: [ ^ false ] ] ].
	^ true! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889996!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure 
	
	^encoder parseNodeIncluding: aPosition ifAbsent: aBlockClosure 
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890024!
positionsForLiteralVariableNode: aName ifAbsent: aBlock

	^encoder positionsForLiteralVariableNode: aName ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889421!
preenLocalIfNotNilArg
	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| varsToHide |
	varsToHide := Set new.
	self nodesDo:
		[:node| | variable |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not
		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:
			[node arguments last arguments isEmpty
				ifTrue: [node arguments last arguments: { variable }.
						varsToHide add: variable]
				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].
			 node receiver receiver: node receiver receiver value]].
	varsToHide notEmpty ifTrue:
		[self nodesDo:
			[:node|
			((node == self or: [node isBlockNode])
			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:
				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889900!
sourceText

	^ sourceText ifNil: [self printString]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889469!
generate
	"The receiver is the root of a parse tree. Answer a CompiledMethod."

	^self generate: #(0 0 0 0)! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889510!
generate: trailer using: aCompiledMethodClass ifQuick: methodBlock
	| v |
	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])
		ifFalse: [^ self].
	v := block code.
	v < 0
		ifTrue: [^ self].
	v = LdSelf
		ifTrue: [^ methodBlock value: (aCompiledMethodClass toReturnSelfTrailerBytes: trailer)].
	(v between: LdTrue and: LdMinus1 + 3)
		ifTrue: [^ methodBlock value: (aCompiledMethodClass toReturnConstant: v - LdSelf trailerBytes: trailer)].
	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))
		ifTrue: [^ methodBlock value: (aCompiledMethodClass toReturnField: v trailerBytes: trailer)].
	v // 256 = 1
		ifTrue: [^ methodBlock value: (aCompiledMethodClass toReturnField: v \\ 256 trailerBytes: trailer)]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890316!
selector: selOrFalse arguments: args precedence: p temporariesDeclaration: tempsDeclaration block: blk encoder: anEncoder primitive: prim properties: propDict
	"Initialize the receiver with respect to the arguments given."
	"RNG: this is the preferred initializer (with temporariesDeclaration) as opposed to the one with 'temporaries' that is going to be deprecated"

	encoder := anEncoder.
	selectorOrFalse := selOrFalse.
	precedence := p.
	arguments := args.
	temporariesDeclaration _ tempsDeclaration.
	temporaries := tempsDeclaration allDeclaredVariableNodes.
	block := blk.
	primitive := prim.
	properties := propDict.! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890065!
rawSourceRanges

	^self rawSourceRangesAndMethodDo: [:rawSourceRanges :method| rawSourceRanges]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50554816!
rawSourceRangesAndMethodNodeDo: aBinaryBlock

	"Evaluate aBinaryBlock with the methodNode and rawSourceRanges generated from the receiver.
	
	This method is similar to #rawSourceRangesAndMethodDo: except that it:
	* provides the MethodNode instead of the CompiledMethod
	* ensures that the same parse nodes instances are used for both the raw source ranges keys and the method node children.
	
	If #rawSourceRangesAndMethodDo: was used instead, the method node will have to be recreated from the returned compiled method and that will cause
	its parse nodes to be different objects (have different identity) that the ones used for the raw souce ranges keys."
	
	| methodNode |
	methodNode := encoder classEncoding parserClass new
					encoderClass: encoder class;
					parse: (sourceText "If no source, use decompile string as source to map from"
							ifNil: [self decompileString]
							ifNotNil: [sourceText])
					class: self methodClass.

	^ aBinaryBlock
		value: methodNode encoder rawSourceRanges
		value: methodNode! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890204!
hasGeneratedMethod
	^encoder hasGeneratedMethod! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629749!
actualMessageSendsSelectorPositionsOfAll: compiledMethods ifAbsent: aBlock withPossibleMessageSends: shouldAddPossibleMessageSends 

	^encoder 
		actualMessageSendsSelectorPositionsOfAll: compiledMethods 
		ifAbsent: aBlock 
		withPossibleMessageSends: shouldAddPossibleMessageSends 
		using: self
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889494!
generate: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	^ Smalltalk isSpur 
		ifTrue: [ self generateSpur: trailer using: aCompiledMethodClass ]
		ifFalse: [ self generatePreSpur: trailer using: aCompiledMethodClass ]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370581!
singleCompleteSourceRangeOf: requestedParseNode ifPresent: sourceRangePresentBlock ifAbsent: sourceRangeAbsentBlock
	"Finds the source range associated with the requested parse node.
	If it is present, evaluates sourceRangePresentBlock with the result.
	Otherwise, it evaluates sourceRangeAbsentBlock.
	Raises an error if the requested parse node has multiple source ranges"
	| sourceRanges |

	sourceRanges := self
		completeSourceRangesOf: requestedParseNode
		ifAbsent: [^sourceRangeAbsentBlock value].

	^sourceRanges size > 1
		ifTrue: [self error: 'there are multiple source ranges for the parse node: ' , requestedParseNode printString ]
		ifFalse: [sourceRangePresentBlock value: sourceRanges anyOne].! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889894!
selectorAndArgumentsAsString
	
	^String streamContents: [ :aStream | self printSelectorAndArgumentsOn: aStream ]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890239!
noteBlockExit: aBlock
	"Evaluate aBlock with the numbering for the block exit."
	aBlock value: locationCounter + 1.
	locationCounter := locationCounter + 2! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889287!
argumentNames

	^arguments collect: [ :anArgumentNode | anArgumentNode name ]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889710!
properties
	^properties! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889964!
messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock

	^encoder messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889378 overrides: 50663138!
temporaries: aCollectionOfTemporaries
	"For transformations etc, not used in compilation"
	"RNG: deprecated in favor of #temporariesDeclaration:"

	temporaries := aCollectionOfTemporaries! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890018!
positionsForLiteralNode: aName ifAbsent: aBlock

	^encoder positionsForLiteralNode: aName ifAbsent: aBlock
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889408!
preen
	"Preen for pretty-printing and/or decompilation.
	 i.e. post-process to cover up for inadequacies in both algorithms.
	 Currently one case, hiding the assignment to the arg of an inlined block arg to ifNotNil:,
		(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...]."

	self preenLocalIfNotNilArg! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889921!
completeSourceRanges
	"Returns the 'expanded' version of the source ranges, for instance in message sends it also includes the receiver, and if there are parentheses they are included in the source range as well. Right now used for refactorings."

	^ encoder completeSourceRangesBasedOn: self sourceText! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50504688!
completeSourceRangesOf: requestedParseNode ifAbsent: emptySourceRangesBlock
	"Returns the source ranges associated with the requested parse node."

	| completeSourceRanges |

	completeSourceRanges := Set new.

	"There may be more than one equivalent key in the complete source ranges map
	if more than one block declare a temporary variable with the same name - Fernando"
	self completeSourceRangesDo: [:parseNode :sourceRanges |
		(parseNode equivalentTo: requestedParseNode) ifTrue: [completeSourceRanges addAll: sourceRanges]].

	^completeSourceRanges ifEmpty: emptySourceRangesBlock 
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629724!
actualMessageSendKeywordPositionsOfAll: compiledMethods at: aKeywordIndex ifAbsent: absentBlock withPossibleMessageSends: shouldAddPossibleMessageSends

	^encoder 
		actualMessageSendKeywordPositionsOfAll: compiledMethods 
		at: aKeywordIndex 
		ifAbsent: absentBlock 
		withPossibleMessageSends: shouldAddPossibleMessageSends 
		using: self
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890209!
addLocalsToPool: locals "<Set of: TempVariableNode>"
	localsPool isNil ifTrue:
		[localsPool := IdentitySet new].
	localsPool addAll: locals! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50342810!
printPrimitiveOn: aStream
	"Print the primitive on aStream"
	| primDecl |
	primitive = 0 ifTrue:
		[^self].
	primitive = 120 ifTrue: "External call spec"
		[^aStream print: encoder literals first].
	aStream nextPutAll: '<primitive: '.
	primitive = 117
		ifTrue:
			[primDecl := encoder literals at: 1.
			 (primDecl at: 2) asPlainString printOn: aStream.
			 (primDecl at: 1) ifNotNil:
				[:moduleName|
				aStream nextPutAll:' module: '.
				moduleName asPlainString printOn: aStream]]
		ifFalse:
			[aStream print: primitive].
	self primitiveErrorVariableName ifNotNil:
		[:primitiveErrorVariableName|
		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].
	aStream nextPut: $>.
	((Smalltalk classNamed: #StackInterpreter) ifNil: [Smalltalk classNamed: #Interpreter]) ifNotNil:
		[:interpreterClass|
		 aStream nextPutAll: ' "', ((interpreterClass primitiveTable) at: primitive + 1), '" ']! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890060!
rangeForNode: node ifAbsent: aBlock

	^encoder rangeForNode: node ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889364 overrides: 50663187!
temporaries
	"For transformations etc, not used in compilation"

	"RNG: implementation can be changed after adopting the use of temporariesDeclaration inst var.
	After that, the implementation for this message can be changed to:
	^ temporariesDeclaration allDeclaredVariableNodes
	
	Or we can analyze the senders and change the way we request the temporaries"
	
	^temporaries! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890031!
positionsForTemporaryVariable: aName ifAbsent: aBlock

	^encoder positionsForTemporaryVariable: aName ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890279!
selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict
	"Initialize the receiver with respect to the arguments given."
	"RNG: its external use is deprecated, in favor of any of the methods that receives a temporariesDeclaration instead of the collection of temporaries"

	encoder := anEncoder.
	selectorOrFalse := selOrFalse.
	precedence := p.
	arguments := args.
	temporaries := temps.
	block := blk.
	primitive := prim.
	properties := propDict.! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889971!
nextPositionAfterAddPositionTo: symbolPositions of: symbolString startingAt: insidePosition

	| symbolStartPosition nextPosition |

	symbolStartPosition := sourceText indexOfSubCollection: symbolString startingAt: insidePosition.

	symbolStartPosition = 0
		ifTrue: [ nextPosition := SmallInteger maxVal ]
		ifFalse: [
			nextPosition := symbolStartPosition + symbolString size.
			(sourceText at: nextPosition) tokenish ifFalse: [ symbolPositions add: (symbolStartPosition to: nextPosition - 1) ]].

	^nextPosition

	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890256 overrides: 50663087!
block
	^ block! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889622!
generateSpur: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits locals literals stack header method |
	self generate: trailer
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	self ensureClosureAnalysisDone.
	encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primitive > 0
					ifTrue: [encoder sizeCallPrimitive: primitive]
					ifFalse: [0])
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	locals := arguments, temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).
	encoder noteBlockExtent: block blockExtent hasLocals: locals.
	header := encoder computeMethodHeaderForNumArgs: arguments size
					numTemps: locals size
					numLits: (nLits := (literals := encoder allLiterals) size)
					primitive: primitive.
	method := aCompiledMethodClass
					createMethod: blkSize
					trailer: trailer
					header: header.
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primitive > 0 ifTrue:
		[encoder genCallPrimitive: primitive.
		 primErrNode ifNotNil:
			[primErrNode emitCodeForStore: stack encoder: encoder]].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889536!
generatePreSpur: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits literals stack method |
	self generate: trailer 
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	encoder supportsClosureOpcodes ifTrue:
		[self ensureClosureAnalysisDone.
		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	method := aCompiledMethodClass
				newBytes: blkSize
				trailerBytes: trailer 
				nArgs: arguments size
				nTemps: (encoder supportsClosureOpcodes
							ifTrue: [| locals |
									locals := arguments,
											  temporaries,
											  (primErrNode
												ifNil: [#()]
												ifNotNil: [{primErrNode}]).
									encoder
										noteBlockExtent: block blockExtent
										hasLocals: locals.
									locals size]
							ifFalse: [encoder maxTemp])
				nStack: 0
				nLits: (nLits := (literals := encoder allLiterals) size)
				primitive: primitive.
	nLits > 255 ifTrue:
		[^self error: 'Too many literals referenced'].
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890393!
hasLocalNamed: aName

	"See #hasLocallyArgumentOrTemporaryNamed: comment - Hernan" 

	^ encoder hasLocalNamed: aName ! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889827!
printSelectorAndArgumentsOn: aStream

	| selectorNode |
	
	selectorNode _ self selectorNode.
	precedence = 1
		ifTrue:
			[selectorNode isForFFICall
				ifTrue: [selectorNode
							printAsFFICallWithArguments: arguments
							on: aStream
							indent: 0]
				ifFalse: [aStream nextPutAll: selectorNode key]]
		ifFalse:
			[selectorNode key keywords withIndexDo:
				[:kwd :i | | arg |
				arg _ arguments at: i.
				i = 1 ifFalse: [ aStream space ].
				aStream nextPutAll: kwd; space; nextPutAll: arg key ]].
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890374!
anyParseNodeWithin: aSourceCodeInterval satisfy: aCondition

	self completeSourceRangesDo: [ :parseNode :sourceRanges |
		(aCondition value: parseNode) ifTrue: [
			(sourceRanges anySatisfy: [ :sourceRange | aSourceCodeInterval rangeIncludes: sourceRange first ])
				ifTrue: [ ^ true ] ] ].
	^ false! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889360!
tempNodes

	^encoder tempNodes! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889990!
parameterDefinitionPositionAt: anIndex

	^encoder parameterDefinitionPositionFor: (arguments at: anIndex)! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889852 overrides: 16906223!
printWithClosureAnalysisOn: aStream 
	self ensureClosureAnalysisDone.
	precedence = 1
		ifTrue: 
			[(self selector includesSubString: '()/')
				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).
						arguments
							do: [:arg| aStream nextPutAll: arg key]
							separatedBy: [aStream nextPutAll: ', '].
						aStream nextPut: $)]
				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"
		ifFalse: 
			[self selector keywords with: arguments do: 
				[:kwd :arg | 
				aStream nextPutAll: kwd; space.
				arg printDefinitionForClosureAnalysisOn: aStream.
				aStream space]].
	comment == nil ifFalse: [
			aStream newLineTab: 1.
			 self printCommentOn: aStream indent: 1].
	temporaries size > 0 ifTrue: [
			aStream newLineTab: 1; nextPut: $|.
			temporaries do: [:temp | 
				aStream space.
				temp printDefinitionForClosureAnalysisOn: aStream].
			aStream space; nextPut: $|].
	primitive > 0 ifTrue:
		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"
			[aStream newLineTab: 1.
			 self printPrimitiveOn: aStream]].
	self printPropertiesOn: aStream.
	self printPragmasOn: aStream.
	aStream newLineTab: 1.
	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889465!
encoder
	^ encoder! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889352!
removeProperty: aSymbol
	properties := properties copyWithout: (Association
											key: aSymbol
											value: (properties propertyValueAt: aSymbol))! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890229!
noteBlockEntry: aBlock
	"Evaluate aBlock with the numbering for the block entry."
	locationCounter isNil ifTrue:
		[locationCounter := -1].
	aBlock value: locationCounter + 1.
	locationCounter := locationCounter + 2! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629781!
topParseNodeIncluding: aPosition ifAbsent: anAbsentBlock

	^encoder topParseNodeIncluding: aPosition ifAbsent: anAbsentBlock
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50505378!
parseNodesPathAt: aPosition ifAbsent: aBlockClosure

	"This is to be sure that the enconder has the completeSourceRanges - Hernan"
	self completeSourceRanges.
	^ encoder
		parseNodesPathAt: aPosition
		ifAbsent: aBlockClosure! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889737!
ifPrimitivePrintOn: aStream
	
	primitive > 0 ifTrue:
		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"
			[aStream newLineTab: 1.
			 self printPrimitiveOn: aStream]].
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889768!
printPragmasOn: aStream
	properties ifNil: [^self].
	properties pragmas do: [ :pragma |
		"Primitives are printed in printPrimitiveOn:; skip these"
		(Parser primitivePragmaSelectors includes: pragma keyword) ifFalse:
			[aStream newLineTab: 1.
			 pragma printOn: aStream]]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890399!
isMultipleRanges: aRangeOrRanges

	^aRangeOrRanges isKindOf: OrderedCollection ! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890259!
selector: symbol

	selectorOrFalse := symbol! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889488!
generate: trailer ifQuick: methodBlock
	^self generate: trailer using: CompiledMethod ifQuick: methodBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889387 overrides: 50663104!
temporariesDeclaration

	^ temporariesDeclaration! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629737!
actualMessageSendLastPositionsOfAll: compiledMethods ifAbsent: absentBlock withPossibleMessageSends: shouldAddPossibleMessageSends  

	^encoder 
		actualMessageSendLastPositionsOfAll: compiledMethods 
		ifAbsent: absentBlock 
		withPossibleMessageSends: shouldAddPossibleMessageSends 
		using: self
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890358!
sourceText: stringOrText

	sourceText := stringOrText! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890217!
ensureClosureAnalysisDone
	block blockExtent ifNil:
		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50365199!
blockExtentsToTempsMap
	"Answer a Dictionary of blockExtent to temp locations for the current method.
	 This is used by the debugger to locate temp vars in contexts.  A temp map
	 entry is a pair of the temp's name and its index, where an index is either an
	 integer for a normal temp or a pair of the index of the indirect temp vector
	 containing  the temp and the index of the temp in its indirect temp vector."

	^encoder blockExtentsToTempsMap ifNil:
		[| methNode |
		methNode := encoder classEncoding parserClass new
						encoderClass: encoder class;
						parse: (sourceText
							ifNil: [self decompileString]
							ifNotNil: [sourceText asPlainString])
						class: self methodClass.
		"As a side effect generate: creates data needed for the map."
		methNode generate.
		methNode encoder blockExtentsToTempsMap]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889304!
body
	^block! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889949!
messageSendKeywordPositionsAt: anIndex of: aSelector ifAbsent: aBlock

	^encoder messageSendKeywordPositionsAt: anIndex of: aSelector ifAbsent: aBlock
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890263!
selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 
	"RNG: deprecated, use one of the methods that receives a temporariesDeclaration instead of the collection of temporaries"
	
	self 
		selector: selOrFalse
		arguments: args
		precedence: p
		temporaries: temps
		block: blk
		encoder: anEncoder 
		primitive: prim 
		properties: AdditionalMethodState new.! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370565!
singleCompleteSourceRangeOf: requestedParseNode
	"Returns the source range associated with the requested parse node.
	Fails if there is no source range, or if there are multiple source ranges."

	^self
		singleCompleteSourceRangeOf: requestedParseNode
		ifPresent: [ :sourceRange | sourceRange ]
		ifAbsent: [ self error: 'could not find source range for node: ' , requestedParseNode printString ]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889846!
printTemporariesOn: aStream
	
	block printTemporaries: temporaries on: aStream doPrior: [aStream newLineTab: 1].
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370616 overrides: 50370511!
referencesSelf

	^block referencesSelf! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890225!
locationCounter
	^locationCounter! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658413 overrides: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons
 
	"I assume that if somebody wants the types of a method it is looking for the return types - Hernan"
	^aCompiledMethod returnTypes ! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889475!
generate: trailer 
	"The receiver is the root of a parse tree. Answer a CompiledMethod.
	 The argument, trailer, is arbitrary but is typically either the reference
	 to the source code that is stored with every CompiledMethod, or an
	 encoding of the method's temporary names."

	^self generate: trailer using: CompiledMethod! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889941!
messageSendKeywordAndParameterPositionsAt: anIndex of: aSelector ifAbsent: aClosure

	^encoder messageSendKeywordAndParameterPositionsAt: anIndex of: aSelector ifAbsent: aClosure! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629709!
actualMessageSendKeywordAndParameterPositionsOfAll: compiledMethods at: aParameterIndex of: aSelector ifAbsent: absentBlock withPossibleMessageSends: shouldAddPossibleMessageSends 
	
	^encoder 
		actualMessageSendKeywordAndParameterPositionsOfAll: compiledMethods 
		at: aParameterIndex 
		of: aSelector
		ifAbsent: absentBlock 
		withPossibleMessageSends: shouldAddPossibleMessageSends 
		using: self
	
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50658424 overrides: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
 
	^aCompiledMethod returnLiveTypes: aStorage! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629772!
topBlockTempsMap
	
	self blockExtentsToTempsMap associationsDo: [ :anAssociation | anAssociation key first = 0 ifTrue: [ ^anAssociation value ]].
	
	self error: 'Should not happen, there is always a topContext'! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890096!
selectorKeywordsPositions

	^selectorKeywordsRanges! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890298!
selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict selectorKeywordsRanges: range
	"RNG: deprecated, use one of the methods that receives a temporariesDeclaration instead of the collection of temporaries"
	
	selectorKeywordsRanges := range.
	
	^self selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50365178!
rawSourceRangesAndMethodDo: aBinaryBlock
	"Evaluate aBinaryBlock with the rawSourceRanges and method generated from the receiver."

	| methNode method |
	methNode := encoder classEncoding parserClass new
					encoderClass: encoder class;
					parse: (sourceText "If no source, use decompile string as source to map from"
							ifNil: [self decompileString]
							ifNotNil: [sourceText asPlainString])
					class: self methodClass.
	method := methNode generate.  "set bytecodes to map to"
	^aBinaryBlock
		value: methNode encoder rawSourceRanges
		value: method! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50650244 overrides: 50650231!
sendsRecursivelyToSelf

	^ self body sendsMessageToSelf: self selector! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890247!
referencedValuesWithinBlockExtent: anInterval 
	^(localsPool select:
		[:temp|
		 temp isReferencedWithinBlockExtent: anInterval]) collect:
			[:temp|
			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889297 overrides: 50663156!
arguments: aCollectionOfArguments

	"For transformations etc, not used in compilation"
	arguments := aCollectionOfArguments! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889732!
classAndSelector

	^self methodClass name, '>>', self selector storeString! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889908!
addPositionTo: symbolPositions of: symbolString inside: literalArrayPosition

	| insidePosition |

	insidePosition := literalArrayPosition first.
	[ insidePosition < literalArrayPosition last ] whileTrue: [
		insidePosition := self nextPositionAfterAddPositionTo: symbolPositions of: symbolString startingAt: insidePosition ].
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370612 overrides: 50370508!
isMethodNode

	^true.! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889714!
selector 
	"Answer the message selector for the method represented by the receiver."

	(selectorOrFalse isSymbol)
		ifTrue: [^selectorOrFalse].
	^selectorOrFalse key.
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890091!
selectorKeywordPositionAt: anIndex

	^selectorKeywordsRanges at: anIndex! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890404!
definitionStartPosition
	
	"It does not includes temp definition because the extract can include temps - Hernan"
	^self selectorLastPosition + 1! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890038!
positionsInLiteralArrayOf: aSymbol

	| literalArrayPositions |

	literalArrayPositions := encoder positionsOfLiteralArraysContaining: aSymbol.

	^self positionsOf: aSymbol printString containedIn: literalArrayPositions.

! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889722!
selectorNode
	"Answer a SelectorNode for the message selector of the method represented by the receiver."

	^(selectorOrFalse isMemberOf: SelectorNode)
		ifTrue: [selectorOrFalse]
		ifFalse: [SelectorNode new key: selectorOrFalse]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889705!
parserClass
	"Which parser produces this class of parse node"

	^ Parser! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890048!
positionsOf: symbolString containedIn: literalArrayPositions

	| symbolPositions |

	symbolPositions := OrderedCollection new.

	literalArrayPositions do: [ :literalArrayPosition | self addPositionTo: symbolPositions of: symbolString inside: literalArrayPosition ].

	^symbolPositions




! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370621 overrides: 50370514!
referencesSuper

	^block referencesSuper! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50387442!
statements

	^block statements.! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50370606 overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isMethodNode
		and: [ block equivalentTo: aParseNode block]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889933!
completeSourceRangesDo: aBinaryBlock
	"block has to receive parse node and collection of source ranges"

	^ self completeSourceRanges keysAndValuesDo: aBinaryBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889957!
messageSendLastPositionsOf: aSelector ifAbsent: aBlock

	^encoder messageSendLastPositionsOf: aSelector ifAbsent: aBlock! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889810!
printPropertiesOn: aStream
	properties ifNil: [^self].
	properties propertyKeysAndValuesDo:
		[:prop :val|
		aStream newLine; tab; nextPut: $<.
		prop = #on:in:
			ifTrue:
				[prop keywords with: val do:
					[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]
			ifFalse:
				[prop = #on
					ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 
					ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 
		aStream nextPut: $>]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629797!
withTopParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |
	
	nodeAndPosition :=self topParseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].

	^aBlock value: nodeAndPosition key
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889402 overrides: 50663144!
decompileString 
	"Answer a string description of the parse tree whose root is the receiver."

	^self fullPrintString
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629762 overrides: 50629438!
identifierPrintString

	^self selectorNode identifierPrintString .
	! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890166!
removeAndRenameLastTempIfErrorCode
	self primitiveErrorVariableName ifNotNil:
		[:primitiveErrorVariableName|
		 temporaries last
			name: primitiveErrorVariableName
			key: primitiveErrorVariableName
			code: temporaries last code.
		 temporaries removeLast].! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890011!
positionsForInstanceVariable: aName ifAbsent: aBlock

	^encoder positionsForInstanceVariable: aName ifAbsent: aBlock
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889283 overrides: 16906485!
accept: aVisitor
	^aVisitor visitMethodNode: self! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16890386!
hasArgumentOrTemporaryNamed: aVariableName

	"See #hasLocallyArgumentOrTemporaryNamed: comment - Hernan" 
	
	^self tempNames includes: aVariableName! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889904!
tempNames
	^encoder tempNames! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16889751!
printCommentOn: aStream
	
	comment ifNotNil: [
		aStream newLineTab: 1.
		self printCommentOn: aStream indent: 1].! !
!NewArrayNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16898914!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	"This is a no-op except in TempVariableNode"
	^self! !
!NewArrayNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16898923!
emitCodeForValue: stack encoder: encoder
	encoder genPushNewArray: numElements.
	stack push: 1! !
!NewArrayNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16898909 overrides: 16906485!
accept: aVisitor
	^aVisitor visitNewArrayNode: self! !
!NewArrayNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16898938!
numElements: n
	numElements := n! !
!NewArrayNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16898934!
numElements
	^numElements! !
!NewArrayNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16898929!
sizeCodeForValue: encoder
	^encoder sizePushNewArray: numElements! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906303!
isAssignmentToTemporary

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906245!
expandRange: aSourceRange basedOn: sourceRangesOfChildNode

	| intervals |
	intervals := self consolidateAsCollection: sourceRangesOfChildNode.
	intervals withIndexDo: [ :interval :index |
		(interval first > aSourceRange first) ifTrue: [
			^ self expandRange: aSourceRange basedOnChildRange: (intervals at: index - 1 ifAbsent: [ intervals last ]) ] ].
	^ self expandRange: aSourceRange basedOnChildRange: intervals last! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629472!
nodeTypePrintString
	
	^''! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906194 overrides: 16902975!
printOn: aStream 
	"Refer to the comment in Object|printOn:."

	aStream nextPut: ${.
	self printOn: aStream indent: 0.
	aStream nextPut: $}.! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906362!
isMessageNode
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906231!
printWithClosureAnalysisOn: aStream indent: anInteger 
	"If control gets here, avoid recursion loop."

	super printWithClosureAnalysisOn: aStream! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906207!
printOn: aStream indent: level precedence: p 
	self printOn: aStream indent: level! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906365!
isNilPseudoVariable	
	"Overridden in VariableNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906300!
isAssignmentNode
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906150!
encodeSelector: selector 
	^nil! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 16906392!
isReturnSelf
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:34' prior: 50629444!
isNotNil
	
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50650227!
sendsMessageToSelf: aSelector

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906481!
currentValueIn: aContext

	^nil! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906537!
comment: newComment 
	"self halt."

	comment _ newComment! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906452!
isUnusedTemp
	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906082!
emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder
	stack pop: 1.
	dist = 0 ifTrue: [^encoder genPop].
	condition
		ifTrue: [encoder genBranchPopTrue: dist]
		ifFalse: [encoder genBranchPopFalse: dist]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906369!
isOnlySubnodeOf: aSubtree "<ParseNode>" in: aParseTree "<ParseNode>"
	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.
	 Assumes that aSubtree is in fact a subnode of aParseTree."
	| isSubnode |
	isSubnode := false.
	aSubtree accept: (ParseNodeEnumerator
							ofBlock: [:node| node == self ifTrue: [isSubnode := true]]).
	isSubnode ifFalse:
		[^false].
	aParseTree accept: (ParseNodeEnumerator
							ofBlock: [:node| node == self ifTrue: [^false]]
							select: [:node| node ~= aSubtree]).
	^true! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906062!
pc: anInteger
	"Used by encoder source mapping."

	pc := anInteger! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906127!
sizeCodeForBlockValue: encoder
	"Answer the size for evaluating the last statement in a block"
	^self sizeCodeForValue: encoder! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658235!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons

	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: (LiveTyping getGenericsStorage).! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906313!
isBraceNode

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906316!
isCascadeNode

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906528!
printSingleComment: aString on: aStream indent: indent 
	"Print the comment string"
	
	aStream nextPutAll: aString! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906401!
isSelfBasicNewMessageSend
	"Overridden in  MessageNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658211!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage


	^aTypeCastApplier applyTo: self with: (self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage)! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906269!
expandRanges: sourceRanges basedOn: allSourceRanges using: sourceCode

	^ (self consolidateAsCollection: sourceRanges)
		collect: [ :sourceRange | sourceRange expandToMatchExpressionOn: sourceCode ]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906448!
isUndefTemp
	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906410!
isSelfPseudoVariable	
	"Overridden in VariableNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906415!
isSpecialConstant
	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906223 overrides: 16903022!
printWithClosureAnalysisOn: aStream 
	"Refer to the comment in Object|printOn:."

	aStream nextPut: ${.
	self printWithClosureAnalysisOn: aStream indent: 0.
	aStream nextPut: $}.! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629447!
isSameAs: aParseNode

	"I had to create this message because originalReceiver is MessageNode is a copy of the receiver (I don't 
	undertand why it makes a copy but I can not change that, it is too risky) and it cascade messages I have 
	to use the originalReceiver to get the receiver of the message. So this message has to be reimplemented
	in those nodes that are the same no matter if they are a copy. See LeafNode for example - Hernan"
	^self = aParseNode ! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906310!
isBlockNode
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906470!
printsInNewLine
	"Used for pretty printing to determine whether to start a new line"

	^self isComplex! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906395!
isReturningIf
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906419!
isSuperPseudoVariable	
	"Overridden in VariableNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906476!
toDoIncrement: ignored
	"Only meant for Messages or Assignments - else return nil"
	^ nil! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906427!
isTempOrArg

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906349!
isMessage
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50366864!
nextWordFrom: aStream setCharacter: aBlock

	| outStream char |
	outStream _ String writeStream.
	[ (aStream peekFor: Character space) or: [ aStream peekFor: Character tab ]] whileTrue.
	[ aStream atEnd or: [
		char _ aStream next.
		char isSeparator ]]
			whileFalse: [ outStream nextPut: char ].
	aBlock value: char.
	^ outStream contents! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906398!
isSelectorNode

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906508!
ifNilReceiver
	"assuming this object is the receiver of an ifNil:, what object is being asked about?"
	^self! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906146!
asReturnNode
	^ReturnNode new expr: self! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906201!
printOn: aStream indent: anInteger 
	"If control gets here, avoid recursion loop"

	super printOn: aStream! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906335!
isInstanceVariableNode

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906345!
isLiteralVariableNode

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906496!
nodesDo: aBlock
	self accept: (ParseNodeEnumerator ofBlock: aBlock)! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906212!
printSourceCode
	
	^String streamContents: [ :stream | self printOn: stream indent: 0 ] ! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906326!
isConstantNumber  "Overridden in LiteralNode"
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906434!
isTemporaryDeclaration

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906352!
isMessage: selSymbol receiver: rcvrPred arguments: argsPred
	"See comment in MessageNode."

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629464!
nodeTypeAndIdentifierPrintString
	
	^String streamContents: [ :stream | 
		stream
			nextPutAll: self nodeTypePrintString;
			space;
			nextPutAll: self identifierPrintString ]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906406!
isSelfNewMessageSend
	"Overridden in  MessageNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50370511!
referencesSelf

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658193!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons

	self subclassResponsibility ! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906181!
printCommentOn: aStream indent: indent 
	| thisComment |
	self comment == nil ifTrue: [^ self].
	1 to: self comment size do: [ :index |
		index > 1 ifTrue: [aStream newLineTab: indent].
		aStream nextPut: $".
		thisComment := self comment at: index.
		self printSingleComment: thisComment
			on: aStream
			indent: indent.
		aStream nextPut: $"]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906217!
printWithClosureAnalysis

	^String streamContents: [:str| self printWithClosureAnalysisOn: str]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50366837!
nodePrintOn: aStrm indent: nn
	| var aaStrm myLine |
	"Show just the sub nodes and the code."

	aaStrm := aStrm ifNil: [String writeStream].
	nn timesRepeat: [aaStrm tab].
	aaStrm nextPutAll: self class name; space.
	myLine := self printString withBlanksCondensed.
	myLine := myLine copyFrom: 1 to: (myLine size min: 70).
	aaStrm nextPutAll: myLine; newLine.
	1 to: self class instSize do: [:ii | 
		var := self instVarAt: ii.
		(var respondsTo: #asReturnNode) ifTrue: [var nodePrintOn: aaStrm indent: nn+1]].
	1 to: self class instSize do: [:ii | 
		var := self instVarAt: ii.
		(var isCollection and: [var isSequenceable]) ifTrue: [
			var do: [ :aNode | 
				(aNode respondsTo: #asReturnNode) ifTrue: [
					aNode nodePrintOn: aaStrm indent: nn+1]]]].
	^ aaStrm! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906238!
printWithClosureAnalysisOn: aStream indent: level precedence: p

	self printWithClosureAnalysisOn: aStream indent: level! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658224!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: anStorage


	^RawToLiveTypesAdapter new adapt: (self basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons).
	
	! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906330!
isFalsePseudoVariable	
	"Overridden in VariableNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906389!
isReturn

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906458!
isVariableReference
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906339!
isJust: node
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50650231!
sendsRecursivelyToSelf

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906443!
isTruePseudoVariable	
	"Overridden in VariableNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906290!
ensureCanCascade: encoder! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906099!
emitCodeForJump: dist encoder: encoder

	dist = 0 ifFalse: [encoder genJump: dist]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906278!
assignmentCheck: encoder at: location
	"For messageNodes masquerading as variables for the debugger.
	For now we let this through - ie we allow stores ev
	into args.  Should check against numArgs, though."
	^ -1! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658200!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 

	^aTypeCastApplier applyTo: self with: (self basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons)! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906134!
sizeCodeForEffect: encoder

	^(self sizeCodeForValue: encoder) + encoder sizePop! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906112!
sizeCode: encoder forBranchOn: condition dist: dist
	dist = 0 ifTrue: [^encoder sizePop].
	^condition
		ifTrue: [encoder sizeBranchPopTrue: dist]
		ifFalse: [encoder sizeBranchPopFalse: dist]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50361580!
isConstantCharacter  "Overridden in LiteralNode"
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906287!
canCascade
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906501!
consolidateAsCollection: sourceRanges

	^ sourceRanges isInterval
		ifTrue: [ OrderedCollection with: sourceRanges ]
		ifFalse: [ sourceRanges ]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906424!
isTemp
	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50370508!
isMethodNode

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906320 overrides: 16903382!
isComplex
	"Used for pretty printing to determine whether to start a new line"

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906534!
comment
	^comment! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906105!
emitCodeForReturn: stack encoder: encoder

	self emitCodeForValue: stack encoder: encoder.
	encoder genReturnTop! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629476!
receiverOrCascadeReceiver
	
	"To contemplate cases like: 
	a := Object
		value;
		va
	Thanks Nico Papagna - Hernan"
	
	self nodesDo: [ :aNode | (aNode isCascadeNode or: [ aNode isMessageNode]) ifTrue: [ ^aNode receiverOrCascadeReceiver ]].
	
	"If there is no message node there is nothing valid I could return, but I return self for the rest to work - Hernan"
	^self! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906074!
emitCodeForBlockValue: stack encoder: encoder
	"Generate code for evaluating the last statement in a block"
	^self emitCodeForValue: stack encoder: encoder! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906307!
isBacktickNode

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906067!
optimizedBlockHoistTempsInto: scopeBlock "<BlockNode>" 
	"This is a No-op for all nodes except non-optimized BlockNodes."
	^self! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50370514!
referencesSuper

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906293!
equivalentTo: aParseNode

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906342!
isLiteralNode

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906092!
emitCodeForEffect: stack encoder: encoder

	self emitCodeForValue: stack encoder: encoder.
	encoder genPop.
	stack pop: 1! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906297!
isArg
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906438!
isThisContextPseudoVariable	
	"Overridden in VariableNode."
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906466!
nowHasRef  "Ignored in all but VariableNode"! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906358!
isMessageNamed: aSelector

	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906430!
isTemporariesDeclaration

	^ false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906455!
isVariableNode
	^false! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906462!
nowHasDef  "Ignored in all but VariableNode"! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906057!
pc
	"Used by encoder source mapping."

	^pc ifNil: [ 0 ]
! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658246!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 

	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier  storingGenericsInfoIn: (LiveTyping getGenericsStorage)! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629438!
identifierPrintString
	
	^String streamContents: [ :stream | self printOn: stream indent: 0 ]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906261!
expandRange: parentSourceRange basedOnChildRange: childSourceRange

	^ ((parentSourceRange first min: childSourceRange first) to: parentSourceRange last) asSourceCodeInterval! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906485!
accept: aVisitor
	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.
	 All such implementations under ParseNode should answer the result of the dispatch, e.g.
		^aVisitor visitBlockNode: self"
	^self subclassResponsibility! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906121!
sizeCode: encoder forJump: dist

	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906140!
sizeCodeForReturn: encoder

	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906552!
popCode

	Pop ifNil: [ self initClassCachedState ].
	^ Pop! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906624 overrides: 16904184!
initialize
	"
	ParseNode initialize. VariableNode initialize
	"
	self initClassCachedState! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906590 overrides: 16787193!
initClassCachedState
	"
	ParseNode initialize. VariableNode initialize
	"
	LdInstType := 1.
	LdTempType := 2.
	LdLitType := 3.
	LdLitIndType := 4.
	SendType := 5.
	"Back in the day the following constants corresponded to bytecodes.
	 Now they're just unique values that need to be eliminated when and if
	 things like code:type: are cleaned up."
	CodeBases := #(0 16 32 64 208 ).
	CodeLimits := #(16 16 32 32 16 ).
	LdSelf := 112.
	LdTrue := 113.
	LdFalse := 114.
	LdNil := 115.
	LdMinus1 := 116.
	LoadLong := 128.
	LdSuper := 133.
	Pop := 135.
	LdThisContext := 137.
	EndRemote := 125.
	SendPlus := 176.
	Send := 208.
	
	"((ParseNode class >> #initialize) literals select: [:l| l isVariableBinding and: [(ParseNode classPool includesAssociation: l) and: [(self systemNavigation allCallsOn: l localTo: ParseNode) size = 1]]]) sort: [:a :b| a key <= b key]"

	"ParseNode classPool associations select: [:a| (self systemNavigation allCallsOn: a localTo: ParseNode) isEmpty]"! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906630 overrides: 16787202!
releaseClassCachedState

	LdInstType _ LdTempType _ LdLitType _ LdLitIndType _ SendType _ nil.
	CodeBases _ CodeLimits _ nil.
	LdSelf _ LdTrue _ LdFalse _ nil.
	LdNil _ LdMinus1 _ LoadLong _ nil.
	LdSuper _ Pop _ nil.
	LdThisContext _ EndRemote _ nil.
	SendPlus _ Send _ nil! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906547!
blockReturnCode

	EndRemote ifNil: [ self initClassCachedState ].
	^ EndRemote! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906557!
pushNilCode

	LdNil ifNil: [ self initClassCachedState ].
	^LdNil! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906642 overrides: 16785646!
new
	LdInstType ifNil: [
		ParseNode initClassCachedState.
		VariableNode initClassCachedState ].
	^super new! !
!ParseNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16906562!
tempSortBlock
	"Answer a block that can sort a set of temporaries into a stable
	 order so that different compilations produce the same results."
	^[:t1 :t2| | be1 be2 bs1 bs2 |
	   t1 index < t2 index "simple sort by index."
	   or: [t1 index = t2 index "complex tie break" 
		  and: [t1 isRemote ~= t2 isRemote
				ifTrue: [t2 isRemote] "put direct temps before indirect temps"
				ifFalse: 
					[((be1 := t1 definingScope blockExtent) isNil
					  or: [(be2 := t2 definingScope blockExtent) isNil])
						ifTrue: [t1 name < t2 name] "only have the name left to go on"
						ifFalse: "put temps from outer scopes before those from inner scopes"
							[(bs1 := be1 first) < (bs2 := be2 first)
							 or: [bs1 = bs2 and: [t1 name < t2 name]]]]]]] "only have the name left to go on"! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925885!
addRemoteTemp: aTempVariableNode encoder: encoder
	remoteTemps isNil ifTrue:
		[remoteTemps := OrderedCollection new].
	remoteTemps addLast: aTempVariableNode.
	aTempVariableNode referenceScopesAndIndicesDo:
		[:scopeBlock "<BlockNode>" :location "<Integer>"|
		 self addReadWithin: scopeBlock at: location].
	encoder supportsClosureOpcodes ifFalse:
		[encoder encodeLiteral: remoteTemps size.
		 readNode := encoder encodeSelector: #at:.
		 writeNode := encoder encodeSelector: #at:put:]! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926012!
sizeCodeForIndexOf: aTempVariableNode encoder: encoder
	self assert: encoder supportsClosureOpcodes not.
	^(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode)) sizeCodeForValue: encoder! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926022!
sizeCodeForLoadFor: aTempVariableNode encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^0].
	"Need to size the first half of
		tempVector at: index put: expr
	 i.e. the push of tempVector and index."
	^(super sizeCodeForValue: encoder)
	+ (self sizeCodeForIndexOf: aTempVariableNode encoder: encoder)! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926072 overrides: 16960644!
printDefinitionForClosureAnalysisOn: aStream 
	| refs |
	aStream
		nextPut: ${;
		nextPutAll: key.
	definingScope ifNotNil: [definingScope blockExtent ifNotNil: [:be| aStream nextPutAll: ' d@'; print: be first]].
	readingScopes ifNotNil: [
		refs := Set new.
		readingScopes do: [:elems| refs addAll: elems].
		refs asSortedCollection do: [:read| aStream nextPutAll: ' r@'; print: read]].
	remoteTemps
		do: [:rt| rt printDefinitionForClosureAnalysisOn: aStream]
		separatedBy: [aStream nextPut: $,; space].
	aStream nextPut: $}! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925915!
emitCodeForLoadFor: aTempVariableNode stack: stack encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^self].
	"Need to generate the first half of
		tempVector at: index put: expr
	 i.e. the push of tempVector and index."
	super emitCodeForValue: stack encoder: encoder.
	self emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926035!
sizeCodeForStoreInto: aTempVariableNode encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^encoder sizeStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1 inVectorAt: index].
	^writeNode sizeCode: encoder args: 2 super: false! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925993 overrides: 16960556!
referenceScopesAndIndicesDo: aBinaryBlock
	self shouldNotImplement! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925973 overrides: 16960536!
isIndirectTempVector
	^true! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925999 overrides: 16960633!
scope
	"Answer scope of temporary variables.
	 Currently only the following distinctions are made:
		 0	outer level: args and user-declared temps
		 1	block args and doLimiT temps
		-1	a block temp that is no longer active
		-2	a block temp that held limit of to:do:
		-3	an indirect temp vector"
	^-3! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926096!
remoteTemps: anArray
	remoteTemps := anArray.
	anArray do: [:tempNode| tempNode remoteNode: self]! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925977!
nodeToInitialize: encoder
	^AssignmentNode new
		variable: self
		value: (encoder supportsClosureOpcodes
					ifTrue: [NewArrayNode new numElements: remoteTemps size]
					ifFalse:
						[MessageNode new
							receiver: (encoder encodeVariable: 'Array')
							selector: #new:
							arguments: (Array with: (encoder encodeLiteral: remoteTemps size))
							precedence: 3
							from: encoder])! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926092!
remoteTemps
	^remoteTemps! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925957!
emitCodeForValueOf: aTempVariableNode stack: stack encoder: encoder
	encoder supportsClosureOpcodes
		ifTrue:
			[encoder
				genPushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
				inVectorAt: index.
			 stack push: 1]
		ifFalse:
			[self emitCodeForLoadFor: aTempVariableNode stack: stack encoder: encoder.
			 readNode
				emitCode: stack
				args: 1
				encoder: encoder
				super: false]! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926058!
sizeCodeForValueOf: aTempVariableNode encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^encoder sizePushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1 inVectorAt: index].
	^(self sizeCodeForValue: encoder)
	+ (self sizeCodeForIndexOf: aTempVariableNode encoder: encoder)
	+ (readNode sizeCode: encoder args: 1 super: false)! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925930!
emitCodeForStoreInto: aTempVariableNode stack: stack encoder: encoder
	encoder supportsClosureOpcodes
		ifTrue:
			[encoder
				genStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
				inVectorAt: index]
		ifFalse:
			[writeNode
				emitCode: stack
				args: 2
				encoder: encoder
				super: false]! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925880 overrides: 16960398!
accept: aVisitor
	^aVisitor visitRemoteTempVectorNode: self! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925904!
emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder
	self assert: encoder supportsClosureOpcodes not.
	(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode))
		emitCodeForValue: stack encoder: encoder! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16926046!
sizeCodeForStorePopInto: aTempVariableNode encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^encoder sizeStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1 inVectorAt: index].
	^(self sizeCodeForStoreInto: aTempVariableNode encoder: encoder)
	+ encoder sizePop! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16925943!
emitCodeForStorePopInto: aTempVariableNode stack: stack encoder: encoder
	encoder supportsClosureOpcodes
		ifTrue:
			[encoder
				genStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
				inVectorAt: index]
		ifFalse:
			[self emitCodeForStoreInto: aTempVariableNode stack: stack encoder: encoder.
			 encoder genPop].
	stack pop: 1! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928138 overrides: 50668154!
asReturnNode! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928172 overrides: 50668159!
printOn: aStream indent: level

	aStream nextPutAll: '^ '. "make this a preference??"
	expr printOn: aStream indent: level.
	expr printCommentOn: aStream indent: level! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928152!
emitCodeForValue: stack encoder: encoder

	expr emitCodeForReturn: stack encoder: encoder.
	pc := encoder methodStreamPosition! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928145 overrides: 50668406!
emitCodeForReturn: stack encoder: encoder

	expr emitCodeForReturn: stack encoder: encoder.
	pc := encoder methodStreamPosition! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50370666 overrides: 50668219!
referencesSelf

	^expr referencesSelf! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928209 overrides: 50668063!
isSpecialConstant

	^expr isSpecialConstant! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658884 overrides: 50668223!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^aCompiledMethod returnTypes
! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928118!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	"Note we could do this:
		scopeBlock ~~ rootNode block ifTrue:
			[scopeBlock noteNonLocalReturn].
	 and pass up the flag in <BlockNode>>>analyseTempsWithin:rootNode:
	 which may be fast but will also give less information the debugger.
	 For now we consider clean blocks a premature optimization."
	self flag: 'consider clean blocks'.
	expr analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928180 overrides: 50667899!
printWithClosureAnalysisOn: aStream indent: level

	aStream nextPutAll: '^ '. "make this a preference??"
	expr printWithClosureAnalysisOn: aStream indent: level.
	expr printCommentOn: aStream indent: level! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928164!
sizeCodeForValue: encoder

	^expr sizeCodeForReturn: encoder! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928218!
expr: e 
	expr _ e! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50370670 overrides: 50668448!
referencesSuper

	^expr referencesSuper! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928205 overrides: 50667927!
isReturnSelf
	^expr == NodeSelf! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928189 overrides: 50668452!
equivalentTo: aParseNode

	^ aParseNode isReturn and: [ expr equivalentTo: aParseNode expr ]! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658891 overrides: 50668285!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
 
	^aCompiledMethod returnLiveTypes: aStorage! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928141!
code
	^expr code! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928222!
expr: e encoder: encoder sourceRange: range 
	expr _ e.
	encoder noteSourceRange: range forNode: self! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928202 overrides: 50668301!
isReturn

	^true! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928195!
isImplicitSelfReturnIn: aMethodNode

	self isReturnSelf ifFalse: [^false]. 
	aMethodNode encoder rangeForNode: self ifAbsent: [^true].
	
	^false! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928213 overrides: 50668305!
isVariableReference
	^expr isVariableReference! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50630202 overrides: 50668520!
identifierPrintString
	
	^'^'! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928169!
expr

	^ expr.
! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928113 overrides: 50668535!
accept: aVisitor
	^aVisitor visitReturnNode: self! !
!ReturnNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16928159 overrides: 50668553!
sizeCodeForReturn: encoder

	^expr sizeCodeForReturn: encoder! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932886!
name: literal key: object index: i type: type
	"For compatibility with Encoder>>name:key:class:type:set:"
	^self key: object index: i type: type! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932849 overrides: 50663289!
emitCodeForEffect: stack encoder: encoder

	self shouldNotImplement! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932854!
emitCodeForValue: stack encoder: encoder

	self shouldNotImplement! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932859!
sizeCode: encoder args: nArgs super: supered
	self reserve: encoder.
	^supered
		ifTrue:
			[code < Send "i.e. its a special selector" ifTrue:
				[code := self code: (index := encoder sharableLitIndex: key) type: 5].
			 encoder sizeSendSuper: index numArgs: nArgs]
		ifFalse:
			[self flag: #yuck. "special selector sends cause this problem"
			 encoder
				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])
				numArgs: nArgs]! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932908 overrides: 50668159!
printOn: aStream indent: level 
	aStream nextPutAll: (key == nil
							ifTrue: ['<key==nil>']
							ifFalse: [key])! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932938!
isPvtSelector
	"Answer if this selector node is a private message selector."

	^key isPvtSelector! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932921 overrides: 50663300!
equivalentTo: aParseNode

	^ aParseNode isSelectorNode and: [ super equivalentTo: aParseNode ]! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629836!
isNamed: aSelectorName

	^ self key = aSelectorName! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932927!
isForFFICall
	^key includesSubString: '()/'! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932893 overrides: 50663372!
key: aSelector
	"This is for printing of FFI selectors."
	key := aSelector! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932931!
isInitializePvtSelector
	"Answer whether the receiver is a private instance initialization message selector"

	^ key isInitializePvtSelector! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629832 overrides: 50668520!
identifierPrintString
	
	^key printString ! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932898!
printAsFFICallWithArguments: aSequence on: aStream indent: level
	aStream nextPutAll: (key copyUpTo: $)).
	aSequence
		do: [:arg| arg printOn: aStream indent: level]
		separatedBy: [aStream nextPutAll: ', '].
	aStream nextPut: $)! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932914 overrides: 50667899!
printWithClosureAnalysisOn: aStream indent: level 
	aStream nextPutAll: (key == nil
							ifTrue: ['<key==nil>']
							ifFalse: [key])! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932881 overrides: 50663384!
sizeCodeForValue: encoder

	self shouldNotImplement! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932838!
emitCode: stack args: nArgs encoder: encoder super: supered
	stack pop: nArgs.
	^supered
		ifTrue:
			[encoder genSendSuper: index numArgs: nArgs]
		ifFalse:
			[encoder
				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])
				numArgs: nArgs]! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932944 overrides: 50668143!
isSelectorNode

	^ true! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50370635!
isInfix

	^key isInfix ! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932947 overrides: 50668535!
accept: aVisitor
	^aVisitor visitSelectorNode: self! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932822 overrides: 50663389!
reserve: encoder 
	"If this is a yet unused literal of type -code, reserve it."

	code < 0 ifTrue: [code := self code: (index := encoder sharableLitIndex: key) type: 0 - code]! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932831!
emitCode: stack args: nArgs encoder: encoder

	self emitCode: stack
		args: nArgs
		encoder: encoder
		super: false! !
!SelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16932876 overrides: 50663295!
sizeCodeForEffect: encoder

	self shouldNotImplement! !
!SpecialSelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16944161 overrides: 50669088!
sizeCode: encoder args: nArgs super: supered
	"Size a special selector send.
	 A super send of a special selector must be handled like a normal send."
	^supered
		ifTrue: [super sizeCode: encoder args: nArgs super: supered]
		ifFalse: [encoder sizeSendSpecial: code numArgs: nArgs]! !
!SpecialSelectorNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16944147 overrides: 50669183!
emitCode: stack args: nArgs encoder: encoder super: supered
	"Generate a special selector send.
	 A super send of a special selector must be handled like a normal send."
	supered
		ifTrue:
			[super emitCode: stack args: nArgs encoder: encoder super: supered]
		ifFalse:
			[stack pop: nArgs.
			 encoder genSendSpecial: code numArgs: nArgs]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960756!
name: varName index: i type: type scope: level
	"Only used for initting temporary variables"
	hasDefs := hasRefs := false.
	scope := level.
	^super name: varName key: varName index: i type: type! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960715 overrides: 16977795!
emitCodeForValue: stack encoder: encoder
	remoteNode ~~ nil ifTrue:
		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].
	encoder genPushTemp: index.
	stack push: 1! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960698 overrides: 16977782!
emitCodeForStore: stack encoder: encoder
	remoteNode ~~ nil ifTrue:
		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].
	encoder genStoreTemp: index! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960479 overrides: 16977728!
beingAssignedToAnalyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	self addWriteWithin: scopeBlock at: rootNode locationCounter.
	"For analysis of optimized blocks also record the set of temporaries written to
	 within optimized blocks so that additional writes can be added at locations that
	 represent subsequent iterations of the loop. e.g. testInlineBlockCollectionSD1"
	assignmentPools keysAndValuesDo:
		[:outerScopeBlock :set|
		"definingScope can be nil in expr in expr ifNil: [:arg|...] expressions because
		 arg gets its definingScope set when [:arg|...] is analysed."
		outerScopeBlock actualScope
			= (definingScope
				ifNil: [scopeBlock]
				ifNotNil: [definingScope actualScope]) ifTrue:
			[set add: self]]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960415!
addWriteWithin: scopeBlock "<BlockNode>" at: location "<Integer>"
	writingScopes ifNil: [writingScopes := Dictionary new].
	(writingScopes at: scopeBlock ifAbsentPut: [Set new]) add: location.
	remoteNode ifNotNil:
		[remoteNode addReadWithin: scopeBlock at: location]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960613 overrides: 50668387!
isTemp
	^ true! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960629!
remoteNode
	^remoteNode! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960605!
isMethodArg
	^#method == argType! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960556!
referenceScopesAndIndicesDo: aBinaryBlock
	"Evaluate aBinaryBlock with all read or write scopes and locations.
	 This is used to copy the reference information into RemoteTempVectorNodes"
	readingScopes ~~ nil ifTrue:
		[readingScopes keysAndValuesDo:
			[:scopeBlock "<BlockNode>" :set "<Set of <Integer>>"|
			set do: [:location| aBinaryBlock value: scopeBlock value: location]]].
	writingScopes ~~ nil ifTrue:
		[writingScopes keysAndValuesDo:
			[:scopeBlock "<BlockNode>" :set "<Set of <Integer>>"|
			set do: [:location| aBinaryBlock value: scopeBlock value: location]]]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960621 overrides: 50668054!
isUndefTemp
	^ hasDefs not! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960536!
isIndirectTempVector
	^false! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960724 overrides: 50663321!
sizeCodeForLoad: encoder forValue: forValue
	^remoteNode
		ifNil: [0]
		ifNotNil: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960633!
scope
	"Answer scope of temporary variables.
	 Currently only the following distinctions are made:
		 0	outer level: args and user-declared temps
		 1	block args and doLimiT temps
		-1	a block temp that is no longer active
		-2	a block temp that held limit of to:do:"
	^scope! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960706 overrides: 16977787!
emitCodeForStorePop: stack encoder: encoder
	remoteNode ~~ nil ifTrue:
		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].
	encoder genStorePopTemp: index.
	stack pop: 1! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960470 overrides: 50663349!
analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	self addReadWithin: scopeBlock at: rootNode locationCounter! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960690 overrides: 16977838!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	remoteNode ~~ nil ifTrue:
		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960522!
index: anInteger
	"For renumbering temps in the closure compiler."
	index := anInteger.
	code := self code: index type: LdTempType! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50629947 overrides: 50629841!
nodeTypePrintString

	^self isArg
		ifTrue: [ 'parameter' ]
		ifFalse: [ 'temporary' ]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960665 overrides: 16977868!
printWithClosureAnalysisOn: aStream indent: level
	aStream nextPutAll: name.
	readingScopes ifNotNil: [
		(readingScopes
			inject: Set new
			into: [ :them :reads |
				them addAll: reads.
				them ]) asArray sort do: [ :location |
			aStream
				 space;
				 nextPut: $r;
				 nextPut: $@;
				 print: location ]].
	writingScopes ifNotNil: [
		(writingScopes
			inject: Set new
			into: [ :them :writes |
				them addAll: writes.
				them ]) asArray sort do: [ :location |
			aStream
				 space;
				 nextPut: $w;
				 nextPut: $@;
				 print: location ]].! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960511!
definingScope: scopeBlock "<BlockNode>"
	definingScope = scopeBlock ifTrue: [^ self]. "No need to bail"
	definingScope ifNotNil:
		[self error: 'temp has more than one defining scope.  This is probably a parser error'].
	definingScope := scopeBlock! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960748 overrides: 16977821!
sizeCodeForValue: encoder
	remoteNode ~~ nil ifTrue:
		[^remoteNode sizeCodeForValueOf: self encoder: encoder].
	self reserve: encoder.
	^encoder sizePushTemp: index! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960773!
scope: level
	"Note scope of temporary variables.
	Currently only the following distinctions are made:
		0	outer level: args and user-declared temps
		1	block args and doLimiT temps
		-1	a block temp that is no longer active
		-2	a block temp that held limit of to:do:"
	scope _ level! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960609!
isRemote
	^remoteNode notNil! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658607 overrides: 50658464!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^aCompiledMethod typesOfVariableNamed: name ifAbsent: [ #() ]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960596!
isBlockArg
	^#block == argType! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960507!
definingScope
	^definingScope! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960600!
isDeclaredAtMethodLevel
	"For the explainer."
	^scope = 0! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960529!
isDefinedWithinBlockExtent: anInterval
	^anInterval rangeIncludes: definingScope actualScope blockExtent first! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658616 overrides: 50658540!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage 
	
	^aCompiledMethod liveTypesOfVariableNamed: name
					storingGenericsInfoIn: aStorage
					ifAbsent: [`EmptyType new`].! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960593 overrides: 50668468!
isArg
	^argType notNil! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960769 overrides: 50668478!
nowHasRef
	hasRefs _ true! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960739 overrides: 16977816!
sizeCodeForStorePop: encoder
	remoteNode ~~ nil ifTrue:
		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].
	self reserve: encoder.
	^encoder sizeStorePopTemp: index! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960625 overrides: 50667950!
isUnusedTemp
	^ hasRefs not! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960644!
printDefinitionForClosureAnalysisOn: aStream 
	| refs |
	aStream
		nextPut: ${;
		nextPutAll: key.
	definingScope ifNotNil: [definingScope blockExtent ifNotNil: [:be| aStream nextPutAll: ' d@'; print: be first]].
	readingScopes ifNotNil: [
		refs := Set new.
		readingScopes do: [:elems| refs addAll: elems].
		refs asArray sort do: [:read| aStream nextPutAll: ' r@'; print: read]].
	writingScopes ifNotNil: [
		refs := Set new.
		writingScopes do: [:elems| refs addAll: elems].
		refs asArray sort do: [:write| aStream nextPutAll: ' w@'; print: write]].
	aStream nextPut: $}! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960403!
addReadWithin: scopeBlock "<BlockNode>" at: location "<Integer>"
	readingScopes ifNil: [readingScopes := Dictionary new].
	(readingScopes at: scopeBlock ifAbsentPut: [Set new]) add: location.
	remoteNode ifNotNil:
		[remoteNode addReadWithin: scopeBlock at: location]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960540!
isReferencedWithinBlockExtent: anInterval 
	readingScopes ~~ nil ifTrue:
		[readingScopes do:
			[:set "<Set of <Integer>>"|
			set do:
				[:location|
				 (anInterval rangeIncludes: location) ifTrue:
					[^true]]]].
	writingScopes ~~ nil ifTrue:
		[writingScopes do:
			[:set "<Set of <Integer>>"|
			set do:
				[:location|
				 (anInterval rangeIncludes: location) ifTrue:
					[^true]]]].
	^false! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960765 overrides: 50668497!
nowHasDef
	hasDefs _ true! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960685!
remoteNode: aRemoteTempVectorNode
	remoteNode := aRemoteTempVectorNode! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960585!
beBlockArg
	argType := #block! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658628 overrides: 50667999!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  

	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: (LiveTyping getGenericsStorage)! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960589!
beMethodArg
	argType := #method! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960616 overrides: 50668121!
isTempOrArg

	^self isTemp or: [ self isArg ]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50400638 overrides: 16977637!
assignmentCheck: encoder at: location
	^((self isBlockArg and: [(Preferences at: #allowBlockArgumentAssignment) not])
	    or: [self isMethodArg])
			ifTrue: [location]
			ifFalse: [-1]! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960398 overrides: 16977633!
accept: aVisitor
	^aVisitor visitTempVariableNode: self! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960731 overrides: 16977811!
sizeCodeForStore: encoder
	remoteNode ~~ nil ifTrue:
		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].
	self reserve: encoder.
	^encoder sizeStoreTemp: index! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960427!
analyseClosure: rootNode "<MethodNode>"
	"Analyse whether the temporary needs to be made remote
	 or not, and answer whether it was made remote.
	 A temp cannot be local if it is written to remotely,
	 or if it is written to after it is closed-over.  An exception
	 is an inlined block argument that appears to be written
	 remotely but is actually local to a block."
	| latestWrite |
	self isBlockArg ifTrue: [^false].
	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"
	latestWrite := 0.
	((writingScopes notNil
	 and: [writingScopes associations anySatisfy: [:assoc|
			[:blockScope :refs|
			refs do: [:write| latestWrite := write max: latestWrite].
			"A temp cannot be local if it is written to remotely."
			blockScope actualScope ~~ definingScope actualScope]
				value: assoc key value: assoc value]])
	or: [readingScopes notNil
		and: [readingScopes associations anySatisfy: [:assoc|
				[:blockScope :refs|
				 "A temp cannot be local if it is written to after it is closed-over."
				 blockScope actualScope ~~ definingScope actualScope
				 and: [refs anySatisfy: [:read| read < latestWrite]]]
					value: assoc key value: assoc value]]]) ifTrue:
		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.
		 ^true].
	^false! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960836 overrides: 50668159!
printOn: aStream indent: anInteger

	aStream nextPut: $|; space.
	self printEachTempVarDeclarationOn: aStream.
	aStream nextPut: $|.! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960819!
initializeWithAll: aCollectionOfTempDeclarationNodes declarationWritten: aBoolean

	tempDeclarationNodes := aCollectionOfTempDeclarationNodes.
	declarationWritten := aBoolean! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960794!
allDeclaredVariableNodes

	^ tempDeclarationNodes collect: [ :tempDeclaration | tempDeclaration variableNode ]! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960847!
declaresAnyVariable

	^ tempDeclarationNodes notEmpty! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960882 overrides: 50668488!
isTemporariesDeclaration

	^ true! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960828!
printEachTempVarDeclarationOn: aStream

	^ tempDeclarationNodes do: [ :tempDeclarationNode |
		aStream nextPutAll: tempDeclarationNode variableName; space]! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960852!
declaresSameVariablesThan: aTemporariesDeclarationNode

	tempDeclarationNodes size ~= aTemporariesDeclarationNode temporaryDeclarationNodes size ifTrue: [ ^ false ].

	tempDeclarationNodes with: aTemporariesDeclarationNode temporaryDeclarationNodes do: [ :myTempDeclaration :otherTempDeclaration |
		(myTempDeclaration equivalentTo: otherTempDeclaration) ifFalse: [ ^ false ] ].
	^ true! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960867!
declaresVariable: aVariableNode

	^ self allDeclaredVariableNodes
		anySatisfy: [ :variableNode | variableNode isNamed: aVariableNode name ]! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960806!
temporaryDeclarationNodesDo: aBlock

	tempDeclarationNodes do: aBlock! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658900 overrides: 50668223!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  

	^#()! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960812!
initializeWithAll: aCollectionOfTempDeclarationNodes

	tempDeclarationNodes _ aCollectionOfTempDeclarationNodes! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960843!
declarationWritten

	^ declarationWritten! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960886 overrides: 50668535!
accept: aVisitor

	^ aVisitor visitTemporariesDeclarationNode: self! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960801!
temporaryDeclarationNodes

	^ tempDeclarationNodes! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960875 overrides: 50668452!
equivalentTo: aParseNode

	^ aParseNode isTemporariesDeclaration
		and: [ self declaresSameVariablesThan: aParseNode  ]! !
!TemporariesDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50658907 overrides: 50668285!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
 
	^`EmptyType new`! !
!TemporariesDeclarationNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960898!
empty

	^ self withAll: #() declarationWritten: false! !
!TemporariesDeclarationNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:35' prior: 16960903!
withAll: tempDeclarationNodes

	^ self new initializeWithAll: tempDeclarationNodes declarationWritten: true! !
!TemporariesDeclarationNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960910!
withAll: tempDeclarationNodes declarationWritten: aBoolean

	^ self new initializeWithAll: tempDeclarationNodes declarationWritten: aBoolean! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960942 overrides: 50668159!
printOn: aStream indent: anInteger

	aStream nextPut: $|; space.
	variableNode printOn: aStream indent: anInteger.
	aStream space; nextPut: $|.! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960963!
initializeVariableNode: aVariableNode

	variableNode _ aVariableNode! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960938 overrides: 50668193!
isTemporaryDeclaration

	^ true! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960925!
declaresVariable: aVariableNode

	^ variableNode isNamed: aVariableNode name! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50658915 overrides: 50668223!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  

	^variableNode basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960950 overrides: 50668535!
accept: aVisitor

	^ aVisitor visitTemporaryDeclarationNode: self! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960955!
variableName

	^ self variableNode name! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960959!
variableNode

	^ variableNode! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960931 overrides: 50668452!
equivalentTo: aParseNode

	^ aParseNode isTemporaryDeclaration
		and: [ self declaresVariable: aParseNode variableNode ]! !
!TemporaryDeclarationNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50658925 overrides: 50668285!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
 
	^variableNode liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
! !
!TemporaryDeclarationNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16960975!
of: aVariableNode

	^ self new initializeVariableNode: aVariableNode! !
!UndeclaredVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50658639 overrides: 50658464!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: aSet 
	
	^#()! !
!UndeclaredVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16975653!
tag: anObject
	"Tag can be whatever one wants it to be; used by Parser to tag
	  undeclared temps with the user's desired declaration level."

	tag := anObject! !
!UndeclaredVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16975637 overrides: 16977633!
accept: aVisitor
	^aVisitor visitUndeclaredVariableNode: self! !
!UndeclaredVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16975646!
tag
	"Tag can be whatever one wants it to be; used by Parser to tag
	  undeclared temps with the user's desired declaration level."

	^tag! !
!UndeclaredVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16975642 overrides: 16977704!
isUndeclared
	^true! !
!UndeclaredVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50658645 overrides: 50658540!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage
	
	^`EmptyType new`! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977897!
name: varName key: objRef index: i type: type
	"Only used for initting global (litInd) variables"
	^self name: varName key: objRef code: (self code: (index := i) type: type)! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977864 overrides: 50668159!
printOn: aStream indent: level 
	aStream nextPutAll: name! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977795!
emitCodeForValue: stack encoder: encoder
	stack push: 1.
	encoder
		if: code
		isSpecialLiteralForPush:
			[:specialLiteral|
			 ^encoder genPushSpecialLiteral: specialLiteral].
	(code = LdSelf or: [code = LdSuper]) ifTrue:
		[^encoder genPushReceiver].
	code = LdThisContext ifTrue:
		[^encoder genPushThisContext].
	self flag: 'probably superfluous'.
	self halt.
	^encoder genPushInstVar: index! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977782!
emitCodeForStore: stack encoder: encoder

	self shouldNotImplement! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977728!
beingAssignedToAnalyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	"No-op overridden by TempVariableNode"! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977889 overrides: 50663315!
name: string key: object code: byte
	"Only used for initting std variables, nil, true, false, self, etc."
	name _ string.
	key _ object.
	code _ byte! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50407598 overrides: 50668058!
isSelfPseudoVariable
	"Answer if this ParseNode represents the 'self' pseudo-variable."

	^ key = 'self' or: [ name = 'self'  or: [name = '{{self}}']]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977765 overrides: 50668406!
emitCodeForReturn: stack encoder: encoder
	encoder
		if: code
		isSpecialLiteralForReturn:
			[:specialLiteral|
			"short returns"
			 encoder genReturnSpecialLiteral: specialLiteral.
			 stack push: 1 "doesnt seem right".
			 ^self].
	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 
		["short returns"
		 encoder genReturnReceiver.
		 stack push: 1 "doesnt seem right".
		 ^self].
	super emitCodeForReturn: stack encoder: encoder! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50370626 overrides: 50668219!
referencesSelf

	^ self isSelfPseudoVariable ! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977787!
emitCodeForStorePop: stack encoder: encoder
	self varNodeType ~= 1 ifTrue:
		[self halt].
	encoder genStorePopInstVar: index.
	stack pop: 1! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977878!
name: string
	"Change name"

	name := string! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977743!
variableGetterBlockIn: aContext

	| temps tempIndex ivars |
	(self varNodeType = 4 and: [self key isVariableBinding]) ifTrue: [
		^[self key value]
	].
	aContext ifNil: [^nil].
	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].
	self varNodeType = 1 ifTrue: [
		ivars := aContext receiver class allInstVarNames.
		tempIndex := ivars indexOf: self name ifAbsent: [^nil].
		^[aContext receiver instVarAt: tempIndex]
	].
	self varNodeType = 2 ifTrue: [
		temps := aContext tempNames.
		tempIndex := temps indexOf: self name ifAbsent: [^nil].
		^[aContext tempAt: tempIndex]
	].
	^nil
! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977838 overrides: 50663328!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	"Do nothing"! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50629841 overrides: 50667882!
nodeTypePrintString

	^'pseudo var'! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50658464 overrides: 50663336!
basicTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	"This is other possible implementation... the problem is that self can be referenced in a method that
	is being executed in a subclass, so self in that context is the subclass no the class where the method
	is defined. 
	If I use the below implementation, the Float>>#storeOn:base: version RNG 10/12/2018 05:43:39
	passes the typecheck. If the above implementation is used, that version does not passes the type check
	because 'self infinite' returns type will be True and not Boolean.
	On the other hand, with the below implementation, if in ProtoObject I type 'self initialize ' and ask for the
	autocompleter, it will look for selectors in all subclasses of ProtoObject, while with the above implementation
	it does not.
	In a statically typed language, self would 'statically' reference only to instances of the class where the method
	is defined, in dynamically typed languages self it would be valid to send a message to self defined in a subclass
	because self could be referencing an instance of a subclass. So the behavior of self when analized statically is 
	different, although sending a message to self not defined in the method's class hierarchy is not really a good
	practice.
	This is something to continue thinking about. Maybe both strategies are valid and contextual to what we are
	doing, if typechecking or autocompete, etc - Hernan "
	
	self isSelfPseudoVariable ifTrue: [ ^{aCompiledMethod methodClass} ].
	"self isSelfPseudoVariable ifTrue: [ ^aCompiledMethod methodClass withAllSubclasses ]."
	
	self isSuperPseudoVariable ifTrue: [ 
		"If there is a message send to super in ProtoObject, the type is ProtoObject - Hernan"
		^{aCompiledMethod methodClass superclass ifNil: [ aCompiledMethod methodClass ] ifNotNil: [ :aClass | aClass ]} ].
	"self isSuperPseudoVariable ifTrue: [ ^aCompiledMethod methodClass superclass withAllSubclasses ]."
	
	self isTruePseudoVariable ifTrue: [ ^`Array with: true class` ].
	self isFalsePseudoVariable ifTrue: [ ^`Array with: false class` ].
	self isThisContextPseudoVariable ifTrue: [ ^`Array with: MethodContext` ]. 
	self isNilPseudoVariable ifTrue: [ ^`Array with: nil class` ]. 
	
	self error: 'Unsupported variable node'! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977868 overrides: 50667899!
printWithClosureAnalysisOn: aStream indent: level 

	aStream nextPutAll: name! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977821 overrides: 50663384!
sizeCodeForValue: encoder
	self reserve: encoder.
	encoder
		if: code
		isSpecialLiteralForPush:
			[:specialLiteral| "i.e. the pseudo-variables nil true & false"
			 ^encoder sizePushSpecialLiteral: specialLiteral].
	(code = LdSelf or: [code = LdSuper]) ifTrue:
		[^encoder sizePushReceiver].
	code = LdThisContext ifTrue:
		[^encoder sizePushThisContext].
	self flag: 'probably superfluous'.
	self halt.
	^encoder sizePushInstVar: index! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977649!
index
	"If index is nil, this code attempts to reconstruct the index from its encoding in code."
	index ifNotNil:
		[^index].
	code < 0 ifTrue:[^nil].
	code > 256 ifTrue:
		[self assert: index = (code \\ 256).
		^code \\ 256].
	code >= (CodeBases at: self varNodeType) ifTrue:
		[self assert: index = (code - (CodeBases at: self varNodeType)).
		^code - (CodeBases at: self varNodeType)].
	self assert: index = (code - self varNodeType).
	^code - self varNodeType! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977905!
nameAndKey: aName

	name := key := aName ! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977675 overrides: 50667913!
isNilPseudoVariable
	
	^ key = 'nil' or: [name = '{{nil}}']! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977882!
name: varName index: i type: type
	"Only used for initting instVar refs"
	^self name: varName key: varName index: i type: type! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50370631 overrides: 50668448!
referencesSuper

	^self isSuperPseudoVariable ! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977643 overrides: 50663300!
equivalentTo: aParseNode

	^ aParseNode isVariableNode and: [ super equivalentTo: aParseNode ]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50650249!
argumentNameForNewMessageSentFrom: aSender

	| argumentName |
	
	argumentName := self isPseudoVariable
		ifTrue: [ self pseudoVariableNameIn: aSender ]
		ifFalse: [ self name ].
	
	^ (aSender receiver class definesInstanceVariableNamedInHierarchy: argumentName) 
		ifTrue: [ argumentName article, argumentName capitalized ]
		ifFalse: [ argumentName ]
	! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50658540 overrides: 50663307!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: anStorage
	
	self isSelfPseudoVariable ifTrue: [ ^FixedType for: aCompiledMethod methodClass ].
	
	self isSuperPseudoVariable ifTrue: [ 
		"If there is a message send to super in ProtoObject, the type is ProtoObject - Hernan"
		^(aCompiledMethod methodClass superclass ifNil: [ FixedType for: aCompiledMethod methodClass ] ifNotNil: [ :aClass | FixedType for: aClass ]) ].
	
	self isTruePseudoVariable ifTrue: [ ^`FixedType for: true class` ].
	self isFalsePseudoVariable ifTrue: [ ^`FixedType for: false class` ].
	self isThisContextPseudoVariable ifTrue: [ ^`FixedType for: MethodContext` ]. 
	self isNilPseudoVariable ifTrue: [ ^`FixedType for: nil class` ]. 
	
	self error: 'Unsupported variable node'! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977736 overrides: 50667940!
currentValueIn: aContext

	aContext ifNil: [^nil].
	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) value printString
	

! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977694 overrides: 50668472!
isThisContextPseudoVariable
	
	^key = 'thisContext' or: [name = '{{thisContext}}']! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977816!
sizeCodeForStorePop: encoder
	self shouldNotImplement! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977666 overrides: 50668296!
isFalsePseudoVariable
	
	^key = 'false' or: [name = '{{false}}']! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977671!
isNamed: aName

	^ self name = aName! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50650263!
isPseudoVariable

	^ self isFalsePseudoVariable
		or: [ self isTruePseudoVariable
		or: [ self isSelfPseudoVariable
		or: [ self isSuperPseudoVariable
		or: [ self isThisContextPseudoVariable
		or: [ self isNilPseudoVariable ]]]]]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50650273!
pseudoVariableNameIn: aContext

	(self isSelfPseudoVariable or: [ self isSuperPseudoVariable] ) ifTrue: [ ^aContext receiver argumentName ].
	(self isFalsePseudoVariable or: [ self isTruePseudoVariable]) ifTrue: [ ^ 'aBoolean' ].
	self isThisContextPseudoVariable ifTrue: [ ^ 'aMethodContext' ].
	
	^'anObject'! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977710 overrides: 50668305!
isVariableReference
	^true! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977843!
fieldOffset
	"Return temp or instVar offset for this variable"
	^index ifNil: [code < 256
					ifTrue: [code \\ 16]
					ifFalse: [code \\ 256]]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977714!
varNodeType
	"This code attempts to reconstruct the type from its encoding in code.
		This allows one to test, for instance, (aNode type = LdInstType)."
	| type |
	code < 0 ifTrue: [^code negated].
	code >= 256 ifTrue: [^code // 256].
	type := CodeBases findFirst: [:one | code < one].
	^type = 0 ifTrue: [5] ifFalse: [type - 1]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977707 overrides: 50668493!
isVariableNode
	^true! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977699 overrides: 50668318!
isTruePseudoVariable
	
	^ key = 'true' or: [name = '{{true}}']! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977687 overrides: 50668110!
isSuperPseudoVariable
	"Answer if this ParseNode represents the 'super' pseudo-variable."

	^ key = 'super' or: [name = '{{super}}']! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977637 overrides: 50668333!
assignmentCheck: encoder at: location
	^(encoder cantStoreInto: name) ifTrue: [location] ifFalse: [-1]! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977874!
asStorableNode: encoder
	^ self! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977633 overrides: 50668535!
accept: aVisitor
	^aVisitor visitVariableNode: self! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977861 overrides: 16903442!
name
	^ name! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977811!
sizeCodeForStore: encoder
	self shouldNotImplement! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977850 overrides: 50668553!
sizeCodeForReturn: encoder
	encoder
		if: code
		isSpecialLiteralForReturn:
			[:specialLiteral|
			 ^encoder sizeReturnSpecialLiteral: specialLiteral].
	(self code = LdSelf or: [self code = LdSuper]) ifTrue:
		[^encoder sizeReturnReceiver].
	^super sizeCodeForReturn: encoder! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977704!
isUndeclared
	^false! !
!VariableNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977915 overrides: 50668572!
initClassCachedState
	"
	VariableNode initialize. Decompiler initialize
	"
	| encoder |
	encoder := Encoder new.
	StdVariables := Dictionary new: 16.
	encoder
		fillDict: StdVariables
		with: VariableNode
		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )
		to: (Array with: LdSelf with: LdThisContext with: LdSuper)
				, (Array with: LdNil with: LdFalse with: LdTrue).
	StdSelectors := Dictionary new: 64.
	encoder
		fillDict: StdSelectors
		with: SpecialSelectorNode
		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 
							[:i | Smalltalk specialSelectorAt: i])
		to: (1 to: Smalltalk specialSelectorSize) asArray.
	StdLiterals := LiteralDictionary new: 16.
	encoder
		fillDict: StdLiterals
		with: LiteralNode
		mapping: #(-1 0 1 2 )
		to: (LdMinus1 to: LdMinus1 + 3).
	encoder initScopeAndLiteralTables.

	NodeNil := encoder encodeVariable: 'nil'.
	NodeTrue := encoder encodeVariable: 'true'.
	NodeFalse := encoder encodeVariable: 'false'.
	NodeSelf := encoder encodeVariable: 'self'.
	NodeThisContext := encoder encodeVariable: 'thisContext'.
	NodeSuper := encoder encodeVariable: 'super'! !
!VariableNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977953 overrides: 50668565!
initialize
	"
	VariableNode initialize
	"
	self initClassCachedState! !
!VariableNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 16977958 overrides: 50668607!
releaseClassCachedState

	StdVariables _ nil.
	StdSelectors _ nil.
	StdLiterals _ nil.

	NodeNil _ nil.
	NodeTrue _ nil.
	NodeFalse _ nil.
	NodeSelf _ nil.
	NodeThisContext _ nil.
	NodeSuper _ nil ! !
!VariableNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/8/2023 21:15:36' prior: 50650286!
named: aString 

	^ self new name: aString; yourself! !
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/8/2023 21:17:43' prior: 50660834 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverTypes receiverTypesCompatibility |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverTypes:=aMessageNode receiverLiveTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
	receiverTypesCompatibility := receiverTypes asArray. "TODO. Review this"
	
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypesCompatibility isEmpty and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypesCompatibility ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/8/2023 21:18:27'!
ERROR!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/8/2023 21:20:41' prior: 50670547 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverTypes |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverTypes:=aMessageNode receiverLiveTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
		
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverTypes isEmptyType and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 21:20:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 21:20:54'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 21:22:59'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/8/2023 21:22:59'!
ERROR!

aMessageNode selectorSymbol!

types!

self asArray!

self typeName !

self liveClass !

self typeName !

----SNAPSHOT----(8 December 2023 21:37:07) CuisUniversity-5981.image priorSource: 10197292!

!testRun: #TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:15:52'!
ERROR!

receiverTypes isEmptyType!
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:17:50' prior: 50657624 overrides: 16904184!
initialize

	Utilities informUser: 'Initializing live typing generics' during: [ self initializeLiveTypingGenerics ].! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:17:50' prior: 50657591!
initializeGenericClassesInfo

	LiveTyping initializeGenerics.
	
	"initialize generic info for supported generic types"
	{
		Array.
		Array2D.
		RunArray.
		RunNotArray.
		ShortRunArray.
		Heap.
		LinkedList.
		OrderedCollection.
		SortedCollection.
		Bag.
		IdentityBag.
		Set.
		IdentitySet.
		Dictionary.
		IdentityDictionary.
		OrderedDictionary.
		
		"the following classes only have very basic support"
		WeakArray.
		WeakKeyDictionary.
		WeakIdentityKeyDictionary.
		WeakRegistry.
		WeakSet.
		WeakIdentitySet.
		WeakValueDictionary.
	}
	do: [:aType | 
		aType initializeGeneric.	
	].! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:17:50' prior: 50657561!
addClassVarsToLiveTyping

	| ltc storageVarName |
	ltc := LiveTyping class.
	storageVarName := 'genericsStorage'.
	(ltc definesInstanceVariableNamed: storageVarName) ifFalse: [
		ltc addInstVarName: storageVarName.
	].! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:17:50' prior: 50657614!
runExamples

	"run examples so that live typing collects type info"
	
	GenericsExamples new runAllExamples.
	
	Observed initializeGeneric.
	ObservedExample new example.! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:17:50' prior: 50657571!
deleteOldLiveTypingMethods

	ParseNode allSubclassesDo: [:aSubClass | | classOrganization |
		classOrganization := aSubClass organization.
		(classOrganization categoryOfElement: #typesIn:addingIncompleteTypeInfoTo:)	 = '*LiveTyping' ifTrue:[
			aSubClass removeSelector: #typesIn:addingIncompleteTypeInfoTo:.
		].
		(classOrganization categoryOfElement: #typesIn:addingIncompleteTypeInfoTo:castingWith:)	 = '*LiveTyping' ifTrue:[
			aSubClass removeSelector: #typesIn:addingIncompleteTypeInfoTo:castingWith:.
		].
	].
	! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:17:50' prior: 50657631!
initializeLiveTypingGenerics

	self addClassVarsToLiveTyping.
	self deleteOldLiveTypingMethods.
	self initializeGenericClassesInfo.
	self runExamples.
	! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654832 overrides: 50654794!
liveAndClassTypesDo: aTwoArgBlock

	aTwoArgBlock value: self value: self liveClass.! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654838 overrides: 50654799!
liveTypesDo: aBlock

	aBlock value: self.! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654804!
<= anotherType
	(anotherType isKindOf: ClassLiveType) 
		ifTrue: [
			^ class typeName <= anotherType liveClass typeName
		]
		ifFalse: [
			^ (anotherType isKindOf: UnionType)
		]! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654814 overrides: 50654774!
asArray

	^{self}.! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654818!
liveClass
	^ class! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654827 overrides: 50654790!
classTypesDo: aBlock

	aBlock value: self liveClass! !
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654822 overrides: 50654783!
typeName

	^self liveClass name.! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655205!
add: aClass 
	|freeIndex|
	"TODO: Recorrer una sola vez en vez de includes y findFirst"
	(contentTypes includes: aClass) ifFalse:[
		freeIndex := contentTypes findFirst: [:type | type isNil].
		freeIndex > 0 ifTrue: [
			contentTypes at: freeIndex put: aClass
		]
	]! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655224 overrides: 16901837!
asString
	^ self class asString, #- , self type asString.! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655257!
withAllSuperclasses
	^Array with: collectionType.! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655235!
initializeFor: aType

	contentTypes := Array new:10.
	collectionType := aType.
	isAssigned := true.
	^ self.! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655278!
types
	| aSet |
	
	aSet := Set new.
	aSet add: collectionType.
	^ aSet! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655243 overrides: 16901663!
size
	|size|
	size := 0.
	contentTypes do: [:type| type ifNotNil: [size := size + 1]].
	^ size.
	! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655217!
addAll: aClassesCollection
	
	aClassesCollection do: [:aClass | self add: aClass].! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655229!
containsType: aType
	^ contentTypes anySatisfy: [:savedType | savedType = aType].! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655250!
sort: types

	^ types asArray sort: [:class1 :class2 | class1 asString <= class2 asString].! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655262!
contentTypes

	|nonNullTypes|
	nonNullTypes := Set new.
	(self sort: contentTypes) do: [:type | type ifNotNil: [nonNullTypes add: type]].
	^ nonNullTypes.! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655274!
type
	^ collectionType.! !
!CollectionsContentType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655270!
isAssigned

	^ isAssigned.! !
!CollectionsContentType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655284!
for: aType
	^super new initializeFor: aType.! !
!CollectionsContentType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655290 overrides: 16785646!
new
	^super new initialize.! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655105 overrides: 50654794!
liveAndClassTypesDo: aTwoArgBlock

	"this object represents no type info found, do nothing"! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655080 overrides: 50654747!
isEmptyType

	^true! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655085 overrides: 50654761!
supertypeWith: types 
	
	|typesToProcess|
	
	typesToProcess := self sanitize: types.

	typesToProcess do: [:t | 
		(t isKindOf: EmptyType) ifFalse: [^ UnionType of: self and: typesToProcess].
	].

	^ self.! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655060 overrides: 16901772!
= otherObject

	otherObject ifNotNil: [ 
		^ otherObject isKindOf: EmptyType.
	].
	
	^ false.! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655076 overrides: 16901788!
hash
	^ #EmptyType hash! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655111 overrides: 50654799!
liveTypesDo: aBlock

	"this object represents no type info found, do nothing"! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655055!
<= anotherType
	^ true.! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655072 overrides: 50654774!
asArray

	^#().! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655067 overrides: 50654743!
accept: visitor
	^ visitor visitEmptyType: self.! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655099 overrides: 50654790!
classTypesDo: aBlock

	"this object represents no type info found, do nothing"! !
!EmptyType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655095 overrides: 50654783!
typeName

	^'?'! !
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654872 overrides: 50654761!
supertypeWith: types 
	
	|copiedTypes typesToProcess|
	
	typesToProcess := self sanitize: types.

	copiedTypes := Set new.
	typesToProcess do: [:t | 
		((t isKindOf: EmptyType) or: [t isKindOf: UnionType]) ifTrue: [^ UnionType of: self and: typesToProcess].
		copiedTypes add: t liveClass. 
	].
	
	copiedTypes add: class.

	^ FixedType for: (SupertypeDetective new: copiedTypes) search! !
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654867!
initializeWith: aClass

	class := aClass.! !
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654849 overrides: 16901772!
= otherObject

	otherObject ifNotNil: [ 
		(otherObject isKindOf: FixedType) ifTrue: [
				^ class = otherObject liveClass
			]
		 ].
	
	^ false.! !
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654863 overrides: 16901788!
hash
	^ class hash! !
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654843 overrides: 50622720!
printOn: aStream
	aStream nextPutAll: 'LiveType: ' , class asString! !
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654858 overrides: 50654743!
accept: visitor
	^ visitor visitFixedType: self.! !
!FixedType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654888!
for: aClass 
	^ self new initializeWith: aClass.! !
!GenericParametersCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655305!
allContentTypes

	^ccts collect: [ :cct | cct contentTypes copy].! !
!GenericParametersCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655324!
at: anIndex addAll: aTypeCollection

	(ccts at: anIndex) addAll: aTypeCollection.! !
!GenericParametersCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655294!
initializeFor: aType withParameters: aParameterQuantity

	ccts := Array new: aParameterQuantity.
	1 to: aParameterQuantity do: [:i |
		ccts at: i put: 	(CollectionsContentType for: aType).
	].
	genericType := aType.
	isAssigned := true.
	! !
!GenericParametersCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655310!
contentTypesAt: anIndex

	^ccts at: anIndex :: contentTypes! !
!GenericParametersCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655319!
at: anIndex add: aType

	(ccts at: anIndex) add: aType.! !
!GenericParametersCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655315!
type
	
	^genericType ! !
!GenericParametersCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655330!
for: aType withParameters: aParameterQuantity

	^self new initializeFor: aType withParameters: aParameterQuantity.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654919!
initializeWith: aClass withTypes: aTypesCollection 
	|typesToProcess|

	typesToProcess := self sanitize: aTypesCollection.
	class := aClass.
	innerTypes := Set new.
	
	typesToProcess do: [:type | 
		(type isKindOf: LiveType) ifTrue: [
				innerTypes add: type.
			] ifFalse: [
				innerTypes add: (FixedType for: type)
			]
		].
	^ self.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654955 overrides: 50654761!
supertypeWith: types 
	| supertype superGenerics copiedTypes generics typesToProcess cantUnifyGenerics |

	copiedTypes := Set new.
	generics := Array new: innerTypes size.
	1 to: innerTypes size do: [:i | generics at: i put: ((innerTypes at: i) copy)].
	typesToProcess := self sanitize: types.
	cantUnifyGenerics := false.
	
	typesToProcess do: [:t | 
		((t isKindOf: EmptyType) or: [t isKindOf: UnionType]) ifTrue: [^ UnionType of: self and: typesToProcess].
		copiedTypes add: t liveClass.
		(t isKindOf: FixedType) ifTrue: [
			cantUnifyGenerics := true
		] ifFalse: [
			(t parametersCount = self parametersCount) ifTrue: [ | otherGenerics |
				otherGenerics := t generics.
				1 to: generics size do: [:i | 
					(generics at: i) addAll: (otherGenerics at: i).
				]
			] ifFalse:[
				cantUnifyGenerics := true
			].
		].
	].
	
	copiedTypes add: class.
	

	supertype := (SupertypeDetective new: copiedTypes) search.
	cantUnifyGenerics ifTrue: [^FixedType for: supertype].
	
	superGenerics := Array new: generics size.
	1 to: superGenerics size do: [:i | superGenerics at: i put: {(generics at: i) anyOne supertypeWith: (generics at: i)}].
	^ GenericType for: supertype withMultiParamTypes: superGenerics! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654909!
generics
	^ innerTypes.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654894 overrides: 16901772!
= otherObject

	otherObject ifNotNil: [ 
		(otherObject isKindOf: GenericType) ifTrue: [
				^ class = otherObject liveClass and: [innerTypes = otherObject generics].
			]
		 ].
	
	^ false.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654914 overrides: 16901788!
hash
	^ class hash + innerTypes hash! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654934 overrides: 50654751!
isGenericType

	^true.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654943 overrides: 50622720!
printOn: aStream

	| str types |
	types _ innerTypes asArray.
	str _ ''.
	1 to: (types size - 1) do: [ :i |
		str _ str, (types at: i) asString, ', '	
	].
	str _ str, (types at: (types size)) asString.
	aStream nextPutAll: 'GenericType: ', class asString , '<', str, '>'! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655019!
initializeWith: aClass withMultiParamTypes: aTypesCollectionArray 
	
	class := aClass.
	innerTypes := Array new: aTypesCollectionArray size.
	1 to: aTypesCollectionArray size do:[ :index | | aTypesCollection typesToProcess |
		aTypesCollection := aTypesCollectionArray at: index.
		typesToProcess := self sanitize: aTypesCollection.
		innerTypes at: index put: Set new.
		typesToProcess do: [:type | 
		(type isKindOf: LiveType) ifTrue: [
				(innerTypes at: index) add: type.
			] ifFalse: [
				(innerTypes at: index) add: (FixedType for: type)
			]
		].
	].

	^ self.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654938!
parametersCount

	^innerTypes size! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654904 overrides: 50654743!
accept: visitor
	^ visitor visitGenericType: self.! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50654998 overrides: 50654766!
unifiesWith: anotherType
	^ (anotherType isKindOf: GenericType) 
		and: [self parametersCount = anotherType parametersCount]
		and: [class = anotherType liveClass]! !
!GenericType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655007 overrides: 50654770!
unify: anotherType
	| unifiedTypes otherTypeGenerics |
	unifiedTypes := innerTypes copy.
	otherTypeGenerics := anotherType generics.
	1 to: unifiedTypes size do: [ :i |
		(unifiedTypes at: i) addAll: (otherTypeGenerics at: i).
	].
	^GenericType for: class withMultiParamTypes: unifiedTypes.! !
!GenericType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655041!
for: aClass withMultiParamTypes: aTypesCollectionArray
 	^ self new initializeWith: aClass withMultiParamTypes: aTypesCollectionArray! !
!GenericType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655048!
for: aClass withTypes: aTypesCollection 
 	^ self for: aClass withMultiParamTypes: {aTypesCollection}.! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655379!
in: aCompiledMethod forArguments: aParseNodeCollection storingGenericsInfoIn: aStorage

	| cct |
	cct := CollectionsContentType for: class.
	fromParams ifTrue: [
		argumentCollection do: [ :index |
			[cct addAll: (((aParseNodeCollection at: index)	 
						liveTypesIn: aCompiledMethod 
						addingIncompleteTypeInfoTo: Set new 
						storingGenericsInfoIn: aStorage) generics at: 1).]
				on: MessageNotUnderstood 
				do: [:error | ].	
		].
	]
	ifFalse: [
			
		argumentCollection do: [ :index |
			cct add: ((aParseNodeCollection at: index)	 
						liveTypesIn: aCompiledMethod 
						addingIncompleteTypeInfoTo: Set new 
						storingGenericsInfoIn: aStorage).
		].
	].
	
	

	^RawToLiveTypesAdapter new adapt: {cct}.! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655337 overrides: 16901772!
= anotherObject

	(anotherObject isKindOf: self class) ifFalse: [^false].

	^anotherObject genericClass = self genericClass
		and: [anotherObject methodRef = self methodRef].! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655346 overrides: 16901788!
hash

	^class hash bitXor: methodReference hash.! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655355!
methodRef

	^methodReference ! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655359!
initializeFor: aClass from: aMethodReference onArgs: anArgumentCollection 
	
	
	class := aClass.
	methodReference := aMethodReference.
	argumentCollection := anArgumentCollection.
	fromParams := false.! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655351!
genericClass
	
	^class! !
!GenericTypeConstructor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655369!
initializeFor: aClass from: aMethodReference onParamsFromArgs: anArgumentCollection 
	
	
	class := aClass.
	methodReference := aMethodReference.
	argumentCollection := anArgumentCollection.
	fromParams := true.! !
!GenericTypeConstructor class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:04' prior: 50655406!
for: aClass from: aMethodReference onArgs: anArgumentCollection 
	
	^self new initializeFor: aClass from: aMethodReference onArgs: anArgumentCollection ! !
!GenericTypeConstructor class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655414!
for: aClass from: aMethodReference onParamsFromArgs: anArgumentCollection
	
	^self new initializeFor: aClass from: aMethodReference onParamsFromArgs: anArgumentCollection ! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654794!
liveAndClassTypesDo: aTwoArgBlock

	self subclassResponsibility ! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654747!
isEmptyType

	^false.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654761!
supertypeWith: types 
	self subclassResponsibility.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654799!
liveTypesDo: aBlock

	self subclassResponsibility ! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654751!
isGenericType

	^false.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654774!
asArray

	self subclassResponsibility.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654790!
classTypesDo: aBlock

	self subclassResponsibility ! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654743!
accept: visitor 
	self subclassResponsibility.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654755!
sanitize: types	
	(types isKindOf: Collection) ifFalse: [
		^ Array with: types.
	].
	^ types.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654766!
unifiesWith: anotherType
	^ false.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654770!
unify: anotherType
	self subclassResponsibility.! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654779 overrides: 50622715!
asTypeFor: aReceiverType

	^self! !
!LiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50654783 overrides: 50622711!
typeName

	self subclassResponsibility 
	"^String streamContents: [:stream | 
		self accept: (LiveTypesPrinter on: stream)
	]."! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655485!
visitEmptyType: anEmptyType
	stream nextPut: $?! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655423!
initializeWith: aStream
	stream := aStream.
	^ self.! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655509!
visitGenericType: aGenericType
	stream nextPutAll: aGenericType liveClass typeName.
	"TODO: make upTo an instance variable"
	(LiveTypesPrinter on: stream) print: aGenericType generics upTo: 5.! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655428!
print: typesTree
	self print: typesTree withDelimiter: true.! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655449!
print: typesTreeArray withDelimiter: printDelimiter
	| treeBound treeGenerics canBeNilTmp |
	
	canBeNilTmp := canBeNil.
	canBeNil := false.
	
	printDelimiter ifTrue: [
		stream nextPut: $<.
	].
	1 to: typesTreeArray size do:[:i | | typesTree |
		typesTree := typesTreeArray at: i.
		typesTree type accept: self.
		treeBound := typesTree bound.
		"TODO: Avoid nil checks"
		treeBound
			 ifNotNil: [
				self print: treeBound.
			].
		"TODO: Create an actual clear message for sorting"
		treeGenerics := typesTree generics asArray sort: [:typeTree1 :typeTree2 | typeTree1 type <= typeTree2 type].
		treeGenerics ifNotEmpty: [
				stream nextPutAll: ' # '.
			].
		treeGenerics do: [:generic | self print: {generic} withDelimiter: false] separatedBy: [stream nextPutAll: ' | '].
		(i = typesTreeArray size) ifFalse: [stream nextPutAll: ', '].
	].
	
	canBeNil ifTrue: [
		stream nextPutAll: 'can be nil !!' 
	].
	canBeNil := canBeNilTmp.
	
	printDelimiter ifTrue: [
		stream nextPut: $>.
	].
	"stream newLine"! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655490!
visitFixedType: aFixedType
	|class|
	"TODO: Consider instead actually printing UnionTypes as any instead of forcing UnionType supertypes into Object at the node level. Maybe even consider wheter the supertype of all mixed types should be a Union".
	
	class := aFixedType liveClass.
	(class = UndefinedObject) ifTrue: [
		canBeNil := true.
		^self.
	].
	(class = Object) 
		ifTrue: [
			stream nextPutAll: 'any'
		] 
		ifFalse: [
			stream nextPutAll: class typeName
		].! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655440!
print: liveTypes upTo: aNumberOfTypes withDelimiter: printDelimiter

	| typesTree |
	
	typesTree := TypeNode for: liveTypes.
	
	self print: {typesTree} withDelimiter: printDelimiter.
	
! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655519!
visitUnionType: aUnionType
	"TODO upTo should be an instance variable"
	self print: aUnionType types upTo: 5! !
!LiveTypesPrinter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655433!
print: liveTypes upTo: aNumberOfTypes 

	self print: liveTypes upTo: aNumberOfTypes withDelimiter: true.
! !
!LiveTypesPrinter class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655526!
on: aStream
	^ self new initializeWith: aStream.! !
!RawToLiveTypesAdapter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655557!
create: aRawOrLiveType 
	aRawOrLiveType ifNil: [^ EmptyType new].
	
	(aRawOrLiveType isKindOf: CollectionsContentType) ifTrue: [
		| innerTypes |
		innerTypes := aRawOrLiveType contentTypes copy.
		^ GenericType for: aRawOrLiveType type withTypes: (self adaptToSet: innerTypes).
	].
	
	(aRawOrLiveType isKindOf: GenericParametersCollector) ifTrue: [
		| innerTypes |
		innerTypes := aRawOrLiveType allContentTypes.
		^GenericType for: aRawOrLiveType type withMultiParamTypes: (innerTypes collect: [:contentTypes | self adaptToSet: contentTypes]).
	].
	
	(aRawOrLiveType isKindOf: GenericType) ifTrue: [
		| innerTypes |
		innerTypes := aRawOrLiveType generics copy.
		^ GenericType for: aRawOrLiveType liveClass withMultiParamTypes: (innerTypes collect: [:param | self adaptToSet: param]).
	].
	
	(aRawOrLiveType isKindOf: LiveType) ifTrue: [^aRawOrLiveType].
	(aRawOrLiveType isKindOf: DynamicType) ifTrue: [^aRawOrLiveType].
	
	^ FixedType for: aRawOrLiveType! !
!RawToLiveTypesAdapter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655591!
unifyOrAdd: newLiveType into: liveTypes
	liveTypes 
		detect: [:type | type unifiesWith: newLiveType] 
		ifFound: [:type | 
			liveTypes remove: type.
			liveTypes add: (type unify: newLiveType) ] 
		ifNone: [liveTypes add: newLiveType.].
! !
!RawToLiveTypesAdapter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655544!
adaptToSet: aRawTypes
	| liveTypes |
	aRawTypes ifEmpty: [^ Set with: (self create: nil) ].
	liveTypes := Set new.
	
	aRawTypes do: [:rt | 
			rt ifNotNil: [ 
				| newLiveType |
				newLiveType := self create: rt. 
				self unifyOrAdd: newLiveType into: liveTypes.
			]
		].
	^ liveTypes.! !
!RawToLiveTypesAdapter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655531!
adapt: aRawTypes
	| liveTypes |
	
	liveTypes := self adaptToSet: aRawTypes.
	
	liveTypes ifEmpty: [^EmptyType new].
	
	liveTypes size = 1 ifTrue: [ | type |
		type := liveTypes anyOne.
		(type isKindOf: LiveType) ifTrue: [^type].
		^liveTypes.
	].
	
	^UnionType of: (liveTypes anyOne) and: liveTypes.! !
!SupertypeDetective methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655613!
commonLowestTypeIn: commonSupertypes
	
	"TODO remove this!! ALF & MDS"
	| commonSupertype commonSupertypeSuperclassesSize |
	
	commonSupertypeSuperclassesSize := 0.
	
	commonSupertypes do: [ :currentType | | currentTypeSuperclassesSize |
		currentTypeSuperclassesSize := currentType withAllSuperclasses size.
		currentTypeSuperclassesSize > commonSupertypeSuperclassesSize ifTrue: [
			commonSupertypeSuperclassesSize := currentTypeSuperclassesSize.
			commonSupertype := currentType ]].
	
	^ commonSupertype! !
!SupertypeDetective methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655633!
commonSupertypeIfNoTypes: aBlock

	"TODO remove this!! ALF & MDS"
	| types commonSupertypes commonSupertype |

	searchingTypes isEmpty ifTrue: [ ^aBlock value ].
	searchingTypes size = 1 ifTrue: [ ^searchingTypes anyOne ].
	types := searchingTypes reject: [ :aType | aType = UndefinedObject ].

	"I have to convert types to Array becuase inst var types can be a Set - Hernan"
	commonSupertypes := self allSupertypesOf: types.
	commonSupertype := self commonLowestTypeIn: commonSupertypes.
	
	^commonSupertype ! !
!SupertypeDetective methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655653!
initializeWith: types

	searchingTypes := types.! !
!SupertypeDetective methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655658!
search

	^self commonSupertypeIfNoTypes: [ ProtoObject ]! !
!SupertypeDetective methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655602!
allSupertypesOf: types
	
	"TODO remove this!! ALF & MDS"
	^ types 
		inject: types anyOne withAllSuperclasses 
		into: [ :temporaryCommonSupertypes :type | temporaryCommonSupertypes intersection: type withAllSuperclasses ].
! !
!SupertypeDetective class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655664 overrides: 16785654!
new: types

	^ self new initializeWith: types.! !
!TfgMessageSendNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655669!
initializeMethodRef: aMethodRef

	methodRef _ aMethodRef.! !
!TfgMessageSendNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655674 overrides: 16901772!
= anObject

	^(anObject isKindOf: self class) and: [anObject methodRef = methodRef].! !
!TfgMessageSendNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655680 overrides: 16901788!
hash

	^self class hash bitXor: methodRef hash.! !
!TfgMessageSendNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655684!
methodRef

	^methodRef! !
!TfgMessageSendNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655688 overrides: 16902975!
printOn: aStream
	aStream nextPutAll: self class asString, '('.
	methodRef printClassAndSelectorOn: aStream.
	aStream nextPut: $)! !
!TfgMessageSendNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655696!
methodRef: aMethodRef

	^self basicNew initializeMethodRef: aMethodRef! !
!TfgReturnValue methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655702 overrides: 16901772!
= anObject

	^(anObject isKindOf: self class).! !
!TfgReturnValue methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655707 overrides: 16901788!
hash

	^self class hash! !
!TfgReturnValue methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655711!
methodRef

	^methodRef! !
!TfgVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655720 overrides: 16901772!
= anObject

	^(anObject isKindOf: (self class)) and: [anObject name = name].! !
!TfgVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655715!
initializeFor: aVariableName 
	
	name _ aVariableName.! !
!TfgVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655726 overrides: 16901788!
hash

	^name hash! !
!TfgVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655730 overrides: 16902975!
printOn: aStream
	aStream nextPutAll: self class asString, '(', name, ')'! !
!TfgVariableNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655736 overrides: 16903442!
name

	^name! !
!TfgVariableNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655740!
for: aVariableName 

	^self new initializeFor: aVariableName ! !
!TracedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655757!
selector

	^selector! !
!TracedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655749!
argIndex

	^argIndex! !
!TracedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655745!
accessTypesFrom: aLiveType

	^Set with: aLiveType.! !
!TracedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655763!
initializeFor: aType selector: aSelector argIndex: anIndex

	type _ aType.
	selector _ aSelector.
	argIndex _ anIndex.! !
!TracedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655752!
argIndexes
	
	^argIndex collect: [:assoc | assoc value]! !
!TracedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655760!
type

	^type! !
!TracedType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655770!
type: aType selector: aSelector argIndex: anIndex

	^self basicNew initializeFor: aType 
				selector: aSelector 
				argIndex: anIndex! !
!TracedTypeFromParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655778 overrides: 50671691!
accessTypesFrom: aLiveType

	| liveTypeSet |
	liveTypeSet := Set new.
	aLiveType liveTypesDo: [:lt | 
		[liveTypeSet addAll: (lt generics at: 1)] 
			on: MessageNotUnderstood
			do: [:error | ].
	].
	^liveTypeSet! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655792!
inNeighborsOf: aNode 

	^(links select: [:assoc | assoc value = aNode] thenCollect: [:assoc | assoc key]).! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655835 overrides: 16920235!
initialize

	nodes _ Set new.
	links _ Set new.! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655808!
nodes
	^Set withAll: nodes.! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655788!
edgesSize
	^links size! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655826!
link: aNode to: anotherNode 
	
	self assert: (nodes includes: aNode).
	self assert: (nodes includes: anotherNode).
	
	links add: (Association key: aNode value: anotherNode).! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655839!
from: aTypeFlowGraphNode do: aBlock

"implements DFS from aTypeFlowGraphNode"

	| currentNode visited neighbors nextNodes |
	(nodes includes: aTypeFlowGraphNode) ifFalse: [self error: 'node not found'].
					
	nextNodes _ OrderedCollection with: aTypeFlowGraphNode.
	visited _ Set new.
	
	[nextNodes isEmpty] whileFalse: [
		currentNode _ nextNodes removeLast.
		(visited includes: currentNode) ifFalse: [
			aBlock value: currentNode.
			neighbors _ self outNeighborsOf: currentNode.
			nextNodes addAll: neighbors.
			visited add: currentNode.
		]
	].
	! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655816!
outNeighborsOf: aNode 

	^(links select: [:assoc | assoc key = aNode] thenCollect: [:assoc | assoc value]).! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655798!
isConnected: aNode with: anotherNode

	^links anySatisfy: [:assoc | |n1 n2|
		n1 _ assoc key.
		n2 _ assoc value.
		(n1 = aNode and: [n2 = anotherNode ]) or:[n2 = aNode and: [n1 = anotherNode ]].
	].
	
	
	! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655822!
addNode: aNode

	nodes add: aNode.
	! !
!TypeFlowGraph methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655812!
nodesSize
	^nodes size.! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655872!
bound
	^ bound! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655876!
generics
	^ generics! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655885!
initializeWith: aTypeSet 
	| typesToProcess supertype |
	
	typesToProcess := self sanitize: aTypeSet.
	supertype := typesToProcess anyOne supertypeWith: typesToProcess.
	
	(supertype isKindOf: GenericType) 
		ifTrue: [ 
			| processTypesGenerics |
			processTypesGenerics := Array new: (supertype parametersCount).
			1 to: processTypesGenerics size do: [:i | processTypesGenerics at: i put: Set new].
			typesToProcess do: [:aType | 
				1 to: processTypesGenerics size do: [:i | (processTypesGenerics at: i) addAll: (aType generics at: i)].
				"processTypesGenerics addAll: aType generics"
			].
			bound := processTypesGenerics collect: [:aGenericParameter | TypeNode for: aGenericParameter].
			type := FixedType for: supertype liveClass.
		] 
		ifFalse: [
			(supertype isKindOf: UnionType)
				ifTrue: [
					type := FixedType for: Object.
				]
				ifFalse: [
					type := supertype.
				]
		].
	
	(typesToProcess size > 1) 
		ifTrue: [
			generics := typesToProcess collect: [:aType | TypeNode for: aType].
		]
		ifFalse: [
			generics := Set new.
		]! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655861 overrides: 16901772!
= otherObject

	otherObject ifNotNil: [ 
		(otherObject isKindOf: TypeNode) ifTrue: [
				^ (bound = otherObject bound) 
					and: [generics = otherObject generics ]
					and: [type = otherObject type]
			]
		 ].
	
	^ false.! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655881 overrides: 16901788!
hash
	^ type hash * generics hash * bound hash! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655923 overrides: 16902975!
printOn: aStream
	aStream nextPutAll: 'TypeNode ', type asString , '<', bound asString, '> # ' , generics asString ! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655930!
sanitize: types
	| sanitizedTypes |
	
	sanitizedTypes := types.
	
	(sanitizedTypes isKindOf: UnionType) ifTrue: [sanitizedTypes := sanitizedTypes types].
	
	(sanitizedTypes isKindOf: Collection) ifFalse: [
			sanitizedTypes := Set with: types.
		].
	
	^ {sanitizedTypes} flatten! !
!TypeNode methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655942!
type
	^ type.! !
!TypeNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655946!
for: aTypeSet
	^ self new initializeWith: aTypeSet.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655122 overrides: 50671278!
liveAndClassTypesDo: aTwoArgBlock

	types do: [:lt | lt liveAndClassTypesDo: aTwoArgBlock ].! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655180 overrides: 50671288!
supertypeWith: liveTypes 
	
	|typesToProcess|
	
	typesToProcess := self sanitize: liveTypes.
	types addAll: typesToProcess.

	^ self.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655138 overrides: 16901772!
= otherObject

	otherObject ifNotNil: [ 
		(otherObject isKindOf: UnionType) ifTrue: [
				^ types = otherObject types
			]
		 ].
	
	^ false.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655128 overrides: 50671293!
liveTypesDo: aBlock

	types do: [:lt | lt liveTypesDo: aBlock ].! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655157 overrides: 16901788!
hash
	^ types hash! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655174 overrides: 50622720!
printOn: aStream
	aStream nextPutAll: 'UnionType: <', types asString, '>'! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655195!
types

	^ types copy.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655133!
<= anotherType
	^ false.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655117 overrides: 50671307!
classTypesDo:aBlock

	types do: [:lt | lt classTypesDo: aBlock ].! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655147 overrides: 50671312!
accept: visitor
	^ visitor visitUnionType: self.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655152 overrides: 50671302!
asArray

	^types asArray! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655161!
initializeWith: aType and: anotherType

	|anotherTypes|
	
	anotherTypes := self sanitize: anotherType.
	
	types := Set new.
	types add: aType.
	anotherTypes do: [ :type | 
		(type isKindOf: UnionType) 
			ifTrue: [ types addAll: type types]
			ifFalse: [ types add: type ].
		].
	^ self.! !
!UnionType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655188 overrides: 50671340!
typeName

	^String streamContents: [:stream |
		self classTypesDo: [:ct | stream nextPutAll: ct typeName, ' ']
	].! !
!UnionType class methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:18:05' prior: 50655199!
of: aType and: anotherType 
	^ self new initializeWith: aType and: anotherType.! !
!TypeCheckerDragonTest methodsFor: 'setup' stamp: 'JFGO 12/11/2023 18:23:36'!
test01MethodTypedCorrectlyDoesNotGenerateAlerts

	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #emptyMethodEnableTyping.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
! !

!methodRemoval: TypeCheckerDragonTest #test01EmptyMethodDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:23:36'!
test01EmptyMethodDoesNotGenerateAlerts

	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #emptyMethodEnableTyping.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
!
!TypeCheckerDragonTestMethods methodsFor: 'without context filters' stamp: 'JFGO 12/11/2023 18:24:07'!
methodTypedCorrectlyEnableTyping
	"Actually, by default type checking will be enabled. Disable it manually from outside. Method name is for declarativity purposes"
	1 + 1.! !

!methodRemoval: TypeCheckerDragonTestMethods #emptyMethodEnableTyping stamp: 'JFGO 12/11/2023 18:24:07'!
emptyMethodEnableTyping
	"Actually, by default type checking will be enabled. Disable it manually from outside. Method name is for declarativity purposes"
	1 + 1.!
!TypeCheckerDragonTest methodsFor: 'setup' stamp: 'JFGO 12/11/2023 18:24:29' prior: 50671992!
test01MethodTypedCorrectlyDoesNotGenerateAlerts

	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #methodTypedCorrectlyEnableTyping.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
! !
!TypeCheckerDragonTest methodsFor: 'setup' stamp: 'JFGO 12/11/2023 18:24:58' prior: 50660048!
test02MethodThatDontCheckTypesGeneratesAlert

	| methodToCkeck typeChecker |
	
	methodToCkeck := TypeCheckerDragonTestMethods >> #methodTypedCorrectlyEnableTyping.
	methodToCkeck removeProperties .
	
	typeChecker := methodToCkeck typeCheckDragon.
	
	
	self assertTypeChecker: typeChecker hasOneAlertWithMessage: 'Method has live typing disabled'.
	! !
!TypeCheckerDragonTest methodsFor: 'setup' stamp: 'JFGO 12/11/2023 18:25:30' prior: 50672031!
test01MethodTypedCorrectlyDoesNotGenerateAlerts

	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #methodTypedCorrectlyEnableTyping.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
! !
!TypeCheckerDragonTest methodsFor: 'setup' stamp: 'JFGO 12/11/2023 18:25:36' prior: 50672042!
test02MethodThatDontCheckTypesGeneratesAlert

	| methodToCkeck typeChecker |
	
	methodToCkeck := TypeCheckerDragonTestMethods >> #methodTypedCorrectlyEnableTyping.
	methodToCkeck removeProperties .
	
	typeChecker := methodToCkeck typeCheckDragon.
	
	
	self assertTypeChecker: typeChecker hasOneAlertWithMessage: 'Method has live typing disabled'.
	! !
!TypeCheckerDragonTest methodsFor: 'nil' stamp: 'JFGO 12/11/2023 18:25:47' prior: 50660029 overrides: 16961394!
setUp
	"Ensure that always this method initializes with live typing enabled. See test01 and test02"
	(TypeCheckerDragonTestMethods >> #methodTypedCorrectlyEnableTyping) initializeTypeInformation.
	
	! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:25:49'!
ERROR!

----QUIT----(11 December 2023 18:25:58) CuisUniversity-5981.image priorSource: 10847156!

----STARTUP---- (11 December 2023 18:26:05) as C:\Users\jgutierrez\Tesis\CUIS\windows64\CuisUniversity-5981.image!


----SNAPSHOT----(11 December 2023 18:26:22) CuisUniversity-5981.image priorSource: 10894215!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:27:00'!
ERROR!

receiverTypes!

	receiverTypes!

	receiverTypes asArray!

	receiverTypes typeName!

	receiverTypes className!

!methodRemoval: ClassLiveType #asArray stamp: 'JFGO 12/11/2023 18:33:21'!
asArray

	^{self}.!
!FixedType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:33:53' overrides: 50671302!
asArray
	^{self typeName}! !

	receiverTypes typeName!

!methodRemoval: FixedType #asArray stamp: 'JFGO 12/11/2023 18:34:46'!
asArray
	^{self typeName}!
!ClassLiveType methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:35:07' overrides: 50671302!
asArray
	^{self}! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:36:40'!
ERROR!

self literalValue asLiveType!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:43:03'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:43:03'!
ERROR!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/11/2023 18:49:49' prior: 50670582 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverLiveType |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverLiveType:=aMessageNode receiverLiveTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
		
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverLiveType isEmptyType and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedInAll: receiverLiveType ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/11/2023 18:50:44'!
checkMessageSentIn: aMessageNode isImplementedIn: receiverTypes 
	
	| implementorsFinder |
	
	implementorsFinder := AllActualLocalImplementors of: aMessageNode selectorSymbol forAll: receiverTypes.
	implementorsFinder value.
	
	implementorsFinder notImplementedIsEmpty ifFalse: [  
		alerts add: (TypeCheckerDragonAlert for: methodNode withMessage: 'Message Selector not implemented in Receiver')].! !
!TypeCheckerDragonMethodVisitor methodsFor: 'as yet unclassified' stamp: 'JFGO 12/11/2023 18:50:44' prior: 50672143 overrides: 16906976!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverLiveType |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverLiveType:=aMessageNode receiverLiveTypesIn:  compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
		
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverLiveType isEmptyType and: [ incompleteTypeInfo isEmpty])
		ifTrue: [self addAlertWithMessage: 'Receiver has no types']
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedIn: receiverLiveType ].
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock | argumentBlock accept: self].! !

!methodRemoval: TypeCheckerDragonMethodVisitor #checkMessageSentIn:isImplementedInAll: stamp: 'JFGO 12/11/2023 18:50:44'!
checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes 
	
	| implementorsFinder |
	
	implementorsFinder := AllActualLocalImplementors of: aMessageNode selectorSymbol forAll: receiverTypes.
	implementorsFinder value.
	
	implementorsFinder notImplementedIsEmpty ifFalse: [  
		alerts add: (TypeCheckerDragonAlert for: methodNode withMessage: 'Message Selector not implemented in Receiver')].!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 12/11/2023 18:51:06' prior: 50672169!
checkMessageSentIn: aMessageNode isImplementedIn: receiverLiveType 
	
	| implementorsFinder |
	
	implementorsFinder := AllActualLocalImplementors of: aMessageNode selectorSymbol forAll: receiverLiveType.
	implementorsFinder value.
	
	implementorsFinder notImplementedIsEmpty ifFalse: [  
		alerts add: (TypeCheckerDragonAlert for: methodNode withMessage: 'Message Selector not implemented in Receiver')].! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:51:45'!
ERROR!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 18:51:45'!
ERROR!

	implementors := types !

	implementors := types liveClass!
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'JFGO 12/11/2023 19:13:23' prior: 50622428 overrides: 50622393!
value
	
	notImplemented := OrderedCollection new.
	"implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ]."
	types liveTypesDo: [:aType | ].
	

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'JFGO 12/11/2023 19:15:22' prior: 50672256 overrides: 50622393!
value
	
	notImplemented := OrderedCollection new.
	"implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ]."
	implementors := IdentitySet new.
	types liveTypesDo: [:aClass | (aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | implementors add: method ].
			].
	

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 19:15:24'!
ERROR!

aClass!

self liveClass!
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'JFGO 12/11/2023 19:24:48' prior: 50672275 overrides: 50622393!
value
	
	notImplemented := OrderedCollection new.
	"implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ]."
	implementors := IdentitySet new.
	types liveTypesDo: [:aClass | (aClass liveClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | implementors add: method ].
			].
	

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 19:25:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 19:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/11/2023 19:25:08'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:08'!
ERROR!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:08'!
ERROR!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/11/2023 19:25:09'!
ERROR!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/11/2023 19:25:09'!
ERROR!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/11/2023 19:25:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:09'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/11/2023 19:25:09'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:25:19'!
ERROR!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:28:08'!
ERROR!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:28:08'!
ERROR!
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'JFGO 12/11/2023 19:29:16' prior: 50672305 overrides: 50622393!
value
	
	notImplemented := OrderedCollection new.
	"implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ]."
	implementors := IdentitySet new.
	types liveTypesDo: [:aClass | (aClass liveClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass liveClass selector: selector ) ]
				ifNotNil: [ :method | implementors add: method ].
			].
	

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:06'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:10'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/11/2023 19:31:10'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:31:10'!
FAILURE!

receiverLiveType isEmptyType!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:45:10'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/11/2023 19:45:10'!
FAILURE!

self isEmpty!

----SNAPSHOT----(11 December 2023 20:00:40) CuisUniversity-5981.image priorSource: 10894422!

----QUIT----(11 December 2023 20:01:04) CuisUniversity-5981.image priorSource: 10906725!

----STARTUP---- (11 December 2023 20:01:13) as C:\Users\jgutierrez\Tesis\CUIS\windows64\CuisUniversity-5981.image!


!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/12/2023 17:52:01'!
FAILURE!
!MessageNode methodsFor: '*LiveTypingGenerics-livetypes' stamp: 'JFGO 12/12/2023 17:52:44' prior: 50664540 overrides: 50668031!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage
	
	| messageReturnTypes sentSelector receiverTypes  |
	self halt.
	sentSelector := self selectorSymbol.
	receiverTypes := aTypeCastApplier receiverLiveTypesFor: self in: aCompiledMethod addingIncompleteTypeInfoTo:  incompleteTypeInfoReasons storingGenericsInfoIn: aStorage.
	
	messageReturnTypes := Set new.
	receiverTypes liveTypesDo: [:aReceiverType | | currentReceiverClass currentMethodRef | 								
			currentReceiverClass := aReceiverType liveClass.
			currentMethodRef := (MethodReference class: currentReceiverClass selector: sentSelector).
			(aStorage genericTypeConstructorFrom: currentMethodRef) 
				ifNil: [
					(currentReceiverClass lookupSelector: sentSelector) 
						ifNil: [ incompleteTypeInfoReasons add: (
							IncompleteTypeInfoError dueToMissingImplementationOf: currentMethodRef) ]
						ifNotNil: [ :implementor |
							self returnTypesOf: implementor 
								from: aReceiverType 
								receiving: sentSelector 
								in: aCompiledMethod
								addingReturnTypesTo: messageReturnTypes 
								addingIncompleteTypeInfoTo: incompleteTypeInfoReasons 
								storingGenericsInfoIn: aStorage
							].
				] 
				ifNotNil: [:aGenericTypeConstructor | 
					messageReturnTypes add: (aGenericTypeConstructor in: aCompiledMethod forArguments: self argumentsInEvaluationOrder storingGenericsInfoIn: aStorage).
				].
			
			].
		
	^RawToLiveTypesAdapter new adapt: messageReturnTypes.! !
!MessageNode methodsFor: '*LiveTypingGenerics-livetypes' stamp: 'JFGO 12/8/2023 21:15:33' prior: 50672501 overrides: 50668031!
liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier storingGenericsInfoIn: aStorage
	
	| messageReturnTypes sentSelector receiverTypes  |

	sentSelector := self selectorSymbol.
	receiverTypes := aTypeCastApplier receiverLiveTypesFor: self in: aCompiledMethod addingIncompleteTypeInfoTo:  incompleteTypeInfoReasons storingGenericsInfoIn: aStorage.
	
	messageReturnTypes := Set new.
	receiverTypes liveTypesDo: [:aReceiverType | | currentReceiverClass currentMethodRef | 								
			currentReceiverClass := aReceiverType liveClass.
			currentMethodRef := (MethodReference class: currentReceiverClass selector: sentSelector).
			(aStorage genericTypeConstructorFrom: currentMethodRef) 
				ifNil: [
					(currentReceiverClass lookupSelector: sentSelector) 
						ifNil: [ incompleteTypeInfoReasons add: (
							IncompleteTypeInfoError dueToMissingImplementationOf: currentMethodRef) ]
						ifNotNil: [ :implementor |
							self returnTypesOf: implementor 
								from: aReceiverType 
								receiving: sentSelector 
								in: aCompiledMethod
								addingReturnTypesTo: messageReturnTypes 
								addingIncompleteTypeInfoTo: incompleteTypeInfoReasons 
								storingGenericsInfoIn: aStorage
							].
				] 
				ifNotNil: [:aGenericTypeConstructor | 
					messageReturnTypes add: (aGenericTypeConstructor in: aCompiledMethod forArguments: self argumentsInEvaluationOrder storingGenericsInfoIn: aStorage).
				].
			
			].
		
	^RawToLiveTypesAdapter new adapt: messageReturnTypes.! !

self array!

self array fourth!

self array fourth!

self array fourth isEmpty !

self isEmptyType!

self isEmpty!

self returnTypes!

self array!

self array fourth!

self array fourth!

self array fourth isEmptyType!

self isEmpty!

s := Set new.!

s!

s add: 5; add: 8.!

s!

s anySatisfy: [:item | item class = SmallInteger]!

s allSatisfy: [:item | item class = SmallInteger]!

s isEmpty or: [s allSatisfy: [:item | item class = SmallInteger]]!

s := Set new.!

s isEmpty or: [s allSatisfy: [:item | item class = SmallInteger]]!

s add: 5; add: '8'.!

s isEmpty or: [s allSatisfy: [:item | item class = SmallInteger]]!

returnTypes!

self isEmpty or: [self allSatisfy:[:item | item isEmptyType]]!
!MessageNode methodsFor: '*LiveTypingGenerics-livetypes' stamp: 'JFGO 12/12/2023 19:08:14' prior: 50666050!
returnTypesOf: implementor from: aReceiverType receiving: sentSelector in: aCompiledMethod addingReturnTypesTo: messageReturnTypes addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage

	| returnTypes |

	"generic getter case"
	((aReceiverType isGenericType) and: [aStorage getterMethodsFor: aReceiverType includes: sentSelector]) ifTrue: [
		| parameterIndex |
		parameterIndex := (aStorage getterMethodsFor: aReceiverType) at: sentSelector.
		messageReturnTypes addAll: (aReceiverType generics at: parameterIndex).
		^self.
	].
	
	"generic setter case"
	(((aStorage tracedMethodsFor: aReceiverType liveClass) includesKey: sentSelector)
		or: [(aStorage tracedMethodsFromParametersFor: aReceiverType liveClass) includesKey: sentSelector])
		ifTrue: [ | lastArgument argumentType |
		"setters need to receive the object from where the type will be set, then there's at least one argument - Adrian"
		lastArgument := self argumentsInEvaluationOrder last.
		argumentType := lastArgument 
						liveTypesIn: aCompiledMethod 
						addingIncompleteTypeInfoTo: incompleteTypeInfoReasons 
						storingGenericsInfoIn: aStorage.
						
		messageReturnTypes add: argumentType.
		^self.	
	].
	
	"general case"
	returnTypes := implementor returnLiveTypesForReceiver: aReceiverType liveClass usingStorage: aStorage.
	(returnTypes isEmpty or: [returnTypes allSatisfy:[:item | item isEmptyType]] isEmpty)
		ifTrue: [ incompleteTypeInfoReasons add: (IncompleteTypeInfoWarning dueToNoReturnTypeOf: implementor methodReference) ]
		ifFalse: [
			returnTypes := returnTypes collect: [ :aType | aType asTypeFor: aReceiverType liveClass].
			messageReturnTypes addAll: returnTypes.
		].! !

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/12/2023 19:08:26'!
ERROR!
!MessageNode methodsFor: '*LiveTypingGenerics-livetypes' stamp: 'JFGO 12/12/2023 19:08:38' prior: 50672628!
returnTypesOf: implementor from: aReceiverType receiving: sentSelector in: aCompiledMethod addingReturnTypesTo: messageReturnTypes addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: aStorage

	| returnTypes |

	"generic getter case"
	((aReceiverType isGenericType) and: [aStorage getterMethodsFor: aReceiverType includes: sentSelector]) ifTrue: [
		| parameterIndex |
		parameterIndex := (aStorage getterMethodsFor: aReceiverType) at: sentSelector.
		messageReturnTypes addAll: (aReceiverType generics at: parameterIndex).
		^self.
	].
	
	"generic setter case"
	(((aStorage tracedMethodsFor: aReceiverType liveClass) includesKey: sentSelector)
		or: [(aStorage tracedMethodsFromParametersFor: aReceiverType liveClass) includesKey: sentSelector])
		ifTrue: [ | lastArgument argumentType |
		"setters need to receive the object from where the type will be set, then there's at least one argument - Adrian"
		lastArgument := self argumentsInEvaluationOrder last.
		argumentType := lastArgument 
						liveTypesIn: aCompiledMethod 
						addingIncompleteTypeInfoTo: incompleteTypeInfoReasons 
						storingGenericsInfoIn: aStorage.
						
		messageReturnTypes add: argumentType.
		^self.	
	].
	
	"general case"
	returnTypes := implementor returnLiveTypesForReceiver: aReceiverType liveClass usingStorage: aStorage.
	(returnTypes isEmpty or: [returnTypes allSatisfy:[:item | item isEmptyType]])
		ifTrue: [ incompleteTypeInfoReasons add: (IncompleteTypeInfoWarning dueToNoReturnTypeOf: implementor methodReference) ]
		ifFalse: [
			returnTypes := returnTypes collect: [ :aType | aType asTypeFor: aReceiverType liveClass].
			messageReturnTypes addAll: returnTypes.
		].! !

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/12/2023 19:09:19'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/12/2023 19:09:27'!
PASSED!
!TypeCheckerDragonTest methodsFor: 'tests for methods without branches' stamp: 'JFGO 12/12/2023 19:23:50'!
test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts

	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #methodTypedCorrectlyEnableTyping.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
! !
!TypeCheckerDragonTestMethods methodsFor: 'collections generics' stamp: 'JFGO 12/12/2023 19:24:24' prior: 50660346!
methodWithCollectionWithNoTypeError
	| col |
	col:= OrderedCollection with: 1.
	col do:[:item | item factorial].! !

----SNAPSHOT----(12 December 2023 19:24:28) CuisUniversity-5981.image priorSource: 10906819!
!TypeCheckerDragonTest methodsFor: 'tests for generics collections' stamp: 'JFGO 12/12/2023 19:24:38' prior: 50672754!
test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts

	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #methodWithCollectionWithNoTypeError.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
! !
!TypeCheckerDragonTest methodsFor: 'tests for generics collections' stamp: 'JFGO 12/12/2023 19:26:11' prior: 50672778!
test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts
	"El valor agregado de este test es discutible. Como minimo busca asegurarse que el paquete de LiveTypingGenerics esta correctamente instalado y sin problemas de compatibilidad con typeChecker."
	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #methodWithCollectionWithNoTypeError.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	self deny: typeChecker hasAlerts.
! !

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:26:16'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:26:16'!
FAILURE!

self alerts!

self alerts first!

self alerts first message !

self alerts second message!

aMessageNode receiver!
!TypeCheckerDragonTestMethods methodsFor: 'collections generics' stamp: 'JFGO 12/12/2023 19:31:23' prior: 50660338!
methodWithCollectionWithErrorTypeOnIteration
	"| col |"
	"col:= OrderedCollection with: 1 with: 'string'.
	col do:[:item | item factorial]."! !

!classDefinition: #TypeCheckerDragonTestMethods category: 'LiveTypingTypeChecker-TypeCheckingDragon-Tests' stamp: 'JFGO 12/12/2023 19:31:53'!
Object subclass: #TypeCheckerDragonTestMethods
	instanceVariableNames: 'nilVariableWithNoType aCol'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-TypeCheckingDragon-Tests'!
!TypeCheckerDragonTestMethods methodsFor: 'collections generics' stamp: 'JFGO 12/12/2023 19:31:52' prior: 50672823!
methodWithCollectionWithErrorTypeOnIteration
	"| col |"
	aCol:= OrderedCollection with: 1 with: 'string'.
	aCol do:[:item | item factorial].! !
!TypeCheckerDragonTestMethods methodsFor: 'collections generics' stamp: 'JFGO 12/12/2023 19:32:34' prior: 50672767!
methodWithCollectionWithNoTypeError
	"| col |"
	aCol:= OrderedCollection with: 1.
	aCol do:[:item | item factorial].! !

aMessageNode receiver!

self class!

self receiverOrCascadeReceiver!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:36:04'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/12/2023 19:36:04'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:36:04'!
FAILURE!
!ParseNode methodsFor: '*LiveTypingGenerics' stamp: 'AC 4/10/2023 23:23:16' prior: 50667999!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons

	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: (LiveTyping getGenericsStorage).! !
!ParseNode methodsFor: '*LiveTypingGenerics' stamp: 'JFGO 12/8/2023 21:15:35' prior: 50672916!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons

	^self liveTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons storingGenericsInfoIn: (LiveTyping getGenericsStorage).! !

self methodClass !

self instanceVariablesTypes!

TypeCheckerDragonTestMethods new methodWithCollectionWithNoTypeError !

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:44:05'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:44:05'!
FAILURE!

aMessageNode selectorSymbol!

!classDefinition: #TypeCheckerDragonTestMethods category: 'LiveTypingTypeChecker-TypeCheckingDragon-Tests' stamp: 'JFGO 12/12/2023 19:47:38'!
Object subclass: #TypeCheckerDragonTestMethods
	instanceVariableNames: 'nilVariableWithNoType aCol anotherCol'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-TypeCheckingDragon-Tests'!
!TypeCheckerDragonTestMethods methodsFor: 'collections generics' stamp: 'JFGO 12/12/2023 19:47:35' prior: 50672852!
methodWithCollectionWithNoTypeError
	"| col |"
	anotherCol:= OrderedCollection with: 1.
	anotherCol do:[:item | item factorial].! !

TypeCheckerDragonTestMethods new methodWithCollectionWithNoTypeError!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:48:00'!
FAILURE!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/12/2023 19:48:00'!
FAILURE!

self class!

self receiverOrCascadeReceiver!

self typesOfVariableNamed: aVarName !

self typesOfVariableNamed: aVarName !

----QUIT----(12 December 2023 19:56:49) CuisUniversity-5981.image priorSource: 10915923!

----STARTUP---- (13 December 2023 18:43:31) as C:\Users\jgutierrez\Tesis\CUIS\windows64\CuisUniversity-5981.image!

!TypeCheckerDragonTest methodsFor: 'tests for generics collections' stamp: 'JFGO 12/13/2023 18:43:58' prior: 50672791!
test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts
	"El valor agregado de este test es discutible. Como minimo busca asegurarse que el paquete de LiveTypingGenerics esta correctamente instalado y sin problemas de compatibilidad con typeChecker."
	| methodToCheck typeChecker |
	
	methodToCheck := TypeCheckerDragonTestMethods >> #methodWithCollectionWithNoTypeError.
	
	typeChecker := methodToCheck typeCheckDragon.
	
	"self deny: typeChecker hasAlerts."
	self assert: true.
! !

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/13/2023 18:44:01'!
PASSED!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
Morphic view for MessageSet models. See category 'GUI building'.!

----QUIT----(13 December 2023 19:13:35) CuisUniversity-5981.image priorSource: 10922698!

----STARTUP---- (13 December 2023 19:13:42) as C:\Users\jgutierrez\Tesis\CUIS\windows64\CuisUniversity-5981.image!


!testRun: #TypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesAlert stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesAlert stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesAlert stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test11MethodWithCollectionItemsTypedCorrectlyDoesNotGenerateAlerts stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

!testRun: #TypeCheckerDragonTest #test12MethodWithCollectionIteratingGeneratesAlertForItemsWithErrorTypes stamp: 'JFGO 12/13/2023 19:13:55'!
PASSED!

----SNAPSHOT----(13 December 2023 19:13:59) CuisUniversity-5981.image priorSource: 10922698!