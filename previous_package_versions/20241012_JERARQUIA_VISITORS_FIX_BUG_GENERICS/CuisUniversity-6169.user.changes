

----STARTUP---- (8 October 2024 19:24:23) as C:\Users\juli_\Tesis\TO_UPLOAD\windows64\CuisUniversity-6169.image!


----End fileIn of C:\Users\juli_\Tesis\TO_UPLOAD\windows64\LiveTypingGenerics.pck.st----!

----End fileIn of C:\Users\juli_\Tesis\TO_UPLOAD\windows64\LiveTypingTypeChecker.pck.st----!

!classRemoval: #TypeCheckerTestMethods stamp: 'JFGO 10/10/2024 18:32:09'!
Object subclass: #TypeCheckerTestMethods
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking-Tests'!

!classRemoval: #MethodTypeCheckerTest stamp: 'JFGO 10/10/2024 18:32:10'!
TestCase subclass: #MethodTypeCheckerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking-Tests'!

!classRemoval: #ManyMethodsTypeCheckerTest stamp: 'JFGO 10/10/2024 18:32:10'!
TestCase subclass: #ManyMethodsTypeCheckerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking-Tests'!

!classRemoval: #TypeCheckingWarning stamp: 'JFGO 10/10/2024 18:32:11'!
TypeCheckingIssue subclass: #TypeCheckingWarning
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingProblem stamp: 'JFGO 10/10/2024 18:32:11'!
TypeCheckingIssue subclass: #TypeCheckingProblem
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingIssue stamp: 'JFGO 10/10/2024 18:32:11'!
TypeCheckingResult subclass: #TypeCheckingIssue
	instanceVariableNames: 'method messageNode reason methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingError stamp: 'JFGO 10/10/2024 18:32:11'!
TypeCheckingResult subclass: #TypeCheckingError
	instanceVariableNames: 'method messageNode notImplemented methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #MethodNotAnnotatingTypesProblem stamp: 'JFGO 10/10/2024 18:32:12'!
TypeCheckingResult subclass: #MethodNotAnnotatingTypesProblem
	instanceVariableNames: 'method'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingResult stamp: 'JFGO 10/10/2024 18:32:12'!
Object subclass: #TypeCheckingResult
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingProblemToMethodReferenceAdapter stamp: 'JFGO 10/10/2024 18:32:12'!
Object subclass: #TypeCheckingProblemToMethodReferenceAdapter
	instanceVariableNames: 'typeCheckingProblem prefix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #MethodTypeChecker stamp: 'JFGO 10/10/2024 18:32:12'!
TypeChecker subclass: #MethodTypeChecker
	instanceVariableNames: 'method errors warnings problems'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #ManyMethodsTypeChecker stamp: 'JFGO 10/10/2024 18:32:12'!
TypeChecker subclass: #ManyMethodsTypeChecker
	instanceVariableNames: 'methodsToCheck typeCheckers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeChecker stamp: 'JFGO 10/10/2024 18:32:13'!
Object subclass: #TypeChecker
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #NoTypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:13'!
TypeCastApplierBuilder subclass: #NoTypeCastApplierBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #IsKindOfTypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:13'!
OneTypeCastApplierBuilder subclass: #IsKindOfTypeCastApplierBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #EqualsTypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:13'!
OneTypeCastApplierBuilder subclass: #EqualsTypeCastApplierBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #OneTypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:13'!
EffectiveTypeCastApplierBuilder subclass: #OneTypeCastApplierBuilder
	instanceVariableNames: 'castType'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #IsKindOfManyTypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:14'!
EffectiveTypeCastApplierBuilder subclass: #IsKindOfManyTypeCastApplierBuilder
	instanceVariableNames: 'typesToCastTo typesToReject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #EffectiveTypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:14'!
TypeCastApplierBuilder subclass: #EffectiveTypeCastApplierBuilder
	instanceVariableNames: 'castingBlock rejectingBlock objectToCast afterMessageTypeCasts'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCastApplierBuilder stamp: 'JFGO 10/10/2024 18:32:14'!
Object subclass: #TypeCastApplierBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #NoTypeCastApplier stamp: 'JFGO 10/10/2024 18:32:14'!
TypeCastApplier subclass: #NoTypeCastApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #EffectiveTypeCastApplier stamp: 'JFGO 10/10/2024 18:32:14'!
TypeCastApplier subclass: #EffectiveTypeCastApplier
	instanceVariableNames: 'previous casts rejections'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCastApplier stamp: 'JFGO 10/10/2024 18:32:15'!
Object subclass: #TypeCastApplier
	instanceVariableNames: 'receiverTypes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #IsKindOfTypeReject stamp: 'JFGO 10/10/2024 18:32:15'!
OneTypeCast subclass: #IsKindOfTypeReject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #IsKindOfTypeCast stamp: 'JFGO 10/10/2024 18:32:15'!
OneTypeCast subclass: #IsKindOfTypeCast
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #EqualTypeReject stamp: 'JFGO 10/10/2024 18:32:15'!
OneTypeCast subclass: #EqualTypeReject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #EqualTypeCast stamp: 'JFGO 10/10/2024 18:32:15'!
OneTypeCast subclass: #EqualTypeCast
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #OneTypeCast stamp: 'JFGO 10/10/2024 18:32:15'!
TypeCast subclass: #OneTypeCast
	instanceVariableNames: 'typeToCastTo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #ManyTypesCast stamp: 'JFGO 10/10/2024 18:32:16'!
TypeCast subclass: #ManyTypesCast
	instanceVariableNames: 'typesToCastTo typesToReject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCast stamp: 'JFGO 10/10/2024 18:32:16'!
Object subclass: #TypeCast
	instanceVariableNames: 'objetToCast'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingResultWindow stamp: 'JFGO 10/10/2024 18:32:16'!
MessageSetWindow subclass: #TypeCheckingResultWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #MethodTypeCheckerVisitor stamp: 'JFGO 10/10/2024 18:32:16'!
ParseNodeVisitor subclass: #MethodTypeCheckerVisitor
	instanceVariableNames: 'errors warnings methodNode actualMethod problems methodReference blockCastingApplier castingApplierBuilder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!classRemoval: #TypeCheckingResultSet stamp: 'JFGO 10/10/2024 18:32:16'!
MessageSet subclass: #TypeCheckingResultSet
	instanceVariableNames: 'methodTypeChecker showProblems'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping-TypeChecking'!

!methodRemoval: ParseNode #typesIn:addingIncompleteTypeInfoTo:castingWith: stamp: 'JFGO 10/10/2024 18:32:57'!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 

	^aTypeCastApplier applyTo: self with: (self typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons)!

!methodRemoval: AssignmentNode #typesIn:addingIncompleteTypeInfoTo:castingWith: stamp: 'JFGO 10/10/2024 18:33:05'!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 

	^value typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
!

!methodRemoval: MessageNode #receiverTypesIn:addingIncompleteTypeInfoTo:castingWith: stamp: 'JFGO 10/10/2024 18:34:32'!
receiverTypesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
	
	^self receiverOrCascadeReceiver typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier !

!methodRemoval: MessageNode #typesIn:addingIncompleteTypeInfoTo:castingWith: stamp: 'JFGO 10/10/2024 18:34:35'!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons castingWith: aTypeCastApplier 
	
	| types sentSelector receiverTypes  |

	sentSelector := self selectorSymbol.
	receiverTypes := aTypeCastApplier receiverTypesFor: self in: aCompiledMethod addingIncompleteTypeInfoTo:  incompleteTypeInfoReasons.
	
	types := receiverTypes
		inject: Set new
		into: [ :messageReturnTypes :aReceiverType | 								
			(aReceiverType lookupSelector: sentSelector) 
				ifNil: [ incompleteTypeInfoReasons add: (
					IncompleteTypeInfoError dueToMissingImplementationOf: (MethodReference class: aReceiverType selector: sentSelector)) ]
				ifNotNil: [ :implementor | | returnTypes |
					returnTypes := implementor returnTypes.
					returnTypes isEmpty
						ifTrue: [ incompleteTypeInfoReasons add: (IncompleteTypeInfoWarning dueToNoReturnTypeOf: implementor methodReference) ]
						ifFalse: [ messageReturnTypes addAll: (returnTypes collect: [ :aType | aType asTypeFor: aReceiverType])]].
			messageReturnTypes ].
		
	^types!

!testRun: #ActualImplementorsTest #test01WhenIsImplementedOnlyInRootReturnsThatImplementorOnly stamp: 'JFGO 10/10/2024 18:34:42'!
PASSED!

!testRun: #ActualImplementorsTest #test02ReturnsImplementorsOfSuperclasses stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test03IfNotImplementedInRootOrSuperclassesDoesNotIncludeSubclassesImplementations stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test04IncludesSubclassesImplementations stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test05DoesNotIncludeImplementorsOfSubclassesNotDefinedInSuperclass stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test06DoesNotIncludeImplementorsOfSiblingsWhenNotDefinedInSuperclass stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test07ReturnsAllSubclassesImplementorsOfTheHighestImplementorClass stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test08highestClassImplementingSelectorReturnsHighgestClass stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualImplementorsTest #test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test01SurelyRecognizeTypeSenderWhenSentToInstanceVariable stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test02SurelyRecognizeTypeSenderWhenSentToTemporaryVariable stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test03SurelyRecognizeTypeSenderInACollaboration stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test04RecognizeTypeSendersToInstancesOfSubClasses stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test05RecognizeTypeSendersToLiteralTrue stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test06RecognizeTypeSendersToLiteralFalse stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test07RecognizeTypeSendersToThisContext stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test08RecognizeTypeSendersToSelf stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test09RecognizeTypeSendersToSuper stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test09_01 stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test10RecognizeTypeSendersToSelfOfMessageImplementedInSuperclass stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test11RecognizeTypeSendersToReturnsOfMessageSend stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test12RecognizeTypeSendersOfChainedMessageSends stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test13RecognizeTypeSendersToReturnOfMessageSendNoMatterThePrecedence stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test14RecognizeTypeSendersToClasses stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test15RecognizeTypeSendersToVariablesReferencingClasses stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test16RecognizeTypeSendersToAnyLiteral stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test17CanRecognizePossibleTypeSenders stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test18RecognizeTypeSendersWhenReturnTypeIsSelfType stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test19RecognizeTypeSendersWhenReturnTypeIsClassType stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test20SurelySendWhenReceiverTypeIsSuperclassOfImplementorType stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test21ActualSendersWorksWithCascadeMessageSends stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!testRun: #ActualSendersTest #test22ActualSendersDoesNotHangWhenReceiverIsTempVarInMethodWithoutTypes stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:43'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:43'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:43'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:43'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:43' prior: 50542234!
m3 | x | self m1: 1. false ifTrue: [ x m1 ]! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:43'!
m1!

!testRun: #AddParameterWithActualScopeTest #test01DoesNotChangePossibleMessageSendWhenInstructedToDoSo stamp: 'JFGO 10/10/2024 18:34:43'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:44'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:44'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:44'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:44'!
m3 | x | self m1: 1 m3: 3. false ifTrue: [ x m1: 1 m3: 3 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:44'!
m1: p1 m2: p2 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:44' prior: 50542275!
m3 | x | self m1: 1 m2: 2 m3: 3. false ifTrue: [ x m1: 1 m3: 3 ]! !

!methodRemoval: ClassToAddParameter #m1:m3: stamp: 'JFGO 10/10/2024 18:34:44'!
m1: p1 m3: p3!

!testRun: #AddParameterWithActualScopeTest #test01_01_DoesNotChangePossibleMessageSendWhenInstructedToDoSoWithKeywordMessages stamp: 'JFGO 10/10/2024 18:34:44'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:45'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:45'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:45'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:45'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:45'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:45'!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!testRun: #AddParameterWithActualScopeTest #test02CanNotAddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'JFGO 10/10/2024 18:34:45'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:46'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:46'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:46'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:46'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:46'!
m1: p1 m3: p3! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:46'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:46'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1 m3: 3! !

!testRun: #AddParameterWithActualScopeTest #test02_01_CanNotAddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsForKeywordMessage stamp: 'JFGO 10/10/2024 18:34:46'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:47'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:48'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:48'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:48'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:48'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:48'!
m3 | x | x := ClassOfSender new. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:48'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:48' prior: 50542425!
m3 | x | x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:48'!
m1!

!testRun: #AddParameterWithActualScopeTest #test03AddParameterWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'JFGO 10/10/2024 18:34:48'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:49'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:49'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:49'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:49'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:49'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:49'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:49'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:49'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:49'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:49' prior: 50542484!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:49'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:34:49'!
m1!

!testRun: #AddParameterWithActualScopeTest #test04AddParameterWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'JFGO 10/10/2024 18:34:49'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:50'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:50'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:50'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:50'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:50'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:50'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:50'!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:50'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:50'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:50' prior: 50542549!
m3 | x y | x := self. y := ClassOfSender new. x m1: 1. y m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:50'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:34:50'!
m1!

!testRun: #AddParameterWithActualScopeTest #test05AddParameterInDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'JFGO 10/10/2024 18:34:50'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:50'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:51'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:51'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:51'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51' prior: 50542614!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1: 1. y m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:51'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:34:51'!
m1!

!testRun: #AddParameterWithActualScopeTest #test06AddParameterInDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'JFGO 10/10/2024 18:34:51'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:51'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:51'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:51'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:51' prior: 50542668!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1 ]! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:51'!
m1!

!testRun: #AddParameterWithActualScopeTest #test07AddParameterToPossibleMessageSendIfInstructedToDoSo stamp: 'JFGO 10/10/2024 18:34:51'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52' prior: 50542716!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:34:52'!
m1!

!testRun: #AddParameterWithActualScopeTest #test08AddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'JFGO 10/10/2024 18:34:52'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:52'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m3 self m1. ClassOfSender new m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:52' prior: 50542776!
m3 self m1: 1. ClassOfSender new m1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:52'!
m1!

!testRun: #AddParameterWithActualScopeTest #test09AddParameterOnlyToValidMessageSendWhenMoreSendsInSameMethod stamp: 'JFGO 10/10/2024 18:34:52'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:53'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:53'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:53'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53'!
m3 |x| self m1. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53' prior: 50542822!
m3 |x| self m1: 1. x m1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/10/2024 18:34:53'!
m1!

!testRun: #AddParameterWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenAddingParameterToMethodWithSureAndPossibleSenders stamp: 'JFGO 10/10/2024 18:34:53'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:53'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:53'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:53'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:53'!
m3 | x | x := self. x := ClassOfSender new. x m1; printString! !

!testRun: #AddParameterWithActualScopeTest #test11CanNotAddParameterWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'JFGO 10/10/2024 18:34:53'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:54'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:54'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'JFGO 10/10/2024 18:34:54'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:54'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:34:54'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:54'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:54'!
m3 self m1: 1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:54'!
m1: p1 m2: p2 ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:34:54' prior: 50542924!
m3 self m1: 1 m2: 2! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'JFGO 10/10/2024 18:34:54'!
m1: p1!

!testRun: #AddParameterWithActualScopeTest #test13AddLastParameterCorrectly stamp: 'JFGO 10/10/2024 18:34:54'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:34:55'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/10/2024 18:34:55'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AdditionalMethodStateTest #test01topBlockTempsMapReturnsTheTempsMapOfTheMethod stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test02MethodWithNoParametersNoTemporariesAreInitializedCorrectly stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test03MethodWithOnlyOneArgumentAreInitializedCorrectly stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test04rawTypesOfInvalidVariableNameEvaluatesIfAbsentBlock stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test05MethodWithOnlyOneTempTwoArgumentsAreInitializedCorrectly stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test06MethodWithRemoveVectorVariablesAreInitializedCorrectly stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test07RemoteVectorRawTypesIsNilWhenMethodHasNoVariableInRemoteVector stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test08VariableRawTypesIsNilWhenMethodHasNoVariableButHasInRemoteVector stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #AdditionalMethodStateTest #test09CanGetRawTypesWhenMethodHasNoVariableButHasInRemoteVector stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #ClosureVariablesTest #testOneArrayForTypesIsCreatedWhenAMethodHasNoClosures stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test01TypeConvertionForAClassReturnsSameClass stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test02TypeConvertionForSelfTypeReturnsReceiversType stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test03TypeConvertionForClassTypeReturnsReceiversTypeClass stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test04ClassMessageSendChainsClassType stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test05TypeConvertionForInstanceTypeReturnsMetaclassSoleInstance stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test06newTypeIsMetaclassSoleInstance stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test07InstanceTypeReturnsClassWhenIsKindOfOfBehaviorButNotMeta stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test08InstanceTypeErrorsWhenUsedWithNoBehavior stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #DynamicTypesTest #test09ClassTypeForMetamodelIsMetaclass stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test01TypeCollectionOfInstanceVariableDefinedInLeafClassDoesNotTraverseHierarchy stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test02TypeCollectionIncludesSubclasses stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test03TypeCollectionDoesNotIncludeSuperclassesAndSiblings stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test05TypeCollectionIncludesAllSubclasses stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test06IsNotMegamorphicIfTypesSizeIsLessToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test07IsMegamorphicIfTypesSizeIsEqualToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test08IsNotMegamorphicIfDoesNotFillRawTypesForLocalTypeInfo stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test09IsMegamorphicIfFillsRawTypesOfDefiningClassForLocalTypeInfo stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test10IsMegamorphicIfFillsRawTypesOfNotDefiningClassForLocalTypeInfo stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test11IsTypesEmptyOfNonLocalTypeInfoTakesCareOfHierarchy stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test12IsTypesEmptyForLocalTypeInfoOnlyCheckOnLocalRawTypes stamp: 'JFGO 10/10/2024 18:34:55'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/10/2024 18:34:55'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/10/2024 18:34:55'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #InstanceVariableTypeInfoTest #test13RemovingAClassRemovesItAndItsClassFromInstanceVariableRawTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test14InstVarAtPutKeepTypeInfo stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test01InstanceVariablesTypesIsInitializedWithAnArrayOfClassInstSize stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test02InitializeInstanceVariablesTypesWithAllInstancesStoreCurrentClassInstancesTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test03TypesOfDifferentInstVarsAreStoredCorrectly stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test04MoreThanOneTypeAreStoredCorrectlyInDifferentInstVars stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test05TypesAreStoredUpToInstVarTypesSize stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test06NoTypesAreStoredWhenInstVarTypesIsNil stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test07CommonSupertypeOfReturnsSupertypeOfStoredTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test08CommonSupertypeIfNoTypesEvaluatesAlternativeBlockWhenNoTypeHasBeenStore stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test09EvaluatesIfAbsentBlockWhenAskTypeInfoForNonExistingInstVar stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test01KeepTypesOfLocalTemporariesI stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test02KeepTypesOfRemoteTemporaries stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test03KeepTypesOfParameters stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test04KeepReturnTopTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test05KeepReturnConstantTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test06KeepReturnReceiverTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test07KeepReturnFromClosureTypes stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test08KeepReturnTypeWhenUnwind stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test09BlockReturnDoesNotAffectMethodReturn stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test10KeepTypesOfParametersWhenSendingValueWithArguments stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test11BlockWithParametersDoNotAffectMethodParameters stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test000_AutocompletesMessagesFor_GlobalVariables_WithSelectorsFromTheirClasses stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test001_AutocompletesMessagesFor_Self_WithSelectorsFromTheBrowsedClass stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test002_AutocompletesMessagesFor_Super_WithSelectorsFromTheBrowsedClass stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test003_AutocompletesMessagesFor_Super_WithSelectorsForUnknownClassesWhenTheBrowsedClassDoesNotHaveASuperclass stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test004_AutocompletesMessagesFor_True_WithSelectorsFromTrue stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test005_AutocompletesMessagesFor_False_WithSelectorsFromFalse stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test006_AutocompletesMessagesFor_Nil_WithSelectorsFromUndefinedObject stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test007_AutocompletesMessagesFor_Characters_WithSelectorsFromCharacter stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test008_AutocompletesMessagesFor_Numbers_WithSelectorsFromTheirClass stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test009_AutocompletesMessagesFor_Strings_WithSelectorsFromString stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test010_AutocompletesMessagesFor_Symbols_WithSelectorsFromSymbol stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test011_AutocompletesMessagesFor_StringSymbol_WithSelectorsFromSymbol stamp: 'JFGO 10/10/2024 18:34:56'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test012_AutocompletesMessagesFor_InstanceVariables stamp: 'JFGO 10/10/2024 18:34:57'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test012_AutocompletesMessagesFor_InstanceVariables_WithSelectorsOfInstVarTypes stamp: 'JFGO 10/10/2024 18:34:57'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test013_AutocompletesMessagesFor_MethodArguments_WithSelectorsForUnknownClasses stamp: 'JFGO 10/10/2024 18:34:57'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test014_AutocompletesMessagesFor_TemporaryVariables_WithSelectorsForUnknownClasses stamp: 'JFGO 10/10/2024 18:34:57'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test014_AutocompletesMessagesFor_TemporaryVariables_WithSelectorsOfTempVarTypes stamp: 'JFGO 10/10/2024 18:34:58'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test015_AutocompletesMessagesFor_BlockArguments_WithSelectorsForUnknownClasses stamp: 'JFGO 10/10/2024 18:34:58'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test016_AutocompletesMessagesFor_BlockTemporaryVariables_WithSelectorsForUnknownClasses stamp: 'JFGO 10/10/2024 18:34:58'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test017_AutocompletesMessagesFor_NilWorkspaceVariables_WithSelectorsForUnknownClasses stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test017_AutocompletesMessagesFor_NonNilWorkspaceVariables_WithSelectorsFromTheirClasses stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test018_AutocompletesMessagesFor_ThisContext_WithSelectorsFromMethodContext stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test019_AutocompletesMessagesFor_ClassVariables_WithSelectorsFromTheirClasses stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test020_AutocompletesMessagesFor_PoolConstants_WithSelectorsFromTheirClasses stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test021_AutocompletesMessagesFor_BlockEndings_WithSelectorsFromBlockClosure stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test022_AutocompletesMessagesFor_ArrayEnds_WithSelectorsFromArray stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test023_AutocompletesMessagesFor_RightBraces_WithSelectorsFromArray stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test023_AutocompletingMessagesFor_UnaryMessages stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test024_AutocompletingMessagesFor_RightParenthesis stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test025_AutocompletesMessagesFor_UnknownIdentifiers_WithSelectorsForUnknownClasses stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test026_AutocompletingMessagesFor_Cascade stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test027_AutocompletesEntriesFor_GlobalVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test028_AutocompletesEntriesFor_PoolConstants_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test029_AutocompletesEntriesFor_WorkspaceVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:34:59'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test030_AutocompletesEntriesFor_ClassVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test031_AutocompletesEntriesFor_InstanceVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test032_AutocompletesEntriesFor_MethodArguments_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test033_AutocompletesEntriesFor_TemporaryVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test034_AutocompletesEntriesFor_BlockArguments_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test035_AutocompletesEntriesFor_BlockTemporaryVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test036_AutocompletesEntriesFor_IncompleteIdentifiers_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test037_AutocompletesEntriesFor_ReservedNames_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test038_DoesNotAutocompleteEntriesFor_UndefinedIdentifiers stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test039_AutocompletesEntriesFor_BinaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test040_AutocompletesEntriesFor_IncompleteBinaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test041_AutocompletesEntriesFor_UnaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test042_AutocompletesEntriesFor_IncompleteUnaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test043_AutocompletesEntriesFor_KeywordMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test044_AutocompletesEntriesFor_IncompleteKeywordMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test045_AutocompletesEntriesFor_patternUnary_containsExactlyTwoMethods stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test046_AutocompletesEntriesFor_patternUnary_notContainsAnyMethod stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test047_AutocompletesEntriesFor_patternUnary_doesNotAutocompleteMethodOfSameClass stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test048_AutocompletesEntriesFor_patternKeyword_containsExactlyOneMethod stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test049_AutocompletesEntriesFor_patternKeyword_notContainsAnyMethod stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test050_AutocompletesEntriesFor_patternKeyword_doesNotAutocompleteMethodOfSameClass stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test051_AutocompletesEntriesFor_patternBinary_containsExactlyOneMethod stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test052_AutocompletesEntriesFor_patternBinary_notContainsAnyMethod stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test053_AutocompletesEntriesFor_patternBinary_doestNotAutocompleteMethodOfSameClass stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #testMessages stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ArrayWithArrayAndOtherObjects stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArray stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArrayOfArray stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArrayWithManyElements stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBinaryInParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlock stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlockOfBlock stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlockOfEvaluatedBlock stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndExpresionInParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndLiteralArray stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndMoreThanOneUnaryAfterExpresionInParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterBlock stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterBrace stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterCharacter stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterLiteralArray stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterStringSymbol stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterSymbol stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUnaryInProtoObject stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteKeywordAfterParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteKeywordAfterUnary stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteMessageAfterUnary stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryInParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryWithMoreThanOneUnary stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryWithOneUnary stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ClosedAndUnclosedParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ExpressionInManyParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ExpressionWithMoreThanOneParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_LFBeforeParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_SpaceBeforeParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnaryAfterExpresionInParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedArrayAfterClosedArray stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedBlockAfterBlock stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedDoubleParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_selfInProtoObject stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_ExpresionInParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_MoreThanOneUnaryMessage stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_OnlyRightParenthesis stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #MethodNotAnnotatingTypesTest #test01CanSignalItWithAMethod stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!testRun: #MethodNotAnnotatingTypesTest #test02IsResumable stamp: 'JFGO 10/10/2024 18:35:00'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/10/2024 18:35:00'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/10/2024 18:35:01'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test01RemovingAClassRemovesItFromMethodVariableRawTypesForParameter stamp: 'JFGO 10/10/2024 18:35:01'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/10/2024 18:35:01'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/10/2024 18:35:01'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test02RemovingAClassRemovesItsClassFromMethodVariableRawTypesForParameter stamp: 'JFGO 10/10/2024 18:35:01'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/10/2024 18:35:01'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/10/2024 18:35:01'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test03RemovingAClassRemovesItFromMethodVariablesRawTypes stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/10/2024 18:35:02'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/10/2024 18:35:02'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test04RemovingAClassRemovesItFromMethodVariableRemoteVectorRawTypes stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test01ActualSendersIsEmpty stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test02CategoryIsNil stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test03CompiledMethodSignalsError stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test04CompiledMethodIfAbsentEvaluatesIfAbsentBlock stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test05doesOnlySurelySendReturnsFalse stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test06dynamicTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test07IsNotValid stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test08liveTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test09rangesOASentSelectorWhenSendToReceiverTypesIsEmpty stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test10FailsWhenAsItsSourceCode stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #NotImplementedMethodTest #test11StringVersionStartsWithNotImplemented stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!testRun: #PossibleSenderTest #test01StringVersionBeginsWithPossible stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02'!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1 ]! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02' prior: 50543792!
m3 | x | self m1. false ifTrue: [ x m1: 1 ]! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:02'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test01DoesNotChangePossibleMessageSendWhenInstructedToDoSo stamp: 'JFGO 10/10/2024 18:35:02'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:02'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:02'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!testRun: #RemoveParameterWithActualScopeTest #test02CanNotRemoveParameterWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'JFGO 10/10/2024 18:35:03'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:03'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:03'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:03'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:03'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:03'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:03'!
m3 | x | x := ClassOfSender new. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:03'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:03' prior: 50543892!
m3 | x | x := ClassOfSender new. x m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:03'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test03RemovesParameterWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'JFGO 10/10/2024 18:35:03'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:04'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04' prior: 50543953!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test04RemovesParameterWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'JFGO 10/10/2024 18:35:04'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:04'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m3 | x y | x := self. y := ClassOfSender new. x m1: 1. y m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:04' prior: 50544020!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/10/2024 18:35:04'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test05RemovesParameterInDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'JFGO 10/10/2024 18:35:04'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:05'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:05'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:05'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:05'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:05'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:05'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:05'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1: 1. y m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:05'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:05'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:05' prior: 50544087!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:05'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/10/2024 18:35:05'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test06RemovesParameterInDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'JFGO 10/10/2024 18:35:05'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:05'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:06'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06'!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1]! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06' prior: 50544144!
m3 | x | self m1. false ifTrue: [ x m1]! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:06'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test07RemovesParameterToPossibleMessageSendIfInstructedToDoSo stamp: 'JFGO 10/10/2024 18:35:06'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:06'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:06' prior: 50544194!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/10/2024 18:35:06'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test08RemovesParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'JFGO 10/10/2024 18:35:06'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:07'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:07'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:07'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m3 self m1: 1. ClassOfSender new m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07' prior: 50544256!
m3 self m1. ClassOfSender new m1: 1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:07'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test09RemovesParameterOnlyToValidMessageSendWhenMoreSendsInSameMethod stamp: 'JFGO 10/10/2024 18:35:07'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:07'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:07'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:07'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m3 |x| self m1: 1. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:07' prior: 50544305!
m3 |x| self m1. x m1: 1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/10/2024 18:35:07'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenRemovingParameterToMethodWithSureAndPossibleSenders stamp: 'JFGO 10/10/2024 18:35:07'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:08'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:08'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:08'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:08'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1; printString! !

!testRun: #RemoveParameterWithActualScopeTest #test11CanNotRemoveParameterWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'JFGO 10/10/2024 18:35:08'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:08'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveParameterWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'JFGO 10/10/2024 18:35:08'!
PASSED!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:09'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09'!
m1: p1 m2: p2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09'!
m3 self m1: 1 m2: 2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09'!
m2: p2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09' prior: 50544410!
m3 self m2: 2! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'JFGO 10/10/2024 18:35:09'!
m1: p1 m2: p2!

!testRun: #RemoveParameterWithActualScopeTest #test13RemovesOtherThanLastParameterCorrectly stamp: 'JFGO 10/10/2024 18:35:09'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:09'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/10/2024 18:35:09'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:09'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:09' prior: 50544457!
m3 | x | self m2. false ifTrue: [ x m1 ]! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:09'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test01DoesNotRenamesPossibleMessageSendWhenInstructedToDoSo stamp: 'JFGO 10/10/2024 18:35:09'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:10'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:10'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:10'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10'!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!testRun: #RenameSelectorWithActualScopeTest #test02CanNotRenameWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'JFGO 10/10/2024 18:35:10'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:10'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:10'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:10'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:10'!
ClassToRenameSelector subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10'!
m3 | x | x := ClassOfSender new. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:10' prior: 50544556!
m3 | x | x := ClassOfSender new. x m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:10'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test03RenamesWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'JFGO 10/10/2024 18:35:10'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:11'!
ClassToRenameSelector subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11' prior: 50544616!
m3 | x | x := self. x := ClassOfSender new. x m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:11'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:35:11'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test04RenamesWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'JFGO 10/10/2024 18:35:11'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:11'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:11' prior: 50544682!
m3 | x y | x := self. y := ClassOfSender new. x m2. y m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:11'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:35:11'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test05RenamesDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'JFGO 10/10/2024 18:35:11'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:12'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:12'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:12'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:12'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:12'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:12'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:12'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:12'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:12'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:12' prior: 50544748!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m2. y m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:12'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:35:12'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test06RenamesDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'JFGO 10/10/2024 18:35:12'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:12'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:13'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:13'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13' prior: 50544804!
m3 | x | self m2. false ifTrue: [ x m2 ]! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:13'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test07RenamePossibleMessageSendIfInstructedToDoSo stamp: 'JFGO 10/10/2024 18:35:13'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:13'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:13'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:13'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:13' prior: 50544853!
m3 | x | x := self. x := ClassOfSender new. x m2! !

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/10/2024 18:35:13'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test08RenamesWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'JFGO 10/10/2024 18:35:13'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:13'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:14'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:14'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:14'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m3 self m1. ClassOfSender new m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14' prior: 50544915!
m3 self m2. ClassOfSender new m1! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:14'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test09RenamesOnlyValidMessageSendWhenMoreSendsInSameMethod stamp: 'JFGO 10/10/2024 18:35:14'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:14'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:14'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:14'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m3 |x| self m1. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:14' prior: 50544962!
m3 |x| self m2. x m1! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/10/2024 18:35:14'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenRenamingAMethodWithSureAndPossibleSenders stamp: 'JFGO 10/10/2024 18:35:14'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:15'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:15'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/10/2024 18:35:15'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:15'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:15'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 18:35:15'!
m3 | x | x := self. x := ClassOfSender new. x m1; printString! !

!testRun: #RenameSelectorWithActualScopeTest #test11CanNotRenameWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/10/2024 18:35:15'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/10/2024 18:35:15'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameSelectorWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test01QuickReturnSelfMethodsReturnSelfTypeAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test02QuickReturnTrueMethodsReturnTrueReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test03QuickReturnFalseMethodsReturnFalseAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test04QuickReturnNilMethodsReturnUndefinedObjectAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test05QuickReturnMinusOneMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test06QuickReturnZeroMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test07QuickReturnOneMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test08QuickReturnTwoMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test09QuickReturnOfFirstInstanceVariableMethodsReturnInstanceVariableTypesAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test10QuickReturnOfSecondInstanceVariableMethodsReturnInstanceVariableTypesAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test11classMethodReturnsClassTypeAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test12newMethodReturnsInstanceTypeAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!testRun: #ReturnTypeInfoTest #test13yourselfMethodReturnsSelfTypeAsReturnType stamp: 'JFGO 10/10/2024 18:35:15'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/10/2024 18:35:15'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/10/2024 18:35:16'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #ReturnTypeInfoTest #test14RemovingAClassRemovesItAndItsClassFromMethodReturnType stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #ReturnTypeInfoTest #test15ReturnTypesOfAbstractMethodsIncludesSubclassesImplementationsTypes stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #ReturnTypeInfoTest #test16ReturnTypesOfAbstractMethodWorksWhenNotImplementedInAllSubclasses stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test01IsEmptyWhenAllTypesAreNil stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test02StoresAddedTypes stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test03StoresSameTypeOnce stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test04StoresMoreThanOneTypeCorrectly stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test05DoesNotStoreTypesWhenContainerIsNil stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test06CommonSupertypeOfSiblingsClassesReturnsRightSuperclass stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test07CommonSupertypeOnSameHierarchyIsMostTopClass stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test08CommonSupertypeOnSameHierarchyIsNotAffectedByAddingOrder stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test09ObjectIsCommonSupertypeWhenClassesAreNotSiblings stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test10ProtoObjectIsCommonSupertypeWhenThereAreNoTypesStored stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test11ProtoObjectIsCommonSupertypeWhenCointainerIsNil stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test12CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenIsEmpty stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test13CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenContainerIsNil stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test14UndefinedObjectIsNotConsideredWhenLookingForCommonSupertype stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test15StoresTypesIsTrueWhenContainerIsNotNil stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test16StoresTypesIsFalseWhenContainerIsNil stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test17IsMegamorphicWhenContainerIsFull stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test18IsNotMegamorphicWhenContainerIsNotFull stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test19CommonSelectorsPreviousToSameOnlyTypeIsEmpty stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test20CommonSelectorsPreviousToSuperclassOfOnlyAddedTypeAreAddedTypeSelectors stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test21CommonSelectorsPreviousToSuperclassSuperclassOfOnlyAddedTypeAreAddedTypeUpToSuperclassSelectors stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test22CommonSelectorsPreviousToInvalidSuperclassRaisesError stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test23CommonSelectorsPreviousToSuperclassOfSiblingTypesAreSiblingsCommonSelectors stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test24CommonSelectorsPreviousToOnSameHierarchyReturnsCommonSuperclassesSelectors stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test25CommonSelectorsPreviousToAddedSSupertypeOnSameHierarchyIsEmpty stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test26CommonSelectorsPreviousToWhenNotStoringTypesIsEmpty stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test27CommonSelectorsPreviousToIfInvalidSupertypeEvaluatesInvalidBlock stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test28CommonSelectorsPreviousToIfInvalidSupertypeWithManyTypesEvaluatesInvalidBlock stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test29CommonSelectosGoesUpToIncludingProtoObject stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test30CommonSupertypeIfGenericEvaluatesIfGenericBlockForObject stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test31CommonSupertypeIfGenericEvaluatesIfGenericBlockForProtoObject stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test32WithCommonSupertypeDoIfGenericEvaluatesDoBlockWhenNoGenericSupertype stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test33WithCommonSupertypeDoIfGenericEvaluatesGenericBlockWhenGenericSupertype stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test34AddingATypeWhenNoMoreSpaceEvaluatesIsFullBlock stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test35TypeIsNotMoreInTypesWhenRemoved stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test36RemovingTypeWhenTypesIsEmptyEvaluatesIfAbsent stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test37RemovingNotIncludedTypeEvaluatesIfAbsent stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test38RemovingLastAddedTypeWorksAsExpected stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test39RemoveTypeSignalExceptionWhenTypeNotFound stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #VariableTypeInfoTest #test40TypesDoEvaluatesBlockOnEachType stamp: 'JFGO 10/10/2024 18:35:16'!
PASSED!

!testRun: #FlowGraphCreationTest #test01onVarToVarAssigmentAssignorFlowsToAssignee stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test02ThereIsAlwaysANodeForReturnValue stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test03onAssigmentToAssigmentAllVarsAreLinked stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test04onVarReturnItFlowsToReturnNode stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test05CanTrackAMethodThroughMessageSends stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test06TrackedMethodIsLinkedToVarsOnAssigment stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test07CanTrackMultipleMethodThroughMessageSends stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test08TrackedMethodsAreLinkedToVarsOnAssigment stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test09InstVarsAreAlwaysAddedToGraph stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #FlowGraphCreationTest #test10WhenVarIsConnectedToReturnValueItsNeighborsAreAlsoConnected stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test01CanAddAGenericType stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test02GenericsDoesNotRepeat stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test03GenericsCannotBeAlteredFromOuterScope stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test04CanSaveASelectorForAGeneric stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test05TracedMethodsCanBeRecovered stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test06TracedMethodsCantBeModifiedExternally stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test07ATracedMethodCanBeDeleted stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test08AGenericCanBeDeleted stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test09CanSaveAGetterSelectorForAGeneric stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test10GetterSelectorsCantBeModifiedExternally stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test11CanStoreAndRetrieveTracedMethodRefs stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test12CanStoreAndRetrieveMultipleTracedMethodRefs stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test13AnalysisCanBeInitializedRecursively stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test14RecursiveAnalysisHasRecursiveTracedMethods stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test15GraphsAreDeletedWhenAllAnalysisFinish stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test16CanStoreGenericTypeConstructors stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test17SaveASelectorForAGenericWithMultipleParams stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #GAStorageTest #test18AGetterMethodCanBeDeleted stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test01GenericClassesAreReplacedByGenericTypeInstances stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test02GenericClassesAreMergedWithTheirGenericTypes stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test03LiteralCollectionOneLiteralElement stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test04LiteralCollectionLiteralElementsOfDifferentType stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test05LiteralCollectionElementsFromVariable stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test06LiteralCollectionElementsFromMethodCall stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test07LiteralCollectionElementsFromMethodCallWithArgumentsTypesFromContext stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test08LiteralCollectionElementsFromRecursiveMethod stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test09LiteralCollectionFlowingInMultipleVariables stamp: 'JFGO 10/10/2024 18:36:20'!
PASSED!

!testRun: #InferenceTest #test10LiteralCollectionFlowingInMultipleVariablesArgumentInMethod stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test11LiteralCollectionFlowingInMultipleVariablesEachReceivingMessages stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test12LiteralCollectionFlowingInMultipleVariablesEachReceivingMessagesBeforeAndAfterAssigment stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test13LiteralCollectionFlowingInMultipleVariablesArgumentInMultipleMethod stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test14LiteralCollectionFlowingInMultipleVariablesMultipleArgumentsInMethod stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test15LiteralCollectionFlowingToNonSelfMethod stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test16LiteralCollectionFlowingToSuperMethod stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test17GenericTypeReturningParameterFromGetter stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test18MethodReturningGenericType stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test19InstanceVariableUsedOnlyWithinCurrentClass stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test20InstanceVariableExposedByGetterAssignToVariable stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test21InstanceVariableExposedByMultipleGettersAssignToVariable stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test22InstanceVariableMessageSendsToGetters stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test23InstanceVariableGettersUsedAsArguments stamp: 'JFGO 10/10/2024 18:36:21'!
PASSED!

!testRun: #InferenceTest #test24InstanceVariableFlowingToOtherVariables stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test25CollectionContainingAnotherCollection stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test26CollectionContainingMultipleCollections stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test27CollectionAssignedFromMethodCallAndNotUsedAfter stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test28ReturnResultOfMethodCall stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test29MethodCallOnMultipleClassesWithSameProtocol stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test30MethodCallInsideGenericClasses stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test31CascadeMessageSends stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test32ArgumentCollectsInfoFromCalls stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test33ArgumentCollectsInfoFromCallsAndCurrentMethod stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test34GenericTypeConstructorFromArguments stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test35GenericTypeConstructorFromArgumentParameters stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test36TraceReturnValueWhenMethodReturnsArgument stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test37AddingFromOtherCollectionParameters stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test38CollectionFromLiteralNode stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test39CollectionWithMultipleParameters stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test40GetterForGenericWithMultipleParameters stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test41ArgumentCollectsInfoFromCallsWithMultipleParameters stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test42ArgumentCollectsInfoFromCallsAndCurrentMethodWithMultipleParameters stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test43ReturnTypeOfSetterMethodIsLastArgument stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test44CollectionIsDetectedWhenReturnedFromMethodAndAssignedToVariable stamp: 'JFGO 10/10/2024 18:36:22'!
PASSED!

!testRun: #InferenceTest #test45ArgumentCollectsInfoCurrentMethodWithNoCallers stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test001SameType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test002DifferentType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test003SameHierarchy stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test004CommonSupertypeIsObject stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test005SameGeneric stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test006SameGenericDifferentOrder stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test007GenericsHandleSystemTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test008NestedGenerics stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test009GenericSupertypeWithSameGenerics stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test010GenericSupertypeWithCommonGenerics stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test011FixedAgainstGenericType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test012FixedAgainstGenericTypeInList stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test013GenericAgainstFixedTypeInList stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test014NestedGenerics stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test015NestedGenericsWithDifferentDepth stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test016EmptyTypeAgainstSelf stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test017EmptyTypeAgainstFixedType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test018EmptyTypeAgainstGenericType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test019UnionTypeCollectsTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test020UnionTypeAgainstSelf stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test021UnionTypeAgainstInnerElement stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test022ConvertionAccordingToReceiver stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test023ConvertionToArray stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test024EnumeratingClassTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test025EnumeratingLiveTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #LiveTypeTests #test026EnumeratingLiveAndClassTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test001EmptyRawTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test002AllClasses stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test003AnEmptyCollectionsContentType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test004ClassesAndCollectionsContentType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test005ACollectionsContentTypeWithTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test006SeveralCollectionsContentTypesWithTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test007CreateFixedType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test008CreateEmptyType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test009CreateGenericType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test010CreateGenericNestedType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test011CreateGenericNonEmptyType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test012CreateGenericMultipleNestedType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test001TooltipForEmptyCollection stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test002TooltipForSingleItemCollection stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test003TooltipForTwoItemsWhenSupertypeIsObject stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test004TooltipForTwoItemsWithCommonSupertype stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test005TooltipForVariableWithCollectionAndSomeOtherType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test006TooltipForMergedCollections stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test007TooltipForSameCollectionsWithSameTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test008TooltipForSameCollectionsWithCommonSuperTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test009TooltipForSameCollectionsWithNoSuperTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test010TooltipForCommonSuperCollectionsWithCommonSuperTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test011TooltipForNestedCollections stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test012TooltipForCommonSuperCollectionsWithNoSuperTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test013TooltipForCommonSuperCollectionsRepeatedWithNoSuperTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test014TooltipForCommonSuperCollectionsWithEmptyCollections stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test015TooltipForCommonSuperCollectionsWithAnEmptyCollection stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test016TooltipForCommonSuperCollectionsAndNoCollection stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test017TooltipForCommonSuperTypeAndNoCommonType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test018TooltipForCommonSuperCollectionsAndNoCollection stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test019TooltipForNestedCollectionsOneOfThemEmpty stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test020TooltipForNestedCollectionsBothSameTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test021TooltipForNestedCollectionsEachNoCommonInnerType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test022TooltipForNestedCommonSuperCollectionsNoCommonInnerType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test023TooltipForNestedNoCommonSupertype stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test024TooltipForNestedRepeatedTypeDifferentInners stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test025TooltipForNestedCommonTypesAndIntruder stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test026TooltipForNestedCommontTypesWithTwoLevelIntruder stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test027TooltipForAwfullyComplexInnerCollections stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test028TooltipOnlyOneType stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test029TooltipCommonSuperTypeSingleClasses stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test030TooltipNoTypes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test031TooltipNoCommonSuperTypeSingleClasses stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TooltipTests #test032TooltipForCollectionWithTwoParameters stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeFlowGraphTest #test01IsCreatedEmpty stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeFlowGraphTest #test02AddingANodeIncreasesTheirCount stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeFlowGraphTest #test03AddingAnEdgeIncreasesTheirCount stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeFlowGraphTest #test04CannotLinkInexistantNodes stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeFlowGraphTest #test05CanAccessNodesButCantDirectlyAddToResult stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeFlowGraphTest #test06CheckingConnectionOnAssociatedUndirectedGraph stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test001Empty stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test002Fixed stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test003GenericSingleValue stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test004MultipleFixed stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test005GenericMultipleValues stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test006MultipleFixedWithNoCommonSupertype stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test007MultipleGenerics stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test008GenericEmptyValue stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test009MultipleGenericsEmptyValue stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #TypeNodeTests #test010EmptyAndFixed stamp: 'JFGO 10/10/2024 18:36:23'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test01ManyMethodsCanBeTypeChecked stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test02ClassesCanBeTypeChecked stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test04AlertsDetectIfNone stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test05AlertsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test07ErrorsDetectIfNone stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test10WarningsDetectIfNone stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test15HasErrorsOrWarnings stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 10/10/2024 18:36:27'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test14TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test17TypeCastManyVariablesNestedRejectionsRejectsEachLevelCastedTypeForEachVariable stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/10/2024 18:36:28'!
PASSED!

----End fileIn of C:\Users\juli_\Tesis\TO_UPLOAD\windows64\Catedra-ISW1-2024-1C-Parcial.st----!

aMessageNode arguments!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 18:42:50'!
PASSED!
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 18:46:33' prior: 50539836!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	self halt.
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: or: [aMessageNode selectorSymbol = #ifTrue:ifFalse:].
	blockIsRejectingCondition := blockIsRejectingCondition and: [aBlockNode = aMessageNode arguments second].
	^blockIsRejectingCondition .
	
	


! !

aMessageNode arguments!
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 18:48:39' prior: 50547365!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	"self halt."
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: or: [aMessageNode selectorSymbol = #ifTrue:ifFalse:].
	blockIsRejectingCondition := blockIsRejectingCondition and: [aBlockNode = aMessageNode arguments second].
	^blockIsRejectingCondition .
	
	


! !
!Floor class methodsFor: 'assertions' stamp: 'JFGO 10/10/2024 18:50:50' prior: 50547025!
assertIsInteger: aNumber ifFalse: signalsBlock

	aNumber class = SmallInteger ifFalse: signalsBlock! !
!Floor class methodsFor: 'assertions' stamp: 'JFGO 10/10/2024 18:51:38' prior: 50547396!
assertIsInteger: aNumber ifFalse: signalsBlock

	aNumber isInteger ifFalse: [signalsBlock value]! !
!Floor class methodsFor: 'assertions' stamp: 'JFGO 10/10/2024 18:53:23' prior: 50547402!
assertIsInteger: aNumber ifFalse: signalsBlock

	aNumber isInteger ifFalse: signalsBlock! !
!Floor class methodsFor: 'assertions' stamp: 'JFGO 10/10/2024 18:51:38' prior: 50547408!
assertIsInteger: aNumber ifFalse: signalsBlock

	aNumber isInteger ifFalse: [signalsBlock value]! !
!Floor class methodsFor: 'assertions' stamp: 'JFGO 10/10/2024 18:55:21' prior: 50547414!
assertIsInteger: aNumber ifFalse: signalsBlock

	aNumber isInteger ifFalse: signalsBlock! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 18:58:33' prior: 50547381!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	self halt.
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: or: [aMessageNode selectorSymbol = #ifTrue:ifFalse:].
	blockIsRejectingCondition := blockIsRejectingCondition and: [aBlockNode = aMessageNode arguments second].
	^blockIsRejectingCondition .
	
	


! !

aMessageNode selectorSymbol!

aMessageNode!
!TypesWithContextAppliersTestMethods methodsFor: 'equals type context' stamp: 'JFGO 10/10/2024 19:00:20' prior: 50540453!
typeCastIfFalse
	|v1 b |
	v1 := 5.
	v1:= OrderedCollection new.
	v1 := 'true'.
	b:=[v1 isEmpty.].
	v1 class = SmallInteger ifFalse:b! !

aMessageNode!
!TypesWithContextAppliersTestMethods methodsFor: 'equals type context' stamp: 'JFGO 9/18/2024 18:40:02' prior: 50547444!
typeCastIfFalse
	|v1|
	v1 := 5.
	v1:= OrderedCollection new.
	v1 := 'true'.
	v1 class = SmallInteger ifFalse:[v1 isEmpty.]! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:01:52' prior: 50547427!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	"self halt."
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: or: [aMessageNode selectorSymbol = #ifTrue:ifFalse:].
	blockIsRejectingCondition := blockIsRejectingCondition and: [aBlockNode = aMessageNode arguments second].
	^blockIsRejectingCondition .
	
	


! !
!TypesWithContextAppliersTestMethods methodsFor: 'equals type context' stamp: 'JFGO 10/10/2024 19:02:02'!
typeCastIfFalseWithBlockVariable
	|v1 block |
	v1 := 5.
	v1:= OrderedCollection new.
	v1 := 'true'.
	block:=[v1 isEmpty.].
	v1 class = SmallInteger ifFalse:block! !
!TypesWithContextAppliersTest methodsFor: 'equals class type context' stamp: 'JFGO 10/10/2024 19:03:48'!
test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable
	"This happens because for the visitor the block is just a temporal variable with nothing to check"
	| blockToTestString |
	
	blockToTestString:= '[ v1 isEmpty. ]'.
	
	self withMessageName: #typeCastIfFalse 
	calculateTypesOfNode: 'v1' 
	withinBlockWithCode: blockToTestString 
	asserting: [:types | 
		self assert:types size equals: 2.
		self assert: types includes: OrderedCollection.
		self assert: types includes: String.
	].


	! !
!TypesWithContextAppliersTest methodsFor: 'equals class type context' stamp: 'JFGO 10/10/2024 19:05:04' prior: 50547485!
test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable
	"This happens because when the visitor pass through the block node there's no context yet and it's not possible to tell that is going to be actually used inside an IF"
	| blockToTestString |
	
	blockToTestString:= '[ v1 isEmpty. ]'.
	
	self withMessageName: #typeCastIfFalse 
	calculateTypesOfNode: 'v1' 
	withinBlockWithCode: blockToTestString 
	asserting: [:types | 
		self assert:types size equals: 2.
		self assert: types includes: OrderedCollection.
		self assert: types includes: String.
	].


	! !
!TypesWithContextAppliersTest methodsFor: 'equals class type context' stamp: 'JFGO 10/10/2024 19:06:44' prior: 50547505!
test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable
	"This happens because when the visitor pass through the block node there's no context yet and it's not possible to tell that is going to be actually used inside an IF"
	| blockToTestString |
	
	blockToTestString:= '[ v1 isEmpty. ]'.
	
	self withMessageName: #typeCastIfFalse 
	calculateTypesOfNode: 'v1' 
	withinBlockWithCode: blockToTestString 
	asserting: [:types | 
		self assert:types size equals: 3.
		self assert: types includes: OrderedCollection.
		self assert: types includes: String.
		self assert: types includes: SmallInteger.
	].


	! !
!TypesWithContextAppliersTest methodsFor: 'equals class type context' stamp: 'JFGO 10/10/2024 19:07:10' prior: 50547527!
test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable
	"This happens because when the visitor pass through the block node there's no context yet and it's not possible to tell that is going to be actually used inside an IF"
	| blockToTestString |
	
	blockToTestString:= '[ v1 isEmpty. ]'.
	
	self withMessageName: #typeCastIfFalseWithBlockVariable 
	calculateTypesOfNode: 'v1' 
	withinBlockWithCode: blockToTestString 
	asserting: [:types | 
		self assert:types size equals: 3.
		self assert: types includes: OrderedCollection.
		self assert: types includes: String.
		self assert: types includes: SmallInteger.
	].


	! !

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/10/2024 19:07:11'!
ERROR!
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:07:47' prior: 50547461!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	"self halt."
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: and: [aBlockNode = aMessageNode arguments second].
	blockIsRejectingCondition := blockIsRejectingCondition or: [aMessageNode selectorSymbol = #ifTrue:ifFalse: and: [aBlockNode = aMessageNode arguments second]].
	^blockIsRejectingCondition .
	
	


! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:11:46' prior: 50547578!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	"self halt."
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: and: [aBlockNode = self falseArgumentFrom: aMessageNode].
	blockIsRejectingCondition := blockIsRejectingCondition or: [aMessageNode selectorSymbol = #ifTrue:ifFalse: and: [aBlockNode = aMessageNode arguments second]].
	^blockIsRejectingCondition .
	
	


! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:12:03'!
falseArgumentFrom: aMessageNode
	^aMessageNode arguments second.
	
	


! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:13:15' prior: 50547612!
falseArgumentFrom: aMessageNode
	"Sometimes for #ifFalse: message, smalltalk creates 2 arguments, first one empty. Other times not. It has to do with whether is written with a block variable or the block explicit"
	^aMessageNode arguments second.
	
	


! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:13:58' prior: 50547618!
falseArgumentFrom: aMessageNode
	"Sometimes for #ifFalse: message, smalltalk creates 2 arguments, first one empty. Other times not. It has to do with whether is written with a block variable or the block explicit"
	aMessageNode arguments size = 2 ifTrue: [
		^aMessageNode arguments second.
	]
	^aMessageNode arguments first.
	


! !
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:14:34'!
falseArgumentInIfFalseMessageFrom: aMessageNode
	"Sometimes for #ifFalse: message, smalltalk creates 2 arguments, first one empty. Other times not. It has to do with whether is written with a block variable or the block explicit"
	aMessageNode arguments size = 2 ifTrue: [
		^aMessageNode arguments second.
	]
	^aMessageNode arguments first.
	


! !
!TypeContextAppliers methodsFor: 'as yet unclassified' stamp: 'JFGO 10/10/2024 19:14:34' prior: 50547595!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	"self halt."
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: and: [aBlockNode = self falseArgumentInIfFalseMessageFrom: aMessageNode].
	blockIsRejectingCondition := blockIsRejectingCondition or: [aMessageNode selectorSymbol = #ifTrue:ifFalse: and: [aBlockNode = aMessageNode arguments second]].
	^blockIsRejectingCondition .
	
	


! !

!methodRemoval: TypeContextAppliers #falseArgumentFrom: stamp: 'JFGO 10/10/2024 19:14:34'!
falseArgumentFrom: aMessageNode
	"Sometimes for #ifFalse: message, smalltalk creates 2 arguments, first one empty. Other times not. It has to do with whether is written with a block variable or the block explicit"
	aMessageNode arguments size = 2 ifTrue: [
		^aMessageNode arguments second.
	]
	^aMessageNode arguments first.
	


!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:14:47'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:14:47'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/10/2024 19:14:47'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:14:47'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/10/2024 19:14:47'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/10/2024 19:14:48'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/10/2024 19:14:48'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:14:55'!
ERROR!
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:16:24' prior: 50547659!
is: aBlockNode asRejectingArgumentIn: aMessageNode

	| blockIsRejectingCondition |
	"self halt."
	blockIsRejectingCondition := aMessageNode selectorSymbol = #ifFalse: and: [aBlockNode = (self falseArgumentInIfFalseMessageFrom: aMessageNode)].
	blockIsRejectingCondition := blockIsRejectingCondition or: [aMessageNode selectorSymbol = #ifTrue:ifFalse: and: [aBlockNode = aMessageNode arguments second]].
	^blockIsRejectingCondition .
	
	


! !

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:26'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/10/2024 19:16:26'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/10/2024 19:16:26'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:26'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:26'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:26'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:26'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/10/2024 19:16:27'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/10/2024 19:16:27'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/10/2024 19:16:27'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/10/2024 19:16:27'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/10/2024 19:16:27'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/10/2024 19:16:27'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/10/2024 19:16:27'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:30'!
ERROR!
!TypeContextAppliers methodsFor: 'contexts building' stamp: 'JFGO 10/10/2024 19:16:42' prior: 50547644!
falseArgumentInIfFalseMessageFrom: aMessageNode
	"Sometimes for #ifFalse: message, smalltalk creates 2 arguments, first one empty. Other times not. It has to do with whether is written with a block variable or the block explicit"
	aMessageNode arguments size = 2 ifTrue: [
		^aMessageNode arguments second.
	].
	^aMessageNode arguments first.
	


! !

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/10/2024 19:16:49'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/10/2024 19:16:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/10/2024 19:16:50'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test01ManyMethodsCanBeTypeChecked stamp: 'JFGO 10/10/2024 19:16:55'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test02ClassesCanBeTypeChecked stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test04AlertsDetectIfNone stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test05AlertsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test07ErrorsDetectIfNone stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test10WarningsDetectIfNone stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test15HasErrorsOrWarnings stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test14TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test17TypeCastManyVariablesNestedRejectionsRejectsEachLevelCastedTypeForEachVariable stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:56'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/10/2024 19:16:57'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:57'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:16:57'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/10/2024 19:16:57'!
PASSED!

!testRun: #FloorTest #test01CannotCreateFloorWithoutRooms stamp: 'JFGO 10/10/2024 19:18:35'!
PASSED!

!testRun: #FloorTest #test02CannotCreateFloorWithNoIntergerNumberOfRooms stamp: 'JFGO 10/10/2024 19:18:35'!
PASSED!

!testRun: #FloorTest #test03CannotCreateFloorWithoutPrices stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #FloorTest #test04WhenAFloorIsCreatedAllTheRoomsAreAvailable stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #FloorTest #test05WhenAFloorReceivesAGuestInARoomReducesTheAvailableRoomsByOneAndIncreaseOccupiedByOne stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #FloorTest #test06WhenAFloorReceivesOnReservationAGuestInARoomKeepsTheAvailableRoomsAndOccupiedAndReducesTheReservedByOne stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #FloorTest #test07WhenARoomIsReservedTheFloorAvailableRoomsReducesByOneAndIncreaseReservedAndOccupiedByOne stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #FloorTest #test08TotalProfitShouldBeTheSumOfOccupiedRoomsProfits stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #FloorTest #test09TotalLossesShouldBeTheSumOfAvailableRoomsLosses stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test01CannotCreateHotelWithoutFloors stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test02NewHotelsAreEmpty stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test03HotelCanReceiveATypeOfGuestInRoomAtFloor stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test04HotelCanTakeAReservationForARoomAtFloor stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test05HotelCanReceiveWithReservationATypeOfGuestInRoomAtFloor stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test06HotelCannotReceiveWithReservationWithoutPreviousReservation stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test07HotelProfitsAreTheSumOfEachFloorProfits stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test08HotelLossesAreTheSumOfEachFloorLosses stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test09HotelCannotReserveANonexistentRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test10HotelCannotReserveANonexistentFloor stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test11HotelCannotReceiveAtNonexistentRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test12HotelCannotReceiveAtNonexistentFloor stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #HotelTest #test13HotelCannotReceiveWithReservationAtNonexistentRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test01NewRoomsAreAvailable stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test02ReceivingAGuestMakesTheRoomOccupied stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test03ReservingARoomMakesTheRoomReservedAndOccupied stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test04CannotReceiveAGuestInAOccupiedRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test05CannotReceiveAGuestInAReservedRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test06ReceivingOnReservationMakesTheRoomOccupied stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test07CannotReceiveOnReservationAnAvailableRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test08CannotReceiveOnReservationAnOccupiedRoom stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test09ProfitOfAvailableRoomIsCeroPesos stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test10ProfitOfReservedRoomIsHalfTheMinPriceInList stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test11ProfitOfOccupiedRoomDependsOnGuestType stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test12NoProfitOnOccupiedRoomByUnknownGuestType stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test13LossesOfAvailableRoomIsTheMaxPriceInList stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test14LossesOfReservedRoomIsCeroPesos stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test15LossesOfOccupiedRoomIsCeroPesos stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test16CannotReserveWhenReserved stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #RoomTest #test17CannotReserveWhenOccupied stamp: 'JFGO 10/10/2024 19:18:36'!
PASSED!

!testRun: #LogTestChangesTest #test01RunningAPassingTestShouldBeLogged stamp: 'JFGO 10/10/2024 19:21:54'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:21:55'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test02RunningAFailingTestShouldBeLogged stamp: 'JFGO 10/10/2024 19:21:55'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:21:56'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test03RunningATestWithAnErrorShouldBeLogged stamp: 'JFGO 10/10/2024 19:21:56'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:21:56'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test04OverridingAMethodShouldBeLoggedWithAReferenceToTheOverridenMethod stamp: 'JFGO 10/10/2024 19:21:56'!
PASSED!

!classRemoval: #SubclassTestDataClass__ stamp: 'JFGO 10/10/2024 19:21:57'!
TestChangesTestClass__ subclass: #SubclassTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:21:57'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #SubclassTestDataClass__ stamp: 'JFGO 10/10/2024 19:21:58'!
TestChangesTestClass__ subclass: #SubclassTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:21:58'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:21:59'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test01ScanPassingTestChange stamp: 'JFGO 10/10/2024 19:23:14'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:23:15'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test02ScanFailedTestChange stamp: 'JFGO 10/10/2024 19:23:15'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:23:16'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test03ScanNewTestClass stamp: 'JFGO 10/10/2024 19:23:16'!
PASSED!

!classRemoval: #TestClassA stamp: 'JFGO 10/10/2024 19:23:16'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test04ScanOverridenMethod stamp: 'JFGO 10/10/2024 19:23:17'!
PASSED!

!classRemoval: #AClass__ stamp: 'JFGO 10/10/2024 19:23:17'!
TestChangesTestClass__ subclass: #AClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:23:17'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test05ScanAMethodThatIsNotOverriden stamp: 'JFGO 10/10/2024 19:23:18'!
PASSED!

!classRemoval: #AClass__ stamp: 'JFGO 10/10/2024 19:23:18'!
TestChangesTestClass__ subclass: #AClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:23:18'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #TestChangesTest #testDataClassName stamp: 'JFGO 10/10/2024 19:23:18'!
PASSED!
!Behavior method!
description
	#_coverageTracker173026205_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026205_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026205_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173026205_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173026205_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173026205_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173026205_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026205_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173026205_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173026205_
					coverAll:
						{65 to: 78}
					byLiteralOrPseudoVariable: ' was removed') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
newTest: aTestReference
	| errorMessage |
	#_coverageTracker173026244_ markAsExecuted.
	#_coverageTracker173026244_
		cover: (47 to: 58)
		declaredAt: (29 to: 40)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173026244_
				coverAll:
					{63 to: 69}
				by: TDDGuru.
			#_coverageTracker173026244_
				coverAll:
					{71 to: 110. 136 to: 141}
				evaluating: [
					receiver3
						testAddedBeforeRunningTheRestOfTheTests:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173026244_
								cover: (112 to: 125)
								declaredAt: (10 to: 23)
								by: aTestReference.
							#_coverageTracker173026244_
								coverAll:
									{127 to: 134}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173026244_
								cover: (143 to: 156)
								declaredAt: (10 to: 23)
								by: aTestReference.
							#_coverageTracker173026244_
								coverAll:
									{158 to: 168}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #testAddedBeforeRunningTheRestOfTheTests:class:
				to: receiver3 ] value).
	[ | receiver5 |
	receiver5 _ #_coverageTracker173026244_
		coverAll:
			{172 to: 175}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026244_
		coverAll:
			{177 to: 188. 203 to: 218}
		evaluating: [
			receiver5
				reportError:
					(#_coverageTracker173026244_
						cover: (190 to: 201)
						declaredAt: (29 to: 40)
						by: errorMessage)
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173026244_
						coverAll:
							{221 to: 239}
						by: WritingAFailingTest.
					#_coverageTracker173026244_
						coverAll:
							{241 to: 252}
						evaluating: [
							receiver4 currentTest:
								(#_coverageTracker173026244_
									cover: (254 to: 267)
									declaredAt: (10 to: 23)
									by: aTestReference) ]
						thatSends: #currentTest:
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
timeString
	#_coverageTracker173026281_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026281_
		coverAll:
			{15 to: 18}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026281_
		coverAll:
			{20 to: 24}
		evaluating: [ receiver1 stamp ]
		thatSends: #stamp
		to: receiver1 ] value.
	#_coverageTracker173026281_
		coverAll:
			{26 to: 35}
		evaluating: [ receiver2 substrings ]
		thatSends: #substrings
		to: receiver2 ] value.
	#_coverageTracker173026281_
		coverAll:
			{37 to: 41}
		evaluating: [ receiver3 third ]
		thatSends: #third
		to: receiver3 ] value.! !
!Behavior method!
reportError: description
	#_coverageTracker173026299_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026299_
		cover: (27 to: 40)
		declaredAt: (27 to: 40)
		by: analysisResult.
	#_coverageTracker173026299_
		coverAll:
			{42 to: 50. 64 to: 66}
		evaluating: [
			receiver1
				addError:
					(#_coverageTracker173026299_
						cover: (52 to: 62)
						declaredAt: (14 to: 24)
						by: description)
				in:
					(#_coverageTracker173026299_
						cover: (68 to: 80)
						declaredAt: (68 to: 80)
						by: currentChange) ]
		thatSends: #addError:in:
		to: receiver1 ] value.! !
!Behavior method!
changeClass
	#_coverageTracker173026308_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173026308_
		cover: (16 to: 27)
		declaredAt: (16 to: 27)
		by: changeRecord.
	#_coverageTracker173026308_
		coverAll:
			{29 to: 39}
		evaluating: [ receiver1 changeClass ]
		thatSends: #changeClass
		to: receiver1 ] value.! !
!Behavior method!
testReference
	#_coverageTracker173026313_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ #_coverageTracker173026313_
		coverAll:
			{18 to: 43}
		by: UninstalledMethodReference.
	#_coverageTracker173026313_
		coverAll:
			{45 to: 53. 73 to: 78. 101 to: 111}
		evaluating: [
			receiver4
				selector:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173026313_
						coverAll:
							{55 to: 58}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026313_
						coverAll:
							{60 to: 71}
						evaluating: [ receiver1 testSelector ]
						thatSends: #testSelector
						to: receiver1 ] value
				class:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173026313_
						coverAll:
							{80 to: 83}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026313_
						coverAll:
							{85 to: 99}
						evaluating: [ receiver2 changeClassName ]
						thatSends: #changeClassName
						to: receiver2 ] value
				sourceCode:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173026313_
						coverAll:
							{113 to: 116}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026313_
						coverAll:
							{118 to: 121}
						evaluating: [ receiver3 code ]
						thatSends: #code
						to: receiver3 ] value ]
		thatSends: #selector:class:sourceCode:
		to: receiver4 ] value.! !
!Behavior method!
newModelMethod: aSymbol
	#_coverageTracker173026334_ markAsExecuted.! !
!Behavior method!
analysisResult
	#_coverageTracker173026341_ markAsExecuted.
	^ #_coverageTracker173026341_
		cover: (19 to: 32)
		declaredAt: (19 to: 32)
		by: analysisResult.! !
!Behavior method!
newTestReference
	#_coverageTracker173026344_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ #_coverageTracker173026344_
		coverAll:
			{21 to: 46}
		by: UninstalledMethodReference.
	#_coverageTracker173026344_
		coverAll:
			{48 to: 56. 66 to: 71. 94 to: 104}
		evaluating: [
			receiver4
				selector:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173026344_
						coverAll:
							{58 to: 61}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026344_
						coverAll:
							{63 to: 64}
						evaluating: [ receiver1 to ]
						thatSends: #to
						to: receiver1 ] value
				class:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173026344_
						coverAll:
							{73 to: 76}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026344_
						coverAll:
							{78 to: 92}
						evaluating: [ receiver2 changeClassName ]
						thatSends: #changeClassName
						to: receiver2 ] value
				sourceCode:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173026344_
						coverAll:
							{106 to: 109}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026344_
						coverAll:
							{111 to: 114}
						evaluating: [ receiver3 code ]
						thatSends: #code
						to: receiver3 ] value ]
		thatSends: #selector:class:sourceCode:
		to: receiver4 ] value.! !
!Behavior method!
testRemoved: aTestReference
	#_coverageTracker173026355_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026355_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026355_
		coverAll:
			{35 to: 46}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173026355_
		coverAll:
			{48 to: 59}
		evaluating: [
			receiver2 testRemoved:
				(#_coverageTracker173026355_
					cover: (61 to: 74)
					declaredAt: (14 to: 27)
					by: aTestReference) ]
		thatSends: #testRemoved:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026355_
		cover: (78 to: 86)
		declaredAt: (78 to: 86)
		by: inventory.
	#_coverageTracker173026355_
		coverAll:
			{88 to: 99}
		evaluating: [
			receiver3 testRemoved:
				(#_coverageTracker173026355_
					cover: (101 to: 114)
					declaredAt: (14 to: 27)
					by: aTestReference) ]
		thatSends: #testRemoved:
		to: receiver3 ] value.
	[ | receiver7 |
	receiver7 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173026355_
		coverAll:
			{120 to: 123}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026355_
		coverAll:
			{125 to: 135}
		evaluating: [ receiver4 noTestsLeft ]
		thatSends: #noTestsLeft
		to: receiver4 ] value.
	#_coverageTracker173026355_
		coverAll:
			{137 to: 143}
		evaluating: [
			receiver7 ifTrue: [
				[ | receiver6 |
				receiver6 _ [ | receiver5 |
				receiver5 _ #_coverageTracker173026355_
					coverAll:
						{147 to: 150}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026355_
					coverAll:
						{152 to: 163}
					evaluating: [ receiver5 currentState ]
					thatSends: #currentState
					to: receiver5 ] value.
				#_coverageTracker173026355_
					coverAll:
						{165 to: 175}
					evaluating: [ receiver6 noMoreTests ]
					thatSends: #noMoreTests
					to: receiver6 ] value ]]
		thatSends: #ifTrue:
		to: receiver7 ] value.! !
!Behavior method!
changeWhenMethodWasAdded: aSelector in: className
	#_coverageTracker173026378_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173026378_
		cover: (55 to: 62)
		declaredAt: (55 to: 62)
		by: timeline.
	#_coverageTracker173026378_
		coverAll:
			{64 to: 88. 100 to: 102}
		evaluating: [
			receiver1
				changeWhenMethodWasAdded:
					(#_coverageTracker173026378_
						cover: (90 to: 98)
						declaredAt: (27 to: 35)
						by: aSelector)
				in:
					(#_coverageTracker173026378_
						cover: (104 to: 112)
						declaredAt: (41 to: 49)
						by: className) ]
		thatSends: #changeWhenMethodWasAdded:in:
		to: receiver1 ] value.! !
!Behavior method!
displayOn: aMorph
	#_coverageTracker173026384_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026384_
		cover: (20 to: 25)
		declaredAt: (12 to: 17)
		by: aMorph.
	#_coverageTracker173026384_
		coverAll:
			{27 to: 49}
		evaluating: [
			receiver1 displayStateTransition:
				(#_coverageTracker173026384_
					coverAll:
						{51 to: 54}
					byLiteralOrPseudoVariable: self) ]
		thatSends: #displayStateTransition:
		to: receiver1 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173026393_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026393_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173026393_
		coverAll:
			{34 to: 45}
		evaluating: [
			receiver2 testRemoved:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026393_
					coverAll:
						{47 to: 50}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026393_
					coverAll:
						{52 to: 66}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #testRemoved:
		to: receiver2 ] value.! !
!Behavior method!
methodClassIfInstalled
	#_coverageTracker173026399_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173026399_
		coverAll:
			{28 to: 36}
		by: Smalltalk.
	#_coverageTracker173026399_
		coverAll:
			{38 to: 48}
		evaluating: [
			receiver2 classNamed:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026399_
					coverAll:
						{50 to: 53}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026399_
					coverAll:
						{55 to: 65}
					evaluating: [ receiver1 methodClass ]
					thatSends: #methodClass
					to: receiver1 ] value ]
		thatSends: #classNamed:
		to: receiver2 ] value.
	#_coverageTracker173026399_
		coverAll:
			{68 to: 73}
		evaluating: [ receiver3 ifNil: [ ^ #_coverageTracker173026399_
					coverAll:
						{79 to: 93}
					by: UndefinedObject ]]
		thatSends: #ifNil:
		to: receiver3 ] value.! !
!Behavior method!
rerun
	#_coverageTracker173026418_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026418_
		coverAll:
			{8 to: 11}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026418_
		coverAll:
			{13 to: 31}
		evaluating: [ receiver1 initializeInventory ]
		thatSends: #initializeInventory
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026418_
		coverAll:
			{35 to: 38}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026418_
		coverAll:
			{40 to: 58}
		evaluating: [ receiver2 initializeChangeLog ]
		thatSends: #initializeChangeLog
		to: receiver2 ] value.
	^ [ | receiver3 |
	receiver3 _ #_coverageTracker173026418_
		coverAll:
			{64 to: 67}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026418_
		coverAll:
			{69 to: 71}
		evaluating: [ receiver3 run ]
		thatSends: #run
		to: receiver3 ] value.! !
!Behavior method!
newModelClass: className
	#_coverageTracker173026422_ markAsExecuted.! !
!Behavior method!
reportErrorIn: aChange with: errorMessage
	#_coverageTracker173026426_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026426_
		cover: (44 to: 57)
		declaredAt: (44 to: 57)
		by: analysisResult.
	#_coverageTracker173026426_
		coverAll:
			{59 to: 67. 82 to: 84}
		evaluating: [
			receiver1
				addError:
					(#_coverageTracker173026426_
						cover: (69 to: 80)
						declaredAt: (30 to: 41)
						by: errorMessage)
				in:
					(#_coverageTracker173026426_
						cover: (86 to: 92)
						declaredAt: (16 to: 22)
						by: aChange) ]
		thatSends: #addError:in:
		to: receiver1 ] value.! !
!Behavior method!
category
	#_coverageTracker173026431_ markAsExecuted.
	^ #_coverageTracker173026431_
		coverAll:
			{13 to: 25}
		byLiteralOrPseudoVariable: #classRemoved.! !
!Behavior method!
reportErrorIn: aChange with: errorMessage
	#_coverageTracker173026434_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026434_
		cover: (44 to: 50)
		declaredAt: (44 to: 50)
		by: context.
	#_coverageTracker173026434_
		coverAll:
			{52 to: 65. 75 to: 79}
		evaluating: [
			receiver1
				reportErrorIn:
					(#_coverageTracker173026434_
						cover: (67 to: 73)
						declaredAt: (16 to: 22)
						by: aChange)
				with:
					(#_coverageTracker173026434_
						cover: (81 to: 92)
						declaredAt: (30 to: 41)
						by: errorMessage) ]
		thatSends: #reportErrorIn:with:
		to: receiver1 ] value.! !
!Behavior method!
events
	#_coverageTracker173026440_ markAsExecuted.
	^ #_coverageTracker173026440_
		cover: (11 to: 16)
		declaredAt: (11 to: 16)
		by: events.! !
!Behavior method!
change
	#_coverageTracker173026447_ markAsExecuted.
	^ #_coverageTracker173026447_
		cover: (11 to: 16)
		declaredAt: (11 to: 16)
		by: change.! !
!Behavior method!
testChanged: aSymbol
	#_coverageTracker173026448_ markAsExecuted.! !
!Behavior method!
testClassRemoved: aSymbol
	#_coverageTracker173026458_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026458_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026458_
		coverAll:
			{34 to: 51}
		evaluating: [
			receiver1 modelClassRemoved:
				(#_coverageTracker173026458_
					cover: (53 to: 59)
					declaredAt: (19 to: 25)
					by: aSymbol) ]
		thatSends: #modelClassRemoved:
		to: receiver1 ] value.! !
!Behavior method!
selector: testSelector class: className sourceCode: aSourceCodeString
	#_coverageTracker173026463_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026463_
		coverAll:
			{74 to: 77}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026463_
		coverAll:
			{79 to: 81}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173026463_
		coverAll:
			{83 to: 91}
		evaluating: [
			receiver2 selector:
				(#_coverageTracker173026463_
					cover: (93 to: 104)
					declaredAt: (11 to: 22)
					by: testSelector) ]
		thatSends: #selector:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173026463_
		coverAll:
			{107 to: 112}
		evaluating: [
			receiver3 class:
				(#_coverageTracker173026463_
					cover: (114 to: 122)
					declaredAt: (31 to: 39)
					by: className) ]
		thatSends: #class:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ cascadeReceiver.
	#_coverageTracker173026463_
		coverAll:
			{125 to: 135}
		evaluating: [
			receiver4 sourceCode:
				(#_coverageTracker173026463_
					cover: (137 to: 153)
					declaredAt: (53 to: 69)
					by: aSourceCodeString) ]
		thatSends: #sourceCode:
		to: receiver4 ] value ] value.! !
!Behavior method!
newClassNamed: aSymbol subclassOf: aClass
	| newClass |
	#_coverageTracker173026472_ markAsExecuted.
	#_coverageTracker173026472_
		cover: (59 to: 66)
		declaredAt: (47 to: 54)
		by:
			(newClass _ [ | receiver2 |
			receiver2 _ #_coverageTracker173026472_
				cover: (71 to: 76)
				declaredAt: (36 to: 41)
				by: aClass.
			#_coverageTracker173026472_
				coverAll:
					{78 to: 86. 96 to: 117. 122 to: 140. 145 to: 161. 166 to: 174}
				evaluating: [
					receiver2
						subclass:
							(#_coverageTracker173026472_
								cover: (88 to: 94)
								declaredAt: (16 to: 22)
								by: aSymbol)
						instanceVariableNames:
							(#_coverageTracker173026472_
								coverAll:
									{119 to: 120}
								byLiteralOrPseudoVariable: '')
						classVariableNames:
							(#_coverageTracker173026472_
								coverAll:
									{142 to: 143}
								byLiteralOrPseudoVariable: '')
						poolDictionaries:
							(#_coverageTracker173026472_
								coverAll:
									{163 to: 164}
								byLiteralOrPseudoVariable: '')
						category:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173026472_
								coverAll:
									{176 to: 179}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173026472_
								coverAll:
									{181 to: 203}
								evaluating: [ receiver1 classCategoryOfTestData ]
								thatSends: #classCategoryOfTestData
								to: receiver1 ] value ]
				thatSends: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026472_
		cover: (207 to: 219)
		declaredAt: (207 to: 219)
		by: classesByName.
	#_coverageTracker173026472_
		coverAll:
			{221 to: 223. 233 to: 236}
		evaluating: [
			receiver3
				at:
					(#_coverageTracker173026472_
						cover: (225 to: 231)
						declaredAt: (16 to: 22)
						by: aSymbol)
				put:
					(#_coverageTracker173026472_
						cover: (238 to: 245)
						declaredAt: (47 to: 54)
						by: newClass) ]
		thatSends: #at:put:
		to: receiver3 ] value.
	^ #_coverageTracker173026472_
		cover: (253 to: 260)
		declaredAt: (47 to: 54)
		by: newClass.! !
!Behavior method!
category
	#_coverageTracker173026500_ markAsExecuted.
	^ #_coverageTracker173026500_
		coverAll:
			{13 to: 24}
		byLiteralOrPseudoVariable: #testRenamed.! !
!Behavior method!
lookahead: numberOfLookaheadChanges
	#_coverageTracker173026503_ markAsExecuted.
	#_coverageTracker173026503_
		cover: (38 to: 46)
		declaredAt: (38 to: 46)
		by:
			(lookahead _ #_coverageTracker173026503_
				cover: (51 to: 74)
				declaredAt: (12 to: 35)
				by: numberOfLookaheadChanges).! !
!Behavior method!
testChanged: aTestReference
	#_coverageTracker173026508_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026508_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026508_
		coverAll:
			{35 to: 47}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026508_
					coverAll:
						{50 to: 68}
					by: WritingAFailingTest.
				#_coverageTracker173026508_
					coverAll:
						{70 to: 81}
					evaluating: [
						receiver1 currentTest:
							(#_coverageTracker173026508_
								cover: (83 to: 96)
								declaredAt: (14 to: 27)
								by: aTestReference) ]
					thatSends: #currentTest:
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
modelMethodChanged: aMethodReference
	#_coverageTracker173026513_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026513_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026513_
		coverAll:
			{45 to: 57}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026513_
					coverAll:
						{60 to: 67}
					by: Refactor.
				#_coverageTracker173026513_
					coverAll:
						{69 to: 87}
					evaluating: [
						receiver1 modelMethodChanged:
							(#_coverageTracker173026513_
								cover: (89 to: 104)
								declaredAt: (21 to: 36)
								by: aMethodReference) ]
					thatSends: #modelMethodChanged:
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
colorForStateTransition: aTDDState
	#_coverageTracker173026519_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173026519_
		coverAll:
			{39 to: 58}
		by: AnalysisResultWindow.
	#_coverageTracker173026519_
		coverAll:
			{60 to: 80}
		evaluating: [
			receiver1 stateTransitionColor:
				(#_coverageTracker173026519_
					cover: (82 to: 90)
					declaredAt: (26 to: 34)
					by: aTDDState) ]
		thatSends: #stateTransitionColor:
		to: receiver1 ] value.! !
!Behavior method!
logChangesWhile: aBlockClosure
	#_coverageTracker173026525_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173026525_
		coverAll:
			{36 to: 46}
		by: Preferences.
	#_coverageTracker173026525_
		coverAll:
			{50 to: 68. 109 to: 111. 145 to: 147}
		evaluating: [
			receiver2
				withTemporaryValue:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173026525_
						coverAll:
							{70 to: 73}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026525_
						coverAll:
							{75 to: 105}
						evaluating: [ receiver1 userChangesForTestFileExtension ]
						thatSends: #userChangesForTestFileExtension
						to: receiver1 ] value
				of:
					(#_coverageTracker173026525_
						coverAll:
							{113 to: 141}
						byLiteralOrPseudoVariable: #userChangesFileNameExtension)
				do:
					(#_coverageTracker173026525_
						cover: (149 to: 161)
						declaredAt: (18 to: 30)
						by: aBlockClosure) ]
		thatSends: #withTemporaryValue:of:do:
		to: receiver2 ] value.! !
!Behavior method!
renameClass: aSymbol to: aSymbol2
	| class |
	#_coverageTracker173026533_ markAsExecuted.
	#_coverageTracker173026533_
		cover: (48 to: 52)
		declaredAt: (39 to: 43)
		by:
			(class _ [ | receiver1 |
			receiver1 _ #_coverageTracker173026533_
				coverAll:
					{57 to: 60}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173026533_
				coverAll:
					{62 to: 72}
				evaluating: [
					receiver1 classNamed:
						(#_coverageTracker173026533_
							cover: (74 to: 80)
							declaredAt: (14 to: 20)
							by: aSymbol) ]
				thatSends: #classNamed:
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026533_
		cover: (86 to: 98)
		declaredAt: (86 to: 98)
		by: classesByName.
	#_coverageTracker173026533_
		coverAll:
			{100 to: 109}
		evaluating: [
			receiver2 removeKey:
				(#_coverageTracker173026533_
					cover: (111 to: 117)
					declaredAt: (14 to: 20)
					by: aSymbol) ]
		thatSends: #removeKey:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026533_
		cover: (121 to: 133)
		declaredAt: (86 to: 98)
		by: classesByName.
	#_coverageTracker173026533_
		coverAll:
			{135 to: 137. 148 to: 151}
		evaluating: [
			receiver3
				at:
					(#_coverageTracker173026533_
						cover: (139 to: 146)
						declaredAt: (26 to: 33)
						by: aSymbol2)
				put:
					(#_coverageTracker173026533_
						cover: (153 to: 157)
						declaredAt: (39 to: 43)
						by: class) ]
		thatSends: #at:put:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173026533_
		cover: (163 to: 167)
		declaredAt: (39 to: 43)
		by: class.
	#_coverageTracker173026533_
		coverAll:
			{169 to: 175}
		evaluating: [
			receiver4 rename:
				(#_coverageTracker173026533_
					cover: (177 to: 184)
					declaredAt: (26 to: 33)
					by: aSymbol2) ]
		thatSends: #rename:
		to: receiver4 ] value.! !
!Behavior method!
newTestClass: aSymbol
	#_coverageTracker173026555_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026555_
		coverAll:
			{25 to: 28}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026555_
		coverAll:
			{30 to: 42}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026555_
					coverAll:
						{44 to: 51}
					by: Refactor.
				#_coverageTracker173026555_
					coverAll:
						{53 to: 55}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
testClassRemoved: aSymbol
	#_coverageTracker173026561_ markAsExecuted.! !
!Behavior method!
analyzeChange: aChange
	#_coverageTracker173026563_ markAsExecuted.
	#_coverageTracker173026563_
		cover: (26 to: 39)
		declaredAt: (26 to: 39)
		by:
			(previousChange _ #_coverageTracker173026563_
				cover: (44 to: 56)
				declaredAt: (44 to: 56)
				by: currentChange).
	#_coverageTracker173026563_
		cover: (60 to: 72)
		declaredAt: (44 to: 56)
		by:
			(currentChange _ #_coverageTracker173026563_
				cover: (77 to: 83)
				declaredAt: (16 to: 22)
				by: aChange).
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026563_
		cover: (88 to: 100)
		declaredAt: (44 to: 56)
		by: currentChange.
	#_coverageTracker173026563_
		coverAll:
			{102 to: 113}
		evaluating: [ receiver1 isRecognized ]
		thatSends: #isRecognized
		to: receiver1 ] value.
	#_coverageTracker173026563_
		coverAll:
			{115 to: 121}
		evaluating: [
			receiver4 ifTrue: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173026563_
					cover: (127 to: 140)
					declaredAt: (127 to: 140)
					by: analysisResult.
				#_coverageTracker173026563_
					coverAll:
						{142 to: 151}
					evaluating: [
						receiver2 addChange:
							(#_coverageTracker173026563_
								cover: (153 to: 165)
								declaredAt: (44 to: 56)
								by: currentChange) ]
					thatSends: #addChange:
					to: receiver2 ] value.
				[ | receiver3 |
				receiver3 _ #_coverageTracker173026563_
					cover: (170 to: 182)
					declaredAt: (44 to: 56)
					by: currentChange.
				#_coverageTracker173026563_
					coverAll:
						{184 to: 198}
					evaluating: [
						receiver3 reportChangeTo:
							(#_coverageTracker173026563_
								coverAll:
									{200 to: 203}
								byLiteralOrPseudoVariable: self) ]
					thatSends: #reportChangeTo:
					to: receiver3 ] value ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.! !
!Behavior method!
description
	#_coverageTracker173026584_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026584_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026584_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173026584_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173026584_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173026584_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173026584_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026584_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173026584_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173026584_
					coverAll:
						{65 to: 88}
					byLiteralOrPseudoVariable: ' was added or modified') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
addEvent: anEvent
	#_coverageTracker173026603_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026603_
		cover: (20 to: 25)
		declaredAt: (20 to: 25)
		by: events.
	#_coverageTracker173026603_
		coverAll:
			{27 to: 30}
		evaluating: [
			receiver1 add:
				(#_coverageTracker173026603_
					cover: (32 to: 38)
					declaredAt: (11 to: 17)
					by: anEvent) ]
		thatSends: #add:
		to: receiver1 ] value.
	#_coverageTracker173026603_
		cover: (42 to: 48)
		declaredAt: (42 to: 48)
		by:
			(changes _ #_coverageTracker173026603_
				coverAll:
					{53 to: 55}
				byLiteralOrPseudoVariable: nil).
	#_coverageTracker173026603_
		cover: (59 to: 76)
		declaredAt: (59 to: 76)
		by:
			(statesAfterChanges _ [ | receiver2 |
			receiver2 _ #_coverageTracker173026603_
				coverAll:
					{81 to: 90}
				by: Dictionary.
			#_coverageTracker173026603_
				coverAll:
					{92 to: 94}
				evaluating: [ receiver2 new ]
				thatSends: #new
				to: receiver2 ] value).! !
!Behavior method!
description
	#_coverageTracker173026619_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026619_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026619_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173026619_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173026619_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173026619_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173026619_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026619_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173026619_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173026619_
					coverAll:
						{65 to: 78}
					byLiteralOrPseudoVariable: ' was removed') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173026626_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026626_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173026626_
		coverAll:
			{34 to: 41}
		evaluating: [
			receiver2 newTest:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026626_
					coverAll:
						{43 to: 46}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026626_
					coverAll:
						{48 to: 62}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #newTest:
		to: receiver2 ] value.! !
!Behavior method!
colorForRow: row
	| event |
	#_coverageTracker173026630_ markAsExecuted.
	#_coverageTracker173026630_
		cover: (30 to: 34)
		declaredAt: (21 to: 25)
		by:
			(event _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173026630_
				cover: (39 to: 43)
				declaredAt: (39 to: 43)
				by: owner.
			#_coverageTracker173026630_
				coverAll:
					{45 to: 49}
				evaluating: [ receiver1 model ]
				thatSends: #model
				to: receiver1 ] value.
			#_coverageTracker173026630_
				coverAll:
					{51 to: 59}
				evaluating: [
					receiver2 changeAt:
						(#_coverageTracker173026630_
							cover: (61 to: 63)
							declaredAt: (14 to: 16)
							by: row) ]
				thatSends: #changeAt:
				to: receiver2 ] value).
	[ | receiver7 |
	receiver7 _ [ | receiver4 |
	receiver4 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173026630_
		cover: (70 to: 74)
		declaredAt: (21 to: 25)
		by: event.
	#_coverageTracker173026630_
		coverAll:
			{76 to: 79}
		evaluating: [ receiver3 type ]
		thatSends: #type
		to: receiver3 ] value.
	#_coverageTracker173026630_
		coverAll:
			{81 to: 81}
		evaluating: [
			receiver4 =
				(#_coverageTracker173026630_
					coverAll:
						{83 to: 89}
					byLiteralOrPseudoVariable: #change) ]
		thatSends: #=
		to: receiver4 ] value.
	#_coverageTracker173026630_
		coverAll:
			{92 to: 98}
		evaluating: [ receiver7 ifTrue: [ ^ [ | receiver6 |
				receiver6 _ #_coverageTracker173026630_
					coverAll:
						{104 to: 107}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026630_
					coverAll:
						{109 to: 123}
					evaluating: [
						receiver6 colorForChange:
							[ | receiver5 |
							receiver5 _ #_coverageTracker173026630_
								cover: (125 to: 129)
								declaredAt: (21 to: 25)
								by: event.
							#_coverageTracker173026630_
								coverAll:
									{131 to: 136}
								evaluating: [ receiver5 change ]
								thatSends: #change
								to: receiver5 ] value ]
					thatSends: #colorForChange:
					to: receiver6 ] value ]]
		thatSends: #ifTrue:
		to: receiver7 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver9 |
	receiver9 _ [ | receiver8 |
	receiver8 _ #_coverageTracker173026630_
		cover: (143 to: 147)
		declaredAt: (21 to: 25)
		by: event.
	#_coverageTracker173026630_
		coverAll:
			{149 to: 152}
		evaluating: [ receiver8 type ]
		thatSends: #type
		to: receiver8 ] value.
	#_coverageTracker173026630_
		coverAll:
			{154 to: 154}
		evaluating: [
			receiver9 =
				(#_coverageTracker173026630_
					coverAll:
						{156 to: 171}
					byLiteralOrPseudoVariable: #stateTransition) ]
		thatSends: #=
		to: receiver9 ] value.
	#_coverageTracker173026630_
		coverAll:
			{174 to: 180}
		evaluating: [ receiver11 ifTrue: [ ^ [ | receiver10 |
				receiver10 _ #_coverageTracker173026630_
					coverAll:
						{186 to: 189}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026630_
					coverAll:
						{191 to: 214}
					evaluating: [
						receiver10 colorForStateTransition:
							(#_coverageTracker173026630_
								cover: (216 to: 220)
								declaredAt: (21 to: 25)
								by: event) ]
					thatSends: #colorForStateTransition:
					to: receiver10 ] value ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.
	^ #_coverageTracker173026630_
		coverAll:
			{235 to: 246}
		evaluating: [
			super colorForRow:
				(#_coverageTracker173026630_
					cover: (248 to: 250)
					declaredAt: (14 to: 16)
					by: row) ]
		thatSends: #colorForRow:
		to: super.! !
!Behavior method!
description
	#_coverageTracker173026648_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026648_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026648_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173026648_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173026648_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173026648_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173026648_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026648_
					coverAll:
						{49 to: 60}
					evaluating: [ receiver3 testSelector ]
					thatSends: #testSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173026648_
		coverAll:
			{61 to: 61}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173026648_
					coverAll:
						{63 to: 71}
					byLiteralOrPseudoVariable: ' FAILED') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
on: aString initialTestClasses: anArray
	#_coverageTracker173026660_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026660_
		coverAll:
			{45 to: 48}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026660_
		coverAll:
			{50 to: 52}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173026660_
		coverAll:
			{54 to: 65}
		evaluating: [
			receiver2 changesFile:
				(#_coverageTracker173026660_
					cover: (67 to: 73)
					declaredAt: (5 to: 11)
					by: aString) ]
		thatSends: #changesFile:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173026660_
		coverAll:
			{76 to: 94}
		evaluating: [
			receiver3 initialTestClasses:
				(#_coverageTracker173026660_
					cover: (96 to: 102)
					declaredAt: (33 to: 39)
					by: anArray) ]
		thatSends: #initialTestClasses:
		to: receiver3 ] value ] value.! !
!Behavior method!
testPassed: aTestReference
	#_coverageTracker173026666_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026666_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026666_
		coverAll:
			{35 to: 67}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026666_
		coverAll:
			{71 to: 74}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026666_
		coverAll:
			{76 to: 108}
		evaluating: [
			receiver2 testDidNotFailErrorInCurrentTest:
				(#_coverageTracker173026666_
					cover: (110 to: 123)
					declaredAt: (13 to: 26)
					by: aTestReference) ]
		thatSends: #testDidNotFailErrorInCurrentTest:
		to: receiver2 ] value.
	#_coverageTracker173026666_
		coverAll:
			{133 to: 143}
		evaluating: [
			super testPassed:
				(#_coverageTracker173026666_
					cover: (145 to: 158)
					declaredAt: (13 to: 26)
					by: aTestReference) ]
		thatSends: #testPassed:
		to: super.! !
!Behavior method!
isCorrect
	#_coverageTracker173026671_ markAsExecuted.
	^ #_coverageTracker173026671_
		coverAll:
			{14 to: 17}
		byLiteralOrPseudoVariable: true.! !
!Behavior method!
testFailed: aSymbol
	#_coverageTracker173026673_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026673_
		cover: (23 to: 33)
		declaredAt: (23 to: 33)
		by: passedTests.
	#_coverageTracker173026673_
		coverAll:
			{35 to: 41. 51 to: 59}
		evaluating: [
			receiver1
				remove:
					(#_coverageTracker173026673_
						cover: (43 to: 49)
						declaredAt: (13 to: 19)
						by: aSymbol)
				ifAbsent: [ ]]
		thatSends: #remove:ifAbsent:
		to: receiver1 ] value.! !
!Behavior method!
details
	#_coverageTracker173026677_ markAsExecuted.
	#_coverageTracker173026677_
		cover: (10 to: 21)
		declaredAt: (10 to: 21)
		by:
			(changeDetail _ [ | receiver2 |
			receiver2 _ #_coverageTracker173026677_
				coverAll:
					{26 to: 39}
				by: TextModelMorph.
			#_coverageTracker173026677_
				coverAll:
					{41 to: 53. 70 to: 80}
				evaluating: [
					receiver2
						textProvider:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173026677_
								cover: (55 to: 59)
								declaredAt: (55 to: 59)
								by: model.
							#_coverageTracker173026677_
								coverAll:
									{61 to: 68}
								evaluating: [ receiver1 timeline ]
								thatSends: #timeline
								to: receiver1 ] value
						textGetter:
							(#_coverageTracker173026677_
								coverAll:
									{82 to: 102}
								byLiteralOrPseudoVariable: #selectedChangeDetail) ]
				thatSends: #textProvider:textGetter:
				to: receiver2 ] value).
	[ | receiver5 |
	receiver5 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173026677_
		cover: (106 to: 110)
		declaredAt: (55 to: 59)
		by: model.
	#_coverageTracker173026677_
		coverAll:
			{112 to: 119}
		evaluating: [ receiver3 timeline ]
		thatSends: #timeline
		to: receiver3 ] value.
	#_coverageTracker173026677_
		coverAll:
			{121 to: 125. 142 to: 146. 157 to: 159}
		evaluating: [
			receiver5
				when:
					(#_coverageTracker173026677_
						coverAll:
							{127 to: 140}
						byLiteralOrPseudoVariable: #detailChanged)
				send:
					(#_coverageTracker173026677_
						coverAll:
							{148 to: 155}
						byLiteralOrPseudoVariable: #refetch)
				to:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173026677_
						cover: (161 to: 172)
						declaredAt: (10 to: 21)
						by: changeDetail.
					#_coverageTracker173026677_
						coverAll:
							{174 to: 178}
						evaluating: [ receiver4 model ]
						thatSends: #model
						to: receiver4 ] value ]
		thatSends: #when:send:to:
		to: receiver5 ] value.
	[ | receiver6 |
	receiver6 _ #_coverageTracker173026677_
		cover: (182 to: 193)
		declaredAt: (10 to: 21)
		by: changeDetail.
	#_coverageTracker173026677_
		coverAll:
			{195 to: 208}
		evaluating: [ receiver6 disableEditing ]
		thatSends: #disableEditing
		to: receiver6 ] value.
	^ #_coverageTracker173026677_
		cover: (216 to: 227)
		declaredAt: (10 to: 21)
		by: changeDetail.! !
!Behavior method!
newTest: aTestReference
	#_coverageTracker173026687_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026687_
		coverAll:
			{27 to: 30}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026687_
		coverAll:
			{32 to: 51}
		evaluating: [ receiver1 currentTestIsDefined ]
		thatSends: #currentTestIsDefined
		to: receiver1 ] value.
	#_coverageTracker173026687_
		coverAll:
			{53 to: 59}
		evaluating: [
			receiver4 ifTrue: [
				[ | receiver3 |
				receiver3 _ #_coverageTracker173026687_
					coverAll:
						{63 to: 66}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026687_
					coverAll:
						{68 to: 80}
					evaluating: [
						receiver3 transitionTo:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173026687_
								coverAll:
									{83 to: 104}
								by: MoreThanOneTestWritten.
							#_coverageTracker173026687_
								coverAll:
									{106 to: 110. 117 to: 120}
								evaluating: [
									receiver2
										with:
											(#_coverageTracker173026687_
												cover: (112 to: 115)
												declaredAt: (112 to: 115)
												by: test)
										and:
											(#_coverageTracker173026687_
												cover: (122 to: 135)
												declaredAt: (10 to: 23)
												by: aTestReference) ]
								thatSends: #with:and:
								to: receiver2 ] value ]
					thatSends: #transitionTo:
					to: receiver3 ] value ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173026687_
		coverAll:
			{144 to: 147}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026687_
		coverAll:
			{149 to: 160}
		evaluating: [
			receiver5 currentTest:
				(#_coverageTracker173026687_
					cover: (162 to: 175)
					declaredAt: (10 to: 23)
					by: aTestReference) ]
		thatSends: #currentTest:
		to: receiver5 ] value.! !
!Behavior method!
tddGuruTestDefaultChangesFile
	#_coverageTracker173026702_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173026702_
		coverAll:
			{35 to: 38}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026702_
		coverAll:
			{40 to: 63}
		evaluating: [
			receiver2 changeFileWithExtension:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026702_
					coverAll:
						{65 to: 68}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026702_
					coverAll:
						{70 to: 100}
					evaluating: [ receiver1 tddGuruTestChangesFileExtension ]
					thatSends: #tddGuruTestChangesFileExtension
					to: receiver1 ] value ]
		thatSends: #changeFileWithExtension:
		to: receiver2 ] value.! !
!Behavior method!
testRemovedWhileInRed: aSymbol class: aSymbol2
	#_coverageTracker173026705_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026705_
		coverAll:
			{53 to: 56}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026705_
		coverAll:
			{58 to: 69. 79 to: 84}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173026705_
						cover: (71 to: 77)
						declaredAt: (24 to: 30)
						by: aSymbol)
				class:
					(#_coverageTracker173026705_
						cover: (86 to: 93)
						declaredAt: (39 to: 46)
						by: aSymbol2) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173026705_
		coverAll:
			{95 to: 95}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173026705_
					coverAll:
						{97 to: 123}
					byLiteralOrPseudoVariable: ' was removed while in Red') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
showAnalysisResult
	#_coverageTracker173026710_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026710_
		coverAll:
			{22 to: 41}
		by: AnalysisResultWindow.
	#_coverageTracker173026710_
		coverAll:
			{43 to: 50. 67 to: 77}
		evaluating: [
			receiver1
				openFor:
					(#_coverageTracker173026710_
						cover: (52 to: 65)
						declaredAt: (52 to: 65)
						by: analysisResult)
				analyzedBy:
					(#_coverageTracker173026710_
						coverAll:
							{79 to: 82}
						byLiteralOrPseudoVariable: self) ]
		thatSends: #openFor:analyzedBy:
		to: receiver1 ] value.! !
!Behavior method!
overridesASuperclassMethod
	#_coverageTracker173026715_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173026715_
		cover: (31 to: 42)
		declaredAt: (31 to: 42)
		by: changeRecord.
	#_coverageTracker173026715_
		coverAll:
			{44 to: 69}
		evaluating: [ receiver1 overridesASuperclassMethod ]
		thatSends: #overridesASuperclassMethod
		to: receiver1 ] value.! !
!Behavior method!
setBalloonText: stringTextOrSymbol
	#_coverageTracker173026716_ markAsExecuted.! !
!Behavior method!
colorForChange: aChange
	#_coverageTracker173026720_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026720_
		cover: (28 to: 32)
		declaredAt: (28 to: 32)
		by: owner.
	#_coverageTracker173026720_
		coverAll:
			{34 to: 47}
		evaluating: [ receiver1 analysisResult ]
		thatSends: #analysisResult
		to: receiver1 ] value.
	#_coverageTracker173026720_
		coverAll:
			{49 to: 58}
		evaluating: [
			receiver2 isCorrect:
				(#_coverageTracker173026720_
					cover: (60 to: 66)
					declaredAt: (17 to: 23)
					by: aChange) ]
		thatSends: #isCorrect:
		to: receiver2 ] value.
	#_coverageTracker173026720_
		coverAll:
			{69 to: 75. 117 to: 124}
		evaluating: [
			receiver5
				ifTrue: [ ^ [ | receiver3 |
					receiver3 _ #_coverageTracker173026720_
						coverAll:
							{81 to: 100}
						by: AnalysisResultWindow.
					#_coverageTracker173026720_
						coverAll:
							{102 to: 113}
						evaluating: [ receiver3 successColor ]
						thatSends: #successColor
						to: receiver3 ] value ]
				ifFalse: [ ^ [ | receiver4 |
					receiver4 _ #_coverageTracker173026720_
						coverAll:
							{130 to: 149}
						by: AnalysisResultWindow.
					#_coverageTracker173026720_
						coverAll:
							{151 to: 160}
						evaluating: [ receiver4 errorColor ]
						thatSends: #errorColor
						to: receiver4 ] value ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver5 ] value.! !
!Behavior method!
changeFileWithExtension: fileExtension
	#_coverageTracker173026727_ markAsExecuted.
	^ [ | receiver9 |
	receiver9 _ [ | receiver8 |
	receiver8 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026727_
		coverAll:
			{44 to: 57}
		by: DirectoryEntry.
	#_coverageTracker173026727_
		coverAll:
			{59 to: 78}
		evaluating: [ receiver1 userChangesDirectory ]
		thatSends: #userChangesDirectory
		to: receiver1 ] value.
	#_coverageTracker173026727_
		coverAll:
			{80 to: 81}
		evaluating: [
			receiver8 //
				[ | receiver7 |
				receiver7 _ [ | receiver6 |
				receiver6 _ [ | receiver2 |
				receiver2 _ #_coverageTracker173026727_
					coverAll:
						{85 to: 98}
					by: FileIOAccessor.
				#_coverageTracker173026727_
					coverAll:
						{100 to: 106}
					evaluating: [ receiver2 default ]
					thatSends: #default
					to: receiver2 ] value.
				#_coverageTracker173026727_
					coverAll:
						{108 to: 119}
					evaluating: [
						receiver6 baseNameFor:
							[ | receiver5 |
							receiver5 _ [ | receiver4 |
							receiver4 _ [ | receiver3 |
							receiver3 _ #_coverageTracker173026727_
								coverAll:
									{121 to: 129}
								by: Smalltalk.
							#_coverageTracker173026727_
								coverAll:
									{131 to: 139}
								evaluating: [ receiver3 imageName ]
								thatSends: #imageName
								to: receiver3 ] value.
							#_coverageTracker173026727_
								coverAll:
									{141 to: 156}
								evaluating: [ receiver4 pathAndLocalName ]
								thatSends: #pathAndLocalName
								to: receiver4 ] value.
							#_coverageTracker173026727_
								coverAll:
									{158 to: 163}
								evaluating: [ receiver5 second ]
								thatSends: #second
								to: receiver5 ] value ]
					thatSends: #baseNameFor:
					to: receiver6 ] value.
				#_coverageTracker173026727_
					coverAll:
						{165 to: 165}
					evaluating: [
						receiver7 ,
							(#_coverageTracker173026727_
								cover: (167 to: 179)
								declaredAt: (26 to: 38)
								by: fileExtension) ]
					thatSends: #,
					to: receiver7 ] value ]
		thatSends: #//
		to: receiver8 ] value.
	#_coverageTracker173026727_
		coverAll:
			{183 to: 190}
		evaluating: [ receiver9 pathName ]
		thatSends: #pathName
		to: receiver9 ] value.! !
!Behavior method!
code
	| changeClass sourceString |
	#_coverageTracker173026745_ markAsExecuted.
	#_coverageTracker173026745_
		cover: (37 to: 48)
		declaredAt: (21 to: 32)
		by:
			(sourceString _ [ | receiver1 |
			receiver1 _ #_coverageTracker173026745_
				cover: (53 to: 64)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173026745_
				coverAll:
					{66 to: 71}
				evaluating: [ receiver1 string ]
				thatSends: #string
				to: receiver1 ] value).
	#_coverageTracker173026745_
		cover: (75 to: 85)
		declaredAt: (9 to: 19)
		by:
			(changeClass _ [ | receiver2 |
			receiver2 _ #_coverageTracker173026745_
				cover: (90 to: 101)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173026745_
				coverAll:
					{103 to: 113}
				evaluating: [ receiver2 changeClass ]
				thatSends: #changeClass
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026745_
		cover: (117 to: 127)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173026745_
		coverAll:
			{129 to: 134}
		evaluating: [ receiver3 ifNil: [ ^ #_coverageTracker173026745_
					cover: (140 to: 151)
					declaredAt: (21 to: 32)
					by: sourceString ]]
		thatSends: #ifNil:
		to: receiver3 ] value.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173026745_
		cover: (161 to: 171)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173026745_
		coverAll:
			{173 to: 185}
		evaluating: [ receiver4 compilerClass ]
		thatSends: #compilerClass
		to: receiver4 ] value.
	#_coverageTracker173026745_
		coverAll:
			{187 to: 189}
		evaluating: [ receiver5 new ]
		thatSends: #new
		to: receiver5 ] value.
	#_coverageTracker173026745_
		coverAll:
			{193 to: 199. 214 to: 216. 230 to: 239}
		evaluating: [
			receiver6
				format:
					(#_coverageTracker173026745_
						cover: (201 to: 212)
						declaredAt: (21 to: 32)
						by: sourceString)
				in:
					(#_coverageTracker173026745_
						cover: (218 to: 228)
						declaredAt: (9 to: 19)
						by: changeClass)
				notifying:
					(#_coverageTracker173026745_
						coverAll:
							{241 to: 243}
						byLiteralOrPseudoVariable: nil) ]
		thatSends: #format:in:notifying:
		to: receiver6 ] value.! !
!Behavior method!
newTestClass: className
	#_coverageTracker173026755_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026755_
		cover: (26 to: 32)
		declaredAt: (26 to: 32)
		by: context.
	#_coverageTracker173026755_
		coverAll:
			{34 to: 42}
		evaluating: [
			receiver2 setState:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026755_
					coverAll:
						{44 to: 62}
					by: WritingAFailingTest.
				#_coverageTracker173026755_
					coverAll:
						{64 to: 66}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #setState:
		to: receiver2 ] value.! !
!Behavior method!
runFromSelectedChange
	| userChangesFileName tddGuru |
	#_coverageTracker173026760_ markAsExecuted.
	[ | receiver11 |
	receiver11 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026760_
		cover: (59 to: 63)
		declaredAt: (59 to: 63)
		by: model.
	#_coverageTracker173026760_
		coverAll:
			{65 to: 73}
		evaluating: [ receiver1 listIndex ]
		thatSends: #listIndex
		to: receiver1 ] value.
	#_coverageTracker173026760_
		coverAll:
			{75 to: 75}
		evaluating: [
			receiver2 >
				(#_coverageTracker173026760_
					coverAll:
						{77 to: 77}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #>
		to: receiver2 ] value.
	#_coverageTracker173026760_
		coverAll:
			{79 to: 85}
		evaluating: [
			receiver11 ifTrue: [
				#_coverageTracker173026760_
					cover: (91 to: 109)
					declaredAt: (26 to: 44)
					by:
						(userChangesFileName _ [ | receiver4 |
						receiver4 _ [ | receiver3 |
						receiver3 _ #_coverageTracker173026760_
							cover: (114 to: 118)
							declaredAt: (59 to: 63)
							by: model.
						#_coverageTracker173026760_
							coverAll:
								{120 to: 123}
							evaluating: [ receiver3 file ]
							thatSends: #file
							to: receiver3 ] value.
						#_coverageTracker173026760_
							coverAll:
								{125 to: 128}
							evaluating: [ receiver4 name ]
							thatSends: #name
							to: receiver4 ] value).
				#_coverageTracker173026760_
					cover: (133 to: 139)
					declaredAt: (46 to: 52)
					by:
						(tddGuru _ [ | receiver5 |
						receiver5 _ #_coverageTracker173026760_
							coverAll:
								{144 to: 150}
							by: TDDGuru.
						#_coverageTracker173026760_
							coverAll:
								{152 to: 154. 176 to: 180}
							evaluating: [
								receiver5
									on:
										(#_coverageTracker173026760_
											cover: (156 to: 174)
											declaredAt: (26 to: 44)
											by: userChangesFileName)
									from:
										(#_coverageTracker173026760_
											cover: (182 to: 205)
											declaredAt: (182 to: 205)
											by: changesFileStartPosition) ]
							thatSends: #on:from:
							to: receiver5 ] value).
				[ | receiver7 |
				receiver7 _ #_coverageTracker173026760_
					cover: (210 to: 216)
					declaredAt: (46 to: 52)
					by: tddGuru.
				#_coverageTracker173026760_
					coverAll:
						{218 to: 236}
					evaluating: [
						receiver7 startingFromChange:
							[ | receiver6 |
							receiver6 _ #_coverageTracker173026760_
								cover: (238 to: 242)
								declaredAt: (59 to: 63)
								by: model.
							#_coverageTracker173026760_
								coverAll:
									{244 to: 252}
								evaluating: [ receiver6 listIndex ]
								thatSends: #listIndex
								to: receiver6 ] value ]
					thatSends: #startingFromChange:
					to: receiver7 ] value.
				[ | cascadeReceiver |
				cascadeReceiver _ #_coverageTracker173026760_
					cover: (257 to: 263)
					declaredAt: (46 to: 52)
					by: tddGuru.
				[ | receiver8 |
				receiver8 _ cascadeReceiver.
				#_coverageTracker173026760_
					coverAll:
						{265 to: 267}
					evaluating: [ receiver8 run ]
					thatSends: #run
					to: receiver8 ] value.
				[ | receiver9 |
				receiver9 _ cascadeReceiver.
				#_coverageTracker173026760_
					coverAll:
						{270 to: 287}
					evaluating: [ receiver9 showAnalysisResult ]
					thatSends: #showAnalysisResult
					to: receiver9 ] value ] value.
				[ | receiver10 |
				receiver10 _ #_coverageTracker173026760_
					coverAll:
						{292 to: 295}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026760_
					coverAll:
						{297 to: 302}
					evaluating: [ receiver10 delete ]
					thatSends: #delete
					to: receiver10 ] value ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.! !
!Behavior method!
type
	#_coverageTracker173026785_ markAsExecuted.
	^ #_coverageTracker173026785_
		coverAll:
			{9 to: 15}
		byLiteralOrPseudoVariable: #change.! !
!Behavior method!
methodReferenceWith: selector andClass: className
	#_coverageTracker173026788_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ #_coverageTracker173026788_
		coverAll:
			{54 to: 79}
		by: UninstalledMethodReference.
	#_coverageTracker173026788_
		coverAll:
			{81 to: 89. 100 to: 105. 117 to: 127. 148 to: 157}
		evaluating: [
			receiver3
				selector:
					(#_coverageTracker173026788_
						cover: (91 to: 98)
						declaredAt: (22 to: 29)
						by: selector)
				class:
					(#_coverageTracker173026788_
						cover: (107 to: 115)
						declaredAt: (41 to: 49)
						by: className)
				sourceCode:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173026788_
						cover: (129 to: 141)
						declaredAt: (129 to: 141)
						by: currentChange.
					#_coverageTracker173026788_
						coverAll:
							{143 to: 146}
						evaluating: [ receiver1 code ]
						thatSends: #code
						to: receiver1 ] value
				overrides:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173026788_
						cover: (159 to: 171)
						declaredAt: (129 to: 141)
						by: currentChange.
					#_coverageTracker173026788_
						coverAll:
							{173 to: 198}
						evaluating: [ receiver2 overridesASuperclassMethod ]
						thatSends: #overridesASuperclassMethod
						to: receiver2 ] value ]
		thatSends: #selector:class:sourceCode:overrides:
		to: receiver3 ] value.! !
!Behavior method!
drawAt: aPoint on: aCanvas
	| stateName stateNamePosition stringWidth topLeft bottomRight |
	#_coverageTracker173026796_ markAsExecuted.
	#_coverageTracker173026796_
		cover: (96 to: 102)
		declaredAt: (71 to: 77)
		by:
			(topLeft _ #_coverageTracker173026796_
				cover: (107 to: 112)
				declaredAt: (9 to: 14)
				by: aPoint).
	#_coverageTracker173026796_
		cover: (116 to: 126)
		declaredAt: (79 to: 89)
		by:
			(bottomRight _ [ | receiver5 |
			receiver5 _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173026796_
				cover: (133 to: 138)
				declaredAt: (9 to: 14)
				by: aPoint.
			#_coverageTracker173026796_
				coverAll:
					{140 to: 140}
				evaluating: [ receiver1 x ]
				thatSends: #x
				to: receiver1 ] value.
			#_coverageTracker173026796_
				coverAll:
					{142 to: 142}
				evaluating: [
					receiver2 +
						(#_coverageTracker173026796_
							cover: (144 to: 148)
							declaredAt: (144 to: 148)
							by: width) ]
				thatSends: #+
				to: receiver2 ] value.
			#_coverageTracker173026796_
				coverAll:
					{151 to: 151}
				evaluating: [
					receiver5 @
						[ | receiver4 |
						receiver4 _ [ | receiver3 |
						receiver3 _ #_coverageTracker173026796_
							cover: (154 to: 159)
							declaredAt: (9 to: 14)
							by: aPoint.
						#_coverageTracker173026796_
							coverAll:
								{161 to: 161}
							evaluating: [ receiver3 y ]
							thatSends: #y
							to: receiver3 ] value.
						#_coverageTracker173026796_
							coverAll:
								{163 to: 163}
							evaluating: [
								receiver4 +
									(#_coverageTracker173026796_
										cover: (165 to: 170)
										declaredAt: (165 to: 170)
										by: height) ]
							thatSends: #+
							to: receiver4 ] value ]
				thatSends: #@
				to: receiver5 ] value).
	[ | receiver8 |
	receiver8 _ #_coverageTracker173026796_
		cover: (176 to: 182)
		declaredAt: (20 to: 26)
		by: aCanvas.
	#_coverageTracker173026796_
		coverAll:
			{184 to: 193. 225 to: 230. 243 to: 249}
		evaluating: [
			receiver8
				roundRect:
					[ | receiver6 |
					receiver6 _ #_coverageTracker173026796_
						cover: (196 to: 202)
						declaredAt: (71 to: 77)
						by: topLeft.
					#_coverageTracker173026796_
						coverAll:
							{204 to: 210}
						evaluating: [
							receiver6 corner:
								(#_coverageTracker173026796_
									cover: (212 to: 222)
									declaredAt: (79 to: 89)
									by: bottomRight) ]
						thatSends: #corner:
						to: receiver6 ] value
				color:
					[ | receiver7 |
					receiver7 _ #_coverageTracker173026796_
						coverAll:
							{232 to: 235}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026796_
						coverAll:
							{237 to: 241}
						evaluating: [ receiver7 color ]
						thatSends: #color
						to: receiver7 ] value
				radius:
					(#_coverageTracker173026796_
						coverAll:
							{251 to: 253}
						byLiteralOrPseudoVariable: 0.8) ]
		thatSends: #roundRect:color:radius:
		to: receiver8 ] value.
	#_coverageTracker173026796_
		cover: (259 to: 267)
		declaredAt: (31 to: 39)
		by:
			(stateName _ [ | receiver10 |
			receiver10 _ [ | receiver9 |
			receiver9 _ #_coverageTracker173026796_
				cover: (272 to: 279)
				declaredAt: (272 to: 279)
				by: tddState.
			#_coverageTracker173026796_
				coverAll:
					{281 to: 291}
				evaluating: [ receiver9 printString ]
				thatSends: #printString
				to: receiver9 ] value.
			#_coverageTracker173026796_
				coverAll:
					{293 to: 301. 305 to: 307}
				evaluating: [
					receiver10
						copyFrom:
							(#_coverageTracker173026796_
								coverAll:
									{303 to: 303}
								byLiteralOrPseudoVariable: 1)
						to:
							(#_coverageTracker173026796_
								coverAll:
									{309 to: 309}
								byLiteralOrPseudoVariable: 1) ]
				thatSends: #copyFrom:to:
				to: receiver10 ] value).
	#_coverageTracker173026796_
		cover: (313 to: 323)
		declaredAt: (59 to: 69)
		by:
			(stringWidth _ [ | receiver12 |
			receiver12 _ [ | receiver11 |
			receiver11 _ #_coverageTracker173026796_
				coverAll:
					{328 to: 331}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173026796_
				coverAll:
					{333 to: 336}
				evaluating: [ receiver11 font ]
				thatSends: #font
				to: receiver11 ] value.
			#_coverageTracker173026796_
				coverAll:
					{338 to: 351}
				evaluating: [
					receiver12 widthOfString:
						(#_coverageTracker173026796_
							cover: (353 to: 361)
							declaredAt: (31 to: 39)
							by: stateName) ]
				thatSends: #widthOfString:
				to: receiver12 ] value).
	#_coverageTracker173026796_
		cover: (365 to: 381)
		declaredAt: (41 to: 57)
		by:
			(stateNamePosition _ [ | receiver14 |
			receiver14 _ [ | receiver13 |
			receiver13 _ #_coverageTracker173026796_
				cover: (387 to: 391)
				declaredAt: (144 to: 148)
				by: width.
			#_coverageTracker173026796_
				coverAll:
					{393 to: 393}
				evaluating: [
					receiver13 -
						(#_coverageTracker173026796_
							cover: (395 to: 405)
							declaredAt: (59 to: 69)
							by: stringWidth) ]
				thatSends: #-
				to: receiver13 ] value.
			#_coverageTracker173026796_
				coverAll:
					{408 to: 408}
				evaluating: [
					receiver14 /
						(#_coverageTracker173026796_
							coverAll:
								{410 to: 410}
							byLiteralOrPseudoVariable: 2) ]
				thatSends: #/
				to: receiver14 ] value).
	[ | receiver19 |
	receiver19 _ #_coverageTracker173026796_
		cover: (414 to: 420)
		declaredAt: (20 to: 26)
		by: aCanvas.
	#_coverageTracker173026796_
		coverAll:
			{422 to: 432. 444 to: 446. 479 to: 483. 495 to: 500}
		evaluating: [
			receiver19
				drawString:
					(#_coverageTracker173026796_
						cover: (434 to: 442)
						declaredAt: (31 to: 39)
						by: stateName)
				at:
					[ | receiver16 |
					receiver16 _ #_coverageTracker173026796_
						cover: (449 to: 465)
						declaredAt: (41 to: 57)
						by: stateNamePosition.
					#_coverageTracker173026796_
						coverAll:
							{467 to: 467}
						evaluating: [
							receiver16 @
								[ | receiver15 |
								receiver15 _ #_coverageTracker173026796_
									cover: (469 to: 474)
									declaredAt: (9 to: 14)
									by: aPoint.
								#_coverageTracker173026796_
									coverAll:
										{476 to: 476}
									evaluating: [ receiver15 y ]
									thatSends: #y
									to: receiver15 ] value ]
						thatSends: #@
						to: receiver16 ] value
				font:
					[ | receiver17 |
					receiver17 _ #_coverageTracker173026796_
						coverAll:
							{485 to: 488}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026796_
						coverAll:
							{490 to: 493}
						evaluating: [ receiver17 font ]
						thatSends: #font
						to: receiver17 ] value
				color:
					[ | receiver18 |
					receiver18 _ #_coverageTracker173026796_
						coverAll:
							{502 to: 506}
						by: Color.
					#_coverageTracker173026796_
						coverAll:
							{508 to: 512}
						evaluating: [ receiver18 white ]
						thatSends: #white
						to: receiver18 ] value ]
		thatSends: #drawString:at:font:color:
		to: receiver19 ] value.! !
!Behavior method!
for: aTDDState width: widthNumber height: heightNumber
	#_coverageTracker173026840_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026840_
		coverAll:
			{59 to: 62}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026840_
		coverAll:
			{64 to: 66}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173026840_
		coverAll:
			{68 to: 71. 83 to: 88. 102 to: 108}
		evaluating: [
			receiver2
				for:
					(#_coverageTracker173026840_
						cover: (73 to: 81)
						declaredAt: (6 to: 14)
						by: aTDDState)
				width:
					(#_coverageTracker173026840_
						cover: (90 to: 100)
						declaredAt: (23 to: 33)
						by: widthNumber)
				height:
					(#_coverageTracker173026840_
						cover: (110 to: 121)
						declaredAt: (43 to: 54)
						by: heightNumber) ]
		thatSends: #for:width:height:
		to: receiver2 ] value.! !
!Behavior method!
eventsWithType: aSymbol
	#_coverageTracker173026852_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026852_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026852_
		coverAll:
			{34 to: 39}
		evaluating: [ receiver1 events ]
		thatSends: #events
		to: receiver1 ] value.
	#_coverageTracker173026852_
		coverAll:
			{41 to: 47}
		evaluating: [
			receiver4 select: [ :anEvent |
				[ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker173026852_
					cover: (62 to: 68)
					declaredAt: (52 to: 58)
					by: anEvent.
				#_coverageTracker173026852_
					coverAll:
						{70 to: 73}
					evaluating: [ receiver2 type ]
					thatSends: #type
					to: receiver2 ] value.
				#_coverageTracker173026852_
					coverAll:
						{75 to: 75}
					evaluating: [
						receiver3 =
							(#_coverageTracker173026852_
								cover: (77 to: 83)
								declaredAt: (17 to: 23)
								by: aSymbol) ]
					thatSends: #=
					to: receiver3 ] value ]]
		thatSends: #select:
		to: receiver4 ] value.! !
!Behavior method!
category
	#_coverageTracker173026858_ markAsExecuted.
	^ #_coverageTracker173026858_
		coverAll:
			{13 to: 24}
		byLiteralOrPseudoVariable: #testRemoved.! !
!Behavior method!
newTestClass: aSymbol
	#_coverageTracker173026860_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026860_
		coverAll:
			{25 to: 28}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026860_
		coverAll:
			{30 to: 62}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026860_
		coverAll:
			{66 to: 69}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026860_
		coverAll:
			{71 to: 83}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173026860_
					coverAll:
						{85 to: 95}
					by: NotDoingTDD.
				#_coverageTracker173026860_
					coverAll:
						{97 to: 99}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
testRemoved: aMethodReference
	#_coverageTracker173026864_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026864_
		cover: (33 to: 37)
		declaredAt: (33 to: 37)
		by: tests.
	#_coverageTracker173026864_
		coverAll:
			{39 to: 45. 64 to: 72}
		evaluating: [
			receiver1
				remove:
					(#_coverageTracker173026864_
						cover: (47 to: 62)
						declaredAt: (14 to: 29)
						by: aMethodReference)
				ifAbsent: [ ]]
		thatSends: #remove:ifAbsent:
		to: receiver1 ] value.! !
!Behavior method!
selectedCode
	| sourceCode |
	#_coverageTracker173026870_ markAsExecuted.
	#_coverageTracker173026870_
		cover: (31 to: 40)
		declaredAt: (17 to: 26)
		by:
			(sourceCode _ #_coverageTracker173026870_
				coverAll:
					{45 to: 46}
				byLiteralOrPseudoVariable: '').
	[ | receiver7 |
	receiver7 _ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026870_
		cover: (53 to: 65)
		declaredAt: (53 to: 65)
		by: selectedEvent.
	#_coverageTracker173026870_
		coverAll:
			{67 to: 72}
		evaluating: [ receiver1 notNil ]
		thatSends: #notNil
		to: receiver1 ] value.
	#_coverageTracker173026870_
		coverAll:
			{74 to: 77}
		evaluating: [
			receiver4 and: [
				[ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker173026870_
					cover: (81 to: 93)
					declaredAt: (53 to: 65)
					by: selectedEvent.
				#_coverageTracker173026870_
					coverAll:
						{95 to: 98}
					evaluating: [ receiver2 type ]
					thatSends: #type
					to: receiver2 ] value.
				#_coverageTracker173026870_
					coverAll:
						{100 to: 100}
					evaluating: [
						receiver3 =
							(#_coverageTracker173026870_
								coverAll:
									{102 to: 108}
								byLiteralOrPseudoVariable: #change) ]
					thatSends: #=
					to: receiver3 ] value ]]
		thatSends: #and:
		to: receiver4 ] value.
	#_coverageTracker173026870_
		coverAll:
			{113 to: 119}
		evaluating: [
			receiver7 ifTrue: [
				#_coverageTracker173026870_
					cover: (123 to: 132)
					declaredAt: (17 to: 26)
					by:
						(sourceCode _ [ | receiver6 |
						receiver6 _ [ | receiver5 |
						receiver5 _ #_coverageTracker173026870_
							cover: (137 to: 149)
							declaredAt: (53 to: 65)
							by: selectedEvent.
						#_coverageTracker173026870_
							coverAll:
								{151 to: 156}
							evaluating: [ receiver5 change ]
							thatSends: #change
							to: receiver5 ] value.
						#_coverageTracker173026870_
							coverAll:
								{158 to: 161}
							evaluating: [ receiver6 code ]
							thatSends: #code
							to: receiver6 ] value) ]]
		thatSends: #ifTrue:
		to: receiver7 ] value.
	^ [ | receiver9 |
	receiver9 _ #_coverageTracker173026870_
		coverAll:
			{171 to: 174}
		by: Text.
	#_coverageTracker173026870_
		coverAll:
			{179 to: 190. 230 to: 242}
		evaluating: [
			receiver9
				initialFont:
					[ | receiver8 |
					receiver8 _ #_coverageTracker173026870_
						coverAll:
							{193 to: 203}
						by: Preferences.
					#_coverageTracker173026870_
						coverAll:
							{205 to: 207}
						evaluating: [
							receiver8 at:
								(#_coverageTracker173026870_
									coverAll:
										{209 to: 225}
									byLiteralOrPseudoVariable: #standardCodeFont) ]
						thatSends: #at:
						to: receiver8 ] value
				stringOrText:
					(#_coverageTracker173026870_
						cover: (244 to: 253)
						declaredAt: (17 to: 26)
						by: sourceCode) ]
		thatSends: #initialFont:stringOrText:
		to: receiver9 ] value.! !
!Behavior method!
methodReference
	#_coverageTracker173026882_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ #_coverageTracker173026882_
		coverAll:
			{20 to: 45}
		by: UninstalledMethodReference.
	#_coverageTracker173026882_
		coverAll:
			{47 to: 55. 77 to: 82. 105 to: 115}
		evaluating: [
			receiver4
				selector:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173026882_
						coverAll:
							{57 to: 60}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026882_
						coverAll:
							{62 to: 75}
						evaluating: [ receiver1 methodSelector ]
						thatSends: #methodSelector
						to: receiver1 ] value
				class:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173026882_
						coverAll:
							{84 to: 87}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026882_
						coverAll:
							{89 to: 103}
						evaluating: [ receiver2 changeClassName ]
						thatSends: #changeClassName
						to: receiver2 ] value
				sourceCode:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173026882_
						coverAll:
							{117 to: 120}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026882_
						coverAll:
							{122 to: 125}
						evaluating: [ receiver3 code ]
						thatSends: #code
						to: receiver3 ] value ]
		thatSends: #selector:class:sourceCode:
		to: receiver4 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173026891_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026891_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173026891_
		coverAll:
			{34 to: 44}
		evaluating: [
			receiver2 testPassed:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173026891_
					coverAll:
						{46 to: 49}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173026891_
					coverAll:
						{51 to: 63}
					evaluating: [ receiver1 testReference ]
					thatSends: #testReference
					to: receiver1 ] value ]
		thatSends: #testPassed:
		to: receiver2 ] value.! !
!Behavior method!
testFailedDetector
	#_coverageTracker173026896_ markAsExecuted.
	^ [ | receiver10 |
	receiver10 _ #_coverageTracker173026896_
		coverAll:
			{23 to: 36}
		by: ChangeDetector.
	#_coverageTracker173026896_
		coverAll:
			{38 to: 41. 54 to: 67. 71 to: 82}
		evaluating: [
			receiver10
				for:
					(#_coverageTracker173026896_
						coverAll:
							{43 to: 52}
						by: TestFailed)
				withLookahead:
					(#_coverageTracker173026896_
						coverAll:
							{69 to: 69}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver9 |
					receiver9 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173026896_
						cover: (106 to: 118)
						declaredAt: (87 to: 99)
						by: aChangeRecord.
					#_coverageTracker173026896_
						coverAll:
							{120 to: 129}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173026896_
						coverAll:
							{131 to: 131}
						evaluating: [
							receiver2 =
								(#_coverageTracker173026896_
									coverAll:
										{133 to: 140}
									byLiteralOrPseudoVariable: #testRun) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173026896_
						coverAll:
							{146 to: 149. 208 to: 211}
						evaluating: [
							receiver9
								and: [
									[ | receiver5 |
									receiver5 _ [ | receiver3 |
									receiver3 _ #_coverageTracker173026896_
										cover: (153 to: 165)
										declaredAt: (87 to: 99)
										by: aChangeRecord.
									#_coverageTracker173026896_
										coverAll:
											{167 to: 175}
										evaluating: [ receiver3 isFailure ]
										thatSends: #isFailure
										to: receiver3 ] value.
									#_coverageTracker173026896_
										coverAll:
											{177 to: 179}
										evaluating: [
											receiver5 or:
												[ | receiver4 |
												receiver4 _ #_coverageTracker173026896_
													cover: (181 to: 193)
													declaredAt: (87 to: 99)
													by: aChangeRecord.
												#_coverageTracker173026896_
													coverAll:
														{195 to: 201}
													evaluating: [ receiver4 isError ]
													thatSends: #isError
													to: receiver4 ] value ]
										thatSends: #or:
										to: receiver5 ] value ]
								and: [
									[ | receiver8 |
									receiver8 _ #_coverageTracker173026896_
										coverAll:
											{215 to: 218}
										byLiteralOrPseudoVariable: self.
									#_coverageTracker173026896_
										coverAll:
											{220 to: 233. 264 to: 269}
										evaluating: [
											receiver8
												testIsTracked:
													[ | receiver6 |
													receiver6 _ #_coverageTracker173026896_
														cover: (235 to: 247)
														declaredAt: (87 to: 99)
														by: aChangeRecord.
													#_coverageTracker173026896_
														coverAll:
															{249 to: 262}
														evaluating: [ receiver6 methodSelector ]
														thatSends: #methodSelector
														to: receiver6 ] value
												class:
													[ | receiver7 |
													receiver7 _ #_coverageTracker173026896_
														cover: (271 to: 283)
														declaredAt: (87 to: 99)
														by: aChangeRecord.
													#_coverageTracker173026896_
														coverAll:
															{285 to: 299}
														evaluating: [ receiver7 changeClassName ]
														thatSends: #changeClassName
														to: receiver7 ] value ]
										thatSends: #testIsTracked:class:
										to: receiver8 ] value ]]
						thatSends: #and:and:
						to: receiver9 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver10 ] value.! !
!Behavior method!
assert: aResult hasNErrors: count
	#_coverageTracker173026916_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026916_
		coverAll:
			{36 to: 39}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026916_
		coverAll:
			{41 to: 47. 69 to: 75}
		evaluating: [
			receiver3
				assert:
					[ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173026916_
						cover: (49 to: 55)
						declaredAt: (9 to: 15)
						by: aResult.
					#_coverageTracker173026916_
						coverAll:
							{57 to: 62}
						evaluating: [ receiver1 errors ]
						thatSends: #errors
						to: receiver1 ] value.
					#_coverageTracker173026916_
						coverAll:
							{64 to: 67}
						evaluating: [ receiver2 size ]
						thatSends: #size
						to: receiver2 ] value
				equals:
					(#_coverageTracker173026916_
						cover: (77 to: 81)
						declaredAt: (29 to: 33)
						by: count) ]
		thatSends: #assert:equals:
		to: receiver3 ] value.! !
!Behavior method!
newModelMethod: methodReference
	| errorMessage |
	#_coverageTracker173026924_ markAsExecuted.
	#_coverageTracker173026924_
		cover: (55 to: 66)
		declaredAt: (37 to: 48)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173026924_
				coverAll:
					{71 to: 77}
				by: TDDGuru.
			#_coverageTracker173026924_
				coverAll:
					{79 to: 100. 127 to: 132}
				evaluating: [
					receiver3
						methodAddedBeforeTest:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173026924_
								cover: (102 to: 116)
								declaredAt: (17 to: 31)
								by: methodReference.
							#_coverageTracker173026924_
								coverAll:
									{118 to: 125}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173026924_
								cover: (134 to: 148)
								declaredAt: (17 to: 31)
								by: methodReference.
							#_coverageTracker173026924_
								coverAll:
									{150 to: 160}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #methodAddedBeforeTest:class:
				to: receiver3 ] value).
	[ | receiver8 |
	receiver8 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173026924_
		coverAll:
			{166 to: 169}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026924_
		coverAll:
			{171 to: 190}
		evaluating: [ receiver4 currentTestIsDefined ]
		thatSends: #currentTestIsDefined
		to: receiver4 ] value.
	#_coverageTracker173026924_
		coverAll:
			{192 to: 198}
		evaluating: [
			receiver8 ifTrue: [
				#_coverageTracker173026924_
					cover: (205 to: 216)
					declaredAt: (37 to: 48)
					by:
						(errorMessage _ [ | receiver7 |
						receiver7 _ #_coverageTracker173026924_
							coverAll:
								{221 to: 227}
							by: TDDGuru.
						#_coverageTracker173026924_
							coverAll:
								{229 to: 263. 290 to: 295}
							evaluating: [
								receiver7
									modelMethodAddedBeforeRunningTests:
										[ | receiver5 |
										receiver5 _ #_coverageTracker173026924_
											cover: (265 to: 279)
											declaredAt: (17 to: 31)
											by: methodReference.
										#_coverageTracker173026924_
											coverAll:
												{281 to: 288}
											evaluating: [ receiver5 selector ]
											thatSends: #selector
											to: receiver5 ] value
									class:
										[ | receiver6 |
										receiver6 _ #_coverageTracker173026924_
											cover: (297 to: 311)
											declaredAt: (17 to: 31)
											by: methodReference.
										#_coverageTracker173026924_
											coverAll:
												{313 to: 323}
											evaluating: [ receiver6 methodClass ]
											thatSends: #methodClass
											to: receiver6 ] value ]
							thatSends: #modelMethodAddedBeforeRunningTests:class:
							to: receiver7 ] value) ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.
	[ | receiver10 |
	receiver10 _ #_coverageTracker173026924_
		coverAll:
			{331 to: 334}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026924_
		coverAll:
			{336 to: 347. 362 to: 377}
		evaluating: [
			receiver10
				reportError:
					(#_coverageTracker173026924_
						cover: (349 to: 360)
						declaredAt: (37 to: 48)
						by: errorMessage)
				andTransitionTo:
					[ | receiver9 |
					receiver9 _ #_coverageTracker173026924_
						coverAll:
							{379 to: 389}
						by: NotDoingTDD.
					#_coverageTracker173026924_
						coverAll:
							{391 to: 393}
						evaluating: [ receiver9 new ]
						thatSends: #new
						to: receiver9 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver10 ] value.! !
!Behavior method!
for: aChange in: aTimeline
	#_coverageTracker173026946_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026946_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026946_
		coverAll:
			{36 to: 38}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173026946_
		coverAll:
			{43 to: 49}
		evaluating: [
			receiver2 change:
				(#_coverageTracker173026946_
					cover: (51 to: 57)
					declaredAt: (6 to: 12)
					by: aChange) ]
		thatSends: #change:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173026946_
		coverAll:
			{63 to: 71}
		evaluating: [
			receiver3 timeline:
				(#_coverageTracker173026946_
					cover: (73 to: 81)
					declaredAt: (18 to: 26)
					by: aTimeline) ]
		thatSends: #timeline:
		to: receiver3 ] value ] value.! !
!Behavior method!
type
	#_coverageTracker173026951_ markAsExecuted.
	^ #_coverageTracker173026951_
		coverAll:
			{9 to: 24}
		byLiteralOrPseudoVariable: #stateTransition.! !
!Behavior method!
timeDifferenceWithPreviousChange
	| previousEvent timeDifference |
	#_coverageTracker173026954_ markAsExecuted.
	#_coverageTracker173026954_
		cover: (71 to: 83)
		declaredAt: (37 to: 49)
		by:
			(previousEvent _ [ | receiver1 |
			receiver1 _ #_coverageTracker173026954_
				coverAll:
					{88 to: 91}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173026954_
				coverAll:
					{93 to: 105}
				evaluating: [ receiver1 previousEvent ]
				thatSends: #previousEvent
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173026954_
		cover: (109 to: 121)
		declaredAt: (37 to: 49)
		by: previousEvent.
	#_coverageTracker173026954_
		coverAll:
			{123 to: 128}
		evaluating: [ receiver2 ifNil: [ ^ #_coverageTracker173026954_
					coverAll:
						{134 to: 141}
					byLiteralOrPseudoVariable: '00m00s' ]]
		thatSends: #ifNil:
		to: receiver2 ] value.
	#_coverageTracker173026954_
		cover: (149 to: 162)
		declaredAt: (51 to: 64)
		by:
			(timeDifference _ [ | receiver7 |
			receiver7 _ [ | receiver4 |
			receiver4 _ [ | receiver3 |
			receiver3 _ #_coverageTracker173026954_
				coverAll:
					{167 to: 170}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173026954_
				coverAll:
					{172 to: 177}
				evaluating: [ receiver3 change ]
				thatSends: #change
				to: receiver3 ] value.
			#_coverageTracker173026954_
				coverAll:
					{179 to: 182}
				evaluating: [ receiver4 time ]
				thatSends: #time
				to: receiver4 ] value.
			#_coverageTracker173026954_
				coverAll:
					{184 to: 196}
				evaluating: [
					receiver7 distanceFrom:
						[ | receiver6 |
						receiver6 _ [ | receiver5 |
						receiver5 _ #_coverageTracker173026954_
							cover: (198 to: 210)
							declaredAt: (37 to: 49)
							by: previousEvent.
						#_coverageTracker173026954_
							coverAll:
								{212 to: 217}
							evaluating: [ receiver5 change ]
							thatSends: #change
							to: receiver5 ] value.
						#_coverageTracker173026954_
							coverAll:
								{219 to: 222}
							evaluating: [ receiver6 time ]
							thatSends: #time
							to: receiver6 ] value ]
				thatSends: #distanceFrom:
				to: receiver7 ] value).
	[ | receiver16 |
	receiver16 _ [ | receiver10 |
	receiver10 _ #_coverageTracker173026954_
		cover: (227 to: 240)
		declaredAt: (51 to: 64)
		by: timeDifference.
	#_coverageTracker173026954_
		coverAll:
			{242 to: 242}
		evaluating: [
			receiver10 >
				[ | receiver9 |
				receiver9 _ [ | receiver8 |
				receiver8 _ #_coverageTracker173026954_
					coverAll:
						{245 to: 253}
					by: TimeUnits.
				#_coverageTracker173026954_
					coverAll:
						{255 to: 258}
					evaluating: [ receiver8 hour ]
					thatSends: #hour
					to: receiver8 ] value.
				#_coverageTracker173026954_
					coverAll:
						{260 to: 264}
					evaluating: [
						receiver9 with:
							(#_coverageTracker173026954_
								coverAll:
									{266 to: 266}
								byLiteralOrPseudoVariable: 1) ]
					thatSends: #with:
					to: receiver9 ] value ]
		thatSends: #>
		to: receiver10 ] value.
	#_coverageTracker173026954_
		coverAll:
			{271 to: 277. 298 to: 305}
		evaluating: [
			receiver16
				ifTrue: [ ^ #_coverageTracker173026954_
						coverAll:
							{283 to: 291}
						byLiteralOrPseudoVariable: '>1 hour' ]
				ifFalse: [ ^ [ | receiver15 |
					receiver15 _ [ | receiver14 |
					receiver14 _ [ | receiver12 |
					receiver12 _ [ | receiver11 |
					receiver11 _ #_coverageTracker173026954_
						coverAll:
							{312 to: 315}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173026954_
						coverAll:
							{317 to: 332}
						evaluating: [
							receiver11 minutesAsString:
								(#_coverageTracker173026954_
									cover: (334 to: 347)
									declaredAt: (51 to: 64)
									by: timeDifference) ]
						thatSends: #minutesAsString:
						to: receiver11 ] value.
					#_coverageTracker173026954_
						coverAll:
							{349 to: 349}
						evaluating: [
							receiver12 ,
								(#_coverageTracker173026954_
									coverAll:
										{351 to: 353}
									byLiteralOrPseudoVariable: 'm') ]
						thatSends: #,
						to: receiver12 ] value.
					#_coverageTracker173026954_
						coverAll:
							{354 to: 354}
						evaluating: [
							receiver14 ,
								[ | receiver13 |
								receiver13 _ #_coverageTracker173026954_
									coverAll:
										{357 to: 360}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173026954_
									coverAll:
										{362 to: 377}
									evaluating: [
										receiver13 secondsAsString:
											(#_coverageTracker173026954_
												cover: (379 to: 392)
												declaredAt: (51 to: 64)
												by: timeDifference) ]
									thatSends: #secondsAsString:
									to: receiver13 ] value ]
						thatSends: #,
						to: receiver14 ] value.
					#_coverageTracker173026954_
						coverAll:
							{394 to: 394}
						evaluating: [
							receiver15 ,
								(#_coverageTracker173026954_
									coverAll:
										{396 to: 398}
									byLiteralOrPseudoVariable: 's') ]
						thatSends: #,
						to: receiver15 ] value ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver16 ] value.! !
!Behavior method!
name
	#_coverageTracker173026984_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173026984_
		coverAll:
			{9 to: 12}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026984_
		coverAll:
			{14 to: 22}
		evaluating: [ receiver1 className ]
		thatSends: #className
		to: receiver1 ] value.! !
!Behavior method!
= anObject
	#_coverageTracker173026988_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173026988_
		coverAll:
			{15 to: 18}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026988_
		coverAll:
			{20 to: 24}
		evaluating: [ receiver1 class ]
		thatSends: #class
		to: receiver1 ] value.
	#_coverageTracker173026988_
		coverAll:
			{26 to: 26}
		evaluating: [
			receiver2 =
				(#_coverageTracker173026988_
					cover: (28 to: 35)
					declaredAt: (3 to: 10)
					by: anObject) ]
		thatSends: #=
		to: receiver2 ] value.! !
!Behavior method!
testFailed: aSymbol
	#_coverageTracker173026992_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173026992_
		cover: (23 to: 33)
		declaredAt: (23 to: 33)
		by: passedTests.
	#_coverageTracker173026992_
		coverAll:
			{35 to: 41. 51 to: 59}
		evaluating: [
			receiver1
				remove:
					(#_coverageTracker173026992_
						cover: (43 to: 49)
						declaredAt: (13 to: 19)
						by: aSymbol)
				ifAbsent: [ ]]
		thatSends: #remove:ifAbsent:
		to: receiver1 ] value.! !
!Behavior method!
assert: aResult hasErrorWithDescription: aDescription
	#_coverageTracker173026996_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173026996_
		coverAll:
			{56 to: 59}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173026996_
		coverAll:
			{61 to: 67}
		evaluating: [
			receiver3 assert:
				[ | receiver2 |
				receiver2 _ [ | receiver1 |
				receiver1 _ #_coverageTracker173026996_
					cover: (70 to: 76)
					declaredAt: (9 to: 15)
					by: aResult.
				#_coverageTracker173026996_
					coverAll:
						{78 to: 83}
					evaluating: [ receiver1 errors ]
					thatSends: #errors
					to: receiver1 ] value.
				#_coverageTracker173026996_
					coverAll:
						{85 to: 93}
					evaluating: [
						receiver2 includes:
							(#_coverageTracker173026996_
								cover: (95 to: 106)
								declaredAt: (42 to: 53)
								by: aDescription) ]
					thatSends: #includes:
					to: receiver2 ] value ]
		thatSends: #assert:
		to: receiver3 ] value.! !
!Behavior method!
testChanged: aTestReference
	#_coverageTracker173027001_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027001_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027001_
		coverAll:
			{35 to: 48}
		evaluating: [
			receiver1 markAsChanged:
				(#_coverageTracker173027001_
					cover: (50 to: 63)
					declaredAt: (14 to: 27)
					by: aTestReference) ]
		thatSends: #markAsChanged:
		to: receiver1 ] value.! !
!Behavior method!
testDidNotFail: testSelector class: className
	#_coverageTracker173027004_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027004_
		coverAll:
			{52 to: 55}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027004_
		coverAll:
			{57 to: 68. 83 to: 88}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173027004_
						cover: (70 to: 81)
						declaredAt: (17 to: 28)
						by: testSelector)
				class:
					(#_coverageTracker173027004_
						cover: (90 to: 98)
						declaredAt: (37 to: 45)
						by: className) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173027004_
		coverAll:
			{100 to: 100}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027004_
					coverAll:
						{102 to: 136}
					byLiteralOrPseudoVariable: ' passed but it should have failed') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
description
	#_coverageTracker173027010_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027010_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027010_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173027010_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027010_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173027010_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173027010_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027010_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173027010_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173027010_
					coverAll:
						{65 to: 79}
					byLiteralOrPseudoVariable: ' was modified') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173027015_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027015_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173027015_
		coverAll:
			{34 to: 52}
		evaluating: [
			receiver2 modelMethodRemoved:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027015_
					coverAll:
						{54 to: 57}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027015_
					coverAll:
						{59 to: 73}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #modelMethodRemoved:
		to: receiver2 ] value.! !
!Behavior method!
modelMethodRemoved: aSymbol
	#_coverageTracker173027026_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027026_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027026_
		coverAll:
			{36 to: 48}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027026_
					coverAll:
						{50 to: 57}
					by: Refactor.
				#_coverageTracker173027026_
					coverAll:
						{59 to: 61}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
checkIfItWasAValidRefactor
	#_coverageTracker173027031_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173027031_
		cover: (29 to: 38)
		declaredAt: (29 to: 38)
		by: newMethods.
	#_coverageTracker173027031_
		coverAll:
			{40 to: 42}
		evaluating: [
			receiver4 do: [ :aMethodReference |
				[ | receiver3 |
				receiver3 _ [ | receiver1 |
				receiver1 _ #_coverageTracker173027031_
					coverAll:
						{70 to: 73}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027031_
					coverAll:
						{75 to: 81}
					evaluating: [
						receiver1 isUsed:
							(#_coverageTracker173027031_
								cover: (83 to: 98)
								declaredAt: (47 to: 62)
								by: aMethodReference) ]
					thatSends: #isUsed:
					to: receiver1 ] value.
				#_coverageTracker173027031_
					coverAll:
						{101 to: 108}
					evaluating: [
						receiver3 ifFalse: [
							[ | receiver2 |
							receiver2 _ #_coverageTracker173027031_
								coverAll:
									{112 to: 115}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173027031_
								coverAll:
									{117 to: 138}
								evaluating: [
									receiver2 methodWasNotUsedError:
										(#_coverageTracker173027031_
											cover: (140 to: 155)
											declaredAt: (47 to: 62)
											by: aMethodReference) ]
								thatSends: #methodWasNotUsedError:
								to: receiver2 ] value ]]
					thatSends: #ifFalse:
					to: receiver3 ] value ]]
		thatSends: #do:
		to: receiver4 ] value.! !
!Behavior method!
testUtilityChanged: aMethodReference
	#_coverageTracker173027037_ markAsExecuted.! !
!Behavior method!
testRenamedBeforeRunningTheTests: aSymbol class: aSymbol2
	#_coverageTracker173027040_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027040_
		coverAll:
			{64 to: 67}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027040_
		coverAll:
			{69 to: 80. 90 to: 95}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173027040_
						cover: (82 to: 88)
						declaredAt: (35 to: 41)
						by: aSymbol)
				class:
					(#_coverageTracker173027040_
						cover: (97 to: 104)
						declaredAt: (50 to: 57)
						by: aSymbol2) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173027040_
		coverAll:
			{106 to: 106}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027040_
					coverAll:
						{108 to: 146}
					byLiteralOrPseudoVariable: ' was renamed before running the tests') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
newTestClass: aSymbol
	#_coverageTracker173027047_ markAsExecuted.! !
!Behavior method!
testRenamedFrom: previousTestReference to: currentTestReference
	#_coverageTracker173027049_ markAsExecuted.
	self.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027049_
		cover: (67 to: 71)
		declaredAt: (67 to: 71)
		by: tests.
	#_coverageTracker173027049_
		coverAll:
			{73 to: 79}
		evaluating: [
			receiver1 remove:
				(#_coverageTracker173027049_
					cover: (81 to: 101)
					declaredAt: (18 to: 38)
					by: previousTestReference) ]
		thatSends: #remove:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027049_
		cover: (105 to: 109)
		declaredAt: (67 to: 71)
		by: tests.
	#_coverageTracker173027049_
		coverAll:
			{111 to: 114}
		evaluating: [
			receiver2 add:
				(#_coverageTracker173027049_
					cover: (116 to: 135)
					declaredAt: (44 to: 63)
					by: currentTestReference) ]
		thatSends: #add:
		to: receiver2 ] value.! !
!Behavior method!
description
	#_coverageTracker173027054_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027054_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027054_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173027054_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027054_
					coverAll:
						{38 to: 51}
					byLiteralOrPseudoVariable: ' was removed') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
changeClass
	#_coverageTracker173027064_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027064_
		cover: (16 to: 27)
		declaredAt: (16 to: 27)
		by: changeRecord.
	#_coverageTracker173027064_
		coverAll:
			{29 to: 39}
		evaluating: [ receiver1 changeClass ]
		thatSends: #changeClass
		to: receiver1 ] value.! !
!Behavior method!
displayChange: aChange
	| detail |
	#_coverageTracker173027067_ markAsExecuted.
	[ | receiver10 |
	receiver10 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027067_
		cover: (40 to: 44)
		declaredAt: (40 to: 44)
		by: model.
	#_coverageTracker173027067_
		coverAll:
			{46 to: 55}
		evaluating: [
			receiver1 isCorrect:
				(#_coverageTracker173027067_
					cover: (57 to: 63)
					declaredAt: (16 to: 22)
					by: aChange) ]
		thatSends: #isCorrect:
		to: receiver1 ] value.
	#_coverageTracker173027067_
		coverAll:
			{68 to: 74. 170 to: 177}
		evaluating: [
			receiver10
				ifTrue: [
					[ | receiver2 |
					receiver2 _ #_coverageTracker173027067_
						cover: (78 to: 94)
						declaredAt: (78 to: 94)
						by: changeDetailTitle.
					#_coverageTracker173027067_
						coverAll:
							{96 to: 104}
						evaluating: [
							receiver2 contents:
								(#_coverageTracker173027067_
									coverAll:
										{106 to: 114}
									byLiteralOrPseudoVariable: 'CORRECT') ]
						thatSends: #contents:
						to: receiver2 ] value.
					[ | receiver5 |
					receiver5 _ #_coverageTracker173027067_
						cover: (117 to: 133)
						declaredAt: (78 to: 94)
						by: changeDetailTitle.
					#_coverageTracker173027067_
						coverAll:
							{135 to: 140}
						evaluating: [
							receiver5 color:
								[ | receiver4 |
								receiver4 _ [ | receiver3 |
								receiver3 _ #_coverageTracker173027067_
									coverAll:
										{142 to: 145}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173027067_
									coverAll:
										{147 to: 151}
									evaluating: [ receiver3 class ]
									thatSends: #class
									to: receiver3 ] value.
								#_coverageTracker173027067_
									coverAll:
										{153 to: 164}
									evaluating: [ receiver4 successColor ]
									thatSends: #successColor
									to: receiver4 ] value ]
						thatSends: #color:
						to: receiver5 ] value ]
				ifFalse: [
					[ | receiver6 |
					receiver6 _ #_coverageTracker173027067_
						cover: (181 to: 197)
						declaredAt: (78 to: 94)
						by: changeDetailTitle.
					#_coverageTracker173027067_
						coverAll:
							{199 to: 207}
						evaluating: [
							receiver6 contents:
								(#_coverageTracker173027067_
									coverAll:
										{209 to: 215}
									byLiteralOrPseudoVariable: 'ERROR') ]
						thatSends: #contents:
						to: receiver6 ] value.
					[ | receiver9 |
					receiver9 _ #_coverageTracker173027067_
						cover: (218 to: 234)
						declaredAt: (78 to: 94)
						by: changeDetailTitle.
					#_coverageTracker173027067_
						coverAll:
							{236 to: 241}
						evaluating: [
							receiver9 color:
								[ | receiver8 |
								receiver8 _ [ | receiver7 |
								receiver7 _ #_coverageTracker173027067_
									coverAll:
										{243 to: 246}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173027067_
									coverAll:
										{248 to: 252}
									evaluating: [ receiver7 class ]
									thatSends: #class
									to: receiver7 ] value.
								#_coverageTracker173027067_
									coverAll:
										{254 to: 263}
									evaluating: [ receiver8 errorColor ]
									thatSends: #errorColor
									to: receiver8 ] value ]
						thatSends: #color:
						to: receiver9 ] value ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver10 ] value.
	#_coverageTracker173027067_
		cover: (272 to: 277)
		declaredAt: (27 to: 32)
		by:
			(detail _ #_coverageTracker173027067_
				coverAll:
					{282 to: 283}
				byLiteralOrPseudoVariable: '').
	[ | receiver16 |
	receiver16 _ [ | receiver11 |
	receiver11 _ #_coverageTracker173027067_
		cover: (288 to: 292)
		declaredAt: (40 to: 44)
		by: model.
	#_coverageTracker173027067_
		coverAll:
			{294 to: 302}
		evaluating: [
			receiver11 hasError:
				(#_coverageTracker173027067_
					cover: (304 to: 310)
					declaredAt: (16 to: 22)
					by: aChange) ]
		thatSends: #hasError:
		to: receiver11 ] value.
	#_coverageTracker173027067_
		coverAll:
			{313 to: 319}
		evaluating: [
			receiver16 ifTrue: [
				#_coverageTracker173027067_
					cover: (336 to: 341)
					declaredAt: (27 to: 32)
					by:
						(detail _ [ | receiver13 |
						receiver13 _ #_coverageTracker173027067_
							cover: (326 to: 331)
							declaredAt: (27 to: 32)
							by: detail.
						#_coverageTracker173027067_
							coverAll:
								{343 to: 349}
							evaluating: [
								receiver13 append:
									[ | receiver12 |
									receiver12 _ #_coverageTracker173027067_
										cover: (352 to: 356)
										declaredAt: (40 to: 44)
										by: model.
									#_coverageTracker173027067_
										coverAll:
											{358 to: 365}
										evaluating: [
											receiver12 errorIn:
												(#_coverageTracker173027067_
													cover: (367 to: 373)
													declaredAt: (16 to: 22)
													by: aChange) ]
										thatSends: #errorIn:
										to: receiver12 ] value ]
							thatSends: #append:
							to: receiver13 ] value).
				#_coverageTracker173027067_
					cover: (390 to: 395)
					declaredAt: (27 to: 32)
					by:
						(detail _ [ | receiver15 |
						receiver15 _ #_coverageTracker173027067_
							cover: (380 to: 385)
							declaredAt: (27 to: 32)
							by: detail.
						#_coverageTracker173027067_
							coverAll:
								{397 to: 403}
							evaluating: [
								receiver15 append:
									[ | receiver14 |
									receiver14 _ #_coverageTracker173027067_
										coverAll:
											{405 to: 410}
										by: String.
									#_coverageTracker173027067_
										coverAll:
											{412 to: 424}
										evaluating: [ receiver14 newLineString ]
										thatSends: #newLineString
										to: receiver14 ] value ]
							thatSends: #append:
							to: receiver15 ] value) ]]
		thatSends: #ifTrue:
		to: receiver16 ] value.
	[ | receiver17 |
	receiver17 _ #_coverageTracker173027067_
		cover: (431 to: 442)
		declaredAt: (431 to: 442)
		by: changeDetail.
	#_coverageTracker173027067_
		coverAll:
			{444 to: 452}
		evaluating: [
			receiver17 contents:
				(#_coverageTracker173027067_
					cover: (454 to: 459)
					declaredAt: (27 to: 32)
					by: detail) ]
		thatSends: #contents:
		to: receiver17 ] value.! !
!Behavior method!
testClassRemoved: className
	#_coverageTracker173027108_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027108_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027108_
		coverAll:
			{35 to: 52}
		evaluating: [
			receiver1 modelClassRemoved:
				(#_coverageTracker173027108_
					cover: (54 to: 62)
					declaredAt: (19 to: 27)
					by: className) ]
		thatSends: #modelClassRemoved:
		to: receiver1 ] value.! !
!Behavior method!
testRenamedFrom: fromMethodReference to: toMethodReference
	| errorMessage |
	#_coverageTracker173027112_ markAsExecuted.
	#_coverageTracker173027112_
		cover: (82 to: 93)
		declaredAt: (64 to: 75)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173027112_
				coverAll:
					{98 to: 104}
				by: TDDGuru.
			#_coverageTracker173027112_
				coverAll:
					{106 to: 138. 169 to: 174}
				evaluating: [
					receiver3
						testRenamedBeforeRunningTheTests:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173027112_
								cover: (140 to: 158)
								declaredAt: (18 to: 36)
								by: fromMethodReference.
							#_coverageTracker173027112_
								coverAll:
									{160 to: 167}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173027112_
								cover: (176 to: 192)
								declaredAt: (42 to: 58)
								by: toMethodReference.
							#_coverageTracker173027112_
								coverAll:
									{194 to: 204}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #testRenamedBeforeRunningTheTests:class:
				to: receiver3 ] value).
	[ | receiver5 |
	receiver5 _ #_coverageTracker173027112_
		coverAll:
			{208 to: 211}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027112_
		coverAll:
			{213 to: 224. 239 to: 254}
		evaluating: [
			receiver5
				reportError:
					(#_coverageTracker173027112_
						cover: (226 to: 237)
						declaredAt: (64 to: 75)
						by: errorMessage)
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173027112_
						coverAll:
							{256 to: 266}
						by: NotDoingTDD.
					#_coverageTracker173027112_
						coverAll:
							{268 to: 270}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
nextChange
	#_coverageTracker173027121_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027121_
		cover: (15 to: 29)
		declaredAt: (15 to: 29)
		by: changeDetectors.
	#_coverageTracker173027121_
		coverAll:
			{31 to: 33}
		evaluating: [
			receiver2 do: [ :changeDetector |
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027121_
					cover: (58 to: 71)
					declaredAt: (38 to: 51)
					by: changeDetector.
				#_coverageTracker173027121_
					coverAll:
						{73 to: 87. 100 to: 106}
					evaluating: [
						receiver1
							detectChangeIn:
								(#_coverageTracker173027121_
									cover: (89 to: 98)
									declaredAt: (89 to: 98)
									by: changeList)
							ifTrue: [ :change |
								^ #_coverageTracker173027121_
									cover: (122 to: 127)
									declaredAt: (111 to: 116)
									by: change ]]
					thatSends: #detectChangeIn:ifTrue:
					to: receiver1 ] value ]]
		thatSends: #do:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027121_
		coverAll:
			{137 to: 140}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027121_
		coverAll:
			{142 to: 147}
		evaluating: [
			receiver3 error:
				(#_coverageTracker173027121_
					coverAll:
						{149 to: 168}
					byLiteralOrPseudoVariable: 'No change detected') ]
		thatSends: #error:
		to: receiver3 ] value.! !
!Behavior method!
newTestClass: aSymbol
	#_coverageTracker173027128_ markAsExecuted.! !
!Behavior method!
category
	#_coverageTracker173027129_ markAsExecuted.
	^ #_coverageTracker173027129_
		coverAll:
			{13 to: 26}
		byLiteralOrPseudoVariable: #newModelClass.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173027132_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027132_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173027132_
		coverAll:
			{34 to: 44}
		evaluating: [
			receiver2 testFailed:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027132_
					coverAll:
						{46 to: 49}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027132_
					coverAll:
						{51 to: 63}
					evaluating: [ receiver1 testReference ]
					thatSends: #testReference
					to: receiver1 ] value ]
		thatSends: #testFailed:
		to: receiver2 ] value.! !
!Behavior method!
classRemovedBeforeRunningTests: className
	#_coverageTracker173027135_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027135_
		coverAll:
			{47 to: 54}
		byLiteralOrPseudoVariable: 'Class '.
	#_coverageTracker173027135_
		coverAll:
			{55 to: 55}
		evaluating: [
			receiver1 ,
				(#_coverageTracker173027135_
					cover: (57 to: 65)
					declaredAt: (33 to: 41)
					by: className) ]
		thatSends: #,
		to: receiver1 ] value.
	#_coverageTracker173027135_
		coverAll:
			{66 to: 66}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027135_
					coverAll:
						{68 to: 112}
					byLiteralOrPseudoVariable: ' was removed before running the tests first') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
initialize
	#_coverageTracker173027150_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027150_
		coverAll:
			{13 to: 16}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027150_
		coverAll:
			{18 to: 36}
		evaluating: [ receiver1 initializeInventory ]
		thatSends: #initializeInventory
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027150_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027150_
		coverAll:
			{45 to: 57}
		evaluating: [
			receiver3 initialState:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027150_
					coverAll:
						{59 to: 68}
					by: NotStarted.
				#_coverageTracker173027150_
					coverAll:
						{70 to: 72}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #initialState:
		to: receiver3 ] value.
	#_coverageTracker173027150_
		cover: (76 to: 99)
		declaredAt: (76 to: 99)
		by:
			(changesFileStartPosition _ #_coverageTracker173027150_
				coverAll:
					{104 to: 104}
				byLiteralOrPseudoVariable: 0).
	#_coverageTracker173027150_
		cover: (108 to: 120)
		declaredAt: (108 to: 120)
		by:
			(startingPoint _ #_coverageTracker173027150_
				coverAll:
					{125 to: 125}
				byLiteralOrPseudoVariable: 1).! !
!Behavior method!
newTestClass: aSymbol
	#_coverageTracker173027157_ markAsExecuted.! !
!Behavior method!
testPassed: aSymbol
	#_coverageTracker173027159_ markAsExecuted.! !
!Behavior method!
printString
	#_coverageTracker173027161_ markAsExecuted.
	^ #_coverageTracker173027161_
		coverAll:
			{16 to: 30}
		byLiteralOrPseudoVariable: 'Not doing TDD'.! !
!Behavior method!
changeTime
	#_coverageTracker173027164_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027164_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027164_
		coverAll:
			{21 to: 26}
		evaluating: [ receiver1 change ]
		thatSends: #change
		to: receiver1 ] value.
	#_coverageTracker173027164_
		coverAll:
			{28 to: 37}
		evaluating: [ receiver2 timeString ]
		thatSends: #timeString
		to: receiver2 ] value.! !
!Behavior method!
markAsNew: aMethodReference
	#_coverageTracker173027167_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027167_
		cover: (31 to: 40)
		declaredAt: (31 to: 40)
		by: newMethods.
	#_coverageTracker173027167_
		coverAll:
			{42 to: 48. 67 to: 75}
		evaluating: [
			receiver1
				remove:
					(#_coverageTracker173027167_
						cover: (50 to: 65)
						declaredAt: (12 to: 27)
						by: aMethodReference)
				ifAbsent: [ ]]
		thatSends: #remove:ifAbsent:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027167_
		cover: (82 to: 91)
		declaredAt: (31 to: 40)
		by: newMethods.
	#_coverageTracker173027167_
		coverAll:
			{93 to: 96}
		evaluating: [
			receiver2 add:
				(#_coverageTracker173027167_
					cover: (98 to: 113)
					declaredAt: (12 to: 27)
					by: aMethodReference) ]
		thatSends: #add:
		to: receiver2 ] value.! !
!Behavior method!
code
	| changeClass sourceString |
	#_coverageTracker173027173_ markAsExecuted.
	#_coverageTracker173027173_
		cover: (37 to: 48)
		declaredAt: (21 to: 32)
		by:
			(sourceString _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027173_
				cover: (53 to: 64)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173027173_
				coverAll:
					{66 to: 71}
				evaluating: [ receiver1 string ]
				thatSends: #string
				to: receiver1 ] value).
	#_coverageTracker173027173_
		cover: (75 to: 85)
		declaredAt: (9 to: 19)
		by:
			(changeClass _ [ | receiver2 |
			receiver2 _ #_coverageTracker173027173_
				cover: (90 to: 101)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173027173_
				coverAll:
					{103 to: 113}
				evaluating: [ receiver2 changeClass ]
				thatSends: #changeClass
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027173_
		cover: (117 to: 127)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173027173_
		coverAll:
			{129 to: 134}
		evaluating: [ receiver3 ifNil: [ ^ #_coverageTracker173027173_
					cover: (140 to: 151)
					declaredAt: (21 to: 32)
					by: sourceString ]]
		thatSends: #ifNil:
		to: receiver3 ] value.
	^ [ | receiver8 |
	receiver8 _ [
	[ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173027173_
		cover: (162 to: 172)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173027173_
		coverAll:
			{174 to: 186}
		evaluating: [ receiver4 compilerClass ]
		thatSends: #compilerClass
		to: receiver4 ] value.
	#_coverageTracker173027173_
		coverAll:
			{188 to: 190}
		evaluating: [ receiver5 new ]
		thatSends: #new
		to: receiver5 ] value.
	#_coverageTracker173027173_
		coverAll:
			{194 to: 200. 215 to: 217. 231 to: 240}
		evaluating: [
			receiver6
				format:
					(#_coverageTracker173027173_
						cover: (202 to: 213)
						declaredAt: (21 to: 32)
						by: sourceString)
				in:
					(#_coverageTracker173027173_
						cover: (219 to: 229)
						declaredAt: (9 to: 19)
						by: changeClass)
				notifying:
					(#_coverageTracker173027173_
						coverAll:
							{242 to: 244}
						byLiteralOrPseudoVariable: nil) ]
		thatSends: #format:in:notifying:
		to: receiver6 ] value ].
	#_coverageTracker173027173_
		coverAll:
			{249 to: 251. 283 to: 285}
		evaluating: [
			receiver8
				on:
					(#_coverageTracker173027173_
						coverAll:
							{253 to: 279}
						by: InMidstOfFileinNotification)
				do: [ :anException |
					[ | receiver7 |
					receiver7 _ #_coverageTracker173027173_
						cover: (304 to: 314)
						declaredAt: (290 to: 300)
						by: anException.
					#_coverageTracker173027173_
						coverAll:
							{316 to: 322}
						evaluating: [
							receiver7 resume:
								(#_coverageTracker173027173_
									coverAll:
										{324 to: 327}
									byLiteralOrPseudoVariable: true) ]
						thatSends: #resume:
						to: receiver7 ] value ]]
		thatSends: #on:do:
		to: receiver8 ] value.! !
!Behavior method!
modelClassRemoved: aSymbol
	#_coverageTracker173027197_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027197_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027197_
		coverAll:
			{35 to: 67}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027197_
		coverAll:
			{71 to: 74}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027197_
		coverAll:
			{76 to: 88}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027197_
					coverAll:
						{90 to: 100}
					by: NotDoingTDD.
				#_coverageTracker173027197_
					coverAll:
						{102 to: 104}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
modelMethodChanged: aMethodReference
	#_coverageTracker173027202_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027202_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027202_
		coverAll:
			{45 to: 58}
		evaluating: [
			receiver1 markAsChanged:
				(#_coverageTracker173027202_
					cover: (60 to: 75)
					declaredAt: (21 to: 36)
					by: aMethodReference) ]
		thatSends: #markAsChanged:
		to: receiver1 ] value.! !
!Behavior method!
lastStateTransitionBefore: aChange
	| indexOfEvent stateTransitionsBefore eventsUpToChangeEvent |
	#_coverageTracker173027208_ markAsExecuted.
	#_coverageTracker173027208_
		cover: (103 to: 114)
		declaredAt: (40 to: 51)
		by:
			(indexOfEvent _ [ | receiver6 |
			receiver6 _ #_coverageTracker173027208_
				cover: (119 to: 124)
				declaredAt: (119 to: 124)
				by: events.
			#_coverageTracker173027208_
				coverAll:
					{126 to: 134}
				evaluating: [
					receiver6 findLast: [ :event |
						[ | receiver5 |
						receiver5 _ [ | receiver2 |
						receiver2 _ [ | receiver1 |
						receiver1 _ #_coverageTracker173027208_
							cover: (147 to: 151)
							declaredAt: (139 to: 143)
							by: event.
						#_coverageTracker173027208_
							coverAll:
								{153 to: 156}
							evaluating: [ receiver1 type ]
							thatSends: #type
							to: receiver1 ] value.
						#_coverageTracker173027208_
							coverAll:
								{158 to: 158}
							evaluating: [
								receiver2 =
									(#_coverageTracker173027208_
										coverAll:
											{160 to: 166}
										byLiteralOrPseudoVariable: #change) ]
							thatSends: #=
							to: receiver2 ] value.
						#_coverageTracker173027208_
							coverAll:
								{168 to: 171}
							evaluating: [
								receiver5 and: [
									[ | receiver4 |
									receiver4 _ [ | receiver3 |
									receiver3 _ #_coverageTracker173027208_
										cover: (175 to: 179)
										declaredAt: (139 to: 143)
										by: event.
									#_coverageTracker173027208_
										coverAll:
											{181 to: 186}
										evaluating: [ receiver3 change ]
										thatSends: #change
										to: receiver3 ] value.
									#_coverageTracker173027208_
										coverAll:
											{188 to: 188}
										evaluating: [
											receiver4 =
												(#_coverageTracker173027208_
													cover: (190 to: 196)
													declaredAt: (28 to: 34)
													by: aChange) ]
										thatSends: #=
										to: receiver4 ] value ]]
							thatSends: #and:
							to: receiver5 ] value ]]
				thatSends: #findLast:
				to: receiver6 ] value).
	#_coverageTracker173027208_
		cover: (203 to: 223)
		declaredAt: (76 to: 96)
		by:
			(eventsUpToChangeEvent _ [ | receiver8 |
			receiver8 _ #_coverageTracker173027208_
				cover: (228 to: 233)
				declaredAt: (119 to: 124)
				by: events.
			#_coverageTracker173027208_
				coverAll:
					{235 to: 243. 247 to: 249}
				evaluating: [
					receiver8
						copyFrom:
							(#_coverageTracker173027208_
								coverAll:
									{245 to: 245}
								byLiteralOrPseudoVariable: 1)
						to:
							[ | receiver7 |
							receiver7 _ #_coverageTracker173027208_
								cover: (252 to: 263)
								declaredAt: (40 to: 51)
								by: indexOfEvent.
							#_coverageTracker173027208_
								coverAll:
									{265 to: 265}
								evaluating: [
									receiver7 -
										(#_coverageTracker173027208_
											coverAll:
												{267 to: 267}
											byLiteralOrPseudoVariable: 1) ]
								thatSends: #-
								to: receiver7 ] value ]
				thatSends: #copyFrom:to:
				to: receiver8 ] value).
	#_coverageTracker173027208_
		cover: (272 to: 293)
		declaredAt: (53 to: 74)
		by:
			(stateTransitionsBefore _ [ | receiver11 |
			receiver11 _ #_coverageTracker173027208_
				cover: (298 to: 318)
				declaredAt: (76 to: 96)
				by: eventsUpToChangeEvent.
			#_coverageTracker173027208_
				coverAll:
					{320 to: 326}
				evaluating: [
					receiver11 select: [ :event |
						[ | receiver10 |
						receiver10 _ [ | receiver9 |
						receiver9 _ #_coverageTracker173027208_
							cover: (339 to: 343)
							declaredAt: (331 to: 335)
							by: event.
						#_coverageTracker173027208_
							coverAll:
								{345 to: 348}
							evaluating: [ receiver9 type ]
							thatSends: #type
							to: receiver9 ] value.
						#_coverageTracker173027208_
							coverAll:
								{350 to: 350}
							evaluating: [
								receiver10 =
									(#_coverageTracker173027208_
										coverAll:
											{352 to: 367}
										byLiteralOrPseudoVariable: #stateTransition) ]
							thatSends: #=
							to: receiver10 ] value ]]
				thatSends: #select:
				to: receiver11 ] value).
	^ [ | receiver12 |
	receiver12 _ #_coverageTracker173027208_
		cover: (377 to: 398)
		declaredAt: (53 to: 74)
		by: stateTransitionsBefore.
	#_coverageTracker173027208_
		coverAll:
			{400 to: 403}
		evaluating: [ receiver12 last ]
		thatSends: #last
		to: receiver12 ] value.! !
!Behavior method!
testRemoved: methodReference
	#_coverageTracker173027229_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173027229_
		coverAll:
			{32 to: 35}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027229_
		coverAll:
			{37 to: 48. 153 to: 168}
		evaluating: [
			receiver5
				reportError:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173027229_
						coverAll:
							{51 to: 57}
						by: TDDGuru.
					#_coverageTracker173027229_
						coverAll:
							{59 to: 90. 117 to: 122}
						evaluating: [
							receiver3
								methodRemovedBeforeRunningTests:
									[ | receiver1 |
									receiver1 _ #_coverageTracker173027229_
										cover: (92 to: 106)
										declaredAt: (14 to: 28)
										by: methodReference.
									#_coverageTracker173027229_
										coverAll:
											{108 to: 115}
										evaluating: [ receiver1 selector ]
										thatSends: #selector
										to: receiver1 ] value
								class:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173027229_
										cover: (124 to: 138)
										declaredAt: (14 to: 28)
										by: methodReference.
									#_coverageTracker173027229_
										coverAll:
											{140 to: 150}
										evaluating: [ receiver2 methodClass ]
										thatSends: #methodClass
										to: receiver2 ] value ]
						thatSends: #methodRemovedBeforeRunningTests:class:
						to: receiver3 ] value
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173027229_
						coverAll:
							{170 to: 180}
						by: NotDoingTDD.
					#_coverageTracker173027229_
						coverAll:
							{182 to: 184}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
userChangesForTestFileExtension
	#_coverageTracker173027245_ markAsExecuted.
	^ #_coverageTracker173027245_
		coverAll:
			{36 to: 50}
		byLiteralOrPseudoVariable: '.test.changes'.! !
!Behavior method!
modelMethodRemoved: aMethodReference
	#_coverageTracker173027247_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027247_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027247_
		coverAll:
			{45 to: 77}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027247_
		coverAll:
			{81 to: 84}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027247_
		coverAll:
			{86 to: 98}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027247_
					coverAll:
						{100 to: 110}
					by: NotDoingTDD.
				#_coverageTracker173027247_
					coverAll:
						{112 to: 114}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
removeClass: aSymbol
	| class |
	#_coverageTracker173027252_ markAsExecuted.
	#_coverageTracker173027252_
		cover: (35 to: 39)
		declaredAt: (26 to: 30)
		by:
			(class _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027252_
				coverAll:
					{44 to: 47}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027252_
				coverAll:
					{49 to: 59}
				evaluating: [
					receiver1 classNamed:
						(#_coverageTracker173027252_
							cover: (61 to: 67)
							declaredAt: (14 to: 20)
							by: aSymbol) ]
				thatSends: #classNamed:
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027252_
		cover: (71 to: 75)
		declaredAt: (26 to: 30)
		by: class.
	#_coverageTracker173027252_
		coverAll:
			{77 to: 92}
		evaluating: [ receiver2 removeFromSystem ]
		thatSends: #removeFromSystem
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027252_
		cover: (96 to: 108)
		declaredAt: (96 to: 108)
		by: classesByName.
	#_coverageTracker173027252_
		coverAll:
			{110 to: 119}
		evaluating: [
			receiver3 removeKey:
				(#_coverageTracker173027252_
					cover: (121 to: 127)
					declaredAt: (14 to: 20)
					by: aSymbol) ]
		thatSends: #removeKey:
		to: receiver3 ] value.! !
!Behavior method!
modelClassRemoved: aSymbol
	#_coverageTracker173027258_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027258_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027258_
		coverAll:
			{35 to: 46. 98 to: 113}
		evaluating: [
			receiver3
				reportError:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173027258_
						coverAll:
							{49 to: 55}
						by: TDDGuru.
					#_coverageTracker173027258_
						coverAll:
							{57 to: 87}
						evaluating: [
							receiver1 classRemovedBeforeRunningTests:
								(#_coverageTracker173027258_
									cover: (89 to: 95)
									declaredAt: (20 to: 26)
									by: aSymbol) ]
						thatSends: #classRemovedBeforeRunningTests:
						to: receiver1 ] value
				andTransitionTo:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173027258_
						coverAll:
							{115 to: 125}
						by: NotDoingTDD.
					#_coverageTracker173027258_
						coverAll:
							{127 to: 129}
						evaluating: [ receiver2 new ]
						thatSends: #new
						to: receiver2 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver3 ] value.! !
!Behavior method!
testChanged: aTestReference
	| errorMessage |
	#_coverageTracker173027266_ markAsExecuted.
	[ | receiver8 |
	receiver8 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173027266_
		cover: (51 to: 64)
		declaredAt: (14 to: 27)
		by: aTestReference.
	#_coverageTracker173027266_
		coverAll:
			{66 to: 67}
		evaluating: [
			receiver2 ~=
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027266_
					coverAll:
						{69 to: 72}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027266_
					coverAll:
						{74 to: 84}
					evaluating: [ receiver1 currentTest ]
					thatSends: #currentTest
					to: receiver1 ] value ]
		thatSends: #~=
		to: receiver2 ] value.
	#_coverageTracker173027266_
		coverAll:
			{86 to: 92}
		evaluating: [
			receiver8 ifTrue: [
				#_coverageTracker173027266_
					cover: (99 to: 110)
					declaredAt: (35 to: 46)
					by:
						(errorMessage _ [ | receiver5 |
						receiver5 _ #_coverageTracker173027266_
							coverAll:
								{115 to: 121}
							by: TDDGuru.
						#_coverageTracker173027266_
							coverAll:
								{123 to: 162. 188 to: 190}
							evaluating: [
								receiver5
									testChangedWhileThisTestWasBeingWritten:
										[ | receiver3 |
										receiver3 _ #_coverageTracker173027266_
											cover: (164 to: 177)
											declaredAt: (14 to: 27)
											by: aTestReference.
										#_coverageTracker173027266_
											coverAll:
												{179 to: 186}
											evaluating: [ receiver3 selector ]
											thatSends: #selector
											to: receiver3 ] value
									in:
										[ | receiver4 |
										receiver4 _ #_coverageTracker173027266_
											cover: (192 to: 205)
											declaredAt: (14 to: 27)
											by: aTestReference.
										#_coverageTracker173027266_
											coverAll:
												{207 to: 217}
											evaluating: [ receiver4 methodClass ]
											thatSends: #methodClass
											to: receiver4 ] value ]
							thatSends: #testChangedWhileThisTestWasBeingWritten:in:
							to: receiver5 ] value).
				[ | receiver7 |
				receiver7 _ #_coverageTracker173027266_
					coverAll:
						{222 to: 225}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027266_
					coverAll:
						{227 to: 238. 253 to: 268}
					evaluating: [
						receiver7
							reportError:
								(#_coverageTracker173027266_
									cover: (240 to: 251)
									declaredAt: (35 to: 46)
									by: errorMessage)
							andTransitionTo:
								[ | receiver6 |
								receiver6 _ #_coverageTracker173027266_
									coverAll:
										{270 to: 280}
									by: NotDoingTDD.
								#_coverageTracker173027266_
									coverAll:
										{282 to: 284}
									evaluating: [ receiver6 new ]
									thatSends: #new
									to: receiver6 ] value ]
					thatSends: #reportError:andTransitionTo:
					to: receiver7 ] value ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.! !
!Behavior method!
testRenamedDetector
	| isANewTestChange isAMethodRemovedChange sameClassAndStamp testExists |
	#_coverageTracker173027282_ markAsExecuted.
	#_coverageTracker173027282_
		cover: (97 to: 112)
		declaredAt: (24 to: 39)
		by:
			(isANewTestChange _ [ :changeRecord |
			[ | receiver9 |
			receiver9 _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027282_
				cover: (138 to: 149)
				declaredAt: (120 to: 131)
				by: changeRecord.
			#_coverageTracker173027282_
				coverAll:
					{151 to: 160}
				evaluating: [ receiver1 changeType ]
				thatSends: #changeType
				to: receiver1 ] value.
			#_coverageTracker173027282_
				coverAll:
					{162 to: 162}
				evaluating: [
					receiver2 =
						(#_coverageTracker173027282_
							coverAll:
								{164 to: 170}
							byLiteralOrPseudoVariable: #method) ]
				thatSends: #=
				to: receiver2 ] value.
			#_coverageTracker173027282_
				coverAll:
					{175 to: 178. 221 to: 224. 275 to: 278}
				evaluating: [
					receiver9
						and: [
							[ | receiver4 |
							receiver4 _ [ | receiver3 |
							receiver3 _ #_coverageTracker173027282_
								cover: (182 to: 193)
								declaredAt: (120 to: 131)
								by: changeRecord.
							#_coverageTracker173027282_
								coverAll:
									{195 to: 210}
								evaluating: [ receiver3 isMethodDeletion ]
								thatSends: #isMethodDeletion
								to: receiver3 ] value.
							#_coverageTracker173027282_
								coverAll:
									{212 to: 214}
								evaluating: [ receiver4 not ]
								thatSends: #not
								to: receiver4 ] value ]
						and: [
							[ | receiver6 |
							receiver6 _ [ | receiver5 |
							receiver5 _ #_coverageTracker173027282_
								cover: (228 to: 239)
								declaredAt: (120 to: 131)
								by: changeRecord.
							#_coverageTracker173027282_
								coverAll:
									{241 to: 254}
								evaluating: [ receiver5 methodSelector ]
								thatSends: #methodSelector
								to: receiver5 ] value.
							#_coverageTracker173027282_
								coverAll:
									{256 to: 269}
								evaluating: [ receiver6 isTestSelector ]
								thatSends: #isTestSelector
								to: receiver6 ] value ]
						and: [
							[ | receiver8 |
							receiver8 _ [ | receiver7 |
							receiver7 _ #_coverageTracker173027282_
								cover: (282 to: 293)
								declaredAt: (120 to: 131)
								by: changeRecord.
							#_coverageTracker173027282_
								coverAll:
									{295 to: 299}
								evaluating: [ receiver7 prior ]
								thatSends: #prior
								to: receiver7 ] value.
							#_coverageTracker173027282_
								coverAll:
									{301 to: 305}
								evaluating: [ receiver8 isNil ]
								thatSends: #isNil
								to: receiver8 ] value ]]
				thatSends: #and:and:and:
				to: receiver9 ] value ]).
	#_coverageTracker173027282_
		cover: (312 to: 333)
		declaredAt: (41 to: 62)
		by:
			(isAMethodRemovedChange _ [ :changeRecord |
			[ | receiver10 |
			receiver10 _ #_coverageTracker173027282_
				cover: (356 to: 367)
				declaredAt: (341 to: 352)
				by: changeRecord.
			#_coverageTracker173027282_
				coverAll:
					{369 to: 384}
				evaluating: [ receiver10 isMethodDeletion ]
				thatSends: #isMethodDeletion
				to: receiver10 ] value ]).
	#_coverageTracker173027282_
		cover: (389 to: 405)
		declaredAt: (64 to: 80)
		by:
			(sameClassAndStamp _ [ :previous :current |
			[ | receiver17 |
			receiver17 _ [ | receiver13 |
			receiver13 _ [ | receiver11 |
			receiver11 _ #_coverageTracker173027282_
				cover: (436 to: 443)
				declaredAt: (413 to: 420)
				by: previous.
			#_coverageTracker173027282_
				coverAll:
					{445 to: 459}
				evaluating: [ receiver11 changeClassName ]
				thatSends: #changeClassName
				to: receiver11 ] value.
			#_coverageTracker173027282_
				coverAll:
					{461 to: 461}
				evaluating: [
					receiver13 =
						[ | receiver12 |
						receiver12 _ #_coverageTracker173027282_
							cover: (463 to: 469)
							declaredAt: (423 to: 429)
							by: current.
						#_coverageTracker173027282_
							coverAll:
								{471 to: 485}
							evaluating: [ receiver12 changeClassName ]
							thatSends: #changeClassName
							to: receiver12 ] value ]
				thatSends: #=
				to: receiver13 ] value.
			#_coverageTracker173027282_
				coverAll:
					{489 to: 492}
				evaluating: [
					receiver17 and: [
						[ | receiver16 |
						receiver16 _ [ | receiver14 |
						receiver14 _ #_coverageTracker173027282_
							cover: (496 to: 503)
							declaredAt: (413 to: 420)
							by: previous.
						#_coverageTracker173027282_
							coverAll:
								{505 to: 509}
							evaluating: [ receiver14 stamp ]
							thatSends: #stamp
							to: receiver14 ] value.
						#_coverageTracker173027282_
							coverAll:
								{511 to: 511}
							evaluating: [
								receiver16 =
									[ | receiver15 |
									receiver15 _ #_coverageTracker173027282_
										cover: (513 to: 519)
										declaredAt: (423 to: 429)
										by: current.
									#_coverageTracker173027282_
										coverAll:
											{521 to: 525}
										evaluating: [ receiver15 stamp ]
										thatSends: #stamp
										to: receiver15 ] value ]
							thatSends: #=
							to: receiver16 ] value ]]
				thatSends: #and:
				to: receiver17 ] value ]).
	#_coverageTracker173027282_
		cover: (532 to: 541)
		declaredAt: (82 to: 91)
		by:
			(testExists _ [ :changeRecord |
			[ | receiver20 |
			receiver20 _ #_coverageTracker173027282_
				coverAll:
					{564 to: 567}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027282_
				coverAll:
					{569 to: 582. 612 to: 617}
				evaluating: [
					receiver20
						testIsTracked:
							[ | receiver18 |
							receiver18 _ #_coverageTracker173027282_
								cover: (584 to: 595)
								declaredAt: (549 to: 560)
								by: changeRecord.
							#_coverageTracker173027282_
								coverAll:
									{597 to: 610}
								evaluating: [ receiver18 methodSelector ]
								thatSends: #methodSelector
								to: receiver18 ] value
						class:
							[ | receiver19 |
							receiver19 _ #_coverageTracker173027282_
								cover: (619 to: 630)
								declaredAt: (549 to: 560)
								by: changeRecord.
							#_coverageTracker173027282_
								coverAll:
									{632 to: 646}
								evaluating: [ receiver19 changeClassName ]
								thatSends: #changeClassName
								to: receiver19 ] value ]
				thatSends: #testIsTracked:class:
				to: receiver20 ] value ]).
	^ [ | receiver27 |
	receiver27 _ #_coverageTracker173027282_
		coverAll:
			{657 to: 670}
		by: ChangeDetector.
	#_coverageTracker173027282_
		coverAll:
			{672 to: 675. 689 to: 702. 706 to: 717}
		evaluating: [
			receiver27
				for:
					(#_coverageTracker173027282_
						coverAll:
							{677 to: 687}
						by: TestRenamed)
				withLookahead:
					(#_coverageTracker173027282_
						coverAll:
							{704 to: 704}
						byLiteralOrPseudoVariable: 2)
				detectsWhen: [ :changeRecord1 :changeRecord2 |
					[ | receiver26 |
					receiver26 _ [ | receiver21 |
					receiver21 _ #_coverageTracker173027282_
						cover: (755 to: 767)
						declaredAt: (737 to: 749)
						by: changeRecord2.
					#_coverageTracker173027282_
						coverAll:
							{769 to: 774}
						evaluating: [ receiver21 notNil ]
						thatSends: #notNil
						to: receiver21 ] value.
					#_coverageTracker173027282_
						coverAll:
							{778 to: 781. 827 to: 830. 882 to: 885. 953 to: 956}
						evaluating: [
							receiver26
								and: [
									[ | receiver22 |
									receiver22 _ #_coverageTracker173027282_
										cover: (785 to: 800)
										declaredAt: (24 to: 39)
										by: isANewTestChange.
									#_coverageTracker173027282_
										coverAll:
											{802 to: 807}
										evaluating: [
											receiver22 value:
												(#_coverageTracker173027282_
													cover: (809 to: 821)
													declaredAt: (722 to: 734)
													by: changeRecord1) ]
										thatSends: #value:
										to: receiver22 ] value ]
								and: [
									[ | receiver23 |
									receiver23 _ #_coverageTracker173027282_
										cover: (834 to: 855)
										declaredAt: (41 to: 62)
										by: isAMethodRemovedChange.
									#_coverageTracker173027282_
										coverAll:
											{857 to: 862}
										evaluating: [
											receiver23 value:
												(#_coverageTracker173027282_
													cover: (864 to: 876)
													declaredAt: (737 to: 749)
													by: changeRecord2) ]
										thatSends: #value:
										to: receiver23 ] value ]
								and: [
									[ | receiver24 |
									receiver24 _ #_coverageTracker173027282_
										cover: (889 to: 905)
										declaredAt: (64 to: 80)
										by: sameClassAndStamp.
									#_coverageTracker173027282_
										coverAll:
											{907 to: 912. 928 to: 933}
										evaluating: [
											receiver24
												value:
													(#_coverageTracker173027282_
														cover: (914 to: 926)
														declaredAt: (722 to: 734)
														by: changeRecord1)
												value:
													(#_coverageTracker173027282_
														cover: (935 to: 947)
														declaredAt: (737 to: 749)
														by: changeRecord2) ]
										thatSends: #value:value:
										to: receiver24 ] value ]
								and: [
									[ | receiver25 |
									receiver25 _ #_coverageTracker173027282_
										cover: (960 to: 969)
										declaredAt: (82 to: 91)
										by: testExists.
									#_coverageTracker173027282_
										coverAll:
											{971 to: 976}
										evaluating: [
											receiver25 value:
												(#_coverageTracker173027282_
													cover: (978 to: 990)
													declaredAt: (737 to: 749)
													by: changeRecord2) ]
										thatSends: #value:
										to: receiver25 ] value ]]
						thatSends: #and:and:and:and:
						to: receiver26 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver27 ] value.! !
!Behavior method!
tddGuruTestChangesFileExtension
	#_coverageTracker173027345_ markAsExecuted.
	^ #_coverageTracker173027345_
		coverAll:
			{37 to: 59}
		byLiteralOrPseudoVariable: '.tddguru.test.changes'.! !
!Behavior method!
update: aSection
	#_coverageTracker173027347_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027347_
		coverAll:
			{19 to: 22}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027347_
		coverAll:
			{24 to: 40}
		evaluating: [ receiver1 updateCodeSection ]
		thatSends: #updateCodeSection
		to: receiver1 ] value.! !
!Behavior method!
isCorrect
	#_coverageTracker173027351_ markAsExecuted.
	^ #_coverageTracker173027351_
		coverAll:
			{14 to: 17}
		byLiteralOrPseudoVariable: true.! !
!Behavior method!
testRenamedFrom: aSymbol to: aSymbol2
	#_coverageTracker173027354_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027354_
		coverAll:
			{41 to: 44}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027354_
		coverAll:
			{46 to: 58}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027354_
					coverAll:
						{60 to: 67}
					by: Refactor.
				#_coverageTracker173027354_
					coverAll:
						{69 to: 71}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
runTest: aTestSelector class: className
	| class |
	#_coverageTracker173027364_ markAsExecuted.
	#_coverageTracker173027364_
		cover: (54 to: 58)
		declaredAt: (45 to: 49)
		by:
			(class _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027364_
				coverAll:
					{63 to: 66}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027364_
				coverAll:
					{68 to: 78}
				evaluating: [
					receiver1 classNamed:
						(#_coverageTracker173027364_
							cover: (80 to: 88)
							declaredAt: (31 to: 39)
							by: className) ]
				thatSends: #classNamed:
				to: receiver1 ] value).
	[ | receiver3 |
	receiver3 _ [
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027364_
		cover: (94 to: 98)
		declaredAt: (45 to: 49)
		by: class.
	#_coverageTracker173027364_
		coverAll:
			{100 to: 103}
		evaluating: [
			receiver2 run:
				(#_coverageTracker173027364_
					cover: (105 to: 117)
					declaredAt: (10 to: 22)
					by: aTestSelector) ]
		thatSends: #run:
		to: receiver2 ] value ].
	#_coverageTracker173027364_
		coverAll:
			{121 to: 123. 135 to: 137}
		evaluating: [
			receiver3
				on:
					(#_coverageTracker173027364_
						coverAll:
							{125 to: 133}
						by: Exception)
				do: [ ]]
		thatSends: #on:do:
		to: receiver3 ] value.! !
!Behavior method!
code
	#_coverageTracker173027372_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027372_
		cover: (9 to: 27)
		declaredAt: (9 to: 27)
		by: newTestChangeRecord.
	#_coverageTracker173027372_
		coverAll:
			{29 to: 34}
		evaluating: [ receiver1 string ]
		thatSends: #string
		to: receiver1 ] value.! !
!Behavior method!
displayOn: aMorph
	#_coverageTracker173027374_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027374_
		cover: (20 to: 25)
		declaredAt: (12 to: 17)
		by: aMorph.
	#_coverageTracker173027374_
		coverAll:
			{27 to: 40}
		evaluating: [
			receiver2 displayChange:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027374_
					coverAll:
						{42 to: 45}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027374_
					coverAll:
						{47 to: 52}
					evaluating: [ receiver1 change ]
					thatSends: #change
					to: receiver1 ] value ]
		thatSends: #displayChange:
		to: receiver2 ] value.! !
!Behavior method!
newModelClass: aSymbol
	#_coverageTracker173027379_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027379_
		coverAll:
			{26 to: 29}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027379_
		coverAll:
			{31 to: 63}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027379_
		coverAll:
			{67 to: 70}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027379_
		coverAll:
			{72 to: 84}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027379_
					coverAll:
						{86 to: 96}
					by: NotDoingTDD.
				#_coverageTracker173027379_
					coverAll:
						{98 to: 100}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
newProductionClassDetector
	#_coverageTracker173027385_ markAsExecuted.
	^ [ | receiver6 |
	receiver6 _ #_coverageTracker173027385_
		coverAll:
			{31 to: 44}
		by: ChangeDetector.
	#_coverageTracker173027385_
		coverAll:
			{46 to: 49. 65 to: 78. 82 to: 93}
		evaluating: [
			receiver6
				for:
					(#_coverageTracker173027385_
						coverAll:
							{51 to: 63}
						by: NewModelClass)
				withLookahead:
					(#_coverageTracker173027385_
						coverAll:
							{80 to: 80}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver5 |
					receiver5 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173027385_
						cover: (114 to: 126)
						declaredAt: (98 to: 110)
						by: aChangeRecord.
					#_coverageTracker173027385_
						coverAll:
							{128 to: 137}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173027385_
						coverAll:
							{139 to: 139}
						evaluating: [
							receiver2 =
								(#_coverageTracker173027385_
									coverAll:
										{141 to: 156}
									byLiteralOrPseudoVariable: #classDefinition) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173027385_
						coverAll:
							{158 to: 161}
						evaluating: [
							receiver5 and: [
								[ | receiver4 |
								receiver4 _ [ | receiver3 |
								receiver3 _ #_coverageTracker173027385_
									cover: (165 to: 177)
									declaredAt: (98 to: 110)
									by: aChangeRecord.
								#_coverageTracker173027385_
									coverAll:
										{179 to: 195}
									evaluating: [ receiver3 isTestClassChange ]
									thatSends: #isTestClassChange
									to: receiver3 ] value.
								#_coverageTracker173027385_
									coverAll:
										{197 to: 199}
									evaluating: [ receiver4 not ]
									thatSends: #not
									to: receiver4 ] value ]]
						thatSends: #and:
						to: receiver5 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver6 ] value.! !
!Behavior method!
isCorrect
	#_coverageTracker173027392_ markAsExecuted.
	^ #_coverageTracker173027392_
		coverAll:
			{14 to: 17}
		byLiteralOrPseudoVariable: true.! !
!Behavior method!
printString
	#_coverageTracker173027394_ markAsExecuted.
	^ #_coverageTracker173027394_
		coverAll:
			{16 to: 25}
		byLiteralOrPseudoVariable: 'Refactor'.! !
!Behavior method!
newModelMethod: aMethodReference
	#_coverageTracker173027397_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027397_
		coverAll:
			{36 to: 39}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027397_
		coverAll:
			{41 to: 50}
		evaluating: [
			receiver1 markAsNew:
				(#_coverageTracker173027397_
					cover: (52 to: 67)
					declaredAt: (17 to: 32)
					by: aMethodReference) ]
		thatSends: #markAsNew:
		to: receiver1 ] value.! !
!Behavior method!
update: aSection
	#_coverageTracker173027400_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027400_
		cover: (19 to: 23)
		declaredAt: (19 to: 23)
		by: owner.
	#_coverageTracker173027400_
		coverAll:
			{25 to: 31}
		evaluating: [
			receiver1 update:
				(#_coverageTracker173027400_
					cover: (33 to: 40)
					declaredAt: (9 to: 16)
					by: aSection) ]
		thatSends: #update:
		to: receiver1 ] value.
	#_coverageTracker173027400_
		coverAll:
			{50 to: 56}
		evaluating: [
			super update:
				(#_coverageTracker173027400_
					cover: (58 to: 65)
					declaredAt: (9 to: 16)
					by: aSection) ]
		thatSends: #update:
		to: super.! !
!Behavior method!
color
	#_coverageTracker173027404_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027404_
		coverAll:
			{10 to: 29}
		by: AnalysisResultWindow.
	#_coverageTracker173027404_
		coverAll:
			{31 to: 51}
		evaluating: [
			receiver1 stateTransitionColor:
				(#_coverageTracker173027404_
					cover: (53 to: 60)
					declaredAt: (53 to: 60)
					by: tddState) ]
		thatSends: #stateTransitionColor:
		to: receiver1 ] value.! !
!Behavior method!
displayStateTransition: anEvent
	#_coverageTracker173027410_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027410_
		cover: (34 to: 50)
		declaredAt: (34 to: 50)
		by: changeDetailTitle.
	#_coverageTracker173027410_
		coverAll:
			{52 to: 60}
		evaluating: [
			receiver3 contents:
				[ | receiver2 |
				receiver2 _ [ | receiver1 |
				receiver1 _ #_coverageTracker173027410_
					cover: (62 to: 68)
					declaredAt: (25 to: 31)
					by: anEvent.
				#_coverageTracker173027410_
					coverAll:
						{70 to: 76}
					evaluating: [ receiver1 stateTo ]
					thatSends: #stateTo
					to: receiver1 ] value.
				#_coverageTracker173027410_
					coverAll:
						{78 to: 88}
					evaluating: [ receiver2 printString ]
					thatSends: #printString
					to: receiver2 ] value ]
		thatSends: #contents:
		to: receiver3 ] value.
	[ | receiver7 |
	receiver7 _ #_coverageTracker173027410_
		cover: (93 to: 109)
		declaredAt: (34 to: 50)
		by: changeDetailTitle.
	#_coverageTracker173027410_
		coverAll:
			{111 to: 116}
		evaluating: [
			receiver7 color:
				[ | receiver6 |
				receiver6 _ [ | receiver4 |
				receiver4 _ #_coverageTracker173027410_
					coverAll:
						{119 to: 122}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027410_
					coverAll:
						{124 to: 128}
					evaluating: [ receiver4 class ]
					thatSends: #class
					to: receiver4 ] value.
				#_coverageTracker173027410_
					coverAll:
						{130 to: 150}
					evaluating: [
						receiver6 stateTransitionColor:
							[ | receiver5 |
							receiver5 _ #_coverageTracker173027410_
								cover: (152 to: 158)
								declaredAt: (25 to: 31)
								by: anEvent.
							#_coverageTracker173027410_
								coverAll:
									{160 to: 166}
								evaluating: [ receiver5 stateTo ]
								thatSends: #stateTo
								to: receiver5 ] value ]
					thatSends: #stateTransitionColor:
					to: receiver6 ] value ]
		thatSends: #color:
		to: receiver7 ] value.
	[ | receiver16 |
	receiver16 _ [ | receiver8 |
	receiver8 _ #_coverageTracker173027410_
		cover: (173 to: 179)
		declaredAt: (25 to: 31)
		by: anEvent.
	#_coverageTracker173027410_
		coverAll:
			{181 to: 189}
		evaluating: [ receiver8 stateFrom ]
		thatSends: #stateFrom
		to: receiver8 ] value.
	#_coverageTracker173027410_
		coverAll:
			{191 to: 199}
		evaluating: [
			receiver16 ifNotNil: [
				[ | receiver15 |
				receiver15 _ #_coverageTracker173027410_
					cover: (206 to: 217)
					declaredAt: (206 to: 217)
					by: changeDetail.
				#_coverageTracker173027410_
					coverAll:
						{219 to: 227}
					evaluating: [
						receiver15 contents:
							[ | receiver14 |
							receiver14 _ [ | receiver11 |
							receiver11 _ [ | receiver10 |
							receiver10 _ [ | receiver9 |
							receiver9 _ #_coverageTracker173027410_
								cover: (230 to: 236)
								declaredAt: (25 to: 31)
								by: anEvent.
							#_coverageTracker173027410_
								coverAll:
									{238 to: 246}
								evaluating: [ receiver9 stateFrom ]
								thatSends: #stateFrom
								to: receiver9 ] value.
							#_coverageTracker173027410_
								coverAll:
									{248 to: 258}
								evaluating: [ receiver10 printString ]
								thatSends: #printString
								to: receiver10 ] value.
							#_coverageTracker173027410_
								coverAll:
									{259 to: 259}
								evaluating: [
									receiver11 ,
										(#_coverageTracker173027410_
											coverAll:
												{261 to: 266}
											byLiteralOrPseudoVariable: ' -> ') ]
								thatSends: #,
								to: receiver11 ] value.
							#_coverageTracker173027410_
								coverAll:
									{267 to: 267}
								evaluating: [
									receiver14 ,
										[ | receiver13 |
										receiver13 _ [ | receiver12 |
										receiver12 _ #_coverageTracker173027410_
											cover: (269 to: 275)
											declaredAt: (25 to: 31)
											by: anEvent.
										#_coverageTracker173027410_
											coverAll:
												{277 to: 283}
											evaluating: [ receiver12 stateTo ]
											thatSends: #stateTo
											to: receiver12 ] value.
										#_coverageTracker173027410_
											coverAll:
												{285 to: 295}
											evaluating: [ receiver13 printString ]
											thatSends: #printString
											to: receiver13 ] value ]
								thatSends: #,
								to: receiver14 ] value ]
					thatSends: #contents:
					to: receiver15 ] value ]]
		thatSends: #ifNotNil:
		to: receiver16 ] value.! !
!Behavior method!
modelClassRemoved: aSymbol
	#_coverageTracker173027437_ markAsExecuted.! !
!Behavior method!
run
	#_coverageTracker173027441_ markAsExecuted.
	#_coverageTracker173027441_
		cover: (7 to: 20)
		declaredAt: (7 to: 20)
		by:
			(analysisResult _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027441_
				coverAll:
					{25 to: 38}
				by: AnalysisResult.
			#_coverageTracker173027441_
				coverAll:
					{40 to: 42}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027441_
		coverAll:
			{48 to: 51}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027441_
		coverAll:
			{53 to: 61}
		evaluating: [
			receiver2 setState:
				(#_coverageTracker173027441_
					cover: (63 to: 74)
					declaredAt: (63 to: 74)
					by: initialState) ]
		thatSends: #setState:
		to: receiver2 ] value.
	[ | receiver5 |
	receiver5 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173027441_
		coverAll:
			{80 to: 83}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027441_
		coverAll:
			{85 to: 93}
		evaluating: [ receiver3 changeLog ]
		thatSends: #changeLog
		to: receiver3 ] value.
	#_coverageTracker173027441_
		coverAll:
			{95 to: 97}
		evaluating: [
			receiver5 do: [ :change |
				[ | receiver4 |
				receiver4 _ #_coverageTracker173027441_
					coverAll:
						{111 to: 114}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027441_
					coverAll:
						{116 to: 129}
					evaluating: [
						receiver4 analyzeChange:
							(#_coverageTracker173027441_
								cover: (131 to: 136)
								declaredAt: (102 to: 107)
								by: change) ]
					thatSends: #analyzeChange:
					to: receiver4 ] value ]]
		thatSends: #do:
		to: receiver5 ] value.
	[ | receiver7 |
	receiver7 _ [ | receiver6 |
	receiver6 _ #_coverageTracker173027441_
		coverAll:
			{144 to: 147}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027441_
		coverAll:
			{149 to: 160}
		evaluating: [ receiver6 currentState ]
		thatSends: #currentState
		to: receiver6 ] value.
	#_coverageTracker173027441_
		coverAll:
			{162 to: 177}
		evaluating: [ receiver7 analysisFinished ]
		thatSends: #analysisFinished
		to: receiver7 ] value.
	^ #_coverageTracker173027441_
		cover: (185 to: 198)
		declaredAt: (7 to: 20)
		by: analysisResult.! !
!Behavior method!
description
	#_coverageTracker173027451_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027451_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027451_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173027451_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027451_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173027451_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173027451_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027451_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173027451_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173027451_
					coverAll:
						{65 to: 79}
					byLiteralOrPseudoVariable: ' was modified') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
isCorrect
	#_coverageTracker173027454_ markAsExecuted.
	^ #_coverageTracker173027454_
		cover: (14 to: 22)
		declaredAt: (14 to: 22)
		by: isCorrect.! !
!Behavior method!
initialize
	#_coverageTracker173027456_ markAsExecuted.
	#_coverageTracker173027456_
		cover: (13 to: 21)
		declaredAt: (13 to: 21)
		by:
			(overrides _ #_coverageTracker173027456_
				coverAll:
					{26 to: 30}
				byLiteralOrPseudoVariable: false).! !
!Behavior method!
tddState: aTDDState
	#_coverageTracker173027460_ markAsExecuted.
	#_coverageTracker173027460_
		cover: (22 to: 29)
		declaredAt: (22 to: 29)
		by:
			(tddState _ #_coverageTracker173027460_
				cover: (34 to: 42)
				declaredAt: (11 to: 19)
				by: aTDDState).! !
!Behavior method!
reportError: errorDescription andTransitionTo: newState
	#_coverageTracker173027463_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027463_
		coverAll:
			{58 to: 61}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027463_
		coverAll:
			{63 to: 74}
		evaluating: [
			receiver1 reportError:
				(#_coverageTracker173027463_
					cover: (76 to: 91)
					declaredAt: (14 to: 29)
					by: errorDescription) ]
		thatSends: #reportError:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027463_
		coverAll:
			{95 to: 98}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027463_
		coverAll:
			{100 to: 112}
		evaluating: [
			receiver2 transitionTo:
				(#_coverageTracker173027463_
					cover: (114 to: 121)
					declaredAt: (48 to: 55)
					by: newState) ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
testClassRemovedDetector
	#_coverageTracker173027469_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ #_coverageTracker173027469_
		coverAll:
			{29 to: 42}
		by: ChangeDetector.
	#_coverageTracker173027469_
		coverAll:
			{44 to: 47. 66 to: 79. 83 to: 94}
		evaluating: [
			receiver5
				for:
					(#_coverageTracker173027469_
						coverAll:
							{49 to: 64}
						by: TestClassRemoved)
				withLookahead:
					(#_coverageTracker173027469_
						coverAll:
							{81 to: 81}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver4 |
					receiver4 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173027469_
						cover: (118 to: 130)
						declaredAt: (99 to: 111)
						by: aChangeRecord.
					#_coverageTracker173027469_
						coverAll:
							{132 to: 146}
						evaluating: [ receiver1 isClassDeletion ]
						thatSends: #isClassDeletion
						to: receiver1 ] value.
					#_coverageTracker173027469_
						coverAll:
							{151 to: 154}
						evaluating: [
							receiver4 and: [
								[ | receiver3 |
								receiver3 _ #_coverageTracker173027469_
									coverAll:
										{158 to: 161}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173027469_
									coverAll:
										{163 to: 175}
									evaluating: [
										receiver3 isATestClass:
											[ | receiver2 |
											receiver2 _ #_coverageTracker173027469_
												cover: (177 to: 189)
												declaredAt: (99 to: 111)
												by: aChangeRecord.
											#_coverageTracker173027469_
												coverAll:
													{191 to: 205}
												evaluating: [ receiver2 changeClassName ]
												thatSends: #changeClassName
												to: receiver2 ] value ]
									thatSends: #isATestClass:
									to: receiver3 ] value ]]
						thatSends: #and:
						to: receiver4 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver5 ] value.! !
!Behavior method!
testClassRemoved: aSymbol
	#_coverageTracker173027476_ markAsExecuted.! !
!Behavior method!
currentName
	#_coverageTracker173027477_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027477_
		cover: (16 to: 27)
		declaredAt: (16 to: 27)
		by: changeRecord.
	#_coverageTracker173027477_
		coverAll:
			{29 to: 40}
		evaluating: [ receiver1 newClassName ]
		thatSends: #newClassName
		to: receiver1 ] value.! !
!Behavior method!
testChanged: aTestReference
	#_coverageTracker173027487_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027487_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027487_
		coverAll:
			{35 to: 46}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173027487_
		coverAll:
			{48 to: 59}
		evaluating: [
			receiver2 testChanged:
				(#_coverageTracker173027487_
					cover: (61 to: 74)
					declaredAt: (14 to: 27)
					by: aTestReference) ]
		thatSends: #testChanged:
		to: receiver2 ] value.! !
!Behavior method!
minutesAsString: timeDifference
	| inMinutes |
	#_coverageTracker173027492_ markAsExecuted.
	[ | receiver8 |
	receiver8 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173027492_
		cover: (51 to: 64)
		declaredAt: (18 to: 31)
		by: timeDifference.
	#_coverageTracker173027492_
		coverAll:
			{66 to: 66}
		evaluating: [
			receiver3 >
				[ | receiver2 |
				receiver2 _ [ | receiver1 |
				receiver1 _ #_coverageTracker173027492_
					coverAll:
						{69 to: 77}
					by: TimeUnits.
				#_coverageTracker173027492_
					coverAll:
						{79 to: 84}
					evaluating: [ receiver1 minute ]
					thatSends: #minute
					to: receiver1 ] value.
				#_coverageTracker173027492_
					coverAll:
						{86 to: 90}
					evaluating: [
						receiver2 with:
							(#_coverageTracker173027492_
								coverAll:
									{92 to: 92}
								byLiteralOrPseudoVariable: 1) ]
					thatSends: #with:
					to: receiver2 ] value ]
		thatSends: #>
		to: receiver3 ] value.
	#_coverageTracker173027492_
		coverAll:
			{98 to: 104. 186 to: 193}
		evaluating: [
			receiver8
				ifTrue: [
					#_coverageTracker173027492_
						cover: (108 to: 116)
						declaredAt: (36 to: 44)
						by:
							(inMinutes _ [ | receiver7 |
							receiver7 _ [ | receiver6 |
							receiver6 _ [ | receiver5 |
							receiver5 _ #_coverageTracker173027492_
								cover: (123 to: 136)
								declaredAt: (18 to: 31)
								by: timeDifference.
							#_coverageTracker173027492_
								coverAll:
									{138 to: 147}
								evaluating: [
									receiver5 convertTo:
										[ | receiver4 |
										receiver4 _ #_coverageTracker173027492_
											coverAll:
												{149 to: 157}
											by: TimeUnits.
										#_coverageTracker173027492_
											coverAll:
												{159 to: 164}
											evaluating: [ receiver4 minute ]
											thatSends: #minute
											to: receiver4 ] value ]
								thatSends: #convertTo:
								to: receiver5 ] value.
							#_coverageTracker173027492_
								coverAll:
									{167 to: 171}
								evaluating: [ receiver6 floor ]
								thatSends: #floor
								to: receiver6 ] value.
							#_coverageTracker173027492_
								coverAll:
									{174 to: 179}
								evaluating: [ receiver7 amount ]
								thatSends: #amount
								to: receiver7 ] value) ]
				ifFalse: [
					#_coverageTracker173027492_
						cover: (197 to: 205)
						declaredAt: (36 to: 44)
						by:
							(inMinutes _ #_coverageTracker173027492_
								coverAll:
									{210 to: 210}
								byLiteralOrPseudoVariable: 0) ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver8 ] value.
	^ [ | receiver10 |
	receiver10 _ #_coverageTracker173027492_
		coverAll:
			{221 to: 226}
		by: String.
	#_coverageTracker173027492_
		coverAll:
			{228 to: 242}
		evaluating: [
			receiver10 streamContents: [ :aStream |
				[ | receiver9 |
				receiver9 _ #_coverageTracker173027492_
					cover: (257 to: 265)
					declaredAt: (36 to: 44)
					by: inMinutes.
				#_coverageTracker173027492_
					coverAll:
						{267 to: 274. 284 to: 297. 301 to: 315}
					evaluating: [
						receiver9
							printOn:
								(#_coverageTracker173027492_
									cover: (276 to: 282)
									declaredAt: (247 to: 253)
									by: aStream)
							integerDigits:
								(#_coverageTracker173027492_
									coverAll:
										{299 to: 299}
									byLiteralOrPseudoVariable: 2)
							fractionDigits:
								(#_coverageTracker173027492_
									coverAll:
										{317 to: 317}
									byLiteralOrPseudoVariable: 0) ]
					thatSends: #printOn:integerDigits:fractionDigits:
					to: receiver9 ] value ]]
		thatSends: #streamContents:
		to: receiver10 ] value.! !
!Behavior method!
errorColor
	#_coverageTracker173027509_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027509_
		coverAll:
			{15 to: 19}
		by: Color.
	#_coverageTracker173027509_
		coverAll:
			{21 to: 34}
		evaluating: [
			receiver1 fromHexString:
				(#_coverageTracker173027509_
					coverAll:
						{36 to: 44}
					byLiteralOrPseudoVariable: '#dc3545') ]
		thatSends: #fromHexString:
		to: receiver1 ] value.! !
!Behavior method!
previousName
	#_coverageTracker173027511_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027511_
		cover: (17 to: 28)
		declaredAt: (17 to: 28)
		by: changeRecord.
	#_coverageTracker173027511_
		coverAll:
			{30 to: 44}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.! !
!Behavior method!
modelMethodRemoved: aSymbol
	#_coverageTracker173027515_ markAsExecuted.! !
!Behavior method!
changeEvents
	#_coverageTracker173027516_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027516_
		coverAll:
			{17 to: 20}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027516_
		coverAll:
			{22 to: 36}
		evaluating: [
			receiver1 eventsWithType:
				(#_coverageTracker173027516_
					coverAll:
						{38 to: 44}
					byLiteralOrPseudoVariable: #change) ]
		thatSends: #eventsWithType:
		to: receiver1 ] value.! !
!Behavior method!
methodReference
	#_coverageTracker173027518_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ #_coverageTracker173027518_
		coverAll:
			{20 to: 45}
		by: UninstalledMethodReference.
	#_coverageTracker173027518_
		coverAll:
			{47 to: 55. 77 to: 82. 105 to: 115}
		evaluating: [
			receiver4
				selector:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173027518_
						coverAll:
							{57 to: 60}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027518_
						coverAll:
							{62 to: 75}
						evaluating: [ receiver1 methodSelector ]
						thatSends: #methodSelector
						to: receiver1 ] value
				class:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173027518_
						coverAll:
							{84 to: 87}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027518_
						coverAll:
							{89 to: 103}
						evaluating: [ receiver2 changeClassName ]
						thatSends: #changeClassName
						to: receiver2 ] value
				sourceCode:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173027518_
						coverAll:
							{117 to: 120}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027518_
						coverAll:
							{122 to: 125}
						evaluating: [ receiver3 code ]
						thatSends: #code
						to: receiver3 ] value ]
		thatSends: #selector:class:sourceCode:
		to: receiver4 ] value.! !
!Behavior method!
testAddedErrorMessage: aTestSelector class: className
	#_coverageTracker173027526_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173027526_
		coverAll:
			{58 to: 64}
		byLiteralOrPseudoVariable: 'Test '.
	#_coverageTracker173027526_
		coverAll:
			{65 to: 65}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027526_
					coverAll:
						{68 to: 71}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027526_
					coverAll:
						{73 to: 84. 100 to: 105}
					evaluating: [
						receiver1
							printMethod:
								(#_coverageTracker173027526_
									cover: (86 to: 98)
									declaredAt: (24 to: 36)
									by: aTestSelector)
							class:
								(#_coverageTracker173027526_
									cover: (107 to: 115)
									declaredAt: (45 to: 53)
									by: className) ]
					thatSends: #printMethod:class:
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173027526_
		coverAll:
			{117 to: 117}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173027526_
					coverAll:
						{119 to: 137}
					byLiteralOrPseudoVariable: ' was added in Red') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
newTestClass: aSymbol
	#_coverageTracker173027532_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027532_
		cover: (25 to: 35)
		declaredAt: (25 to: 35)
		by: testClasses.
	#_coverageTracker173027532_
		coverAll:
			{37 to: 40}
		evaluating: [
			receiver1 add:
				(#_coverageTracker173027532_
					cover: (42 to: 48)
					declaredAt: (15 to: 21)
					by: aSymbol) ]
		thatSends: #add:
		to: receiver1 ] value.! !
!Behavior method!
modelClassRemoved: className
	#_coverageTracker173027535_ markAsExecuted.! !
!Behavior method!
testChangedDetector
	#_coverageTracker173027538_ markAsExecuted.
	^ [ | receiver11 |
	receiver11 _ #_coverageTracker173027538_
		coverAll:
			{24 to: 37}
		by: ChangeDetector.
	#_coverageTracker173027538_
		coverAll:
			{39 to: 42. 56 to: 69. 73 to: 84}
		evaluating: [
			receiver11
				for:
					(#_coverageTracker173027538_
						coverAll:
							{44 to: 54}
						by: TestChanged)
				withLookahead:
					(#_coverageTracker173027538_
						coverAll:
							{71 to: 71}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver10 |
					receiver10 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173027538_
						cover: (105 to: 117)
						declaredAt: (89 to: 101)
						by: aChangeRecord.
					#_coverageTracker173027538_
						coverAll:
							{119 to: 128}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173027538_
						coverAll:
							{130 to: 130}
						evaluating: [
							receiver2 =
								(#_coverageTracker173027538_
									coverAll:
										{132 to: 138}
									byLiteralOrPseudoVariable: #method) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173027538_
						coverAll:
							{143 to: 146. 203 to: 206. 258 to: 261}
						evaluating: [
							receiver10
								and: [
									[ | receiver4 |
									receiver4 _ #_coverageTracker173027538_
										coverAll:
											{150 to: 153}
										byLiteralOrPseudoVariable: self.
									#_coverageTracker173027538_
										coverAll:
											{155 to: 167}
										evaluating: [
											receiver4 isATestClass:
												[ | receiver3 |
												receiver3 _ #_coverageTracker173027538_
													cover: (169 to: 181)
													declaredAt: (89 to: 101)
													by: aChangeRecord.
												#_coverageTracker173027538_
													coverAll:
														{183 to: 197}
													evaluating: [ receiver3 changeClassName ]
													thatSends: #changeClassName
													to: receiver3 ] value ]
										thatSends: #isATestClass:
										to: receiver4 ] value ]
								and: [
									[ | receiver6 |
									receiver6 _ [ | receiver5 |
									receiver5 _ #_coverageTracker173027538_
										cover: (210 to: 222)
										declaredAt: (89 to: 101)
										by: aChangeRecord.
									#_coverageTracker173027538_
										coverAll:
											{224 to: 237}
										evaluating: [ receiver5 methodSelector ]
										thatSends: #methodSelector
										to: receiver5 ] value.
									#_coverageTracker173027538_
										coverAll:
											{239 to: 252}
										evaluating: [ receiver6 isTestSelector ]
										thatSends: #isTestSelector
										to: receiver6 ] value ]
								and: [
									[ | receiver9 |
									receiver9 _ [ | receiver8 |
									receiver8 _ [ | receiver7 |
									receiver7 _ #_coverageTracker173027538_
										cover: (265 to: 277)
										declaredAt: (89 to: 101)
										by: aChangeRecord.
									#_coverageTracker173027538_
										coverAll:
											{279 to: 283}
										evaluating: [ receiver7 prior ]
										thatSends: #prior
										to: receiver7 ] value.
									#_coverageTracker173027538_
										coverAll:
											{285 to: 289}
										evaluating: [ receiver8 isNil ]
										thatSends: #isNil
										to: receiver8 ] value.
									#_coverageTracker173027538_
										coverAll:
											{291 to: 293}
										evaluating: [ receiver9 not ]
										thatSends: #not
										to: receiver9 ] value ]]
						thatSends: #and:and:and:
						to: receiver10 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver11 ] value.! !
!Behavior method!
modelMethodRemoved: aMethodReference
	#_coverageTracker173027559_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027559_
		coverAll:
			{40 to: 43}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027559_
		coverAll:
			{45 to: 56}
		evaluating: [
			receiver1 unmarkAsNew:
				(#_coverageTracker173027559_
					cover: (58 to: 73)
					declaredAt: (21 to: 36)
					by: aMethodReference) ]
		thatSends: #unmarkAsNew:
		to: receiver1 ] value.! !
!Behavior method!
selectedEvent
	#_coverageTracker173027564_ markAsExecuted.
	^ #_coverageTracker173027564_
		cover: (18 to: 30)
		declaredAt: (18 to: 30)
		by: selectedEvent.! !
!Behavior method!
testRemoved: aSymbol
	#_coverageTracker173027566_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027566_
		coverAll:
			{24 to: 27}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027566_
		coverAll:
			{29 to: 41}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027566_
					coverAll:
						{43 to: 50}
					by: Refactor.
				#_coverageTracker173027566_
					coverAll:
						{52 to: 54}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
newModelClass: className
	#_coverageTracker173027571_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027571_
		coverAll:
			{27 to: 30}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027571_
		coverAll:
			{32 to: 43}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173027571_
		coverAll:
			{45 to: 58}
		evaluating: [
			receiver2 newModelClass:
				(#_coverageTracker173027571_
					cover: (60 to: 68)
					declaredAt: (16 to: 24)
					by: className) ]
		thatSends: #newModelClass:
		to: receiver2 ] value.! !
!Behavior method!
allTests
	#_coverageTracker173027576_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027576_
		cover: (13 to: 21)
		declaredAt: (13 to: 21)
		by: inventory.
	#_coverageTracker173027576_
		coverAll:
			{23 to: 30}
		evaluating: [ receiver1 allTests ]
		thatSends: #allTests
		to: receiver1 ] value.! !
!Behavior method!
testRenamedFrom: previousTestReference to: currentTestReference
	#_coverageTracker173027579_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027579_
		cover: (67 to: 70)
		declaredAt: (67 to: 70)
		by: test.
	#_coverageTracker173027579_
		coverAll:
			{72 to: 72}
		evaluating: [
			receiver1 =
				(#_coverageTracker173027579_
					cover: (74 to: 94)
					declaredAt: (18 to: 38)
					by: previousTestReference) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173027579_
		coverAll:
			{96 to: 102}
		evaluating: [
			receiver3 ifTrue: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027579_
					coverAll:
						{106 to: 109}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027579_
					coverAll:
						{111 to: 122}
					evaluating: [
						receiver2 currentTest:
							(#_coverageTracker173027579_
								cover: (124 to: 143)
								declaredAt: (44 to: 63)
								by: currentTestReference) ]
					thatSends: #currentTest:
					to: receiver2 ] value ]]
		thatSends: #ifTrue:
		to: receiver3 ] value.! !
!Behavior method!
addChange: aChange
	#_coverageTracker173027584_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027584_
		coverAll:
			{21 to: 24}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027584_
		coverAll:
			{26 to: 34}
		evaluating: [
			receiver2 addEvent:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027584_
					coverAll:
						{37 to: 47}
					by: ChangeEvent.
				#_coverageTracker173027584_
					coverAll:
						{49 to: 52. 62 to: 64}
					evaluating: [
						receiver1
							for:
								(#_coverageTracker173027584_
									cover: (54 to: 60)
									declaredAt: (12 to: 18)
									by: aChange)
							in:
								(#_coverageTracker173027584_
									coverAll:
										{66 to: 69}
									byLiteralOrPseudoVariable: self) ]
					thatSends: #for:in:
					to: receiver1 ] value ]
		thatSends: #addEvent:
		to: receiver2 ] value.! !
!Behavior method!
hasTestWithSelector: aSymbol andClass: className
	#_coverageTracker173027589_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173027589_
		cover: (53 to: 57)
		declaredAt: (53 to: 57)
		by: tests.
	#_coverageTracker173027589_
		coverAll:
			{59 to: 67}
		evaluating: [
			receiver2 includes:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027589_
					coverAll:
						{70 to: 95}
					by: UninstalledMethodReference.
				#_coverageTracker173027589_
					coverAll:
						{97 to: 105. 115 to: 120}
					evaluating: [
						receiver1
							selector:
								(#_coverageTracker173027589_
									cover: (107 to: 113)
									declaredAt: (22 to: 28)
									by: aSymbol)
							class:
								(#_coverageTracker173027589_
									cover: (122 to: 130)
									declaredAt: (40 to: 48)
									by: className) ]
					thatSends: #selector:class:
					to: receiver1 ] value ]
		thatSends: #includes:
		to: receiver2 ] value.! !
!Behavior method!
buildMorphicWindow
	#_coverageTracker173027607_ markAsExecuted.
	[ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027607_
		coverAll:
			{24 to: 27}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027607_
		coverAll:
			{29 to: 39}
		evaluating: [ receiver1 layoutMorph ]
		thatSends: #layoutMorph
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173027607_
		coverAll:
			{44 to: 52. 68 to: 86}
		evaluating: [
			receiver3
				addMorph:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173027607_
						coverAll:
							{54 to: 57}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027607_
						coverAll:
							{59 to: 66}
						evaluating: [ receiver2 timeline ]
						thatSends: #timeline
						to: receiver2 ] value
				proportionalHeight:
					(#_coverageTracker173027607_
						coverAll:
							{88 to: 91}
						byLiteralOrPseudoVariable: 0.7) ]
		thatSends: #addMorph:proportionalHeight:
		to: receiver3 ] value.
	[ | receiver5 |
	receiver5 _ cascadeReceiver.
	#_coverageTracker173027607_
		coverAll:
			{96 to: 115. 130 to: 148}
		evaluating: [
			receiver5
				addAdjusterAndMorph:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173027607_
						coverAll:
							{117 to: 120}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027607_
						coverAll:
							{122 to: 128}
						evaluating: [ receiver4 details ]
						thatSends: #details
						to: receiver4 ] value
				proportionalHeight:
					(#_coverageTracker173027607_
						coverAll:
							{150 to: 153}
						byLiteralOrPseudoVariable: 0.15) ]
		thatSends: #addAdjusterAndMorph:proportionalHeight:
		to: receiver5 ] value.
	[ | receiver7 |
	receiver7 _ cascadeReceiver.
	#_coverageTracker173027607_
		coverAll:
			{158 to: 177. 189 to: 207}
		evaluating: [
			receiver7
				addAdjusterAndMorph:
					[ | receiver6 |
					receiver6 _ #_coverageTracker173027607_
						coverAll:
							{179 to: 182}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027607_
						coverAll:
							{184 to: 187}
						evaluating: [ receiver6 code ]
						thatSends: #code
						to: receiver6 ] value
				proportionalHeight:
					(#_coverageTracker173027607_
						coverAll:
							{209 to: 212}
						byLiteralOrPseudoVariable: 0.15) ]
		thatSends: #addAdjusterAndMorph:proportionalHeight:
		to: receiver7 ] value.
	[ | receiver10 |
	receiver10 _ cascadeReceiver.
	#_coverageTracker173027607_
		coverAll:
			{217 to: 236. 255 to: 266}
		evaluating: [
			receiver10
				addAdjusterAndMorph:
					[ | receiver8 |
					receiver8 _ #_coverageTracker173027607_
						coverAll:
							{238 to: 241}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027607_
						coverAll:
							{243 to: 253}
						evaluating: [ receiver8 buttonPanel ]
						thatSends: #buttonPanel
						to: receiver8 ] value
				fixedHeight:
					[ | receiver9 |
					receiver9 _ #_coverageTracker173027607_
						coverAll:
							{268 to: 271}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027607_
						coverAll:
							{273 to: 295}
						evaluating: [ receiver9 defaultButtonPaneHeight ]
						thatSends: #defaultButtonPaneHeight
						to: receiver9 ] value ]
		thatSends: #addAdjusterAndMorph:fixedHeight:
		to: receiver10 ] value ] value.! !
!Behavior method!
changeClassName
	#_coverageTracker173027620_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027620_
		cover: (20 to: 31)
		declaredAt: (20 to: 31)
		by: changeRecord.
	#_coverageTracker173027620_
		coverAll:
			{33 to: 47}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.! !
!Behavior method!
do: aBlockClosure
	#_coverageTracker173027623_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027623_
		cover: (25 to: 34)
		declaredAt: (25 to: 34)
		by: changeList.
	#_coverageTracker173027623_
		coverAll:
			{36 to: 42}
		evaluating: [ receiver1 isEmpty ]
		thatSends: #isEmpty
		to: receiver1 ] value ].
	#_coverageTracker173027623_
		coverAll:
			{50 to: 60}
		evaluating: [
			receiver4 whileFalse: [ | nextChange |
				#_coverageTracker173027623_
					cover: (83 to: 92)
					declaredAt: (66 to: 75)
					by:
						(nextChange _ [ | receiver2 |
						receiver2 _ #_coverageTracker173027623_
							coverAll:
								{97 to: 100}
							byLiteralOrPseudoVariable: self.
						#_coverageTracker173027623_
							coverAll:
								{102 to: 111}
							evaluating: [ receiver2 nextChange ]
							thatSends: #nextChange
							to: receiver2 ] value).
				[ | receiver3 |
				receiver3 _ #_coverageTracker173027623_
					cover: (116 to: 128)
					declaredAt: (5 to: 17)
					by: aBlockClosure.
				#_coverageTracker173027623_
					coverAll:
						{130 to: 135}
					evaluating: [
						receiver3 value:
							(#_coverageTracker173027623_
								cover: (137 to: 146)
								declaredAt: (66 to: 75)
								by: nextChange) ]
					thatSends: #value:
					to: receiver3 ] value ]]
		thatSends: #whileFalse:
		to: receiver4 ] value.! !
!Behavior method!
hash
	#_coverageTracker173027630_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ #_coverageTracker173027630_
		coverAll:
			{15 to: 18}
		evaluating: [ super hash ]
		thatSends: #hash
		to: super.
	#_coverageTracker173027630_
		coverAll:
			{20 to: 26}
		evaluating: [
			receiver3 bitXor:
				[ | receiver2 |
				receiver2 _ [ | receiver1 |
				receiver1 _ #_coverageTracker173027630_
					coverAll:
						{28 to: 31}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027630_
					coverAll:
						{33 to: 36}
					evaluating: [ receiver1 name ]
					thatSends: #name
					to: receiver1 ] value.
				#_coverageTracker173027630_
					coverAll:
						{38 to: 41}
					evaluating: [ receiver2 hash ]
					thatSends: #hash
					to: receiver2 ] value ]
		thatSends: #bitXor:
		to: receiver3 ] value.! !
!Behavior method!
modelMethodChanged: anUninstalledMethodReference
	#_coverageTracker173027633_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027633_
		coverAll:
			{52 to: 55}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027633_
		coverAll:
			{57 to: 89}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027633_
		coverAll:
			{93 to: 96}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027633_
		coverAll:
			{98 to: 110}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027633_
					coverAll:
						{112 to: 122}
					by: NotDoingTDD.
				#_coverageTracker173027633_
					coverAll:
						{124 to: 126}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
testPassedDetector
	#_coverageTracker173027639_ markAsExecuted.
	^ [ | receiver8 |
	receiver8 _ #_coverageTracker173027639_
		coverAll:
			{23 to: 36}
		by: ChangeDetector.
	#_coverageTracker173027639_
		coverAll:
			{38 to: 41. 54 to: 67. 71 to: 82}
		evaluating: [
			receiver8
				for:
					(#_coverageTracker173027639_
						coverAll:
							{43 to: 52}
						by: TestPassed)
				withLookahead:
					(#_coverageTracker173027639_
						coverAll:
							{69 to: 69}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver7 |
					receiver7 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173027639_
						cover: (106 to: 118)
						declaredAt: (87 to: 99)
						by: aChangeRecord.
					#_coverageTracker173027639_
						coverAll:
							{120 to: 129}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173027639_
						coverAll:
							{131 to: 131}
						evaluating: [
							receiver2 =
								(#_coverageTracker173027639_
									coverAll:
										{133 to: 140}
									byLiteralOrPseudoVariable: #testRun) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173027639_
						coverAll:
							{146 to: 149. 181 to: 184}
						evaluating: [
							receiver7
								and: [
									[ | receiver3 |
									receiver3 _ #_coverageTracker173027639_
										cover: (153 to: 165)
										declaredAt: (87 to: 99)
										by: aChangeRecord.
									#_coverageTracker173027639_
										coverAll:
											{167 to: 174}
										evaluating: [ receiver3 isPassed ]
										thatSends: #isPassed
										to: receiver3 ] value ]
								and: [
									[ | receiver6 |
									receiver6 _ #_coverageTracker173027639_
										coverAll:
											{188 to: 191}
										byLiteralOrPseudoVariable: self.
									#_coverageTracker173027639_
										coverAll:
											{193 to: 206. 237 to: 242}
										evaluating: [
											receiver6
												testIsTracked:
													[ | receiver4 |
													receiver4 _ #_coverageTracker173027639_
														cover: (208 to: 220)
														declaredAt: (87 to: 99)
														by: aChangeRecord.
													#_coverageTracker173027639_
														coverAll:
															{222 to: 235}
														evaluating: [ receiver4 methodSelector ]
														thatSends: #methodSelector
														to: receiver4 ] value
												class:
													[ | receiver5 |
													receiver5 _ #_coverageTracker173027639_
														cover: (244 to: 256)
														declaredAt: (87 to: 99)
														by: aChangeRecord.
													#_coverageTracker173027639_
														coverAll:
															{258 to: 272}
														evaluating: [ receiver5 changeClassName ]
														thatSends: #changeClassName
														to: receiver5 ] value ]
										thatSends: #testIsTracked:class:
										to: receiver6 ] value ]]
						thatSends: #and:and:
						to: receiver7 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver8 ] value.! !
!Behavior method!
testRenamedFrom: aSymbol to: aSymbol2
	#_coverageTracker173027657_ markAsExecuted.! !
!Behavior method!
compileMethod: aString in: className
	| class |
	#_coverageTracker173027665_ markAsExecuted.
	#_coverageTracker173027665_
		cover: (51 to: 55)
		declaredAt: (42 to: 46)
		by:
			(class _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027665_
				coverAll:
					{60 to: 63}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027665_
				coverAll:
					{65 to: 75}
				evaluating: [
					receiver1 classNamed:
						(#_coverageTracker173027665_
							cover: (77 to: 85)
							declaredAt: (28 to: 36)
							by: className) ]
				thatSends: #classNamed:
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027665_
		cover: (91 to: 95)
		declaredAt: (42 to: 46)
		by: class.
	#_coverageTracker173027665_
		coverAll:
			{97 to: 104}
		evaluating: [
			receiver2 compile:
				(#_coverageTracker173027665_
					cover: (106 to: 112)
					declaredAt: (16 to: 22)
					by: aString) ]
		thatSends: #compile:
		to: receiver2 ] value.! !
!Behavior method!
description
	#_coverageTracker173027672_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027672_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027672_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173027672_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173027672_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173027672_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173027672_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027672_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173027672_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173027672_
					coverAll:
						{65 to: 76}
					byLiteralOrPseudoVariable: ' was added') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
classRemovedDetector
	#_coverageTracker173027677_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173027677_
		coverAll:
			{25 to: 38}
		by: ChangeDetector.
	#_coverageTracker173027677_
		coverAll:
			{40 to: 43. 63 to: 76. 80 to: 91}
		evaluating: [
			receiver2
				for:
					(#_coverageTracker173027677_
						coverAll:
							{45 to: 61}
						by: ModelClassRemoved)
				withLookahead:
					(#_coverageTracker173027677_
						coverAll:
							{78 to: 78}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver1 |
					receiver1 _ #_coverageTracker173027677_
						cover: (112 to: 124)
						declaredAt: (96 to: 108)
						by: aChangeRecord.
					#_coverageTracker173027677_
						coverAll:
							{126 to: 140}
						evaluating: [ receiver1 isClassDeletion ]
						thatSends: #isClassDeletion
						to: receiver1 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver2 ] value.! !
!Behavior method!
testRenamedFrom: previousTestReference to: newTestReference
	#_coverageTracker173027682_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027682_
		cover: (62 to: 70)
		declaredAt: (62 to: 70)
		by: inventory.
	#_coverageTracker173027682_
		coverAll:
			{72 to: 87. 111 to: 113}
		evaluating: [
			receiver1
				testRenamedFrom:
					(#_coverageTracker173027682_
						cover: (89 to: 109)
						declaredAt: (18 to: 38)
						by: previousTestReference)
				to:
					(#_coverageTracker173027682_
						cover: (115 to: 130)
						declaredAt: (44 to: 59)
						by: newTestReference) ]
		thatSends: #testRenamedFrom:to:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027682_
		cover: (134 to: 138)
		declaredAt: (134 to: 138)
		by: state.
	#_coverageTracker173027682_
		coverAll:
			{140 to: 155. 179 to: 181}
		evaluating: [
			receiver2
				testRenamedFrom:
					(#_coverageTracker173027682_
						cover: (157 to: 177)
						declaredAt: (18 to: 38)
						by: previousTestReference)
				to:
					(#_coverageTracker173027682_
						cover: (183 to: 198)
						declaredAt: (44 to: 59)
						by: newTestReference) ]
		thatSends: #testRenamedFrom:to:
		to: receiver2 ] value.! !
!Behavior method!
category
	#_coverageTracker173027688_ markAsExecuted.
	^ #_coverageTracker173027688_
		coverAll:
			{13 to: 29}
		byLiteralOrPseudoVariable: #testClassRemoved.! !
!Behavior method!
printString
	#_coverageTracker173027691_ markAsExecuted.
	^ #_coverageTracker173027691_
		coverAll:
			{16 to: 24}
		byLiteralOrPseudoVariable: 'Started'.! !
!Behavior method!
initialize
	#_coverageTracker173027693_ markAsExecuted.
	#_coverageTracker173027693_
		cover: (13 to: 18)
		declaredAt: (13 to: 18)
		by:
			(events _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027693_
				coverAll:
					{23 to: 39}
				by: OrderedCollection.
			#_coverageTracker173027693_
				coverAll:
					{41 to: 43}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	#_coverageTracker173027693_
		cover: (47 to: 64)
		declaredAt: (47 to: 64)
		by:
			(statesAfterChanges _ [ | receiver2 |
			receiver2 _ #_coverageTracker173027693_
				coverAll:
					{69 to: 78}
				by: Dictionary.
			#_coverageTracker173027693_
				coverAll:
					{80 to: 82}
				evaluating: [ receiver2 new ]
				thatSends: #new
				to: receiver2 ] value).! !
!Behavior method!
isUsed: aMethodReference
	#_coverageTracker173027698_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027698_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027698_
		coverAll:
			{36 to: 62}
		evaluating: [
			receiver1 overridesASuperclassMethod:
				(#_coverageTracker173027698_
					cover: (64 to: 79)
					declaredAt: (9 to: 24)
					by: aMethodReference) ]
		thatSends: #overridesASuperclassMethod:
		to: receiver1 ] value.
	#_coverageTracker173027698_
		coverAll:
			{82 to: 84}
		evaluating: [
			receiver3 or: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027698_
					coverAll:
						{87 to: 90}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027698_
					coverAll:
						{92 to: 122}
					evaluating: [
						receiver2 isUsedInOneOfTheChangedMethods:
							(#_coverageTracker173027698_
								cover: (124 to: 139)
								declaredAt: (9 to: 24)
								by: aMethodReference) ]
					thatSends: #isUsedInOneOfTheChangedMethods:
					to: receiver2 ] value ]]
		thatSends: #or:
		to: receiver3 ] value.! !
!Behavior method!
analysisResult
	#_coverageTracker173027703_ markAsExecuted.
	^ #_coverageTracker173027703_
		cover: (19 to: 32)
		declaredAt: (19 to: 32)
		by: analysisResult.! !
!Behavior method!
newTestChangeRecord: aChangeRecord
	#_coverageTracker173027706_ markAsExecuted.
	#_coverageTracker173027706_
		cover: (38 to: 56)
		declaredAt: (38 to: 56)
		by:
			(newTestChangeRecord _ #_coverageTracker173027706_
				cover: (61 to: 73)
				declaredAt: (22 to: 34)
				by: aChangeRecord).! !
!Behavior method!
modelMethodRemoved: anUninstalledMethodReference
	#_coverageTracker173027707_ markAsExecuted.! !
!Behavior method!
testRemoved: aMethodReference
	| remainingTest |
	#_coverageTracker173027711_ markAsExecuted.
	[ | receiver8 |
	receiver8 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027711_
		coverAll:
			{55 to: 58}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027711_
		coverAll:
			{60 to: 82}
		evaluating: [
			receiver1 isOneOfTheCurrentTests:
				(#_coverageTracker173027711_
					cover: (84 to: 99)
					declaredAt: (14 to: 29)
					by: aMethodReference) ]
		thatSends: #isOneOfTheCurrentTests:
		to: receiver1 ] value.
	#_coverageTracker173027711_
		coverAll:
			{104 to: 110. 248 to: 255}
		evaluating: [
			receiver8
				ifTrue: [
					#_coverageTracker173027711_
						cover: (118 to: 130)
						declaredAt: (35 to: 47)
						by:
							(remainingTest _ [ | receiver2 |
							receiver2 _ #_coverageTracker173027711_
								coverAll:
									{135 to: 138}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173027711_
								coverAll:
									{140 to: 153}
								evaluating: [
									receiver2 remainingTest:
										(#_coverageTracker173027711_
											cover: (155 to: 170)
											declaredAt: (14 to: 29)
											by: aMethodReference) ]
								thatSends: #remainingTest:
								to: receiver2 ] value).
					[ | receiver4 |
					receiver4 _ #_coverageTracker173027711_
						coverAll:
							{176 to: 179}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027711_
						coverAll:
							{181 to: 193}
						evaluating: [
							receiver4 transitionTo:
								[ | receiver3 |
								receiver3 _ #_coverageTracker173027711_
									coverAll:
										{196 to: 214}
									by: WritingAFailingTest.
								#_coverageTracker173027711_
									coverAll:
										{216 to: 227}
									evaluating: [
										receiver3 currentTest:
											(#_coverageTracker173027711_
												cover: (229 to: 241)
												declaredAt: (35 to: 47)
												by: remainingTest) ]
									thatSends: #currentTest:
									to: receiver3 ] value ]
						thatSends: #transitionTo:
						to: receiver4 ] value ]
				ifFalse: [
					[ | receiver5 |
					receiver5 _ #_coverageTracker173027711_
						coverAll:
							{263 to: 266}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027711_
						coverAll:
							{268 to: 300}
						evaluating: [ receiver5 reportErrorWhenSecondTestWasAdded ]
						thatSends: #reportErrorWhenSecondTestWasAdded
						to: receiver5 ] value.
					[ | receiver7 |
					receiver7 _ #_coverageTracker173027711_
						coverAll:
							{306 to: 309}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027711_
						coverAll:
							{311 to: 323}
						evaluating: [
							receiver7 transitionTo:
								[ | receiver6 |
								receiver6 _ #_coverageTracker173027711_
									coverAll:
										{325 to: 335}
									by: NotDoingTDD.
								#_coverageTracker173027711_
									coverAll:
										{337 to: 339}
									evaluating: [ receiver6 new ]
									thatSends: #new
									to: receiver6 ] value ]
						thatSends: #transitionTo:
						to: receiver7 ] value ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver8 ] value.! !
!Behavior method!
addError: anErrorString in: aChange
	#_coverageTracker173027725_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027725_
		cover: (38 to: 43)
		declaredAt: (38 to: 43)
		by: errors.
	#_coverageTracker173027725_
		coverAll:
			{45 to: 47. 57 to: 60}
		evaluating: [
			receiver1
				at:
					(#_coverageTracker173027725_
						cover: (49 to: 55)
						declaredAt: (29 to: 35)
						by: aChange)
				put:
					(#_coverageTracker173027725_
						cover: (62 to: 74)
						declaredAt: (11 to: 23)
						by: anErrorString) ]
		thatSends: #at:put:
		to: receiver1 ] value.! !
!Behavior method!
stateFrom
	#_coverageTracker173027734_ markAsExecuted.
	^ #_coverageTracker173027734_
		cover: (14 to: 22)
		declaredAt: (14 to: 22)
		by: fromState.! !
!Behavior method!
reportErrorWhenSecondTestWasAdded
	| errorMessage |
	#_coverageTracker173027738_ markAsExecuted.
	#_coverageTracker173027738_
		cover: (57 to: 65)
		declaredAt: (57 to: 65)
		by:
			(isCorrect _ #_coverageTracker173027738_
				coverAll:
					{70 to: 74}
				byLiteralOrPseudoVariable: false).
	#_coverageTracker173027738_
		cover: (78 to: 89)
		declaredAt: (39 to: 50)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173027738_
				coverAll:
					{94 to: 100}
				by: TDDGuru.
			#_coverageTracker173027738_
				coverAll:
					{102 to: 130. 152 to: 157}
				evaluating: [
					receiver3
						testAddedWhileWritingAnother:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173027738_
								cover: (132 to: 141)
								declaredAt: (132 to: 141)
								by: secondTest.
							#_coverageTracker173027738_
								coverAll:
									{143 to: 150}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173027738_
								cover: (159 to: 168)
								declaredAt: (132 to: 141)
								by: secondTest.
							#_coverageTracker173027738_
								coverAll:
									{170 to: 180}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #testAddedWhileWritingAnother:class:
				to: receiver3 ] value).
	[ | receiver4 |
	receiver4 _ #_coverageTracker173027738_
		coverAll:
			{184 to: 187}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027738_
		coverAll:
			{189 to: 202. 220 to: 224}
		evaluating: [
			receiver4
				reportErrorIn:
					(#_coverageTracker173027738_
						cover: (204 to: 218)
						declaredAt: (204 to: 218)
						by: testAddedChange)
				with:
					(#_coverageTracker173027738_
						cover: (226 to: 237)
						declaredAt: (39 to: 50)
						by: errorMessage) ]
		thatSends: #reportErrorIn:with:
		to: receiver4 ] value.! !
!Behavior method!
analysisFinished
	#_coverageTracker173027747_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173027747_
		coverAll:
			{19 to: 22}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027747_
		coverAll:
			{24 to: 49}
		evaluating: [ receiver1 checkIfItWasAValidRefactor ]
		thatSends: #checkIfItWasAValidRefactor
		to: receiver1 ] value.! !
!Behavior method!
initialState: aTDDState
	#_coverageTracker173027749_ markAsExecuted.
	#_coverageTracker173027749_
		cover: (26 to: 37)
		declaredAt: (26 to: 37)
		by:
			(initialState _ #_coverageTracker173027749_
				cover: (42 to: 50)
				declaredAt: (15 to: 23)
				by: aTDDState).! !
!Behavior method!
changeLog
	#_coverageTracker173027751_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027751_
		cover: (12 to: 20)
		declaredAt: (12 to: 20)
		by: changeLog.
	#_coverageTracker173027751_
		coverAll:
			{22 to: 27}
		evaluating: [
			receiver2 ifNil: [
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027751_
					coverAll:
						{33 to: 36}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027751_
					coverAll:
						{38 to: 56}
					evaluating: [ receiver1 initializeChangeLog ]
					thatSends: #initializeChangeLog
					to: receiver1 ] value ]]
		thatSends: #ifNil:
		to: receiver2 ] value.
	^ #_coverageTracker173027751_
		cover: (66 to: 74)
		declaredAt: (12 to: 20)
		by: changeLog.! !
!Behavior method!
changes
	#_coverageTracker173027756_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027756_
		cover: (14 to: 21)
		declaredAt: (14 to: 21)
		by: timeline.
	#_coverageTracker173027756_
		coverAll:
			{23 to: 29}
		evaluating: [ receiver1 changes ]
		thatSends: #changes
		to: receiver1 ] value.! !
!Behavior method!
newTestDetector
	#_coverageTracker173027759_ markAsExecuted.
	^ [ | receiver10 |
	receiver10 _ #_coverageTracker173027759_
		coverAll:
			{20 to: 33}
		by: ChangeDetector.
	#_coverageTracker173027759_
		coverAll:
			{35 to: 38. 48 to: 61. 65 to: 76}
		evaluating: [
			receiver10
				for:
					(#_coverageTracker173027759_
						coverAll:
							{40 to: 46}
						by: NewTest)
				withLookahead:
					(#_coverageTracker173027759_
						coverAll:
							{63 to: 63}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver9 |
					receiver9 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173027759_
						cover: (97 to: 109)
						declaredAt: (81 to: 93)
						by: aChangeRecord.
					#_coverageTracker173027759_
						coverAll:
							{111 to: 120}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173027759_
						coverAll:
							{122 to: 122}
						evaluating: [
							receiver2 =
								(#_coverageTracker173027759_
									coverAll:
										{124 to: 130}
									byLiteralOrPseudoVariable: #method) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173027759_
						coverAll:
							{135 to: 138. 182 to: 185. 237 to: 240}
						evaluating: [
							receiver9
								and: [
									[ | receiver4 |
									receiver4 _ [ | receiver3 |
									receiver3 _ #_coverageTracker173027759_
										cover: (142 to: 154)
										declaredAt: (81 to: 93)
										by: aChangeRecord.
									#_coverageTracker173027759_
										coverAll:
											{156 to: 171}
										evaluating: [ receiver3 isMethodDeletion ]
										thatSends: #isMethodDeletion
										to: receiver3 ] value.
									#_coverageTracker173027759_
										coverAll:
											{173 to: 175}
										evaluating: [ receiver4 not ]
										thatSends: #not
										to: receiver4 ] value ]
								and: [
									[ | receiver6 |
									receiver6 _ [ | receiver5 |
									receiver5 _ #_coverageTracker173027759_
										cover: (189 to: 201)
										declaredAt: (81 to: 93)
										by: aChangeRecord.
									#_coverageTracker173027759_
										coverAll:
											{203 to: 216}
										evaluating: [ receiver5 methodSelector ]
										thatSends: #methodSelector
										to: receiver5 ] value.
									#_coverageTracker173027759_
										coverAll:
											{218 to: 231}
										evaluating: [ receiver6 isTestSelector ]
										thatSends: #isTestSelector
										to: receiver6 ] value ]
								and: [
									[ | receiver8 |
									receiver8 _ [ | receiver7 |
									receiver7 _ #_coverageTracker173027759_
										cover: (244 to: 256)
										declaredAt: (81 to: 93)
										by: aChangeRecord.
									#_coverageTracker173027759_
										coverAll:
											{258 to: 262}
										evaluating: [ receiver7 prior ]
										thatSends: #prior
										to: receiver7 ] value.
									#_coverageTracker173027759_
										coverAll:
											{264 to: 268}
										evaluating: [ receiver8 isNil ]
										thatSends: #isNil
										to: receiver8 ] value ]]
						thatSends: #and:and:and:
						to: receiver9 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver10 ] value.! !
!Behavior method!
errorIn: aChange
	#_coverageTracker173027773_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027773_
		cover: (21 to: 26)
		declaredAt: (21 to: 26)
		by: errors.
	#_coverageTracker173027773_
		coverAll:
			{28 to: 30}
		evaluating: [
			receiver1 at:
				(#_coverageTracker173027773_
					cover: (32 to: 38)
					declaredAt: (10 to: 16)
					by: aChange) ]
		thatSends: #at:
		to: receiver1 ] value.! !
!Behavior method!
newTest: aTestReference
	#_coverageTracker173027776_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027776_
		coverAll:
			{27 to: 30}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027776_
		coverAll:
			{32 to: 44}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027776_
					coverAll:
						{47 to: 65}
					by: WritingAFailingTest.
				#_coverageTracker173027776_
					coverAll:
						{67 to: 78}
					evaluating: [
						receiver1 currentTest:
							(#_coverageTracker173027776_
								cover: (80 to: 93)
								declaredAt: (10 to: 23)
								by: aTestReference) ]
					thatSends: #currentTest:
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
assertCurrentStateIs: aState
	#_coverageTracker173027779_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027779_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027779_
		coverAll:
			{36 to: 42. 65 to: 71}
		evaluating: [
			receiver2
				assert:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173027779_
						cover: (44 to: 50)
						declaredAt: (44 to: 50)
						by: tddGuru.
					#_coverageTracker173027779_
						coverAll:
							{52 to: 63}
						evaluating: [ receiver1 currentState ]
						thatSends: #currentState
						to: receiver1 ] value
				equals:
					(#_coverageTracker173027779_
						cover: (73 to: 78)
						declaredAt: (23 to: 28)
						by: aState) ]
		thatSends: #assert:equals:
		to: receiver2 ] value.! !
!Behavior method!
remainingTest: anUninstalledMethodReference
	#_coverageTracker173027786_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027786_
		cover: (47 to: 55)
		declaredAt: (47 to: 55)
		by: firstTest.
	#_coverageTracker173027786_
		coverAll:
			{57 to: 57}
		evaluating: [
			receiver1 =
				(#_coverageTracker173027786_
					cover: (59 to: 86)
					declaredAt: (16 to: 43)
					by: anUninstalledMethodReference) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173027786_
		coverAll:
			{88 to: 94}
		evaluating: [ receiver2 ifTrue: [ ^ #_coverageTracker173027786_
					cover: (100 to: 109)
					declaredAt: (100 to: 109)
					by: secondTest ]]
		thatSends: #ifTrue:
		to: receiver2 ] value.
	[ | receiver4 |
	receiver4 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173027786_
		cover: (115 to: 124)
		declaredAt: (100 to: 109)
		by: secondTest.
	#_coverageTracker173027786_
		coverAll:
			{126 to: 126}
		evaluating: [
			receiver3 =
				(#_coverageTracker173027786_
					cover: (128 to: 155)
					declaredAt: (16 to: 43)
					by: anUninstalledMethodReference) ]
		thatSends: #=
		to: receiver3 ] value.
	#_coverageTracker173027786_
		coverAll:
			{157 to: 163}
		evaluating: [ receiver4 ifTrue: [ ^ #_coverageTracker173027786_
					cover: (169 to: 177)
					declaredAt: (47 to: 55)
					by: firstTest ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173027786_
		coverAll:
			{185 to: 188}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027786_
		coverAll:
			{190 to: 195}
		evaluating: [
			receiver5 error:
				(#_coverageTracker173027786_
					coverAll:
						{197 to: 232}
					byLiteralOrPseudoVariable: 'Test is not one of the state tests') ]
		thatSends: #error:
		to: receiver5 ] value.! !
!Behavior method!
stateTransitionFrom: previousTDDState to: currentTDDState
	#_coverageTracker173027795_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027795_
		coverAll:
			{60 to: 63}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027795_
		coverAll:
			{65 to: 73}
		evaluating: [
			receiver2 addEvent:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027795_
					coverAll:
						{76 to: 95}
					by: StateTransitionEvent.
				#_coverageTracker173027795_
					coverAll:
						{97 to: 101. 120 to: 122. 140 to: 142}
					evaluating: [
						receiver1
							from:
								(#_coverageTracker173027795_
									cover: (103 to: 118)
									declaredAt: (22 to: 37)
									by: previousTDDState)
							to:
								(#_coverageTracker173027795_
									cover: (124 to: 138)
									declaredAt: (43 to: 57)
									by: currentTDDState)
							in:
								(#_coverageTracker173027795_
									coverAll:
										{144 to: 147}
									byLiteralOrPseudoVariable: self) ]
					thatSends: #from:to:in:
					to: receiver1 ] value ]
		thatSends: #addEvent:
		to: receiver2 ] value.! !
!Behavior method!
textStylerClassFor: textGetter
	#_coverageTracker173027811_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027811_
		cover: (33 to: 42)
		declaredAt: (21 to: 30)
		by: textGetter.
	#_coverageTracker173027811_
		coverAll:
			{44 to: 44}
		evaluating: [
			receiver1 =
				(#_coverageTracker173027811_
					coverAll:
						{46 to: 58}
					byLiteralOrPseudoVariable: #selectedCode) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173027811_
		coverAll:
			{60 to: 66}
		evaluating: [ receiver2 ifTrue: [ ^ #_coverageTracker173027811_
					coverAll:
						{71 to: 86}
					by: SHTextStylerST80 ]]
		thatSends: #ifTrue:
		to: receiver2 ] value.
	^ #_coverageTracker173027811_
		coverAll:
			{100 to: 118}
		evaluating: [
			super textStylerClassFor:
				(#_coverageTracker173027811_
					cover: (120 to: 129)
					declaredAt: (21 to: 30)
					by: textGetter) ]
		thatSends: #textStylerClassFor:
		to: super.! !
!Behavior method!
noMoreTests
	#_coverageTracker173027817_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027817_
		coverAll:
			{14 to: 17}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027817_
		coverAll:
			{19 to: 31}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027817_
					coverAll:
						{33 to: 37}
					by: Green.
				#_coverageTracker173027817_
					coverAll:
						{39 to: 41}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
time
	| timeParts hours minutes seconds date time |
	#_coverageTracker173027822_ markAsExecuted.
	#_coverageTracker173027822_
		cover: (56 to: 59)
		declaredAt: (41 to: 44)
		by:
			(date _ [ | receiver3 |
			receiver3 _ #_coverageTracker173027822_
				coverAll:
					{64 to: 81}
				by: FixedGregorianDate.
			#_coverageTracker173027822_
				coverAll:
					{83 to: 91}
				evaluating: [
					receiver3 fromDate:
						[ | receiver2 |
						receiver2 _ [ | receiver1 |
						receiver1 _ #_coverageTracker173027822_
							coverAll:
								{93 to: 96}
							byLiteralOrPseudoVariable: self.
						#_coverageTracker173027822_
							coverAll:
								{98 to: 107}
							evaluating: [ receiver1 dateString ]
							thatSends: #dateString
							to: receiver1 ] value.
						#_coverageTracker173027822_
							coverAll:
								{109 to: 114}
							evaluating: [ receiver2 asDate ]
							thatSends: #asDate
							to: receiver2 ] value ]
				thatSends: #fromDate:
				to: receiver3 ] value).
	#_coverageTracker173027822_
		cover: (118 to: 126)
		declaredAt: (9 to: 17)
		by:
			(timeParts _ [ | receiver5 |
			receiver5 _ [ | receiver4 |
			receiver4 _ #_coverageTracker173027822_
				coverAll:
					{131 to: 134}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027822_
				coverAll:
					{136 to: 145}
				evaluating: [ receiver4 timeString ]
				thatSends: #timeString
				to: receiver4 ] value.
			#_coverageTracker173027822_
				coverAll:
					{147 to: 157}
				evaluating: [
					receiver5 findTokens:
						(#_coverageTracker173027822_
							coverAll:
								{159 to: 161}
							byLiteralOrPseudoVariable: ':') ]
				thatSends: #findTokens:
				to: receiver5 ] value).
	[ | receiver6 |
	receiver6 _ #_coverageTracker173027822_
		cover: (269 to: 277)
		declaredAt: (9 to: 17)
		by: timeParts.
	#_coverageTracker173027822_
		coverAll:
			{279 to: 282}
		evaluating: [
			receiver6 add:
				(#_coverageTracker173027822_
					coverAll:
						{284 to: 284}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #add:
		to: receiver6 ] value.
	[ | receiver12 |
	receiver12 _ [ | receiver8 |
	receiver8 _ [ | receiver7 |
	receiver7 _ #_coverageTracker173027822_
		cover: (288 to: 296)
		declaredAt: (9 to: 17)
		by: timeParts.
	#_coverageTracker173027822_
		coverAll:
			{298 to: 301}
		evaluating: [ receiver7 size ]
		thatSends: #size
		to: receiver7 ] value.
	#_coverageTracker173027822_
		coverAll:
			{303 to: 303}
		evaluating: [
			receiver8 <
				(#_coverageTracker173027822_
					coverAll:
						{305 to: 305}
					byLiteralOrPseudoVariable: 3) ]
		thatSends: #<
		to: receiver8 ] value.
	#_coverageTracker173027822_
		coverAll:
			{307 to: 313}
		evaluating: [
			receiver12 ifTrue: [
				[ | receiver11 |
				receiver11 _ #_coverageTracker173027822_
					coverAll:
						{317 to: 320}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027822_
					coverAll:
						{322 to: 327}
					evaluating: [
						receiver11 error:
							[ | receiver10 |
							receiver10 _ #_coverageTracker173027822_
								coverAll:
									{329 to: 352}
								byLiteralOrPseudoVariable: 'Incorrect time format '.
							#_coverageTracker173027822_
								coverAll:
									{353 to: 353}
								evaluating: [
									receiver10 ,
										[ | receiver9 |
										receiver9 _ #_coverageTracker173027822_
											coverAll:
												{355 to: 358}
											byLiteralOrPseudoVariable: self.
										#_coverageTracker173027822_
											coverAll:
												{360 to: 369}
											evaluating: [ receiver9 timeString ]
											thatSends: #timeString
											to: receiver9 ] value ]
								thatSends: #,
								to: receiver10 ] value ]
					thatSends: #error:
					to: receiver11 ] value ]]
		thatSends: #ifTrue:
		to: receiver12 ] value.
	#_coverageTracker173027822_
		cover: (377 to: 381)
		declaredAt: (19 to: 23)
		by:
			(hours _ [ | receiver14 |
			receiver14 _ [ | receiver13 |
			receiver13 _ #_coverageTracker173027822_
				cover: (386 to: 394)
				declaredAt: (9 to: 17)
				by: timeParts.
			#_coverageTracker173027822_
				coverAll:
					{396 to: 400}
				evaluating: [ receiver13 first ]
				thatSends: #first
				to: receiver13 ] value.
			#_coverageTracker173027822_
				coverAll:
					{402 to: 409}
				evaluating: [ receiver14 asNumber ]
				thatSends: #asNumber
				to: receiver14 ] value).
	#_coverageTracker173027822_
		cover: (413 to: 419)
		declaredAt: (25 to: 31)
		by:
			(minutes _ [ | receiver16 |
			receiver16 _ [ | receiver15 |
			receiver15 _ #_coverageTracker173027822_
				cover: (424 to: 432)
				declaredAt: (9 to: 17)
				by: timeParts.
			#_coverageTracker173027822_
				coverAll:
					{434 to: 439}
				evaluating: [ receiver15 second ]
				thatSends: #second
				to: receiver15 ] value.
			#_coverageTracker173027822_
				coverAll:
					{441 to: 448}
				evaluating: [ receiver16 asNumber ]
				thatSends: #asNumber
				to: receiver16 ] value).
	#_coverageTracker173027822_
		cover: (452 to: 458)
		declaredAt: (33 to: 39)
		by:
			(seconds _ [ | receiver18 |
			receiver18 _ [ | receiver17 |
			receiver17 _ #_coverageTracker173027822_
				cover: (463 to: 471)
				declaredAt: (9 to: 17)
				by: timeParts.
			#_coverageTracker173027822_
				coverAll:
					{473 to: 477}
				evaluating: [ receiver17 third ]
				thatSends: #third
				to: receiver17 ] value.
			#_coverageTracker173027822_
				coverAll:
					{479 to: 486}
				evaluating: [ receiver18 asNumber ]
				thatSends: #asNumber
				to: receiver18 ] value).
	#_coverageTracker173027822_
		cover: (492 to: 495)
		declaredAt: (46 to: 49)
		by:
			(time _ [ | receiver19 |
			receiver19 _ #_coverageTracker173027822_
				coverAll:
					{500 to: 508}
				by: TimeOfDay.
			#_coverageTracker173027822_
				coverAll:
					{510 to: 515. 523 to: 530. 540 to: 547}
				evaluating: [
					receiver19
						hours:
							(#_coverageTracker173027822_
								cover: (517 to: 521)
								declaredAt: (19 to: 23)
								by: hours)
						minutes:
							(#_coverageTracker173027822_
								cover: (532 to: 538)
								declaredAt: (25 to: 31)
								by: minutes)
						seconds:
							(#_coverageTracker173027822_
								cover: (549 to: 555)
								declaredAt: (33 to: 39)
								by: seconds) ]
				thatSends: #hours:minutes:seconds:
				to: receiver19 ] value).
	^ [ | receiver20 |
	receiver20 _ #_coverageTracker173027822_
		coverAll:
			{564 to: 580}
		by: GregorianDateTime.
	#_coverageTracker173027822_
		coverAll:
			{582 to: 586. 593 to: 602}
		evaluating: [
			receiver20
				date:
					(#_coverageTracker173027822_
						cover: (588 to: 591)
						declaredAt: (41 to: 44)
						by: date)
				timeOfDay:
					(#_coverageTracker173027822_
						cover: (604 to: 607)
						declaredAt: (46 to: 49)
						by: time) ]
		thatSends: #date:timeOfDay:
		to: receiver20 ] value.! !
!Behavior method!
printString
	#_coverageTracker173027864_ markAsExecuted.
	^ #_coverageTracker173027864_
		coverAll:
			{16 to: 39}
		byLiteralOrPseudoVariable: 'Writing a failing test'.! !
!Behavior method!
newModelClass: className
	#_coverageTracker173027865_ markAsExecuted.! !
!Behavior method!
initialize
	#_coverageTracker173027868_ markAsExecuted.
	#_coverageTracker173027868_
		cover: (13 to: 20)
		declaredAt: (13 to: 20)
		by:
			(timeline _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027868_
				coverAll:
					{25 to: 32}
				by: TimeLine.
			#_coverageTracker173027868_
				coverAll:
					{34 to: 37}
				evaluating: [
					receiver1 for:
						(#_coverageTracker173027868_
							coverAll:
								{39 to: 42}
							byLiteralOrPseudoVariable: self) ]
				thatSends: #for:
				to: receiver1 ] value).
	#_coverageTracker173027868_
		cover: (46 to: 51)
		declaredAt: (46 to: 51)
		by:
			(errors _ [ | receiver2 |
			receiver2 _ #_coverageTracker173027868_
				coverAll:
					{56 to: 65}
				by: Dictionary.
			#_coverageTracker173027868_
				coverAll:
					{67 to: 69}
				evaluating: [ receiver2 new ]
				thatSends: #new
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027868_
		cover: (75 to: 82)
		declaredAt: (13 to: 20)
		by: timeline.
	#_coverageTracker173027868_
		coverAll:
			{84 to: 96}
		evaluating: [
			receiver3 addDependent:
				(#_coverageTracker173027868_
					coverAll:
						{98 to: 101}
					byLiteralOrPseudoVariable: self) ]
		thatSends: #addDependent:
		to: receiver3 ] value.! !
!Behavior method!
selectionIndex: anInteger
	#_coverageTracker173027875_ markAsExecuted.
	#_coverageTracker173027875_
		cover: (28 to: 40)
		declaredAt: (28 to: 40)
		by:
			(selectedEvent _ [ | receiver4 |
			receiver4 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027875_
				cover: (45 to: 53)
				declaredAt: (17 to: 25)
				by: anInteger.
			#_coverageTracker173027875_
				coverAll:
					{55 to: 55}
				evaluating: [
					receiver1 =
						(#_coverageTracker173027875_
							coverAll:
								{57 to: 57}
							byLiteralOrPseudoVariable: 0) ]
				thatSends: #=
				to: receiver1 ] value.
			#_coverageTracker173027875_
				coverAll:
					{59 to: 66}
				evaluating: [
					receiver4 ifFalse: [
						[ | receiver3 |
						receiver3 _ [ | receiver2 |
						receiver2 _ #_coverageTracker173027875_
							coverAll:
								{70 to: 73}
							byLiteralOrPseudoVariable: self.
						#_coverageTracker173027875_
							coverAll:
								{75 to: 86}
							evaluating: [ receiver2 changeEvents ]
							thatSends: #changeEvents
							to: receiver2 ] value.
						#_coverageTracker173027875_
							coverAll:
								{88 to: 90}
							evaluating: [
								receiver3 at:
									(#_coverageTracker173027875_
										cover: (92 to: 100)
										declaredAt: (17 to: 25)
										by: anInteger) ]
							thatSends: #at:
							to: receiver3 ] value ]]
				thatSends: #ifFalse:
				to: receiver4 ] value).
	[ | receiver5 |
	receiver5 _ #_coverageTracker173027875_
		coverAll:
			{108 to: 111}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027875_
		coverAll:
			{113 to: 120}
		evaluating: [
			receiver5 changed:
				(#_coverageTracker173027875_
					coverAll:
						{122 to: 133}
					byLiteralOrPseudoVariable: #codeSection) ]
		thatSends: #changed:
		to: receiver5 ] value.
	[ | receiver6 |
	receiver6 _ #_coverageTracker173027875_
		coverAll:
			{137 to: 140}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027875_
		coverAll:
			{142 to: 154}
		evaluating: [
			receiver6 triggerEvent:
				(#_coverageTracker173027875_
					coverAll:
						{156 to: 169}
					byLiteralOrPseudoVariable: #detailChanged) ]
		thatSends: #triggerEvent:
		to: receiver6 ] value.! !
!Behavior method!
allTestsPassed
	#_coverageTracker173027884_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173027884_
		cover: (19 to: 29)
		declaredAt: (19 to: 29)
		by: passedTests.
	#_coverageTracker173027884_
		coverAll:
			{31 to: 31}
		evaluating: [
			receiver2 =
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027884_
					coverAll:
						{33 to: 36}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027884_
					coverAll:
						{38 to: 45}
					evaluating: [ receiver1 allTests ]
					thatSends: #allTests
					to: receiver1 ] value ]
		thatSends: #=
		to: receiver2 ] value.! !
!Behavior method!
drawStateTransitionRow: aRow on: aCanvas
	| currentEvent stateName stringWidth stateNamePosition |
	#_coverageTracker173027889_ markAsExecuted.
	#_coverageTracker173027889_
		cover: (101 to: 112)
		declaredAt: (45 to: 56)
		by:
			(currentEvent _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027889_
				cover: (117 to: 121)
				declaredAt: (117 to: 121)
				by: owner.
			#_coverageTracker173027889_
				coverAll:
					{123 to: 127}
				evaluating: [ receiver1 model ]
				thatSends: #model
				to: receiver1 ] value.
			#_coverageTracker173027889_
				coverAll:
					{129 to: 137}
				evaluating: [
					receiver2 changeAt:
						(#_coverageTracker173027889_
							cover: (139 to: 142)
							declaredAt: (25 to: 28)
							by: aRow) ]
				thatSends: #changeAt:
				to: receiver2 ] value).
	#_coverageTracker173027889_
		cover: (148 to: 156)
		declaredAt: (58 to: 66)
		by:
			(stateName _ [ | receiver4 |
			receiver4 _ [ | receiver3 |
			receiver3 _ #_coverageTracker173027889_
				cover: (161 to: 172)
				declaredAt: (45 to: 56)
				by: currentEvent.
			#_coverageTracker173027889_
				coverAll:
					{174 to: 180}
				evaluating: [ receiver3 stateTo ]
				thatSends: #stateTo
				to: receiver3 ] value.
			#_coverageTracker173027889_
				coverAll:
					{182 to: 192}
				evaluating: [ receiver4 printString ]
				thatSends: #printString
				to: receiver4 ] value).
	#_coverageTracker173027889_
		cover: (196 to: 206)
		declaredAt: (68 to: 78)
		by:
			(stringWidth _ [ | receiver5 |
			receiver5 _ #_coverageTracker173027889_
				cover: (211 to: 214)
				declaredAt: (211 to: 214)
				by: font.
			#_coverageTracker173027889_
				coverAll:
					{216 to: 229}
				evaluating: [
					receiver5 widthOfString:
						(#_coverageTracker173027889_
							cover: (231 to: 239)
							declaredAt: (58 to: 66)
							by: stateName) ]
				thatSends: #widthOfString:
				to: receiver5 ] value).
	#_coverageTracker173027889_
		cover: (243 to: 259)
		declaredAt: (80 to: 96)
		by:
			(stateNamePosition _ [ | receiver8 |
			receiver8 _ [ | receiver7 |
			receiver7 _ [ | receiver6 |
			receiver6 _ #_coverageTracker173027889_
				coverAll:
					{265 to: 268}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027889_
				coverAll:
					{270 to: 281}
				evaluating: [ receiver6 desiredWidth ]
				thatSends: #desiredWidth
				to: receiver6 ] value.
			#_coverageTracker173027889_
				coverAll:
					{283 to: 283}
				evaluating: [
					receiver7 -
						(#_coverageTracker173027889_
							cover: (285 to: 295)
							declaredAt: (68 to: 78)
							by: stringWidth) ]
				thatSends: #-
				to: receiver7 ] value.
			#_coverageTracker173027889_
				coverAll:
					{298 to: 298}
				evaluating: [
					receiver8 /
						(#_coverageTracker173027889_
							coverAll:
								{300 to: 300}
							byLiteralOrPseudoVariable: 2) ]
				thatSends: #/
				to: receiver8 ] value).
	[ | receiver12 |
	receiver12 _ #_coverageTracker173027889_
		cover: (304 to: 310)
		declaredAt: (34 to: 40)
		by: aCanvas.
	#_coverageTracker173027889_
		coverAll:
			{312 to: 322. 334 to: 336. 385 to: 389. 396 to: 401}
		evaluating: [
			receiver12
				drawString:
					(#_coverageTracker173027889_
						cover: (324 to: 332)
						declaredAt: (58 to: 66)
						by: stateName)
				at:
					[ | receiver10 |
					receiver10 _ #_coverageTracker173027889_
						cover: (339 to: 355)
						declaredAt: (80 to: 96)
						by: stateNamePosition.
					#_coverageTracker173027889_
						coverAll:
							{357 to: 357}
						evaluating: [
							receiver10 @
								[ | receiver9 |
								receiver9 _ #_coverageTracker173027889_
									coverAll:
										{360 to: 363}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173027889_
									coverAll:
										{365 to: 376}
									evaluating: [
										receiver9 drawYForRow:
											(#_coverageTracker173027889_
												cover: (378 to: 381)
												declaredAt: (25 to: 28)
												by: aRow) ]
									thatSends: #drawYForRow:
									to: receiver9 ] value ]
						thatSends: #@
						to: receiver10 ] value
				font:
					(#_coverageTracker173027889_
						cover: (391 to: 394)
						declaredAt: (211 to: 214)
						by: font)
				color:
					[ | receiver11 |
					receiver11 _ #_coverageTracker173027889_
						coverAll:
							{403 to: 407}
						by: Color.
					#_coverageTracker173027889_
						coverAll:
							{409 to: 413}
						evaluating: [ receiver11 white ]
						thatSends: #white
						to: receiver11 ] value ]
		thatSends: #drawString:at:font:color:
		to: receiver12 ] value.! !
!Behavior method!
stateAfter: aChange
	#_coverageTracker173027914_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173027914_
		cover: (25 to: 32)
		declaredAt: (25 to: 32)
		by: timeline.
	#_coverageTracker173027914_
		coverAll:
			{34 to: 44}
		evaluating: [
			receiver1 stateAfter:
				(#_coverageTracker173027914_
					cover: (46 to: 52)
					declaredAt: (13 to: 19)
					by: aChange) ]
		thatSends: #stateAfter:
		to: receiver1 ] value.! !
!Behavior method!
reportChangeTo: aTDDGuru
	#_coverageTracker173027917_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173027917_
		cover: (28 to: 35)
		declaredAt: (17 to: 24)
		by: aTDDGuru.
	#_coverageTracker173027917_
		coverAll:
			{37 to: 53}
		evaluating: [
			receiver2 testClassRemoved:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027917_
					coverAll:
						{55 to: 58}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027917_
					coverAll:
						{60 to: 74}
					evaluating: [ receiver1 changeClassName ]
					thatSends: #changeClassName
					to: receiver1 ] value ]
		thatSends: #testClassRemoved:
		to: receiver2 ] value.! !
!Behavior method!
hash
	#_coverageTracker173027921_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027921_
		coverAll:
			{9 to: 12}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027921_
		coverAll:
			{14 to: 24}
		evaluating: [ receiver1 methodClass ]
		thatSends: #methodClass
		to: receiver1 ] value.
	#_coverageTracker173027921_
		coverAll:
			{26 to: 29}
		evaluating: [ receiver2 hash ]
		thatSends: #hash
		to: receiver2 ] value.
	#_coverageTracker173027921_
		coverAll:
			{31 to: 31}
		evaluating: [
			receiver5 +
				[ | receiver4 |
				receiver4 _ [ | receiver3 |
				receiver3 _ #_coverageTracker173027921_
					coverAll:
						{33 to: 36}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027921_
					coverAll:
						{38 to: 45}
					evaluating: [ receiver3 selector ]
					thatSends: #selector
					to: receiver3 ] value.
				#_coverageTracker173027921_
					coverAll:
						{47 to: 50}
					evaluating: [ receiver4 hash ]
					thatSends: #hash
					to: receiver4 ] value ]
		thatSends: #+
		to: receiver5 ] value.! !
!Behavior method!
initialTestClasses: anArray
	#_coverageTracker173027925_ markAsExecuted.
	#_coverageTracker173027925_
		cover: (31 to: 39)
		declaredAt: (31 to: 39)
		by:
			(inventory _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027925_
				coverAll:
					{44 to: 56}
				by: TestInventory.
			#_coverageTracker173027925_
				coverAll:
					{58 to: 73}
				evaluating: [
					receiver1 withTestClasses:
						(#_coverageTracker173027925_
							cover: (75 to: 81)
							declaredAt: (21 to: 27)
							by: anArray) ]
				thatSends: #withTestClasses:
				to: receiver1 ] value).! !
!Behavior method!
stateTo
	#_coverageTracker173027928_ markAsExecuted.
	^ #_coverageTracker173027928_
		cover: (12 to: 18)
		declaredAt: (12 to: 18)
		by: toState.! !
!Behavior method!
description
	#_coverageTracker173027931_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173027931_
		coverAll:
			{16 to: 32}
		byLiteralOrPseudoVariable: 'New test class '.
	#_coverageTracker173027931_
		coverAll:
			{33 to: 33}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027931_
					coverAll:
						{35 to: 38}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027931_
					coverAll:
						{40 to: 54}
					evaluating: [ receiver1 changeClassName ]
					thatSends: #changeClassName
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
testPassed: aTestReference
	| errorMessage |
	#_coverageTracker173027942_ markAsExecuted.
	[ | receiver7 |
	receiver7 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027942_
		cover: (50 to: 63)
		declaredAt: (13 to: 26)
		by: aTestReference.
	#_coverageTracker173027942_
		coverAll:
			{65 to: 65}
		evaluating: [
			receiver1 =
				(#_coverageTracker173027942_
					cover: (67 to: 70)
					declaredAt: (67 to: 70)
					by: test) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173027942_
		coverAll:
			{72 to: 78}
		evaluating: [
			receiver7 ifTrue: [
				#_coverageTracker173027942_
					cover: (84 to: 95)
					declaredAt: (32 to: 43)
					by:
						(errorMessage _ [ | receiver4 |
						receiver4 _ #_coverageTracker173027942_
							coverAll:
								{100 to: 106}
							by: TDDGuru.
						#_coverageTracker173027942_
							coverAll:
								{108 to: 122. 148 to: 153}
							evaluating: [
								receiver4
									testDidNotFail:
										[ | receiver2 |
										receiver2 _ #_coverageTracker173027942_
											cover: (124 to: 137)
											declaredAt: (13 to: 26)
											by: aTestReference.
										#_coverageTracker173027942_
											coverAll:
												{139 to: 146}
											evaluating: [ receiver2 selector ]
											thatSends: #selector
											to: receiver2 ] value
									class:
										[ | receiver3 |
										receiver3 _ #_coverageTracker173027942_
											cover: (155 to: 168)
											declaredAt: (13 to: 26)
											by: aTestReference.
										#_coverageTracker173027942_
											coverAll:
												{170 to: 180}
											evaluating: [ receiver3 methodClass ]
											thatSends: #methodClass
											to: receiver3 ] value ]
							thatSends: #testDidNotFail:class:
							to: receiver4 ] value).
				[ | receiver6 |
				receiver6 _ #_coverageTracker173027942_
					coverAll:
						{185 to: 188}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027942_
					coverAll:
						{190 to: 201. 216 to: 231}
					evaluating: [
						receiver6
							reportError:
								(#_coverageTracker173027942_
									cover: (203 to: 214)
									declaredAt: (32 to: 43)
									by: errorMessage)
							andTransitionTo:
								[ | receiver5 |
								receiver5 _ #_coverageTracker173027942_
									coverAll:
										{233 to: 237}
									by: Green.
								#_coverageTracker173027942_
									coverAll:
										{239 to: 241}
									evaluating: [ receiver5 new ]
									thatSends: #new
									to: receiver5 ] value ]
					thatSends: #reportError:andTransitionTo:
					to: receiver6 ] value ]]
		thatSends: #ifTrue:
		to: receiver7 ] value.! !
!Behavior method!
with: aTDDState
	#_coverageTracker173027954_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027954_
		coverAll:
			{20 to: 23}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027954_
		coverAll:
			{25 to: 27}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173027954_
		coverAll:
			{29 to: 37}
		evaluating: [
			receiver2 tddState:
				(#_coverageTracker173027954_
					cover: (39 to: 47)
					declaredAt: (7 to: 15)
					by: aTDDState) ]
		thatSends: #tddState:
		to: receiver2 ] value.! !
!Behavior method!
description
	#_coverageTracker173027958_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173027958_
		coverAll:
			{16 to: 33}
		byLiteralOrPseudoVariable: 'New model class '.
	#_coverageTracker173027958_
		coverAll:
			{34 to: 34}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173027958_
					coverAll:
						{36 to: 39}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173027958_
					coverAll:
						{41 to: 55}
					evaluating: [ receiver1 changeClassName ]
					thatSends: #changeClassName
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
modelMethodChanged: aSymbol
	#_coverageTracker173027960_ markAsExecuted.! !
!Behavior method!
isUsedInOneOfTheChangedMethods: aMethodReference
	#_coverageTracker173027962_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ #_coverageTracker173027962_
		cover: (53 to: 66)
		declaredAt: (53 to: 66)
		by: changedMethods.
	#_coverageTracker173027962_
		coverAll:
			{68 to: 78}
		evaluating: [
			receiver3 anySatisfy: [ :aChangedMethod |
				[ | receiver2 |
				receiver2 _ #_coverageTracker173027962_
					cover: (100 to: 113)
					declaredAt: (83 to: 96)
					by: aChangedMethod.
				#_coverageTracker173027962_
					coverAll:
						{115 to: 139}
					evaluating: [
						receiver2 sendsMessageWithSelector:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173027962_
								cover: (141 to: 156)
								declaredAt: (33 to: 48)
								by: aMethodReference.
							#_coverageTracker173027962_
								coverAll:
									{158 to: 165}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value ]
					thatSends: #sendsMessageWithSelector:
					to: receiver2 ] value ]]
		thatSends: #anySatisfy:
		to: receiver3 ] value.! !
!Behavior method!
buttonPanel
	| buttonColor row rerunButton |
	#_coverageTracker173027970_ markAsExecuted.
	#_coverageTracker173027970_
		cover: (49 to: 59)
		declaredAt: (16 to: 26)
		by:
			(buttonColor _ [ | receiver1 |
			receiver1 _ #_coverageTracker173027970_
				coverAll:
					{63 to: 66}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173027970_
				coverAll:
					{68 to: 78}
				evaluating: [ receiver1 buttonColor ]
				thatSends: #buttonColor
				to: receiver1 ] value).
	#_coverageTracker173027970_
		cover: (82 to: 92)
		declaredAt: (32 to: 42)
		by:
			(rerunButton _ [ | receiver2 |
			receiver2 _ #_coverageTracker173027970_
				coverAll:
					{97 to: 116}
				by: PluggableButtonMorph.
			#_coverageTracker173027970_
				coverAll:
					{124 to: 129. 141 to: 152. 163 to: 169}
				evaluating: [
					receiver2
						model:
							(#_coverageTracker173027970_
								coverAll:
									{131 to: 134}
								byLiteralOrPseudoVariable: self)
						stateGetter:
							(#_coverageTracker173027970_
								coverAll:
									{154 to: 156}
								byLiteralOrPseudoVariable: nil)
						action:
							(#_coverageTracker173027970_
								coverAll:
									{171 to: 176}
								byLiteralOrPseudoVariable: #rerun) ]
				thatSends: #model:stateGetter:action:
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173027970_
		cover: (180 to: 190)
		declaredAt: (32 to: 42)
		by: rerunButton.
	#_coverageTracker173027970_
		coverAll:
			{192 to: 197}
		evaluating: [
			receiver3 color:
				(#_coverageTracker173027970_
					cover: (199 to: 209)
					declaredAt: (16 to: 26)
					by: buttonColor) ]
		thatSends: #color:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173027970_
		cover: (213 to: 223)
		declaredAt: (32 to: 42)
		by: rerunButton.
	#_coverageTracker173027970_
		coverAll:
			{225 to: 230}
		evaluating: [
			receiver4 label:
				(#_coverageTracker173027970_
					coverAll:
						{232 to: 240}
					byLiteralOrPseudoVariable: 'Refresh') ]
		thatSends: #label:
		to: receiver4 ] value.
	#_coverageTracker173027970_
		cover: (246 to: 248)
		declaredAt: (28 to: 30)
		by:
			(row _ [ | receiver5 |
			receiver5 _ #_coverageTracker173027970_
				coverAll:
					{252 to: 262}
				by: LayoutMorph.
			#_coverageTracker173027970_
				coverAll:
					{264 to: 269}
				evaluating: [ receiver5 newRow ]
				thatSends: #newRow
				to: receiver5 ] value).
	[ | receiver6 |
	receiver6 _ #_coverageTracker173027970_
		cover: (273 to: 275)
		declaredAt: (28 to: 30)
		by: row.
	#_coverageTracker173027970_
		coverAll:
			{277 to: 295}
		evaluating: [ receiver6 doAdoptWidgetsColor ]
		thatSends: #doAdoptWidgetsColor
		to: receiver6 ] value.
	[ | receiver7 |
	receiver7 _ #_coverageTracker173027970_
		cover: (299 to: 301)
		declaredAt: (28 to: 30)
		by: row.
	#_coverageTracker173027970_
		coverAll:
			{303 to: 308}
		evaluating: [
			receiver7 color:
				(#_coverageTracker173027970_
					cover: (310 to: 320)
					declaredAt: (16 to: 26)
					by: buttonColor) ]
		thatSends: #color:
		to: receiver7 ] value.
	[ | receiver8 |
	receiver8 _ #_coverageTracker173027970_
		cover: (324 to: 326)
		declaredAt: (28 to: 30)
		by: row.
	#_coverageTracker173027970_
		coverAll:
			{328 to: 336}
		evaluating: [
			receiver8 addMorph:
				(#_coverageTracker173027970_
					cover: (338 to: 348)
					declaredAt: (32 to: 42)
					by: rerunButton) ]
		thatSends: #addMorph:
		to: receiver8 ] value.
	^ #_coverageTracker173027970_
		cover: (354 to: 356)
		declaredAt: (28 to: 30)
		by: row.! !
!Behavior method!
drawOn: aCanvas
	#_coverageTracker173027989_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173027989_
		cover: (19 to: 27)
		declaredAt: (19 to: 27)
		by: listItems.
	#_coverageTracker173027989_
		coverAll:
			{29 to: 32}
		evaluating: [ receiver1 size ]
		thatSends: #size
		to: receiver1 ] value.
	#_coverageTracker173027989_
		coverAll:
			{34 to: 34}
		evaluating: [
			receiver2 =
				(#_coverageTracker173027989_
					coverAll:
						{36 to: 36}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #=
		to: receiver2 ] value.
	#_coverageTracker173027989_
		coverAll:
			{38 to: 44}
		evaluating: [ receiver3 ifTrue: [ ^ #_coverageTracker173027989_
					coverAll:
						{49 to: 52}
					byLiteralOrPseudoVariable: self ]]
		thatSends: #ifTrue:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173027989_
		coverAll:
			{60 to: 63}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027989_
		coverAll:
			{65 to: 80}
		evaluating: [
			receiver4 drawHighlightOn:
				(#_coverageTracker173027989_
					cover: (82 to: 88)
					declaredAt: (9 to: 15)
					by: aCanvas) ]
		thatSends: #drawHighlightOn:
		to: receiver4 ] value.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173027989_
		coverAll:
			{92 to: 95}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027989_
		coverAll:
			{97 to: 112}
		evaluating: [
			receiver5 drawSelectionOn:
				(#_coverageTracker173027989_
					cover: (114 to: 120)
					declaredAt: (9 to: 15)
					by: aCanvas) ]
		thatSends: #drawSelectionOn:
		to: receiver5 ] value.
	[ | receiver12 |
	receiver12 _ [ | receiver6 |
	receiver6 _ #_coverageTracker173027989_
		coverAll:
			{128 to: 131}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173027989_
		coverAll:
			{133 to: 155}
		evaluating: [
			receiver6 topVisibleRowForCanvas:
				(#_coverageTracker173027989_
					cover: (157 to: 163)
					declaredAt: (9 to: 15)
					by: aCanvas) ]
		thatSends: #topVisibleRowForCanvas:
		to: receiver6 ] value.
	#_coverageTracker173027989_
		coverAll:
			{168 to: 170. 216 to: 218}
		evaluating: [
			receiver12
				to:
					[ | receiver7 |
					receiver7 _ #_coverageTracker173027989_
						coverAll:
							{173 to: 176}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027989_
						coverAll:
							{178 to: 203}
						evaluating: [
							receiver7 bottomVisibleRowForCanvas:
								(#_coverageTracker173027989_
									cover: (205 to: 211)
									declaredAt: (9 to: 15)
									by: aCanvas) ]
						thatSends: #bottomVisibleRowForCanvas:
						to: receiver7 ] value
				do: [ :row |
					[ | receiver10 |
					receiver10 _ [ | receiver8 |
					receiver8 _ #_coverageTracker173027989_
						cover: (233 to: 237)
						declaredAt: (233 to: 237)
						by: owner.
					#_coverageTracker173027989_
						coverAll:
							{239 to: 264}
						evaluating: [
							receiver8 itemSelectedAmongMultiple:
								(#_coverageTracker173027989_
									cover: (267 to: 269)
									declaredAt: (223 to: 225)
									by: row) ]
						thatSends: #itemSelectedAmongMultiple:
						to: receiver8 ] value.
					#_coverageTracker173027989_
						coverAll:
							{272 to: 278}
						evaluating: [
							receiver10 ifTrue: [
								[ | receiver9 |
								receiver9 _ #_coverageTracker173027989_
									coverAll:
										{286 to: 289}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173027989_
									coverAll:
										{291 to: 313. 319 to: 321}
									evaluating: [
										receiver9
											drawBackgroundForMulti:
												(#_coverageTracker173027989_
													cover: (315 to: 317)
													declaredAt: (223 to: 225)
													by: row)
											on:
												(#_coverageTracker173027989_
													cover: (323 to: 329)
													declaredAt: (9 to: 15)
													by: aCanvas) ]
									thatSends: #drawBackgroundForMulti:on:
									to: receiver9 ] value ]]
						thatSends: #ifTrue:
						to: receiver10 ] value.
					[ | receiver11 |
					receiver11 _ #_coverageTracker173027989_
						coverAll:
							{338 to: 341}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173027989_
						coverAll:
							{343 to: 350. 356 to: 358}
						evaluating: [
							receiver11
								drawRow:
									(#_coverageTracker173027989_
										cover: (352 to: 354)
										declaredAt: (223 to: 225)
										by: row)
								on:
									(#_coverageTracker173027989_
										cover: (360 to: 366)
										declaredAt: (9 to: 15)
										by: aCanvas) ]
						thatSends: #drawRow:on:
						to: receiver11 ] value ]]
		thatSends: #to:do:
		to: receiver12 ] value.! !
!Behavior method!
printString
	#_coverageTracker173028011_ markAsExecuted.
	^ [ | receiver6 |
	receiver6 _ [ | receiver4 |
	receiver4 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173028011_
		coverAll:
			{17 to: 19}
		byLiteralOrPseudoVariable: '['.
	#_coverageTracker173028011_
		coverAll:
			{20 to: 20}
		evaluating: [
			receiver3 ,
				[ | receiver2 |
				receiver2 _ [ | receiver1 |
				receiver1 _ #_coverageTracker173028011_
					coverAll:
						{22 to: 25}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028011_
					coverAll:
						{27 to: 34}
					evaluating: [ receiver1 category ]
					thatSends: #category
					to: receiver1 ] value.
				#_coverageTracker173028011_
					coverAll:
						{36 to: 46}
					evaluating: [ receiver2 printString ]
					thatSends: #printString
					to: receiver2 ] value ]
		thatSends: #,
		to: receiver3 ] value.
	#_coverageTracker173028011_
		coverAll:
			{47 to: 47}
		evaluating: [
			receiver4 ,
				(#_coverageTracker173028011_
					coverAll:
						{49 to: 52}
					byLiteralOrPseudoVariable: '] ') ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173028011_
		coverAll:
			{53 to: 53}
		evaluating: [
			receiver6 ,
				[ | receiver5 |
				receiver5 _ #_coverageTracker173028011_
					coverAll:
						{55 to: 58}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028011_
					coverAll:
						{60 to: 70}
					evaluating: [ receiver5 description ]
					thatSends: #description
					to: receiver5 ] value ]
		thatSends: #,
		to: receiver6 ] value.! !
!Behavior method!
modelClassRemoved: className
	#_coverageTracker173028017_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028017_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028017_
		coverAll:
			{36 to: 47. 101 to: 116}
		evaluating: [
			receiver3
				reportError:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173028017_
						coverAll:
							{50 to: 56}
						by: TDDGuru.
					#_coverageTracker173028017_
						coverAll:
							{58 to: 88}
						evaluating: [
							receiver1 classRemovedBeforeRunningTests:
								(#_coverageTracker173028017_
									cover: (90 to: 98)
									declaredAt: (20 to: 28)
									by: className) ]
						thatSends: #classRemovedBeforeRunningTests:
						to: receiver1 ] value
				andTransitionTo:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173028017_
						coverAll:
							{118 to: 128}
						by: NotDoingTDD.
					#_coverageTracker173028017_
						coverAll:
							{130 to: 132}
						evaluating: [ receiver2 new ]
						thatSends: #new
						to: receiver2 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver3 ] value.! !
!Behavior method!
for: aTDDState width: widthNumber height: heightNumber
	#_coverageTracker173028030_ markAsExecuted.
	#_coverageTracker173028030_
		cover: (57 to: 64)
		declaredAt: (57 to: 64)
		by:
			(tddState _ #_coverageTracker173028030_
				cover: (69 to: 77)
				declaredAt: (6 to: 14)
				by: aTDDState).
	#_coverageTracker173028030_
		cover: (81 to: 85)
		declaredAt: (81 to: 85)
		by:
			(width _ #_coverageTracker173028030_
				cover: (90 to: 100)
				declaredAt: (23 to: 33)
				by: widthNumber).
	#_coverageTracker173028030_
		cover: (104 to: 109)
		declaredAt: (104 to: 109)
		by:
			(height _ #_coverageTracker173028030_
				cover: (114 to: 125)
				declaredAt: (43 to: 54)
				by: heightNumber).! !
!Behavior method!
testFailed: anUninstalledMethodReference
	#_coverageTracker173028033_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028033_
		coverAll:
			{44 to: 47}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028033_
		coverAll:
			{49 to: 81}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028033_
		coverAll:
			{85 to: 88}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028033_
		coverAll:
			{90 to: 102}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028033_
					coverAll:
						{104 to: 106}
					by: Red.
				#_coverageTracker173028033_
					coverAll:
						{108 to: 110}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
initialize
	#_coverageTracker173028042_ markAsExecuted.
	#_coverageTracker173028042_
		cover: (13 to: 27)
		declaredAt: (13 to: 27)
		by:
			(changeDetectors _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028042_
				coverAll:
					{32 to: 48}
				by: OrderedCollection.
			#_coverageTracker173028042_
				coverAll:
					{50 to: 52}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028042_
		cover: (58 to: 72)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{74 to: 77}
		evaluating: [
			receiver3 add:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028042_
					coverAll:
						{79 to: 82}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{84 to: 102}
					evaluating: [ receiver2 testRenamedDetector ]
					thatSends: #testRenamedDetector
					to: receiver2 ] value ]
		thatSends: #add:
		to: receiver3 ] value.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173028042_
		cover: (106 to: 120)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{122 to: 125}
		evaluating: [
			receiver5 add:
				[ | receiver4 |
				receiver4 _ #_coverageTracker173028042_
					coverAll:
						{127 to: 130}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{132 to: 155}
					evaluating: [ receiver4 testClassRemovedDetector ]
					thatSends: #testClassRemovedDetector
					to: receiver4 ] value ]
		thatSends: #add:
		to: receiver5 ] value.
	[ | receiver7 |
	receiver7 _ #_coverageTracker173028042_
		cover: (159 to: 173)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{175 to: 178}
		evaluating: [
			receiver7 add:
				[ | receiver6 |
				receiver6 _ #_coverageTracker173028042_
					coverAll:
						{180 to: 183}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{185 to: 204}
					evaluating: [ receiver6 classRemovedDetector ]
					thatSends: #classRemovedDetector
					to: receiver6 ] value ]
		thatSends: #add:
		to: receiver7 ] value.
	[ | receiver9 |
	receiver9 _ #_coverageTracker173028042_
		cover: (208 to: 222)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{224 to: 227}
		evaluating: [
			receiver9 add:
				[ | receiver8 |
				receiver8 _ #_coverageTracker173028042_
					coverAll:
						{229 to: 232}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{234 to: 253}
					evaluating: [ receiver8 classRenamedDetector ]
					thatSends: #classRenamedDetector
					to: receiver8 ] value ]
		thatSends: #add:
		to: receiver9 ] value.
	[ | receiver11 |
	receiver11 _ #_coverageTracker173028042_
		cover: (257 to: 271)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{273 to: 276}
		evaluating: [
			receiver11 add:
				[ | receiver10 |
				receiver10 _ #_coverageTracker173028042_
					coverAll:
						{278 to: 281}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{283 to: 301}
					evaluating: [ receiver10 testRemovedDetector ]
					thatSends: #testRemovedDetector
					to: receiver10 ] value ]
		thatSends: #add:
		to: receiver11 ] value.
	[ | receiver13 |
	receiver13 _ #_coverageTracker173028042_
		cover: (305 to: 319)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{321 to: 324}
		evaluating: [
			receiver13 add:
				[ | receiver12 |
				receiver12 _ #_coverageTracker173028042_
					coverAll:
						{326 to: 329}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{331 to: 356}
					evaluating: [ receiver12 modelMethodRemovedDetector ]
					thatSends: #modelMethodRemovedDetector
					to: receiver12 ] value ]
		thatSends: #add:
		to: receiver13 ] value.
	[ | receiver15 |
	receiver15 _ #_coverageTracker173028042_
		cover: (360 to: 374)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{376 to: 379}
		evaluating: [
			receiver15 add:
				[ | receiver14 |
				receiver14 _ #_coverageTracker173028042_
					coverAll:
						{381 to: 384}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{386 to: 411}
					evaluating: [ receiver14 newProductionClassDetector ]
					thatSends: #newProductionClassDetector
					to: receiver14 ] value ]
		thatSends: #add:
		to: receiver15 ] value.
	[ | receiver17 |
	receiver17 _ #_coverageTracker173028042_
		cover: (415 to: 429)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{431 to: 434}
		evaluating: [
			receiver17 add:
				[ | receiver16 |
				receiver16 _ #_coverageTracker173028042_
					coverAll:
						{436 to: 439}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{441 to: 467}
					evaluating: [ receiver16 newProductionMethodDetector ]
					thatSends: #newProductionMethodDetector
					to: receiver16 ] value ]
		thatSends: #add:
		to: receiver17 ] value.
	[ | receiver19 |
	receiver19 _ #_coverageTracker173028042_
		cover: (471 to: 485)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{487 to: 490}
		evaluating: [
			receiver19 add:
				[ | receiver18 |
				receiver18 _ #_coverageTracker173028042_
					coverAll:
						{492 to: 495}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{497 to: 511}
					evaluating: [ receiver18 newTestDetector ]
					thatSends: #newTestDetector
					to: receiver18 ] value ]
		thatSends: #add:
		to: receiver19 ] value.
	[ | receiver21 |
	receiver21 _ #_coverageTracker173028042_
		cover: (515 to: 529)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{531 to: 534}
		evaluating: [
			receiver21 add:
				[ | receiver20 |
				receiver20 _ #_coverageTracker173028042_
					coverAll:
						{536 to: 539}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{541 to: 560}
					evaluating: [ receiver20 newTestClassDetector ]
					thatSends: #newTestClassDetector
					to: receiver20 ] value ]
		thatSends: #add:
		to: receiver21 ] value.
	[ | receiver23 |
	receiver23 _ #_coverageTracker173028042_
		cover: (564 to: 578)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{580 to: 583}
		evaluating: [
			receiver23 add:
				[ | receiver22 |
				receiver22 _ #_coverageTracker173028042_
					coverAll:
						{585 to: 588}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{590 to: 620}
					evaluating: [ receiver22 productionMethodChangedDetector ]
					thatSends: #productionMethodChangedDetector
					to: receiver22 ] value ]
		thatSends: #add:
		to: receiver23 ] value.
	[ | receiver25 |
	receiver25 _ #_coverageTracker173028042_
		cover: (624 to: 638)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{640 to: 643}
		evaluating: [
			receiver25 add:
				[ | receiver24 |
				receiver24 _ #_coverageTracker173028042_
					coverAll:
						{645 to: 648}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{650 to: 668}
					evaluating: [ receiver24 testChangedDetector ]
					thatSends: #testChangedDetector
					to: receiver24 ] value ]
		thatSends: #add:
		to: receiver25 ] value.
	[ | receiver27 |
	receiver27 _ #_coverageTracker173028042_
		cover: (672 to: 686)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{688 to: 691}
		evaluating: [
			receiver27 add:
				[ | receiver26 |
				receiver26 _ #_coverageTracker173028042_
					coverAll:
						{693 to: 696}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{698 to: 715}
					evaluating: [ receiver26 testFailedDetector ]
					thatSends: #testFailedDetector
					to: receiver26 ] value ]
		thatSends: #add:
		to: receiver27 ] value.
	[ | receiver29 |
	receiver29 _ #_coverageTracker173028042_
		cover: (719 to: 733)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{735 to: 738}
		evaluating: [
			receiver29 add:
				[ | receiver28 |
				receiver28 _ #_coverageTracker173028042_
					coverAll:
						{740 to: 743}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{745 to: 762}
					evaluating: [ receiver28 testPassedDetector ]
					thatSends: #testPassedDetector
					to: receiver28 ] value ]
		thatSends: #add:
		to: receiver29 ] value.
	[ | receiver31 |
	receiver31 _ #_coverageTracker173028042_
		cover: (766 to: 780)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{782 to: 785}
		evaluating: [
			receiver31 add:
				[ | receiver30 |
				receiver30 _ #_coverageTracker173028042_
					coverAll:
						{787 to: 790}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{792 to: 816}
					evaluating: [ receiver30 testUtilityChangeDetector ]
					thatSends: #testUtilityChangeDetector
					to: receiver30 ] value ]
		thatSends: #add:
		to: receiver31 ] value.
	[ | receiver33 |
	receiver33 _ #_coverageTracker173028042_
		cover: (820 to: 834)
		declaredAt: (13 to: 27)
		by: changeDetectors.
	#_coverageTracker173028042_
		coverAll:
			{836 to: 839}
		evaluating: [
			receiver33 add:
				[ | receiver32 |
				receiver32 _ #_coverageTracker173028042_
					coverAll:
						{841 to: 844}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028042_
					coverAll:
						{846 to: 866}
					evaluating: [ receiver32 unknownChangeDetector ]
					thatSends: #unknownChangeDetector
					to: receiver32 ] value ]
		thatSends: #add:
		to: receiver33 ] value.! !
!Behavior method!
setState: aTDDState
	| previousState |
	#_coverageTracker173028108_ markAsExecuted.
	#_coverageTracker173028108_
		cover: (42 to: 54)
		declaredAt: (25 to: 37)
		by:
			(previousState _ #_coverageTracker173028108_
				cover: (59 to: 63)
				declaredAt: (59 to: 63)
				by: state).
	#_coverageTracker173028108_
		cover: (67 to: 71)
		declaredAt: (59 to: 63)
		by:
			(state _ #_coverageTracker173028108_
				cover: (76 to: 84)
				declaredAt: (11 to: 19)
				by: aTDDState).
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028108_
		cover: (88 to: 92)
		declaredAt: (59 to: 63)
		by: state.
	#_coverageTracker173028108_
		coverAll:
			{94 to: 101}
		evaluating: [
			receiver1 context:
				(#_coverageTracker173028108_
					coverAll:
						{103 to: 106}
					byLiteralOrPseudoVariable: self) ]
		thatSends: #context:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028108_
		cover: (112 to: 125)
		declaredAt: (112 to: 125)
		by: analysisResult.
	#_coverageTracker173028108_
		coverAll:
			{127 to: 146. 162 to: 164}
		evaluating: [
			receiver2
				stateTransitionFrom:
					(#_coverageTracker173028108_
						cover: (148 to: 160)
						declaredAt: (25 to: 37)
						by: previousState)
				to:
					(#_coverageTracker173028108_
						cover: (166 to: 170)
						declaredAt: (59 to: 63)
						by: state) ]
		thatSends: #stateTransitionFrom:to:
		to: receiver2 ] value.! !
!Behavior method!
newTest: aTestReference
	#_coverageTracker173028115_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028115_
		cover: (27 to: 31)
		declaredAt: (27 to: 31)
		by: tests.
	#_coverageTracker173028115_
		coverAll:
			{33 to: 36}
		evaluating: [
			receiver1 add:
				(#_coverageTracker173028115_
					cover: (38 to: 51)
					declaredAt: (10 to: 23)
					by: aTestReference) ]
		thatSends: #add:
		to: receiver1 ] value.! !
!Behavior method!
testRenamedFrom: previousTestReference to: currentTestReference
	#_coverageTracker173028119_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028119_
		coverAll:
			{68 to: 71}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028119_
		coverAll:
			{73 to: 95}
		evaluating: [
			receiver1 isOneOfTheCurrentTests:
				(#_coverageTracker173028119_
					cover: (97 to: 117)
					declaredAt: (18 to: 38)
					by: previousTestReference) ]
		thatSends: #isOneOfTheCurrentTests:
		to: receiver1 ] value.
	#_coverageTracker173028119_
		coverAll:
			{122 to: 128. 204 to: 211}
		evaluating: [
			receiver6
				ifTrue: [
					[ | receiver2 |
					receiver2 _ #_coverageTracker173028119_
						coverAll:
							{132 to: 135}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028119_
						coverAll:
							{137 to: 151. 175 to: 177}
						evaluating: [
							receiver2
								renameTestFrom:
									(#_coverageTracker173028119_
										cover: (153 to: 173)
										declaredAt: (18 to: 38)
										by: previousTestReference)
								to:
									(#_coverageTracker173028119_
										cover: (179 to: 198)
										declaredAt: (44 to: 63)
										by: currentTestReference) ]
						thatSends: #renameTestFrom:to:
						to: receiver2 ] value ]
				ifFalse: [
					[ | receiver3 |
					receiver3 _ #_coverageTracker173028119_
						coverAll:
							{219 to: 222}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028119_
						coverAll:
							{224 to: 256}
						evaluating: [ receiver3 reportErrorWhenSecondTestWasAdded ]
						thatSends: #reportErrorWhenSecondTestWasAdded
						to: receiver3 ] value.
					[ | receiver5 |
					receiver5 _ #_coverageTracker173028119_
						coverAll:
							{262 to: 265}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028119_
						coverAll:
							{267 to: 279}
						evaluating: [
							receiver5 transitionTo:
								[ | receiver4 |
								receiver4 _ #_coverageTracker173028119_
									coverAll:
										{281 to: 291}
									by: NotDoingTDD.
								#_coverageTracker173028119_
									coverAll:
										{293 to: 295}
									evaluating: [ receiver4 new ]
									thatSends: #new
									to: receiver4 ] value ]
						thatSends: #transitionTo:
						to: receiver5 ] value ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver6 ] value.! !
!Behavior method!
changeRecord: aChangeRecord
	#_coverageTracker173028131_ markAsExecuted.
	#_coverageTracker173028131_
		cover: (30 to: 41)
		declaredAt: (30 to: 41)
		by:
			(changeRecord _ #_coverageTracker173028131_
				cover: (46 to: 58)
				declaredAt: (15 to: 27)
				by: aChangeRecord).! !
!Behavior method!
code
	| changeClass sourceString |
	#_coverageTracker173028135_ markAsExecuted.
	#_coverageTracker173028135_
		cover: (37 to: 48)
		declaredAt: (21 to: 32)
		by:
			(sourceString _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028135_
				cover: (53 to: 64)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173028135_
				coverAll:
					{66 to: 71}
				evaluating: [ receiver1 string ]
				thatSends: #string
				to: receiver1 ] value).
	#_coverageTracker173028135_
		cover: (75 to: 85)
		declaredAt: (9 to: 19)
		by:
			(changeClass _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028135_
				cover: (90 to: 101)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173028135_
				coverAll:
					{103 to: 113}
				evaluating: [ receiver2 changeClass ]
				thatSends: #changeClass
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028135_
		cover: (117 to: 127)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173028135_
		coverAll:
			{129 to: 134}
		evaluating: [ receiver3 ifNil: [ ^ #_coverageTracker173028135_
					cover: (140 to: 151)
					declaredAt: (21 to: 32)
					by: sourceString ]]
		thatSends: #ifNil:
		to: receiver3 ] value.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173028135_
		cover: (161 to: 171)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173028135_
		coverAll:
			{173 to: 185}
		evaluating: [ receiver4 compilerClass ]
		thatSends: #compilerClass
		to: receiver4 ] value.
	#_coverageTracker173028135_
		coverAll:
			{187 to: 189}
		evaluating: [ receiver5 new ]
		thatSends: #new
		to: receiver5 ] value.
	#_coverageTracker173028135_
		coverAll:
			{193 to: 199. 214 to: 216. 230 to: 239}
		evaluating: [
			receiver6
				format:
					(#_coverageTracker173028135_
						cover: (201 to: 212)
						declaredAt: (21 to: 32)
						by: sourceString)
				in:
					(#_coverageTracker173028135_
						cover: (218 to: 228)
						declaredAt: (9 to: 19)
						by: changeClass)
				notifying:
					(#_coverageTracker173028135_
						coverAll:
							{241 to: 243}
						byLiteralOrPseudoVariable: nil) ]
		thatSends: #format:in:notifying:
		to: receiver6 ] value.! !
!Behavior method!
assert: aResult hasNWarnings: count
	#_coverageTracker173028147_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028147_
		coverAll:
			{38 to: 41}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028147_
		coverAll:
			{43 to: 49. 73 to: 79}
		evaluating: [
			receiver3
				assert:
					[ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173028147_
						cover: (51 to: 57)
						declaredAt: (9 to: 15)
						by: aResult.
					#_coverageTracker173028147_
						coverAll:
							{59 to: 66}
						evaluating: [ receiver1 warnings ]
						thatSends: #warnings
						to: receiver1 ] value.
					#_coverageTracker173028147_
						coverAll:
							{68 to: 71}
						evaluating: [ receiver2 size ]
						thatSends: #size
						to: receiver2 ] value
				equals:
					(#_coverageTracker173028147_
						cover: (81 to: 85)
						declaredAt: (31 to: 35)
						by: count) ]
		thatSends: #assert:equals:
		to: receiver3 ] value.! !
!Behavior method!
description
	#_coverageTracker173028153_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028153_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028153_
		coverAll:
			{21 to: 32}
		evaluating: [ receiver1 previousName ]
		thatSends: #previousName
		to: receiver1 ] value.
	#_coverageTracker173028153_
		coverAll:
			{34 to: 34}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028153_
					coverAll:
						{36 to: 53}
					byLiteralOrPseudoVariable: ' was renamed to ') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173028153_
		coverAll:
			{54 to: 54}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173028153_
					coverAll:
						{56 to: 59}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028153_
					coverAll:
						{61 to: 71}
					evaluating: [ receiver3 currentName ]
					thatSends: #currentName
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.! !
!Behavior method!
description
	#_coverageTracker173028157_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028157_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028157_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173028157_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028157_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173028157_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173028157_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028157_
					coverAll:
						{49 to: 60}
					evaluating: [ receiver3 testSelector ]
					thatSends: #testSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173028157_
		coverAll:
			{61 to: 61}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173028157_
					coverAll:
						{63 to: 71}
					byLiteralOrPseudoVariable: ' PASSED') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
inventory: aCodeInventory
	#_coverageTracker173028162_ markAsExecuted.
	#_coverageTracker173028162_
		cover: (29 to: 37)
		declaredAt: (29 to: 37)
		by:
			(inventory _ #_coverageTracker173028162_
				cover: (42 to: 55)
				declaredAt: (12 to: 25)
				by: aCodeInventory).! !
!Behavior method!
allTests
	#_coverageTracker173028164_ markAsExecuted.
	^ #_coverageTracker173028164_
		cover: (13 to: 17)
		declaredAt: (13 to: 17)
		by: tests.! !
!Behavior method!
removeTestsOf: className
	#_coverageTracker173028167_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173028167_
		cover: (28 to: 32)
		declaredAt: (28 to: 32)
		by: tests.
	#_coverageTracker173028167_
		coverAll:
			{34 to: 40. 101 to: 107}
		evaluating: [
			receiver4
				select: [ :testReference |
					[ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173028167_
						cover: (61 to: 73)
						declaredAt: (45 to: 57)
						by: testReference.
					#_coverageTracker173028167_
						coverAll:
							{75 to: 85}
						evaluating: [ receiver1 methodClass ]
						thatSends: #methodClass
						to: receiver1 ] value.
					#_coverageTracker173028167_
						coverAll:
							{87 to: 87}
						evaluating: [
							receiver2 =
								(#_coverageTracker173028167_
									cover: (89 to: 97)
									declaredAt: (16 to: 24)
									by: className) ]
						thatSends: #=
						to: receiver2 ] value ]
				thenDo: [ :testReference |
					[ | receiver3 |
					receiver3 _ #_coverageTracker173028167_
						cover: (128 to: 132)
						declaredAt: (28 to: 32)
						by: tests.
					#_coverageTracker173028167_
						coverAll:
							{134 to: 140}
						evaluating: [
							receiver3 remove:
								(#_coverageTracker173028167_
									cover: (142 to: 154)
									declaredAt: (112 to: 124)
									by: testReference) ]
						thatSends: #remove:
						to: receiver3 ] value ]]
		thatSends: #select:thenDo:
		to: receiver4 ] value.! !
!Behavior method!
modelMethodChanged: aMethodReference
	#_coverageTracker173028175_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028175_
		coverAll:
			{41 to: 44}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028175_
		coverAll:
			{46 to: 48}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173028175_
		coverAll:
			{50 to: 68}
		evaluating: [
			receiver2 modelMethodChanged:
				(#_coverageTracker173028175_
					cover: (70 to: 85)
					declaredAt: (21 to: 36)
					by: aMethodReference) ]
		thatSends: #modelMethodChanged:
		to: receiver2 ] value.! !
!Behavior method!
analysisResult: anAnalysisResult
	#_coverageTracker173028180_ markAsExecuted.
	#_coverageTracker173028180_
		cover: (35 to: 48)
		declaredAt: (35 to: 48)
		by:
			(analysisResult _ #_coverageTracker173028180_
				cover: (53 to: 68)
				declaredAt: (17 to: 32)
				by: anAnalysisResult).! !
!Behavior method!
previousEvent
	#_coverageTracker173028182_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028182_
		coverAll:
			{18 to: 21}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028182_
		coverAll:
			{23 to: 30}
		evaluating: [ receiver1 timeline ]
		thatSends: #timeline
		to: receiver1 ] value.
	#_coverageTracker173028182_
		coverAll:
			{32 to: 43}
		evaluating: [
			receiver2 eventBefore:
				(#_coverageTracker173028182_
					coverAll:
						{45 to: 48}
					byLiteralOrPseudoVariable: self) ]
		thatSends: #eventBefore:
		to: receiver2 ] value.! !
!Behavior method!
modelMethodChangedBeforeRunningTests: aSelector class: className
	#_coverageTracker173028193_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028193_
		coverAll:
			{70 to: 84}
		byLiteralOrPseudoVariable: 'Model method '.
	#_coverageTracker173028193_
		coverAll:
			{85 to: 85}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028193_
					coverAll:
						{88 to: 91}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028193_
					coverAll:
						{93 to: 104. 116 to: 121}
					evaluating: [
						receiver1
							printMethod:
								(#_coverageTracker173028193_
									cover: (106 to: 114)
									declaredAt: (39 to: 47)
									by: aSelector)
							class:
								(#_coverageTracker173028193_
									cover: (123 to: 131)
									declaredAt: (56 to: 64)
									by: className) ]
					thatSends: #printMethod:class:
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173028193_
		coverAll:
			{133 to: 133}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173028193_
					coverAll:
						{135 to: 179}
					byLiteralOrPseudoVariable: ' was changed before running the tests first') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
modelMethodChanged: methodReference
	| errorMessage |
	#_coverageTracker173028202_ markAsExecuted.
	#_coverageTracker173028202_
		cover: (57 to: 68)
		declaredAt: (41 to: 52)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028202_
				coverAll:
					{73 to: 79}
				by: TDDGuru.
			#_coverageTracker173028202_
				coverAll:
					{81 to: 104. 131 to: 136}
				evaluating: [
					receiver3
						methodChangedBeforeTest:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173028202_
								cover: (106 to: 120)
								declaredAt: (21 to: 35)
								by: methodReference.
							#_coverageTracker173028202_
								coverAll:
									{122 to: 129}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173028202_
								cover: (138 to: 152)
								declaredAt: (21 to: 35)
								by: methodReference.
							#_coverageTracker173028202_
								coverAll:
									{154 to: 164}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #methodChangedBeforeTest:class:
				to: receiver3 ] value).
	[ | receiver8 |
	receiver8 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173028202_
		coverAll:
			{170 to: 173}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028202_
		coverAll:
			{175 to: 194}
		evaluating: [ receiver4 currentTestIsDefined ]
		thatSends: #currentTestIsDefined
		to: receiver4 ] value.
	#_coverageTracker173028202_
		coverAll:
			{196 to: 202}
		evaluating: [
			receiver8 ifTrue: [
				#_coverageTracker173028202_
					cover: (209 to: 220)
					declaredAt: (41 to: 52)
					by:
						(errorMessage _ [ | receiver7 |
						receiver7 _ #_coverageTracker173028202_
							coverAll:
								{225 to: 231}
							by: TDDGuru.
						#_coverageTracker173028202_
							coverAll:
								{233 to: 269. 296 to: 301}
							evaluating: [
								receiver7
									modelMethodChangedBeforeRunningTests:
										[ | receiver5 |
										receiver5 _ #_coverageTracker173028202_
											cover: (271 to: 285)
											declaredAt: (21 to: 35)
											by: methodReference.
										#_coverageTracker173028202_
											coverAll:
												{287 to: 294}
											evaluating: [ receiver5 selector ]
											thatSends: #selector
											to: receiver5 ] value
									class:
										[ | receiver6 |
										receiver6 _ #_coverageTracker173028202_
											cover: (303 to: 317)
											declaredAt: (21 to: 35)
											by: methodReference.
										#_coverageTracker173028202_
											coverAll:
												{319 to: 329}
											evaluating: [ receiver6 methodClass ]
											thatSends: #methodClass
											to: receiver6 ] value ]
							thatSends: #modelMethodChangedBeforeRunningTests:class:
							to: receiver7 ] value) ]]
		thatSends: #ifTrue:
		to: receiver8 ] value.
	[ | receiver10 |
	receiver10 _ #_coverageTracker173028202_
		coverAll:
			{337 to: 340}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028202_
		coverAll:
			{342 to: 353. 368 to: 383}
		evaluating: [
			receiver10
				reportError:
					(#_coverageTracker173028202_
						cover: (355 to: 366)
						declaredAt: (41 to: 52)
						by: errorMessage)
				andTransitionTo:
					[ | receiver9 |
					receiver9 _ #_coverageTracker173028202_
						coverAll:
							{385 to: 395}
						by: NotDoingTDD.
					#_coverageTracker173028202_
						coverAll:
							{397 to: 399}
						evaluating: [ receiver9 new ]
						thatSends: #new
						to: receiver9 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver10 ] value.! !
!Behavior method!
analyzedBy: aTDDGuru
	#_coverageTracker173028219_ markAsExecuted.
	#_coverageTracker173028219_
		cover: (23 to: 29)
		declaredAt: (23 to: 29)
		by:
			(tddGuru _ #_coverageTracker173028219_
				cover: (34 to: 41)
				declaredAt: (13 to: 20)
				by: aTDDGuru).! !
!Behavior method!
modelMethodChanged: methodReference
	#_coverageTracker173028222_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173028222_
		coverAll:
			{38 to: 41}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028222_
		coverAll:
			{43 to: 54. 151 to: 166}
		evaluating: [
			receiver5
				reportError:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173028222_
						coverAll:
							{57 to: 63}
						by: TDDGuru.
					#_coverageTracker173028222_
						coverAll:
							{65 to: 88. 115 to: 120}
						evaluating: [
							receiver3
								methodChangedBeforeTest:
									[ | receiver1 |
									receiver1 _ #_coverageTracker173028222_
										cover: (90 to: 104)
										declaredAt: (21 to: 35)
										by: methodReference.
									#_coverageTracker173028222_
										coverAll:
											{106 to: 113}
										evaluating: [ receiver1 selector ]
										thatSends: #selector
										to: receiver1 ] value
								class:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173028222_
										cover: (122 to: 136)
										declaredAt: (21 to: 35)
										by: methodReference.
									#_coverageTracker173028222_
										coverAll:
											{138 to: 148}
										evaluating: [ receiver2 methodClass ]
										thatSends: #methodClass
										to: receiver2 ] value ]
						thatSends: #methodChangedBeforeTest:class:
						to: receiver3 ] value
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173028222_
						coverAll:
							{168 to: 178}
						by: NotDoingTDD.
					#_coverageTracker173028222_
						coverAll:
							{180 to: 182}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
testRemoved: aMethodReference
	| errorMessage |
	#_coverageTracker173028230_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028230_
		cover: (53 to: 56)
		declaredAt: (53 to: 56)
		by: test.
	#_coverageTracker173028230_
		coverAll:
			{58 to: 58}
		evaluating: [
			receiver1 =
				(#_coverageTracker173028230_
					cover: (60 to: 75)
					declaredAt: (14 to: 29)
					by: aMethodReference) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173028230_
		coverAll:
			{77 to: 83}
		evaluating: [ receiver4 ifTrue: [ ^ [ | receiver3 |
				receiver3 _ #_coverageTracker173028230_
					coverAll:
						{89 to: 92}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028230_
					coverAll:
						{94 to: 106}
					evaluating: [
						receiver3 transitionTo:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173028230_
								coverAll:
									{108 to: 112}
								by: Green.
							#_coverageTracker173028230_
								coverAll:
									{114 to: 116}
								evaluating: [ receiver2 new ]
								thatSends: #new
								to: receiver2 ] value ]
					thatSends: #transitionTo:
					to: receiver3 ] value ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.
	#_coverageTracker173028230_
		cover: (124 to: 135)
		declaredAt: (35 to: 46)
		by:
			(errorMessage _ [ | receiver7 |
			receiver7 _ #_coverageTracker173028230_
				coverAll:
					{140 to: 146}
				by: TDDGuru.
			#_coverageTracker173028230_
				coverAll:
					{148 to: 178. 206 to: 211}
				evaluating: [
					receiver7
						methodRemovedWhileWritingATest:
							[ | receiver5 |
							receiver5 _ #_coverageTracker173028230_
								cover: (180 to: 195)
								declaredAt: (14 to: 29)
								by: aMethodReference.
							#_coverageTracker173028230_
								coverAll:
									{197 to: 204}
								evaluating: [ receiver5 selector ]
								thatSends: #selector
								to: receiver5 ] value
						class:
							[ | receiver6 |
							receiver6 _ #_coverageTracker173028230_
								cover: (213 to: 228)
								declaredAt: (14 to: 29)
								by: aMethodReference.
							#_coverageTracker173028230_
								coverAll:
									{230 to: 240}
								evaluating: [ receiver6 methodClass ]
								thatSends: #methodClass
								to: receiver6 ] value ]
				thatSends: #methodRemovedWhileWritingATest:class:
				to: receiver7 ] value).
	[ | receiver8 |
	receiver8 _ #_coverageTracker173028230_
		coverAll:
			{244 to: 247}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028230_
		coverAll:
			{249 to: 260}
		evaluating: [
			receiver8 reportError:
				(#_coverageTracker173028230_
					cover: (262 to: 273)
					declaredAt: (35 to: 46)
					by: errorMessage) ]
		thatSends: #reportError:
		to: receiver8 ] value.! !
!Behavior method!
analysisResult: anAnalysisResult
	#_coverageTracker173028244_ markAsExecuted.
	#_coverageTracker173028244_
		cover: (35 to: 48)
		declaredAt: (35 to: 48)
		by:
			(analysisResult _ #_coverageTracker173028244_
				cover: (53 to: 68)
				declaredAt: (17 to: 32)
				by: anAnalysisResult).! !
!Behavior method!
testChangedWhileInRed: aSymbol class: aSymbol2
	#_coverageTracker173028250_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028250_
		coverAll:
			{50 to: 53}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028250_
		coverAll:
			{55 to: 73}
		evaluating: [ receiver1 shouldBeImplemented ]
		thatSends: #shouldBeImplemented
		to: receiver1 ] value.! !
!Behavior method!
testRemovedChangeRecord: aMethodDeletionChangeRecord
	#_coverageTracker173028252_ markAsExecuted.
	#_coverageTracker173028252_
		cover: (56 to: 78)
		declaredAt: (56 to: 78)
		by:
			(testRemovedChangeRecord _ #_coverageTracker173028252_
				cover: (83 to: 109)
				declaredAt: (26 to: 52)
				by: aMethodDeletionChangeRecord).! !
!Behavior method!
unknownChangeDetector
	#_coverageTracker173028256_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028256_
		coverAll:
			{26 to: 39}
		by: ChangeDetector.
	#_coverageTracker173028256_
		coverAll:
			{41 to: 44. 60 to: 73. 77 to: 88}
		evaluating: [
			receiver1
				for:
					(#_coverageTracker173028256_
						coverAll:
							{46 to: 58}
						by: UnknownChange)
				withLookahead:
					(#_coverageTracker173028256_
						coverAll:
							{75 to: 75}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					#_coverageTracker173028256_
						coverAll:
							{109 to: 112}
						byLiteralOrPseudoVariable: true ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver1 ] value.! !
!Behavior method!
category
	#_coverageTracker173028260_ markAsExecuted.
	^ #_coverageTracker173028260_
		coverAll:
			{13 to: 26}
		byLiteralOrPseudoVariable: #methodRemoved.! !
!Behavior method!
isCorrect
	#_coverageTracker173028263_ markAsExecuted.
	^ #_coverageTracker173028263_
		coverAll:
			{14 to: 17}
		byLiteralOrPseudoVariable: true.! !
!Behavior method!
currentTest: aTestReference
	#_coverageTracker173028265_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028265_
		coverAll:
			{32 to: 35}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028265_
		coverAll:
			{37 to: 39}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173028265_
		coverAll:
			{41 to: 52}
		evaluating: [
			receiver2 currentTest:
				(#_coverageTracker173028265_
					cover: (54 to: 67)
					declaredAt: (14 to: 27)
					by: aTestReference) ]
		thatSends: #currentTest:
		to: receiver2 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173028269_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028269_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173028269_
		coverAll:
			{34 to: 48}
		evaluating: [
			receiver2 newModelMethod:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028269_
					coverAll:
						{50 to: 53}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028269_
					coverAll:
						{55 to: 69}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #newModelMethod:
		to: receiver2 ] value.! !
!Behavior method!
selector
	#_coverageTracker173028271_ markAsExecuted.
	^ #_coverageTracker173028271_
		cover: (12 to: 19)
		declaredAt: (12 to: 19)
		by: selector.! !
!Behavior method!
currentChange
	#_coverageTracker173028275_ markAsExecuted.
	^ #_coverageTracker173028275_
		cover: (17 to: 29)
		declaredAt: (17 to: 29)
		by: currentChange.! !
!Behavior method!
methodClass
	#_coverageTracker173028277_ markAsExecuted.
	^ #_coverageTracker173028277_
		cover: (16 to: 24)
		declaredAt: (16 to: 24)
		by: className.! !
!Behavior method!
open: model startPosition: startPosition
	| window |
	#_coverageTracker173028287_ markAsExecuted.
	#_coverageTracker173028287_
		cover: (55 to: 60)
		declaredAt: (45 to: 50)
		by:
			(window _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028287_
				coverAll:
					{65 to: 68}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173028287_
				coverAll:
					{70 to: 74. 82 to: 87}
				evaluating: [
					receiver1
						open:
							(#_coverageTracker173028287_
								cover: (76 to: 80)
								declaredAt: (7 to: 11)
								by: model)
						label:
							(#_coverageTracker173028287_
								coverAll:
									{89 to: 103}
								byLiteralOrPseudoVariable: 'Pick a Change') ]
				thatSends: #open:label:
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028287_
		cover: (107 to: 112)
		declaredAt: (45 to: 50)
		by: window.
	#_coverageTracker173028287_
		coverAll:
			{114 to: 127}
		evaluating: [
			receiver2 startPosition:
				(#_coverageTracker173028287_
					cover: (129 to: 141)
					declaredAt: (28 to: 40)
					by: startPosition) ]
		thatSends: #startPosition:
		to: receiver2 ] value.
	^ #_coverageTracker173028287_
		cover: (147 to: 152)
		declaredAt: (45 to: 50)
		by: window.! !
!Behavior method!
startingFromChange: changeIndex
	#_coverageTracker173028294_ markAsExecuted.
	#_coverageTracker173028294_
		cover: (35 to: 47)
		declaredAt: (35 to: 47)
		by:
			(startingPoint _ #_coverageTracker173028294_
				cover: (52 to: 62)
				declaredAt: (21 to: 31)
				by: changeIndex).! !
!Behavior method!
modelMethodChanged: aSelector
	#_coverageTracker173028298_ markAsExecuted.! !
!Behavior method!
replaceTestOf: previousClassName with: currentClassName
	#_coverageTracker173028300_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ #_coverageTracker173028300_
		cover: (58 to: 62)
		declaredAt: (58 to: 62)
		by: tests.
	#_coverageTracker173028300_
		coverAll:
			{67 to: 73. 145 to: 151}
		evaluating: [
			receiver6
				select: [ :testReference |
					[ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173028300_
						cover: (94 to: 106)
						declaredAt: (78 to: 90)
						by: testReference.
					#_coverageTracker173028300_
						coverAll:
							{108 to: 118}
						evaluating: [ receiver1 methodClass ]
						thatSends: #methodClass
						to: receiver1 ] value.
					#_coverageTracker173028300_
						coverAll:
							{120 to: 120}
						evaluating: [
							receiver2 =
								(#_coverageTracker173028300_
									cover: (122 to: 138)
									declaredAt: (16 to: 32)
									by: previousClassName) ]
						thatSends: #=
						to: receiver2 ] value ]
				thenDo: [ :testReference |
					[ | receiver3 |
					receiver3 _ #_coverageTracker173028300_
						cover: (176 to: 180)
						declaredAt: (58 to: 62)
						by: tests.
					#_coverageTracker173028300_
						coverAll:
							{182 to: 188}
						evaluating: [
							receiver3 remove:
								(#_coverageTracker173028300_
									cover: (190 to: 202)
									declaredAt: (156 to: 168)
									by: testReference) ]
						thatSends: #remove:
						to: receiver3 ] value.
					[ | receiver5 |
					receiver5 _ #_coverageTracker173028300_
						cover: (208 to: 212)
						declaredAt: (58 to: 62)
						by: tests.
					#_coverageTracker173028300_
						coverAll:
							{214 to: 217}
						evaluating: [
							receiver5 add:
								[ | receiver4 |
								receiver4 _ #_coverageTracker173028300_
									cover: (220 to: 232)
									declaredAt: (156 to: 168)
									by: testReference.
								#_coverageTracker173028300_
									coverAll:
										{234 to: 242}
									evaluating: [
										receiver4 copyWith:
											(#_coverageTracker173028300_
												cover: (244 to: 259)
												declaredAt: (40 to: 55)
												by: currentClassName) ]
									thatSends: #copyWith:
									to: receiver4 ] value ]
						thatSends: #add:
						to: receiver5 ] value ]]
		thatSends: #select:thenDo:
		to: receiver6 ] value.! !
!Behavior method!
changeAt: index
	#_coverageTracker173028312_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028312_
		coverAll:
			{20 to: 23}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028312_
		coverAll:
			{25 to: 36}
		evaluating: [ receiver1 changeEvents ]
		thatSends: #changeEvents
		to: receiver1 ] value.
	#_coverageTracker173028312_
		coverAll:
			{38 to: 40}
		evaluating: [
			receiver2 at:
				(#_coverageTracker173028312_
					cover: (42 to: 46)
					declaredAt: (11 to: 15)
					by: index) ]
		thatSends: #at:
		to: receiver2 ] value.! !
!Behavior method!
secondsAsString: timeDifference
	| inMinutes inSeconds |
	#_coverageTracker173028319_ markAsExecuted.
	#_coverageTracker173028319_
		cover: (61 to: 69)
		declaredAt: (36 to: 44)
		by:
			(inMinutes _ [ | receiver3 |
			receiver3 _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028319_
				cover: (76 to: 89)
				declaredAt: (18 to: 31)
				by: timeDifference.
			#_coverageTracker173028319_
				coverAll:
					{91 to: 100}
				evaluating: [
					receiver2 convertTo:
						[ | receiver1 |
						receiver1 _ #_coverageTracker173028319_
							coverAll:
								{102 to: 110}
							by: TimeUnits.
						#_coverageTracker173028319_
							coverAll:
								{112 to: 117}
							evaluating: [ receiver1 minute ]
							thatSends: #minute
							to: receiver1 ] value ]
				thatSends: #convertTo:
				to: receiver2 ] value.
			#_coverageTracker173028319_
				coverAll:
					{120 to: 124}
				evaluating: [ receiver3 floor ]
				thatSends: #floor
				to: receiver3 ] value).
	#_coverageTracker173028319_
		cover: (129 to: 137)
		declaredAt: (46 to: 54)
		by:
			(inSeconds _ [ | receiver8 |
			receiver8 _ [ | receiver7 |
			receiver7 _ [ | receiver6 |
			receiver6 _ [ | receiver4 |
			receiver4 _ #_coverageTracker173028319_
				cover: (144 to: 157)
				declaredAt: (18 to: 31)
				by: timeDifference.
			#_coverageTracker173028319_
				coverAll:
					{159 to: 159}
				evaluating: [
					receiver4 -
						(#_coverageTracker173028319_
							cover: (161 to: 169)
							declaredAt: (36 to: 44)
							by: inMinutes) ]
				thatSends: #-
				to: receiver4 ] value.
			#_coverageTracker173028319_
				coverAll:
					{172 to: 181}
				evaluating: [
					receiver6 convertTo:
						[ | receiver5 |
						receiver5 _ #_coverageTracker173028319_
							coverAll:
								{183 to: 191}
							by: TimeUnits.
						#_coverageTracker173028319_
							coverAll:
								{193 to: 198}
							evaluating: [ receiver5 second ]
							thatSends: #second
							to: receiver5 ] value ]
				thatSends: #convertTo:
				to: receiver6 ] value.
			#_coverageTracker173028319_
				coverAll:
					{201 to: 203}
				evaluating: [ receiver7 abs ]
				thatSends: #abs
				to: receiver7 ] value.
			#_coverageTracker173028319_
				coverAll:
					{205 to: 210}
				evaluating: [ receiver8 amount ]
				thatSends: #amount
				to: receiver8 ] value).
	^ [ | receiver10 |
	receiver10 _ #_coverageTracker173028319_
		coverAll:
			{217 to: 222}
		by: String.
	#_coverageTracker173028319_
		coverAll:
			{224 to: 238}
		evaluating: [
			receiver10 streamContents: [ :aStream |
				[ | receiver9 |
				receiver9 _ #_coverageTracker173028319_
					cover: (253 to: 261)
					declaredAt: (46 to: 54)
					by: inSeconds.
				#_coverageTracker173028319_
					coverAll:
						{263 to: 270. 280 to: 293. 297 to: 311}
					evaluating: [
						receiver9
							printOn:
								(#_coverageTracker173028319_
									cover: (272 to: 278)
									declaredAt: (243 to: 249)
									by: aStream)
							integerDigits:
								(#_coverageTracker173028319_
									coverAll:
										{295 to: 295}
									byLiteralOrPseudoVariable: 2)
							fractionDigits:
								(#_coverageTracker173028319_
									coverAll:
										{313 to: 313}
									byLiteralOrPseudoVariable: 0) ]
					thatSends: #printOn:integerDigits:fractionDigits:
					to: receiver9 ] value ]]
		thatSends: #streamContents:
		to: receiver10 ] value.! !
!Behavior method!
timeline
	#_coverageTracker173028335_ markAsExecuted.
	^ #_coverageTracker173028335_
		cover: (13 to: 20)
		declaredAt: (13 to: 20)
		by: timeline.! !
!Behavior method!
testChanged: anUninstalledMethodReference
	#_coverageTracker173028337_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028337_
		coverAll:
			{46 to: 49}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028337_
		coverAll:
			{51 to: 73}
		evaluating: [
			receiver1 isOneOfTheCurrentTests:
				(#_coverageTracker173028337_
					cover: (75 to: 102)
					declaredAt: (14 to: 41)
					by: anUninstalledMethodReference) ]
		thatSends: #isOneOfTheCurrentTests:
		to: receiver1 ] value.
	#_coverageTracker173028337_
		coverAll:
			{105 to: 112}
		evaluating: [
			receiver5 ifFalse: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028337_
					coverAll:
						{119 to: 122}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028337_
					coverAll:
						{124 to: 156}
					evaluating: [ receiver2 reportErrorWhenSecondTestWasAdded ]
					thatSends: #reportErrorWhenSecondTestWasAdded
					to: receiver2 ] value.
				[ | receiver4 |
				receiver4 _ #_coverageTracker173028337_
					coverAll:
						{161 to: 164}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028337_
					coverAll:
						{166 to: 178}
					evaluating: [
						receiver4 transitionTo:
							[ | receiver3 |
							receiver3 _ #_coverageTracker173028337_
								coverAll:
									{180 to: 190}
								by: NotDoingTDD.
							#_coverageTracker173028337_
								coverAll:
									{192 to: 194}
								evaluating: [ receiver3 new ]
								thatSends: #new
								to: receiver3 ] value ]
					thatSends: #transitionTo:
					to: receiver4 ] value ]]
		thatSends: #ifFalse:
		to: receiver5 ] value.! !
!Behavior method!
changeEvents
	#_coverageTracker173028343_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028343_
		cover: (17 to: 24)
		declaredAt: (17 to: 24)
		by: timeline.
	#_coverageTracker173028343_
		coverAll:
			{26 to: 37}
		evaluating: [ receiver1 changeEvents ]
		thatSends: #changeEvents
		to: receiver1 ] value.! !
!Behavior method!
newModelMethod: anUninstalledMethodReference
	#_coverageTracker173028347_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028347_
		coverAll:
			{48 to: 51}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028347_
		coverAll:
			{53 to: 85}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028347_
		coverAll:
			{89 to: 92}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028347_
		coverAll:
			{94 to: 106}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028347_
					coverAll:
						{108 to: 118}
					by: NotDoingTDD.
				#_coverageTracker173028347_
					coverAll:
						{120 to: 122}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
newModelMethod: aSymbol
	#_coverageTracker173028360_ markAsExecuted.! !
!Behavior method!
setUp
	#_coverageTracker173028363_ markAsExecuted.
	#_coverageTracker173028363_
		cover: (10 to: 16)
		declaredAt: (10 to: 16)
		by:
			(tddGuru _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028363_
				coverAll:
					{21 to: 27}
				by: TDDGuru.
			#_coverageTracker173028363_
				coverAll:
					{29 to: 31}
				evaluating: [
					receiver2 on:
						[ | receiver1 |
						receiver1 _ #_coverageTracker173028363_
							coverAll:
								{33 to: 36}
							byLiteralOrPseudoVariable: self.
						#_coverageTracker173028363_
							coverAll:
								{38 to: 56}
							evaluating: [ receiver1 changesFileForTests ]
							thatSends: #changesFileForTests
							to: receiver1 ] value ]
				thatSends: #on:
				to: receiver2 ] value).
	#_coverageTracker173028363_
		cover: (60 to: 72)
		declaredAt: (60 to: 72)
		by:
			(classesByName _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028363_
				coverAll:
					{77 to: 86}
				by: Dictionary.
			#_coverageTracker173028363_
				coverAll:
					{88 to: 90}
				evaluating: [ receiver3 new ]
				thatSends: #new
				to: receiver3 ] value).
	#_coverageTracker173028363_
		cover: (94 to: 121)
		declaredAt: (94 to: 121)
		by:
			(previousUserChangesExtension _ [ | receiver4 |
			receiver4 _ #_coverageTracker173028363_
				coverAll:
					{126 to: 136}
				by: Preferences.
			#_coverageTracker173028363_
				coverAll:
					{138 to: 140}
				evaluating: [
					receiver4 at:
						(#_coverageTracker173028363_
							coverAll:
								{142 to: 170}
							byLiteralOrPseudoVariable: #userChangesFileNameExtension) ]
				thatSends: #at:
				to: receiver4 ] value).
	[ | receiver6 |
	receiver6 _ #_coverageTracker173028363_
		coverAll:
			{174 to: 184}
		by: Preferences.
	#_coverageTracker173028363_
		coverAll:
			{186 to: 188. 220 to: 223}
		evaluating: [
			receiver6
				at:
					(#_coverageTracker173028363_
						coverAll:
							{190 to: 218}
						byLiteralOrPseudoVariable: #userChangesFileNameExtension)
				put:
					[ | receiver5 |
					receiver5 _ #_coverageTracker173028363_
						coverAll:
							{225 to: 228}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028363_
						coverAll:
							{230 to: 260}
						evaluating: [ receiver5 tddGuruTestChangesFileExtension ]
						thatSends: #tddGuruTestChangesFileExtension
						to: receiver5 ] value ]
		thatSends: #at:put:
		to: receiver6 ] value.! !
!Behavior method!
description
	#_coverageTracker173028373_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028373_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028373_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173028373_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028373_
					coverAll:
						{38 to: 51}
					byLiteralOrPseudoVariable: ' was removed') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
newTest: aTestReference
	| errorMessage |
	#_coverageTracker173028377_ markAsExecuted.
	#_coverageTracker173028377_
		cover: (46 to: 57)
		declaredAt: (28 to: 39)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028377_
				coverAll:
					{62 to: 68}
				by: TDDGuru.
			#_coverageTracker173028377_
				coverAll:
					{70 to: 91. 117 to: 122}
				evaluating: [
					receiver3
						testAddedErrorMessage:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173028377_
								cover: (93 to: 106)
								declaredAt: (10 to: 23)
								by: aTestReference.
							#_coverageTracker173028377_
								coverAll:
									{108 to: 115}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173028377_
								cover: (124 to: 137)
								declaredAt: (10 to: 23)
								by: aTestReference.
							#_coverageTracker173028377_
								coverAll:
									{139 to: 149}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #testAddedErrorMessage:class:
				to: receiver3 ] value).
	[ | receiver5 |
	receiver5 _ #_coverageTracker173028377_
		coverAll:
			{153 to: 156}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028377_
		coverAll:
			{158 to: 169. 184 to: 199}
		evaluating: [
			receiver5
				reportError:
					(#_coverageTracker173028377_
						cover: (171 to: 182)
						declaredAt: (28 to: 39)
						by: errorMessage)
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173028377_
						coverAll:
							{201 to: 211}
						by: NotDoingTDD.
					#_coverageTracker173028377_
						coverAll:
							{213 to: 215}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
assert: expected equals: actual
	"This tests assumes the order of arguments used by Cuis before July 31, 2023,
	and also used by Squeak."
	#_coverageTracker173028386_ markAsExecuted.
	#_coverageTracker173028386_
		coverAll:
			{147 to: 153. 162 to: 168}
		evaluating: [
			super
				assert:
					(#_coverageTracker173028386_
						cover: (155 to: 160)
						declaredAt: (26 to: 31)
						by: actual)
				equals:
					(#_coverageTracker173028386_
						cover: (170 to: 177)
						declaredAt: (9 to: 16)
						by: expected) ]
		thatSends: #assert:equals:
		to: super.! !
!Behavior method!
newModelClass: className
	#_coverageTracker173028390_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028390_
		coverAll:
			{27 to: 30}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028390_
		coverAll:
			{32 to: 44}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028390_
					coverAll:
						{46 to: 64}
					by: WritingAFailingTest.
				#_coverageTracker173028390_
					coverAll:
						{66 to: 68}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
testClasses: aCollectionOfTestClasses
	| classNames |
	#_coverageTracker173028394_ markAsExecuted.
	#_coverageTracker173028394_
		cover: (56 to: 65)
		declaredAt: (42 to: 51)
		by:
			(classNames _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028394_
				cover: (70 to: 93)
				declaredAt: (14 to: 37)
				by: aCollectionOfTestClasses.
			#_coverageTracker173028394_
				coverAll:
					{95 to: 102}
				evaluating: [
					receiver2 collect: [ :aClass |
						[ | receiver1 |
						receiver1 _ #_coverageTracker173028394_
							cover: (116 to: 121)
							declaredAt: (107 to: 112)
							by: aClass.
						#_coverageTracker173028394_
							coverAll:
								{123 to: 126}
							evaluating: [ receiver1 name ]
							thatSends: #name
							to: receiver1 ] value ]]
				thatSends: #collect:
				to: receiver2 ] value).
	#_coverageTracker173028394_
		cover: (132 to: 142)
		declaredAt: (132 to: 142)
		by:
			(testClasses _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028394_
				coverAll:
					{147 to: 149}
				by: Set.
			#_coverageTracker173028394_
				coverAll:
					{151 to: 158}
				evaluating: [
					receiver3 withAll:
						(#_coverageTracker173028394_
							cover: (160 to: 169)
							declaredAt: (42 to: 51)
							by: classNames) ]
				thatSends: #withAll:
				to: receiver3 ] value).
	[ | receiver4 |
	receiver4 _ #_coverageTracker173028394_
		coverAll:
			{176 to: 179}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028394_
		coverAll:
			{181 to: 198}
		evaluating: [
			receiver4 initializeTestsOf:
				(#_coverageTracker173028394_
					cover: (200 to: 223)
					declaredAt: (14 to: 37)
					by: aCollectionOfTestClasses) ]
		thatSends: #initializeTestsOf:
		to: receiver4 ] value.! !
!Behavior method!
printMethod: selector class: className
	#_coverageTracker173028401_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028401_
		cover: (43 to: 51)
		declaredAt: (30 to: 38)
		by: className.
	#_coverageTracker173028401_
		coverAll:
			{52 to: 52}
		evaluating: [
			receiver1 ,
				(#_coverageTracker173028401_
					coverAll:
						{54 to: 57}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver1 ] value.
	#_coverageTracker173028401_
		coverAll:
			{58 to: 58}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028401_
					cover: (60 to: 67)
					declaredAt: (14 to: 21)
					by: selector) ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173028405_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028405_
		cover: (27 to: 33)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173028405_
		coverAll:
			{35 to: 51. 71 to: 73}
		evaluating: [
			receiver3
				classRenamedFrom:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173028405_
						coverAll:
							{53 to: 56}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028405_
						coverAll:
							{58 to: 69}
						evaluating: [ receiver1 previousName ]
						thatSends: #previousName
						to: receiver1 ] value
				to:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173028405_
						coverAll:
							{75 to: 78}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028405_
						coverAll:
							{80 to: 90}
						evaluating: [ receiver2 currentName ]
						thatSends: #currentName
						to: receiver2 ] value ]
		thatSends: #classRenamedFrom:to:
		to: receiver3 ] value.! !
!Behavior method!
newTestClass: className
	#_coverageTracker173028410_ markAsExecuted.! !
!Behavior method!
changeClassName
	#_coverageTracker173028413_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028413_
		cover: (20 to: 31)
		declaredAt: (20 to: 31)
		by: changeRecord.
	#_coverageTracker173028413_
		coverAll:
			{33 to: 47}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.! !
!Behavior method!
addChange: aChange
	#_coverageTracker173028414_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028414_
		cover: (21 to: 28)
		declaredAt: (21 to: 28)
		by: timeline.
	#_coverageTracker173028414_
		coverAll:
			{30 to: 39}
		evaluating: [
			receiver1 addChange:
				(#_coverageTracker173028414_
					cover: (41 to: 47)
					declaredAt: (12 to: 18)
					by: aChange) ]
		thatSends: #addChange:
		to: receiver1 ] value.! !
!Behavior method!
transitionTo: newState
	#_coverageTracker173028417_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028417_
		cover: (26 to: 32)
		declaredAt: (26 to: 32)
		by: context.
	#_coverageTracker173028417_
		coverAll:
			{34 to: 42}
		evaluating: [
			receiver1 setState:
				(#_coverageTracker173028417_
					cover: (44 to: 51)
					declaredAt: (15 to: 22)
					by: newState) ]
		thatSends: #setState:
		to: receiver1 ] value.! !
!Behavior method!
copyWith: newClassName
	#_coverageTracker173028422_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028422_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028422_
		coverAll:
			{34 to: 38}
		evaluating: [ receiver1 class ]
		thatSends: #class
		to: receiver1 ] value.
	#_coverageTracker173028422_
		coverAll:
			{40 to: 48. 64 to: 69. 84 to: 94. 107 to: 116}
		evaluating: [
			receiver3
				selector:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173028422_
						coverAll:
							{50 to: 53}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028422_
						coverAll:
							{55 to: 62}
						evaluating: [ receiver2 selector ]
						thatSends: #selector
						to: receiver2 ] value
				class:
					(#_coverageTracker173028422_
						cover: (71 to: 82)
						declaredAt: (11 to: 22)
						by: newClassName)
				sourceCode:
					(#_coverageTracker173028422_
						cover: (96 to: 105)
						declaredAt: (96 to: 105)
						by: sourceCode)
				overrides:
					(#_coverageTracker173028422_
						cover: (118 to: 126)
						declaredAt: (118 to: 126)
						by: overrides) ]
		thatSends: #selector:class:sourceCode:overrides:
		to: receiver3 ] value.! !
!Behavior method!
changeList: anOrderedCollection
	#_coverageTracker173028428_ markAsExecuted.
	#_coverageTracker173028428_
		cover: (35 to: 44)
		declaredAt: (35 to: 44)
		by:
			(changeList _ #_coverageTracker173028428_
				cover: (49 to: 67)
				declaredAt: (13 to: 31)
				by: anOrderedCollection).! !
!Behavior method!
methodRemovedBeforeRunningTests: methodSelector class: className
	#_coverageTracker173028431_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028431_
		coverAll:
			{71 to: 74}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028431_
		coverAll:
			{76 to: 87. 104 to: 109}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173028431_
						cover: (89 to: 102)
						declaredAt: (34 to: 47)
						by: methodSelector)
				class:
					(#_coverageTracker173028431_
						cover: (111 to: 119)
						declaredAt: (56 to: 64)
						by: className) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173028431_
		coverAll:
			{121 to: 121}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028431_
					coverAll:
						{123 to: 167}
					byLiteralOrPseudoVariable: ' was removed before running the tests first') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
from: aTDDState
	#_coverageTracker173028436_ markAsExecuted.
	#_coverageTracker173028436_
		cover: (18 to: 26)
		declaredAt: (18 to: 26)
		by:
			(fromState _ #_coverageTracker173028436_
				cover: (31 to: 39)
				declaredAt: (7 to: 15)
				by: aTDDState).! !
!Behavior method!
newTest: anUninstalledMethodReference
	#_coverageTracker173028439_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028439_
		coverAll:
			{41 to: 44}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028439_
		coverAll:
			{46 to: 78}
		evaluating: [ receiver1 reportErrorWhenSecondTestWasAdded ]
		thatSends: #reportErrorWhenSecondTestWasAdded
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028439_
		coverAll:
			{82 to: 85}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028439_
		coverAll:
			{87 to: 99}
		evaluating: [
			receiver3 transitionTo:
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028439_
					coverAll:
						{101 to: 111}
					by: NotDoingTDD.
				#_coverageTracker173028439_
					coverAll:
						{113 to: 115}
					evaluating: [ receiver2 new ]
					thatSends: #new
					to: receiver2 ] value ]
		thatSends: #transitionTo:
		to: receiver3 ] value.! !
!Behavior method!
lastSnapshotPosition: userChangesFileName
	| end done block positions prevBlock |
	#_coverageTracker173028446_ markAsExecuted.
	[ | receiver26 |
	receiver26 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028446_
		cover: (85 to: 103)
		declaredAt: (23 to: 41)
		by: userChangesFileName.
	#_coverageTracker173028446_
		coverAll:
			{105 to: 115}
		evaluating: [ receiver1 asFileEntry ]
		thatSends: #asFileEntry
		to: receiver1 ] value.
	#_coverageTracker173028446_
		coverAll:
			{117 to: 129}
		evaluating: [
			receiver26 readStreamDo: [ :changesFile |
				#_coverageTracker173028446_
					cover: (150 to: 158)
					declaredAt: (62 to: 70)
					by:
						(positions _ [ | receiver2 |
						receiver2 _ #_coverageTracker173028446_
							coverAll:
								{162 to: 177}
							by: SortedCollection.
						#_coverageTracker173028446_
							coverAll:
								{179 to: 181}
							evaluating: [ receiver2 new ]
							thatSends: #new
							to: receiver2 ] value).
				#_coverageTracker173028446_
					cover: (186 to: 188)
					declaredAt: (47 to: 49)
					by:
						(end _ [ | receiver3 |
						receiver3 _ #_coverageTracker173028446_
							cover: (192 to: 202)
							declaredAt: (134 to: 144)
							by: changesFile.
						#_coverageTracker173028446_
							coverAll:
								{204 to: 207}
							evaluating: [ receiver3 size ]
							thatSends: #size
							to: receiver3 ] value).
				#_coverageTracker173028446_
					cover: (212 to: 220)
					declaredAt: (72 to: 80)
					by:
						(prevBlock _ #_coverageTracker173028446_
							cover: (224 to: 226)
							declaredAt: (47 to: 49)
							by: end).
				#_coverageTracker173028446_
					cover: (231 to: 235)
					declaredAt: (56 to: 60)
					by:
						(block _ [ | receiver5 |
						receiver5 _ [ | receiver4 |
						receiver4 _ #_coverageTracker173028446_
							cover: (239 to: 241)
							declaredAt: (47 to: 49)
							by: end.
						#_coverageTracker173028446_
							coverAll:
								{243 to: 243}
							evaluating: [
								receiver4 -
									(#_coverageTracker173028446_
										coverAll:
											{245 to: 248}
										byLiteralOrPseudoVariable: 1024) ]
							thatSends: #-
							to: receiver4 ] value.
						#_coverageTracker173028446_
							coverAll:
								{250 to: 253}
							evaluating: [
								receiver5 max:
									(#_coverageTracker173028446_
										coverAll:
											{255 to: 255}
										byLiteralOrPseudoVariable: 0) ]
							thatSends: #max:
							to: receiver5 ] value).
				#_coverageTracker173028446_
					cover: (260 to: 263)
					declaredAt: (51 to: 54)
					by:
						(done _ #_coverageTracker173028446_
							coverAll:
								{267 to: 271}
							byLiteralOrPseudoVariable: false).
				[ | receiver25 |
				receiver25 _ [
				[ | receiver8 |
				receiver8 _ #_coverageTracker173028446_
					cover: (278 to: 281)
					declaredAt: (51 to: 54)
					by: done.
				#_coverageTracker173028446_
					coverAll:
						{283 to: 285}
					evaluating: [
						receiver8 or: [
							[ | receiver7 |
							receiver7 _ [ | receiver6 |
							receiver6 _ #_coverageTracker173028446_
								cover: (289 to: 297)
								declaredAt: (62 to: 70)
								by: positions.
							#_coverageTracker173028446_
								coverAll:
									{299 to: 302}
								evaluating: [ receiver6 size ]
								thatSends: #size
								to: receiver6 ] value.
							#_coverageTracker173028446_
								coverAll:
									{304 to: 304}
								evaluating: [
									receiver7 >
										(#_coverageTracker173028446_
											coverAll:
												{306 to: 306}
											byLiteralOrPseudoVariable: 0) ]
								thatSends: #>
								to: receiver7 ] value ]]
					thatSends: #or:
					to: receiver8 ] value ].
				#_coverageTracker173028446_
					coverAll:
						{314 to: 324}
					evaluating: [
						receiver25 whileFalse: [
							[ | receiver9 |
							receiver9 _ #_coverageTracker173028446_
								cover: (332 to: 342)
								declaredAt: (134 to: 144)
								by: changesFile.
							#_coverageTracker173028446_
								coverAll:
									{344 to: 352}
								evaluating: [
									receiver9 position:
										(#_coverageTracker173028446_
											cover: (354 to: 358)
											declaredAt: (56 to: 60)
											by: block)
									"ignore first fragment" ]
								thatSends: #position:
								to: receiver9 ] value.
							[ | receiver10 |
							receiver10 _ #_coverageTracker173028446_
								cover: (393 to: 403)
								declaredAt: (134 to: 144)
								by: changesFile.
							#_coverageTracker173028446_
								coverAll:
									{405 to: 413}
								evaluating: [ receiver10 nextChunk ]
								thatSends: #nextChunk
								to: receiver10 ] value.
							[ | receiver20 |
							receiver20 _ [
							[ | receiver12 |
							receiver12 _ [ | receiver11 |
							receiver11 _ #_coverageTracker173028446_
								cover: (422 to: 432)
								declaredAt: (134 to: 144)
								by: changesFile.
							#_coverageTracker173028446_
								coverAll:
									{434 to: 441}
								evaluating: [ receiver11 position ]
								thatSends: #position
								to: receiver11 ] value.
							#_coverageTracker173028446_
								coverAll:
									{443 to: 443}
								evaluating: [
									receiver12 <
										(#_coverageTracker173028446_
											cover: (445 to: 453)
											declaredAt: (72 to: 80)
											by: prevBlock) ]
								thatSends: #<
								to: receiver12 ] value ].
							#_coverageTracker173028446_
								coverAll:
									{462 to: 471}
								evaluating: [
									receiver20 whileTrue: [ | pos chunk |
										#_coverageTracker173028446_
											cover: (501 to: 503)
											declaredAt: (483 to: 485)
											by:
												(pos _ [ | receiver13 |
												receiver13 _ #_coverageTracker173028446_
													cover: (507 to: 517)
													declaredAt: (134 to: 144)
													by: changesFile.
												#_coverageTracker173028446_
													coverAll:
														{519 to: 526}
													evaluating: [ receiver13 position ]
													thatSends: #position
													to: receiver13 ] value).
										#_coverageTracker173028446_
											cover: (535 to: 539)
											declaredAt: (487 to: 491)
											by:
												(chunk _ [ | receiver14 |
												receiver14 _ #_coverageTracker173028446_
													cover: (543 to: 553)
													declaredAt: (134 to: 144)
													by: changesFile.
												#_coverageTracker173028446_
													coverAll:
														{555 to: 563}
													evaluating: [ receiver14 nextChunk ]
													thatSends: #nextChunk
													to: receiver14 ] value).
										[ | receiver19 |
										receiver19 _ [ | receiver17 |
										receiver17 _ [ | receiver15 |
										receiver15 _ #_coverageTracker173028446_
											coverAll:
												{574 to: 582}
											by: Smalltalk.
										#_coverageTracker173028446_
											coverAll:
												{584 to: 596}
											evaluating: [
												receiver15 isQuitRecord:
													(#_coverageTracker173028446_
														cover: (598 to: 602)
														declaredAt: (487 to: 491)
														by: chunk) ]
											thatSends: #isQuitRecord:
											to: receiver15 ] value.
										#_coverageTracker173028446_
											coverAll:
												{605 to: 607}
											evaluating: [
												receiver17 or: [
													[ | receiver16 |
													receiver16 _ #_coverageTracker173028446_
														coverAll:
															{611 to: 619}
														by: Smalltalk.
													#_coverageTracker173028446_
														coverAll:
															{621 to: 637}
														evaluating: [
															receiver16 isSnapshotRecord:
																(#_coverageTracker173028446_
																	cover: (639 to: 643)
																	declaredAt: (487 to: 491)
																	by: chunk) ]
														thatSends: #isSnapshotRecord:
														to: receiver16 ] value ]]
											thatSends: #or:
											to: receiver17 ] value.
										#_coverageTracker173028446_
											coverAll:
												{655 to: 661}
											evaluating: [
												receiver19 ifTrue: [
													[ | receiver18 |
													receiver18 _ #_coverageTracker173028446_
														cover: (665 to: 673)
														declaredAt: (62 to: 70)
														by: positions.
													#_coverageTracker173028446_
														coverAll:
															{675 to: 678}
														evaluating: [
															receiver18 add:
																(#_coverageTracker173028446_
																	cover: (680 to: 682)
																	declaredAt: (483 to: 485)
																	by: pos) ]
														thatSends: #add:
														to: receiver18 ] value ]]
											thatSends: #ifTrue:
											to: receiver19 ] value ]]
								thatSends: #whileTrue:
								to: receiver20 ] value.
							[ | receiver24 |
							receiver24 _ [ | receiver21 |
							receiver21 _ #_coverageTracker173028446_
								cover: (692 to: 696)
								declaredAt: (56 to: 60)
								by: block.
							#_coverageTracker173028446_
								coverAll:
									{698 to: 698}
								evaluating: [
									receiver21 =
										(#_coverageTracker173028446_
											coverAll:
												{700 to: 700}
											byLiteralOrPseudoVariable: 0) ]
								thatSends: #=
								to: receiver21 ] value.
							#_coverageTracker173028446_
								coverAll:
									{707 to: 713. 734 to: 741}
								evaluating: [
									receiver24
										ifTrue: [
											#_coverageTracker173028446_
												cover: (716 to: 719)
												declaredAt: (51 to: 54)
												by:
													(done _ #_coverageTracker173028446_
														coverAll:
															{723 to: 726}
														byLiteralOrPseudoVariable: true) ]
										ifFalse: [
											#_coverageTracker173028446_
												cover: (751 to: 759)
												declaredAt: (72 to: 80)
												by:
													(prevBlock _ #_coverageTracker173028446_
														cover: (763 to: 767)
														declaredAt: (56 to: 60)
														by: block).
											#_coverageTracker173028446_
												cover: (784 to: 788)
												declaredAt: (56 to: 60)
												by:
													(block _ [ | receiver23 |
													receiver23 _ [ | receiver22 |
													receiver22 _ #_coverageTracker173028446_
														cover: (776 to: 780)
														declaredAt: (56 to: 60)
														by: block.
													#_coverageTracker173028446_
														coverAll:
															{790 to: 790}
														evaluating: [
															receiver22 -
																(#_coverageTracker173028446_
																	coverAll:
																		{792 to: 795}
																	byLiteralOrPseudoVariable: 1024) ]
														thatSends: #-
														to: receiver22 ] value.
													#_coverageTracker173028446_
														coverAll:
															{797 to: 800}
														evaluating: [
															receiver23 max:
																(#_coverageTracker173028446_
																	coverAll:
																		{802 to: 802}
																	byLiteralOrPseudoVariable: 0) ]
														thatSends: #max:
														to: receiver23 ] value) ]]
								thatSends: #ifTrue:ifFalse:
								to: receiver24 ] value ]]
					thatSends: #whileFalse:
					to: receiver25 ] value ]]
		thatSends: #readStreamDo:
		to: receiver26 ] value.
	^ [ | receiver29 |
	receiver29 _ [ | receiver27 |
	receiver27 _ #_coverageTracker173028446_
		cover: (815 to: 823)
		declaredAt: (62 to: 70)
		by: positions.
	#_coverageTracker173028446_
		coverAll:
			{825 to: 831}
		evaluating: [ receiver27 isEmpty ]
		thatSends: #isEmpty
		to: receiver27 ] value.
	#_coverageTracker173028446_
		coverAll:
			{833 to: 839. 845 to: 852}
		evaluating: [
			receiver29
				ifTrue: [
					#_coverageTracker173028446_
						coverAll:
							{842 to: 842}
						byLiteralOrPseudoVariable: 0 ]
				ifFalse: [
					[ | receiver28 |
					receiver28 _ #_coverageTracker173028446_
						cover: (855 to: 863)
						declaredAt: (62 to: 70)
						by: positions.
					#_coverageTracker173028446_
						coverAll:
							{865 to: 868}
						evaluating: [ receiver28 last ]
						thatSends: #last
						to: receiver28 ] value ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver29 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173028521_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028521_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173028521_
		coverAll:
			{34 to: 47}
		evaluating: [
			receiver2 newModelClass:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028521_
					coverAll:
						{49 to: 52}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028521_
					coverAll:
						{54 to: 68}
					evaluating: [ receiver1 changeClassName ]
					thatSends: #changeClassName
					to: receiver1 ] value ]
		thatSends: #newModelClass:
		to: receiver2 ] value.! !
!Behavior method!
isCorrect: aChange
	| stateAfterChange |
	#_coverageTracker173028526_ markAsExecuted.
	#_coverageTracker173028526_
		cover: (45 to: 60)
		declaredAt: (23 to: 38)
		by:
			(stateAfterChange _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028526_
				coverAll:
					{65 to: 68}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173028526_
				coverAll:
					{70 to: 77}
				evaluating: [ receiver1 timeline ]
				thatSends: #timeline
				to: receiver1 ] value.
			#_coverageTracker173028526_
				coverAll:
					{79 to: 89}
				evaluating: [
					receiver2 stateAfter:
						(#_coverageTracker173028526_
							cover: (91 to: 97)
							declaredAt: (12 to: 18)
							by: aChange) ]
				thatSends: #stateAfter:
				to: receiver2 ] value).
	^ [ | receiver6 |
	receiver6 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173028526_
		cover: (105 to: 120)
		declaredAt: (23 to: 38)
		by: stateAfterChange.
	#_coverageTracker173028526_
		coverAll:
			{122 to: 130}
		evaluating: [ receiver3 isCorrect ]
		thatSends: #isCorrect
		to: receiver3 ] value.
	#_coverageTracker173028526_
		coverAll:
			{132 to: 135}
		evaluating: [
			receiver6 and: [
				[ | receiver5 |
				receiver5 _ [ | receiver4 |
				receiver4 _ #_coverageTracker173028526_
					coverAll:
						{140 to: 143}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028526_
					coverAll:
						{145 to: 153}
					evaluating: [
						receiver4 hasError:
							(#_coverageTracker173028526_
								cover: (155 to: 161)
								declaredAt: (12 to: 18)
								by: aChange) ]
					thatSends: #hasError:
					to: receiver4 ] value.
				#_coverageTracker173028526_
					coverAll:
						{164 to: 166}
					evaluating: [ receiver5 not ]
					thatSends: #not
					to: receiver5 ] value ]]
		thatSends: #and:
		to: receiver6 ] value.! !
!Behavior method!
description
	#_coverageTracker173028535_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028535_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028535_
		coverAll:
			{21 to: 35}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.
	#_coverageTracker173028535_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028535_
					coverAll:
						{38 to: 41}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173028535_
		coverAll:
			{42 to: 42}
		evaluating: [
			receiver4 ,
				[ | receiver3 |
				receiver3 _ #_coverageTracker173028535_
					coverAll:
						{44 to: 47}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028535_
					coverAll:
						{49 to: 62}
					evaluating: [ receiver3 methodSelector ]
					thatSends: #methodSelector
					to: receiver3 ] value ]
		thatSends: #,
		to: receiver4 ] value.
	#_coverageTracker173028535_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver5 ,
				(#_coverageTracker173028535_
					coverAll:
						{65 to: 76}
					byLiteralOrPseudoVariable: ' was added') ]
		thatSends: #,
		to: receiver5 ] value.! !
!Behavior method!
printString
	#_coverageTracker173028539_ markAsExecuted.
	^ #_coverageTracker173028539_
		coverAll:
			{16 to: 22}
		byLiteralOrPseudoVariable: 'Green'.! !
!Behavior method!
detectBlock: aBlock
	#_coverageTracker173028542_ markAsExecuted.
	#_coverageTracker173028542_
		cover: (22 to: 32)
		declaredAt: (22 to: 32)
		by:
			(detectBlock _ #_coverageTracker173028542_
				cover: (37 to: 42)
				declaredAt: (14 to: 19)
				by: aBlock).! !
!Behavior method!
changeClassName
	#_coverageTracker173028544_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028544_
		cover: (20 to: 38)
		declaredAt: (20 to: 38)
		by: newTestChangeRecord.
	#_coverageTracker173028544_
		coverAll:
			{40 to: 54}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.! !
!Behavior method!
methodAddedBeforeTest: aSelector class: className
	#_coverageTracker173028546_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028546_
		coverAll:
			{55 to: 63}
		byLiteralOrPseudoVariable: 'Method '.
	#_coverageTracker173028546_
		coverAll:
			{64 to: 64}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028546_
					coverAll:
						{67 to: 70}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028546_
					coverAll:
						{72 to: 83. 95 to: 100}
					evaluating: [
						receiver1
							printMethod:
								(#_coverageTracker173028546_
									cover: (85 to: 93)
									declaredAt: (24 to: 32)
									by: aSelector)
							class:
								(#_coverageTracker173028546_
									cover: (102 to: 110)
									declaredAt: (41 to: 49)
									by: className) ]
					thatSends: #printMethod:class:
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173028546_
		coverAll:
			{112 to: 112}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173028546_
					coverAll:
						{114 to: 147}
					byLiteralOrPseudoVariable: ' was added before writing a test') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
renameTestFrom: previousTestReference to: currentTestReference
	#_coverageTracker173028553_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028553_
		cover: (65 to: 73)
		declaredAt: (65 to: 73)
		by: firstTest.
	#_coverageTracker173028553_
		coverAll:
			{75 to: 75}
		evaluating: [
			receiver1 =
				(#_coverageTracker173028553_
					cover: (77 to: 97)
					declaredAt: (17 to: 37)
					by: previousTestReference) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173028553_
		coverAll:
			{99 to: 105}
		evaluating: [
			receiver3 ifTrue: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028553_
					cover: (109 to: 117)
					declaredAt: (65 to: 73)
					by: firstTest.
				#_coverageTracker173028553_
					coverAll:
						{119 to: 119}
					evaluating: [
						receiver2 =
							(#_coverageTracker173028553_
								cover: (121 to: 140)
								declaredAt: (43 to: 62)
								by: currentTestReference) ]
					thatSends: #=
					to: receiver2 ] value ]]
		thatSends: #ifTrue:
		to: receiver3 ] value.
	[ | receiver6 |
	receiver6 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173028553_
		cover: (146 to: 155)
		declaredAt: (146 to: 155)
		by: secondTest.
	#_coverageTracker173028553_
		coverAll:
			{157 to: 157}
		evaluating: [
			receiver4 =
				(#_coverageTracker173028553_
					cover: (159 to: 179)
					declaredAt: (17 to: 37)
					by: previousTestReference) ]
		thatSends: #=
		to: receiver4 ] value.
	#_coverageTracker173028553_
		coverAll:
			{181 to: 187}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver5 |
				receiver5 _ #_coverageTracker173028553_
					cover: (191 to: 200)
					declaredAt: (146 to: 155)
					by: secondTest.
				#_coverageTracker173028553_
					coverAll:
						{202 to: 202}
					evaluating: [
						receiver5 =
							(#_coverageTracker173028553_
								cover: (204 to: 223)
								declaredAt: (43 to: 62)
								by: currentTestReference) ]
					thatSends: #=
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.! !
!Behavior method!
changeClass
	#_coverageTracker173028569_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028569_
		cover: (16 to: 27)
		declaredAt: (16 to: 27)
		by: changeRecord.
	#_coverageTracker173028569_
		coverAll:
			{29 to: 39}
		evaluating: [ receiver1 changeClass ]
		thatSends: #changeClass
		to: receiver1 ] value.! !
!Behavior method!
testPassed: aTestReference
	#_coverageTracker173028573_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028573_
		cover: (30 to: 40)
		declaredAt: (30 to: 40)
		by: passedTests.
	#_coverageTracker173028573_
		coverAll:
			{42 to: 45}
		evaluating: [
			receiver1 add:
				(#_coverageTracker173028573_
					cover: (47 to: 60)
					declaredAt: (13 to: 26)
					by: aTestReference) ]
		thatSends: #add:
		to: receiver1 ] value.
	[ | receiver5 |
	receiver5 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028573_
		coverAll:
			{66 to: 69}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028573_
		coverAll:
			{71 to: 84}
		evaluating: [ receiver2 allTestsPassed ]
		thatSends: #allTestsPassed
		to: receiver2 ] value.
	#_coverageTracker173028573_
		coverAll:
			{86 to: 92}
		evaluating: [
			receiver5 ifTrue: [
				[ | receiver4 |
				receiver4 _ #_coverageTracker173028573_
					coverAll:
						{96 to: 99}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028573_
					coverAll:
						{101 to: 113}
					evaluating: [
						receiver4 transitionTo:
							[ | receiver3 |
							receiver3 _ #_coverageTracker173028573_
								coverAll:
									{115 to: 119}
								by: Green.
							#_coverageTracker173028573_
								coverAll:
									{121 to: 123}
								evaluating: [ receiver3 new ]
								thatSends: #new
								to: receiver3 ] value ]
					thatSends: #transitionTo:
					to: receiver4 ] value ]]
		thatSends: #ifTrue:
		to: receiver5 ] value.! !
!Behavior method!
testRenamedFrom: previousTestReference to: currentTestReference
	#_coverageTracker173028579_ markAsExecuted.! !
!Behavior method!
changeCategory
	#_coverageTracker173028582_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028582_
		coverAll:
			{20 to: 23}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028582_
		coverAll:
			{25 to: 30}
		evaluating: [ receiver1 change ]
		thatSends: #change
		to: receiver1 ] value.
	#_coverageTracker173028582_
		coverAll:
			{32 to: 39}
		evaluating: [ receiver2 category ]
		thatSends: #category
		to: receiver2 ] value.
	#_coverageTracker173028582_
		coverAll:
			{41 to: 51}
		evaluating: [ receiver3 printString ]
		thatSends: #printString
		to: receiver3 ] value.! !
!Behavior method!
testClassRemoved: aSymbol
	| errorMessage |
	#_coverageTracker173028585_ markAsExecuted.
	#_coverageTracker173028585_
		cover: (47 to: 58)
		declaredAt: (31 to: 42)
		by:
			(errorMessage _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028585_
				coverAll:
					{63 to: 69}
				by: TDDGuru.
			#_coverageTracker173028585_
				coverAll:
					{71 to: 97}
				evaluating: [
					receiver1 testClassRemovedWhileInRed:
						(#_coverageTracker173028585_
							cover: (99 to: 105)
							declaredAt: (19 to: 25)
							by: aSymbol) ]
				thatSends: #testClassRemovedWhileInRed:
				to: receiver1 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028585_
		coverAll:
			{109 to: 112}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028585_
		coverAll:
			{114 to: 125. 140 to: 155}
		evaluating: [
			receiver3
				reportError:
					(#_coverageTracker173028585_
						cover: (127 to: 138)
						declaredAt: (31 to: 42)
						by: errorMessage)
				andTransitionTo:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173028585_
						coverAll:
							{157 to: 167}
						by: NotDoingTDD.
					#_coverageTracker173028585_
						coverAll:
							{169 to: 171}
						evaluating: [ receiver2 new ]
						thatSends: #new
						to: receiver2 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver3 ] value.! !
!Behavior method!
category
	#_coverageTracker173028600_ markAsExecuted.
	^ #_coverageTracker173028600_
		coverAll:
			{13 to: 25}
		byLiteralOrPseudoVariable: #newTestClass.! !
!Behavior method!
reportChangeTo: aTDDGuru
	#_coverageTracker173028603_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028603_
		cover: (28 to: 35)
		declaredAt: (17 to: 24)
		by: aTDDGuru.
	#_coverageTracker173028603_
		coverAll:
			{37 to: 55}
		evaluating: [
			receiver2 testUtilityChanged:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028603_
					coverAll:
						{57 to: 60}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028603_
					coverAll:
						{62 to: 76}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #testUtilityChanged:
		to: receiver2 ] value.! !
!Behavior method!
modelMethodRemoved: aMethodReference
	#_coverageTracker173028607_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028607_
		coverAll:
			{39 to: 42}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028607_
		coverAll:
			{44 to: 55}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173028607_
		coverAll:
			{57 to: 75}
		evaluating: [
			receiver2 modelMethodRemoved:
				(#_coverageTracker173028607_
					cover: (77 to: 92)
					declaredAt: (21 to: 36)
					by: aMethodReference) ]
		thatSends: #modelMethodRemoved:
		to: receiver2 ] value.! !
!Behavior method!
selectionIndex
	#_coverageTracker173028612_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028612_
		coverAll:
			{20 to: 23}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028612_
		coverAll:
			{25 to: 36}
		evaluating: [ receiver1 changeEvents ]
		thatSends: #changeEvents
		to: receiver1 ] value.
	#_coverageTracker173028612_
		coverAll:
			{38 to: 45}
		evaluating: [
			receiver2 indexOf:
				(#_coverageTracker173028612_
					cover: (47 to: 59)
					declaredAt: (47 to: 59)
					by: selectedEvent) ]
		thatSends: #indexOf:
		to: receiver2 ] value.! !
!Behavior method!
printOn: aStream
	#_coverageTracker173028615_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028615_
		coverAll:
			{20 to: 23}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028615_
		coverAll:
			{25 to: 32}
		evaluating: [ receiver1 category ]
		thatSends: #category
		to: receiver1 ] value.
	#_coverageTracker173028615_
		coverAll:
			{34 to: 44}
		evaluating: [ receiver2 printString ]
		thatSends: #printString
		to: receiver2 ] value.
	#_coverageTracker173028615_
		coverAll:
			{45 to: 45}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173028615_
					coverAll:
						{47 to: 51}
					byLiteralOrPseudoVariable: ' - ') ]
		thatSends: #,
		to: receiver3 ] value.
	#_coverageTracker173028615_
		coverAll:
			{52 to: 52}
		evaluating: [
			receiver5 ,
				[ | receiver4 |
				receiver4 _ #_coverageTracker173028615_
					coverAll:
						{54 to: 57}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028615_
					coverAll:
						{59 to: 69}
					evaluating: [ receiver4 description ]
					thatSends: #description
					to: receiver4 ] value ]
		thatSends: #,
		to: receiver5 ] value.
	#_coverageTracker173028615_
		coverAll:
			{72 to: 79}
		evaluating: [
			receiver6 printOn:
				(#_coverageTracker173028615_
					cover: (81 to: 87)
					declaredAt: (10 to: 16)
					by: aStream) ]
		thatSends: #printOn:
		to: receiver6 ] value.! !
!Behavior method!
timeline
	| timeline |
	#_coverageTracker173028624_ markAsExecuted.
	#_coverageTracker173028624_
		cover: (27 to: 34)
		declaredAt: (13 to: 20)
		by:
			(timeline _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028624_
				coverAll:
					{39 to: 53}
				by: ChangeListMorph.
			#_coverageTracker173028624_
				coverAll:
					{55 to: 60. 77 to: 87. 103 to: 114. 132 to: 143}
				evaluating: [
					receiver2
						model:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173028624_
								cover: (62 to: 66)
								declaredAt: (62 to: 66)
								by: model.
							#_coverageTracker173028624_
								coverAll:
									{68 to: 75}
								evaluating: [ receiver1 timeline ]
								thatSends: #timeline
								to: receiver1 ] value
						listGetter:
							(#_coverageTracker173028624_
								coverAll:
									{89 to: 101}
								byLiteralOrPseudoVariable: #changeEvents)
						indexGetter:
							(#_coverageTracker173028624_
								coverAll:
									{116 to: 130}
								byLiteralOrPseudoVariable: #selectionIndex)
						indexSetter:
							(#_coverageTracker173028624_
								coverAll:
									{145 to: 160}
								byLiteralOrPseudoVariable: #selectionIndex:) ]
				thatSends: #model:listGetter:indexGetter:indexSetter:
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173028624_
		cover: (164 to: 171)
		declaredAt: (13 to: 20)
		by: timeline.
	#_coverageTracker173028624_
		coverAll:
			{173 to: 187}
		evaluating: [
			receiver3 analysisResult:
				(#_coverageTracker173028624_
					cover: (189 to: 193)
					declaredAt: (62 to: 66)
					by: model) ]
		thatSends: #analysisResult:
		to: receiver3 ] value.
	^ #_coverageTracker173028624_
		cover: (200 to: 207)
		declaredAt: (13 to: 20)
		by: timeline.! !
!Behavior method!
testAddedWhileWritingAnother: aSymbol class: className
	#_coverageTracker173028632_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028632_
		coverAll:
			{60 to: 63}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028632_
		coverAll:
			{65 to: 76. 86 to: 91}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173028632_
						cover: (78 to: 84)
						declaredAt: (31 to: 37)
						by: aSymbol)
				class:
					(#_coverageTracker173028632_
						cover: (93 to: 101)
						declaredAt: (46 to: 54)
						by: className) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173028632_
		coverAll:
			{103 to: 103}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173028632_
					coverAll:
						{105 to: 143}
					byLiteralOrPseudoVariable: ' was added while writing another test') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
modelMethodRemovedDetector
	#_coverageTracker173028637_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173028637_
		coverAll:
			{31 to: 44}
		by: ChangeDetector.
	#_coverageTracker173028637_
		coverAll:
			{46 to: 49. 65 to: 78. 82 to: 93}
		evaluating: [
			receiver2
				for:
					(#_coverageTracker173028637_
						coverAll:
							{51 to: 63}
						by: MethodRemoved)
				withLookahead:
					(#_coverageTracker173028637_
						coverAll:
							{80 to: 80}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver1 |
					receiver1 _ #_coverageTracker173028637_
						cover: (114 to: 126)
						declaredAt: (98 to: 110)
						by: aChangeRecord.
					#_coverageTracker173028637_
						coverAll:
							{128 to: 143}
						evaluating: [ receiver1 isMethodDeletion ]
						thatSends: #isMethodDeletion
						to: receiver1 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver2 ] value.! !
!Behavior method!
on: aFileName from: startPosition
	#_coverageTracker173028642_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028642_
		coverAll:
			{38 to: 41}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028642_
		coverAll:
			{43 to: 45}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173028642_
		coverAll:
			{47 to: 58. 70 to: 74}
		evaluating: [
			receiver2
				changesFile:
					(#_coverageTracker173028642_
						cover: (60 to: 68)
						declaredAt: (5 to: 13)
						by: aFileName)
				from:
					(#_coverageTracker173028642_
						cover: (76 to: 88)
						declaredAt: (21 to: 33)
						by: startPosition) ]
		thatSends: #changesFile:from:
		to: receiver2 ] value.! !
!Behavior method!
stateTransitionFrom: previousTDDState to: currentTDDState
	#_coverageTracker173028648_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028648_
		cover: (60 to: 67)
		declaredAt: (60 to: 67)
		by: timeline.
	#_coverageTracker173028648_
		coverAll:
			{69 to: 88. 107 to: 109}
		evaluating: [
			receiver1
				stateTransitionFrom:
					(#_coverageTracker173028648_
						cover: (90 to: 105)
						declaredAt: (22 to: 37)
						by: previousTDDState)
				to:
					(#_coverageTracker173028648_
						cover: (111 to: 125)
						declaredAt: (43 to: 57)
						by: currentTDDState) ]
		thatSends: #stateTransitionFrom:to:
		to: receiver1 ] value.! !
!Behavior method!
states
	#_coverageTracker173028652_ markAsExecuted.
	^ [ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028652_
		coverAll:
			{11 to: 14}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028652_
		coverAll:
			{16 to: 27}
		evaluating: [ receiver1 changeEvents ]
		thatSends: #changeEvents
		to: receiver1 ] value.
	#_coverageTracker173028652_
		coverAll:
			{29 to: 36}
		evaluating: [
			receiver4 collect: [ :changeEvent |
				[ | receiver3 |
				receiver3 _ #_coverageTracker173028652_
					coverAll:
						{55 to: 58}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028652_
					coverAll:
						{60 to: 70}
					evaluating: [
						receiver3 stateAfter:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173028652_
								cover: (72 to: 82)
								declaredAt: (41 to: 51)
								by: changeEvent.
							#_coverageTracker173028652_
								coverAll:
									{84 to: 89}
								evaluating: [ receiver2 change ]
								thatSends: #change
								to: receiver2 ] value ]
					thatSends: #stateAfter:
					to: receiver3 ] value ]]
		thatSends: #collect:
		to: receiver4 ] value.! !
!Behavior method!
testRemoved: methodSelector
	#_coverageTracker173028658_ markAsExecuted.! !
!Behavior method!
classRenamedFrom: previousName to: currentName
	#_coverageTracker173028660_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028660_
		cover: (50 to: 58)
		declaredAt: (50 to: 58)
		by: inventory.
	#_coverageTracker173028660_
		coverAll:
			{60 to: 76. 91 to: 93}
		evaluating: [
			receiver1
				classRenamedFrom:
					(#_coverageTracker173028660_
						cover: (78 to: 89)
						declaredAt: (19 to: 30)
						by: previousName)
				to:
					(#_coverageTracker173028660_
						cover: (95 to: 105)
						declaredAt: (36 to: 46)
						by: currentName) ]
		thatSends: #classRenamedFrom:to:
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028660_
		coverAll:
			{109 to: 112}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028660_
		coverAll:
			{114 to: 125}
		evaluating: [ receiver2 currentState ]
		thatSends: #currentState
		to: receiver2 ] value.
	#_coverageTracker173028660_
		coverAll:
			{127 to: 143. 158 to: 160}
		evaluating: [
			receiver3
				classRenamedFrom:
					(#_coverageTracker173028660_
						cover: (145 to: 156)
						declaredAt: (19 to: 30)
						by: previousName)
				to:
					(#_coverageTracker173028660_
						cover: (162 to: 172)
						declaredAt: (36 to: 46)
						by: currentName) ]
		thatSends: #classRenamedFrom:to:
		to: receiver3 ] value.! !
!Behavior method!
newTestClass: className
	#_coverageTracker173028667_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028667_
		cover: (26 to: 34)
		declaredAt: (26 to: 34)
		by: inventory.
	#_coverageTracker173028667_
		coverAll:
			{36 to: 48}
		evaluating: [
			receiver1 newTestClass:
				(#_coverageTracker173028667_
					cover: (50 to: 58)
					declaredAt: (15 to: 23)
					by: className) ]
		thatSends: #newTestClass:
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028667_
		coverAll:
			{62 to: 65}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028667_
		coverAll:
			{67 to: 78}
		evaluating: [ receiver2 currentState ]
		thatSends: #currentState
		to: receiver2 ] value.
	#_coverageTracker173028667_
		coverAll:
			{80 to: 92}
		evaluating: [
			receiver3 newTestClass:
				(#_coverageTracker173028667_
					cover: (94 to: 102)
					declaredAt: (15 to: 23)
					by: className) ]
		thatSends: #newTestClass:
		to: receiver3 ] value.! !
!Behavior method!
modelMethodChanged: aMethodReference
	#_coverageTracker173028672_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028672_
		coverAll:
			{39 to: 42}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028672_
		coverAll:
			{44 to: 55}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173028672_
		coverAll:
			{57 to: 75}
		evaluating: [
			receiver2 modelMethodChanged:
				(#_coverageTracker173028672_
					cover: (77 to: 92)
					declaredAt: (21 to: 36)
					by: aMethodReference) ]
		thatSends: #modelMethodChanged:
		to: receiver2 ] value.! !
!Behavior method!
initializeTestsOf: aCollectionOfTestClasses
	#_coverageTracker173028676_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028676_
		cover: (46 to: 69)
		declaredAt: (20 to: 43)
		by: aCollectionOfTestClasses.
	#_coverageTracker173028676_
		coverAll:
			{71 to: 73}
		evaluating: [
			receiver2 do: [ :testClass |
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028676_
					coverAll:
						{90 to: 93}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028676_
					coverAll:
						{95 to: 105}
					evaluating: [
						receiver1 addTestsOf:
							(#_coverageTracker173028676_
								cover: (107 to: 115)
								declaredAt: (78 to: 86)
								by: testClass) ]
					thatSends: #addTestsOf:
					to: receiver1 ] value ]]
		thatSends: #do:
		to: receiver2 ] value.! !
!Behavior method!
testDidNotFailErrorInCurrentTest: aTestReference
	#_coverageTracker173028682_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028682_
		coverAll:
			{52 to: 55}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028682_
		coverAll:
			{57 to: 79}
		evaluating: [
			receiver1 isOneOfTheCurrentTests:
				(#_coverageTracker173028682_
					cover: (81 to: 94)
					declaredAt: (35 to: 48)
					by: aTestReference) ]
		thatSends: #isOneOfTheCurrentTests:
		to: receiver1 ] value.
	#_coverageTracker173028682_
		coverAll:
			{97 to: 103}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver5 |
				receiver5 _ #_coverageTracker173028682_
					coverAll:
						{110 to: 113}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028682_
					coverAll:
						{115 to: 126}
					evaluating: [
						receiver5 reportError:
							[ | receiver4 |
							receiver4 _ #_coverageTracker173028682_
								coverAll:
									{129 to: 135}
								by: TDDGuru.
							#_coverageTracker173028682_
								coverAll:
									{137 to: 151. 177 to: 182}
								evaluating: [
									receiver4
										testDidNotFail:
											[ | receiver2 |
											receiver2 _ #_coverageTracker173028682_
												cover: (153 to: 166)
												declaredAt: (35 to: 48)
												by: aTestReference.
											#_coverageTracker173028682_
												coverAll:
													{168 to: 175}
												evaluating: [ receiver2 selector ]
												thatSends: #selector
												to: receiver2 ] value
										class:
											[ | receiver3 |
											receiver3 _ #_coverageTracker173028682_
												cover: (184 to: 197)
												declaredAt: (35 to: 48)
												by: aTestReference.
											#_coverageTracker173028682_
												coverAll:
													{199 to: 209}
												evaluating: [ receiver3 methodClass ]
												thatSends: #methodClass
												to: receiver3 ] value ]
								thatSends: #testDidNotFail:class:
								to: receiver4 ] value ]
					thatSends: #reportError:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.! !
!Behavior method!
noTestsLeft
	#_coverageTracker173028691_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028691_
		cover: (16 to: 24)
		declaredAt: (16 to: 24)
		by: inventory.
	#_coverageTracker173028691_
		coverAll:
			{26 to: 33}
		evaluating: [ receiver1 allTests ]
		thatSends: #allTests
		to: receiver1 ] value.
	#_coverageTracker173028691_
		coverAll:
			{35 to: 41}
		evaluating: [ receiver2 isEmpty ]
		thatSends: #isEmpty
		to: receiver2 ] value.! !
!Behavior method!
testChanged: aSymbol
	#_coverageTracker173028694_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028694_
		coverAll:
			{24 to: 27}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028694_
		coverAll:
			{29 to: 41}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028694_
					coverAll:
						{43 to: 50}
					by: Refactor.
				#_coverageTracker173028694_
					coverAll:
						{52 to: 54}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
testFailed: aSymbol
	#_coverageTracker173028698_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028698_
		coverAll:
			{23 to: 26}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028698_
		coverAll:
			{28 to: 40}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028698_
					coverAll:
						{42 to: 44}
					by: Red.
				#_coverageTracker173028698_
					coverAll:
						{46 to: 48}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
addTestsOf: aClass
	| testReference |
	#_coverageTracker173028702_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028702_
		cover: (43 to: 48)
		declaredAt: (13 to: 18)
		by: aClass.
	#_coverageTracker173028702_
		coverAll:
			{50 to: 65}
		evaluating: [ receiver1 allTestSelectors ]
		thatSends: #allTestSelectors
		to: receiver1 ] value.
	#_coverageTracker173028702_
		coverAll:
			{67 to: 69}
		evaluating: [
			receiver5 do: [ :selector |
				#_coverageTracker173028702_
					cover: (87 to: 99)
					declaredAt: (24 to: 36)
					by:
						(testReference _ [ | receiver3 |
						receiver3 _ #_coverageTracker173028702_
							coverAll:
								{104 to: 129}
							by: UninstalledMethodReference.
						#_coverageTracker173028702_
							coverAll:
								{131 to: 139. 150 to: 155}
							evaluating: [
								receiver3
									selector:
										(#_coverageTracker173028702_
											cover: (141 to: 148)
											declaredAt: (74 to: 81)
											by: selector)
									class:
										[ | receiver2 |
										receiver2 _ #_coverageTracker173028702_
											cover: (157 to: 162)
											declaredAt: (13 to: 18)
											by: aClass.
										#_coverageTracker173028702_
											coverAll:
												{164 to: 167}
											evaluating: [ receiver2 name ]
											thatSends: #name
											to: receiver2 ] value ]
							thatSends: #selector:class:
							to: receiver3 ] value).
				[ | receiver4 |
				receiver4 _ #_coverageTracker173028702_
					coverAll:
						{172 to: 175}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028702_
					coverAll:
						{177 to: 184}
					evaluating: [
						receiver4 newTest:
							(#_coverageTracker173028702_
								cover: (186 to: 198)
								declaredAt: (24 to: 36)
								by: testReference) ]
					thatSends: #newTest:
					to: receiver4 ] value ]]
		thatSends: #do:
		to: receiver5 ] value.! !
!Behavior method!
category
	#_coverageTracker173028721_ markAsExecuted.
	^ #_coverageTracker173028721_
		coverAll:
			{13 to: 20}
		byLiteralOrPseudoVariable: #testRun.! !
!Behavior method!
reportErrorInPreviousChange: description
	#_coverageTracker173028723_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028723_
		cover: (43 to: 56)
		declaredAt: (43 to: 56)
		by: analysisResult.
	#_coverageTracker173028723_
		coverAll:
			{58 to: 66. 80 to: 82}
		evaluating: [
			receiver1
				addError:
					(#_coverageTracker173028723_
						cover: (68 to: 78)
						declaredAt: (30 to: 40)
						by: description)
				in:
					(#_coverageTracker173028723_
						cover: (84 to: 97)
						declaredAt: (84 to: 97)
						by: previousChange) ]
		thatSends: #addError:in:
		to: receiver1 ] value.! !
!Behavior method!
worldMenuOptions
	#_coverageTracker173028728_ markAsExecuted.
	^ #_coverageTracker173028728_
		coverAll:
			{21 to: 333}
		byLiteralOrPseudoVariable: `{
				{#submenuOf -> TheWorldMenu openLabel. #itemGroup -> 40. #itemOrder -> 30. #label -> 'TDDGuru'. #object -> AnalysisResultWindow. #selector -> #startAnalysis. #icon -> #worldIcon. #balloonText -> 'Learn TDD by analyzing your change log'} asDictionary
			}`.! !
!Behavior method!
category
	#_coverageTracker173028733_ markAsExecuted.
	^ #_coverageTracker173028733_
		coverAll:
			{13 to: 25}
		byLiteralOrPseudoVariable: #testRefactor.! !
!Behavior method!
startAnalysis
	| selected changesFile userChangesFileName |
	#_coverageTracker173028736_ markAsExecuted.
	#_coverageTracker173028736_
		cover: (62 to: 80)
		declaredAt: (39 to: 57)
		by:
			(userChangesFileName _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028736_
				coverAll:
					{85 to: 103}
				by: FillInTheBlankMorph.
			#_coverageTracker173028736_
				coverAll:
					{105 to: 112. 146 to: 159. 194 to: 202}
				evaluating: [
					receiver2
						request:
							(#_coverageTracker173028736_
								coverAll:
									{114 to: 144}
								byLiteralOrPseudoVariable: 'Where are the changes logged?')
						initialAnswer:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173028736_
								coverAll:
									{161 to: 169}
								by: Smalltalk.
							#_coverageTracker173028736_
								coverAll:
									{171 to: 192}
								evaluating: [ receiver1 defaultUserChangesName ]
								thatSends: #defaultUserChangesName
								to: receiver1 ] value
						onCancel: [ ^ #_coverageTracker173028736_
								coverAll:
									{208 to: 210}
								byLiteralOrPseudoVariable: nil ]]
				thatSends: #request:initialAnswer:onCancel:
				to: receiver2 ] value).
	#_coverageTracker173028736_
		cover: (218 to: 228)
		declaredAt: (27 to: 37)
		by:
			(changesFile _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028736_
				cover: (233 to: 251)
				declaredAt: (39 to: 57)
				by: userChangesFileName.
			#_coverageTracker173028736_
				coverAll:
					{253 to: 263}
				evaluating: [ receiver3 asFileEntry ]
				thatSends: #asFileEntry
				to: receiver3 ] value).
	[ | receiver13 |
	receiver13 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173028736_
		cover: (269 to: 279)
		declaredAt: (27 to: 37)
		by: changesFile.
	#_coverageTracker173028736_
		coverAll:
			{281 to: 286}
		evaluating: [ receiver4 exists ]
		thatSends: #exists
		to: receiver4 ] value.
	#_coverageTracker173028736_
		coverAll:
			{288 to: 294}
		evaluating: [
			receiver13 ifTrue: [
				#_coverageTracker173028736_
					cover: (300 to: 307)
					declaredAt: (18 to: 25)
					by:
						(selected _ [ | receiver6 |
						receiver6 _ [ | receiver5 |
						receiver5 _ #_coverageTracker173028736_
							coverAll:
								{313 to: 325}
							by: SelectionMenu.
						#_coverageTracker173028736_
							coverAll:
								{327 to: 333. 388 to: 398}
							evaluating: [
								receiver5
									labels:
										(#_coverageTracker173028736_
											coverAll:
												{335 to: 386}
											byLiteralOrPseudoVariable:
												{'The whole change log'. 'From a specific change'})
									selections:
										(#_coverageTracker173028736_
											coverAll:
												{400 to: 415}
											byLiteralOrPseudoVariable:
												{#all. #pick}) ]
							thatSends: #labels:selections:
							to: receiver5 ] value.
						#_coverageTracker173028736_
							coverAll:
								{418 to: 436}
							evaluating: [
								receiver6 startUpWithCaption:
									(#_coverageTracker173028736_
										coverAll:
											{438 to: 464}
										byLiteralOrPseudoVariable: 'TDDGuru should analyze...') ]
							thatSends: #startUpWithCaption:
							to: receiver6 ] value).
				[ | receiver9 |
				receiver9 _ [ | receiver7 |
				receiver7 _ #_coverageTracker173028736_
					cover: (469 to: 476)
					declaredAt: (18 to: 25)
					by: selected.
				#_coverageTracker173028736_
					coverAll:
						{478 to: 478}
					evaluating: [
						receiver7 =
							(#_coverageTracker173028736_
								coverAll:
									{409 to: 413}
								byLiteralOrPseudoVariable: #pick) ]
					thatSends: #=
					to: receiver7 ] value.
				#_coverageTracker173028736_
					coverAll:
						{486 to: 492}
					evaluating: [
						receiver9 ifTrue: [
							[ | receiver8 |
							receiver8 _ #_coverageTracker173028736_
								coverAll:
									{496 to: 499}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173028736_
								coverAll:
									{501 to: 522}
								evaluating: [
									receiver8 pickAChangeAndAnalyze:
										(#_coverageTracker173028736_
											cover: (524 to: 542)
											declaredAt: (39 to: 57)
											by: userChangesFileName) ]
								thatSends: #pickAChangeAndAnalyze:
								to: receiver8 ] value ]]
					thatSends: #ifTrue:
					to: receiver9 ] value.
				[ | receiver12 |
				receiver12 _ [ | receiver10 |
				receiver10 _ #_coverageTracker173028736_
					cover: (549 to: 556)
					declaredAt: (18 to: 25)
					by: selected.
				#_coverageTracker173028736_
					coverAll:
						{558 to: 558}
					evaluating: [
						receiver10 =
							(#_coverageTracker173028736_
								coverAll:
									{402 to: 405}
								byLiteralOrPseudoVariable: #all) ]
					thatSends: #=
					to: receiver10 ] value.
				#_coverageTracker173028736_
					coverAll:
						{565 to: 571}
					evaluating: [
						receiver12 ifTrue: [
							[ | receiver11 |
							receiver11 _ #_coverageTracker173028736_
								coverAll:
									{575 to: 578}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173028736_
								coverAll:
									{580 to: 596}
								evaluating: [
									receiver11 analyzeWholeFile:
										(#_coverageTracker173028736_
											cover: (598 to: 616)
											declaredAt: (39 to: 57)
											by: userChangesFileName) ]
								thatSends: #analyzeWholeFile:
								to: receiver11 ] value ]]
					thatSends: #ifTrue:
					to: receiver12 ] value ]]
		thatSends: #ifTrue:
		to: receiver13 ] value.! !
!Behavior method!
overridesASuperclassMethod: aMethodReference
	#_coverageTracker173028762_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028762_
		cover: (50 to: 65)
		declaredAt: (29 to: 44)
		by: aMethodReference.
	#_coverageTracker173028762_
		coverAll:
			{67 to: 92}
		evaluating: [ receiver1 overridesASuperclassMethod ]
		thatSends: #overridesASuperclassMethod
		to: receiver1 ] value.! !
!Behavior method!
stamp
	#_coverageTracker173028765_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028765_
		cover: (10 to: 21)
		declaredAt: (10 to: 21)
		by: changeRecord.
	#_coverageTracker173028765_
		coverAll:
			{23 to: 27}
		evaluating: [ receiver1 stamp ]
		thatSends: #stamp
		to: receiver1 ] value.! !
!Behavior method!
currentTest
	#_coverageTracker173028766_ markAsExecuted.
	^ #_coverageTracker173028766_
		cover: (16 to: 19)
		declaredAt: (16 to: 19)
		by: test.! !
!Behavior method!
drawRow: aRow on: aCanvas
	| currentEvent |
	#_coverageTracker173028770_ markAsExecuted.
	#_coverageTracker173028770_
		cover: (46 to: 57)
		declaredAt: (30 to: 41)
		by:
			(currentEvent _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028770_
				cover: (62 to: 66)
				declaredAt: (62 to: 66)
				by: owner.
			#_coverageTracker173028770_
				coverAll:
					{68 to: 72}
				evaluating: [ receiver1 model ]
				thatSends: #model
				to: receiver1 ] value.
			#_coverageTracker173028770_
				coverAll:
					{74 to: 82}
				evaluating: [
					receiver2 changeAt:
						(#_coverageTracker173028770_
							cover: (84 to: 87)
							declaredAt: (10 to: 13)
							by: aRow) ]
				thatSends: #changeAt:
				to: receiver2 ] value).
	[ | receiver6 |
	receiver6 _ [ | receiver4 |
	receiver4 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173028770_
		cover: (93 to: 104)
		declaredAt: (30 to: 41)
		by: currentEvent.
	#_coverageTracker173028770_
		coverAll:
			{106 to: 109}
		evaluating: [ receiver3 type ]
		thatSends: #type
		to: receiver3 ] value.
	#_coverageTracker173028770_
		coverAll:
			{111 to: 111}
		evaluating: [
			receiver4 =
				(#_coverageTracker173028770_
					coverAll:
						{113 to: 119}
					byLiteralOrPseudoVariable: #change) ]
		thatSends: #=
		to: receiver4 ] value.
	#_coverageTracker173028770_
		coverAll:
			{121 to: 127}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver5 |
				receiver5 _ #_coverageTracker173028770_
					coverAll:
						{131 to: 134}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028770_
					coverAll:
						{136 to: 149. 156 to: 158}
					evaluating: [
						receiver5
							drawChangeRow:
								(#_coverageTracker173028770_
									cover: (151 to: 154)
									declaredAt: (10 to: 13)
									by: aRow)
							on:
								(#_coverageTracker173028770_
									cover: (160 to: 166)
									declaredAt: (19 to: 25)
									by: aCanvas) ]
					thatSends: #drawChangeRow:on:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver10 |
	receiver10 _ [ | receiver8 |
	receiver8 _ [ | receiver7 |
	receiver7 _ #_coverageTracker173028770_
		cover: (172 to: 183)
		declaredAt: (30 to: 41)
		by: currentEvent.
	#_coverageTracker173028770_
		coverAll:
			{185 to: 188}
		evaluating: [ receiver7 type ]
		thatSends: #type
		to: receiver7 ] value.
	#_coverageTracker173028770_
		coverAll:
			{190 to: 190}
		evaluating: [
			receiver8 =
				(#_coverageTracker173028770_
					coverAll:
						{192 to: 207}
					byLiteralOrPseudoVariable: #stateTransition) ]
		thatSends: #=
		to: receiver8 ] value.
	#_coverageTracker173028770_
		coverAll:
			{209 to: 215}
		evaluating: [
			receiver10 ifTrue: [
				[ | receiver9 |
				receiver9 _ #_coverageTracker173028770_
					coverAll:
						{219 to: 222}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028770_
					coverAll:
						{224 to: 246. 253 to: 255}
					evaluating: [
						receiver9
							drawStateTransitionRow:
								(#_coverageTracker173028770_
									cover: (248 to: 251)
									declaredAt: (10 to: 13)
									by: aRow)
							on:
								(#_coverageTracker173028770_
									cover: (257 to: 263)
									declaredAt: (19 to: 25)
									by: aCanvas) ]
					thatSends: #drawStateTransitionRow:on:
					to: receiver9 ] value ]]
		thatSends: #ifTrue:
		to: receiver10 ] value.! !
!Behavior method!
drawIconFor: aRow in: aCanvas
	| currentEvent stateAfterChange icon |
	#_coverageTracker173028788_ markAsExecuted.
	#_coverageTracker173028788_
		cover: (75 to: 86)
		declaredAt: (34 to: 45)
		by:
			(currentEvent _ [ | receiver2 |
			receiver2 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028788_
				cover: (91 to: 95)
				declaredAt: (91 to: 95)
				by: owner.
			#_coverageTracker173028788_
				coverAll:
					{97 to: 101}
				evaluating: [ receiver1 model ]
				thatSends: #model
				to: receiver1 ] value.
			#_coverageTracker173028788_
				coverAll:
					{103 to: 111}
				evaluating: [
					receiver2 changeAt:
						(#_coverageTracker173028788_
							cover: (113 to: 116)
							declaredAt: (14 to: 17)
							by: aRow) ]
				thatSends: #changeAt:
				to: receiver2 ] value).
	#_coverageTracker173028788_
		cover: (120 to: 135)
		declaredAt: (47 to: 62)
		by:
			(stateAfterChange _ [ | receiver5 |
			receiver5 _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028788_
				cover: (140 to: 144)
				declaredAt: (91 to: 95)
				by: owner.
			#_coverageTracker173028788_
				coverAll:
					{146 to: 150}
				evaluating: [ receiver3 model ]
				thatSends: #model
				to: receiver3 ] value.
			#_coverageTracker173028788_
				coverAll:
					{152 to: 162}
				evaluating: [
					receiver5 stateAfter:
						[ | receiver4 |
						receiver4 _ #_coverageTracker173028788_
							cover: (164 to: 175)
							declaredAt: (34 to: 45)
							by: currentEvent.
						#_coverageTracker173028788_
							coverAll:
								{177 to: 182}
							evaluating: [ receiver4 change ]
							thatSends: #change
							to: receiver4 ] value ]
				thatSends: #stateAfter:
				to: receiver5 ] value).
	#_coverageTracker173028788_
		cover: (186 to: 189)
		declaredAt: (64 to: 67)
		by:
			(icon _ [ | receiver8 |
			receiver8 _ #_coverageTracker173028788_
				coverAll:
					{194 to: 205}
				by: TDDStateIcon.
			#_coverageTracker173028788_
				coverAll:
					{207 to: 210. 229 to: 234. 239 to: 245}
				evaluating: [
					receiver8
						for:
							(#_coverageTracker173028788_
								cover: (212 to: 227)
								declaredAt: (47 to: 62)
								by: stateAfterChange)
						width:
							(#_coverageTracker173028788_
								coverAll:
									{236 to: 237}
								byLiteralOrPseudoVariable: 20)
						height:
							[ | receiver7 |
							receiver7 _ [ | receiver6 |
							receiver6 _ #_coverageTracker173028788_
								cover: (248 to: 251)
								declaredAt: (248 to: 251)
								by: font.
							#_coverageTracker173028788_
								coverAll:
									{253 to: 263}
								evaluating: [ receiver6 lineSpacing ]
								thatSends: #lineSpacing
								to: receiver6 ] value.
							#_coverageTracker173028788_
								coverAll:
									{265 to: 265}
								evaluating: [
									receiver7 -
										(#_coverageTracker173028788_
											coverAll:
												{267 to: 267}
											byLiteralOrPseudoVariable: 1) ]
								thatSends: #-
								to: receiver7 ] value ]
				thatSends: #for:width:height:
				to: receiver8 ] value).
	[ | receiver11 |
	receiver11 _ #_coverageTracker173028788_
		cover: (272 to: 275)
		declaredAt: (64 to: 67)
		by: icon.
	#_coverageTracker173028788_
		coverAll:
			{277 to: 283. 316 to: 318}
		evaluating: [
			receiver11
				drawAt:
					[ | receiver10 |
					receiver10 _ #_coverageTracker173028788_
						coverAll:
							{286 to: 286}
						byLiteralOrPseudoVariable: 0.
					#_coverageTracker173028788_
						coverAll:
							{288 to: 288}
						evaluating: [
							receiver10 @
								[ | receiver9 |
								receiver9 _ #_coverageTracker173028788_
									coverAll:
										{291 to: 294}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173028788_
									coverAll:
										{296 to: 307}
									evaluating: [
										receiver9 drawYForRow:
											(#_coverageTracker173028788_
												cover: (309 to: 312)
												declaredAt: (14 to: 17)
												by: aRow) ]
									thatSends: #drawYForRow:
									to: receiver9 ] value ]
						thatSends: #@
						to: receiver10 ] value
				on:
					(#_coverageTracker173028788_
						cover: (320 to: 326)
						declaredAt: (23 to: 29)
						by: aCanvas) ]
		thatSends: #drawAt:on:
		to: receiver11 ] value.
	[ | receiver13 |
	receiver13 _ #_coverageTracker173028788_
		cover: (330 to: 333)
		declaredAt: (64 to: 67)
		by: icon.
	#_coverageTracker173028788_
		coverAll:
			{335 to: 349}
		evaluating: [
			receiver13 setBalloonText:
				[ | receiver12 |
				receiver12 _ #_coverageTracker173028788_
					cover: (351 to: 366)
					declaredAt: (47 to: 62)
					by: stateAfterChange.
				#_coverageTracker173028788_
					coverAll:
						{368 to: 375}
					evaluating: [ receiver12 asString ]
					thatSends: #asString
					to: receiver12 ] value ]
		thatSends: #setBalloonText:
		to: receiver13 ] value.! !
!Behavior method!
newModelMethod: aMethodReference
	#_coverageTracker173028812_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028812_
		coverAll:
			{36 to: 39}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028812_
		coverAll:
			{41 to: 53}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028812_
					coverAll:
						{56 to: 63}
					by: Refactor.
				#_coverageTracker173028812_
					coverAll:
						{65 to: 79}
					evaluating: [
						receiver1 newModelMethod:
							(#_coverageTracker173028812_
								cover: (81 to: 96)
								declaredAt: (17 to: 32)
								by: aMethodReference) ]
					thatSends: #newModelMethod:
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
category
	#_coverageTracker173028816_ markAsExecuted.
	^ #_coverageTracker173028816_
		coverAll:
			{13 to: 20}
		byLiteralOrPseudoVariable: #unknown.! !
!Behavior method!
modelMethodRemoved: aMethodReference
	| errorMessage |
	#_coverageTracker173028818_ markAsExecuted.
	#_coverageTracker173028818_
		cover: (60 to: 71)
		declaredAt: (42 to: 53)
		by:
			(errorMessage _ [ | receiver3 |
			receiver3 _ #_coverageTracker173028818_
				coverAll:
					{76 to: 82}
				by: TDDGuru.
			#_coverageTracker173028818_
				coverAll:
					{84 to: 114. 142 to: 147}
				evaluating: [
					receiver3
						methodRemovedWhileWritingATest:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173028818_
								cover: (116 to: 131)
								declaredAt: (21 to: 36)
								by: aMethodReference.
							#_coverageTracker173028818_
								coverAll:
									{133 to: 140}
								evaluating: [ receiver1 selector ]
								thatSends: #selector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173028818_
								cover: (149 to: 164)
								declaredAt: (21 to: 36)
								by: aMethodReference.
							#_coverageTracker173028818_
								coverAll:
									{166 to: 176}
								evaluating: [ receiver2 methodClass ]
								thatSends: #methodClass
								to: receiver2 ] value ]
				thatSends: #methodRemovedWhileWritingATest:class:
				to: receiver3 ] value).
	[ | receiver5 |
	receiver5 _ #_coverageTracker173028818_
		coverAll:
			{180 to: 183}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028818_
		coverAll:
			{185 to: 196. 211 to: 226}
		evaluating: [
			receiver5
				reportError:
					(#_coverageTracker173028818_
						cover: (198 to: 209)
						declaredAt: (42 to: 53)
						by: errorMessage)
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173028818_
						coverAll:
							{228 to: 238}
						by: NotDoingTDD.
					#_coverageTracker173028818_
						coverAll:
							{240 to: 242}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
drawChangeRow: aRow on: aCanvas
	#_coverageTracker173028836_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028836_
		coverAll:
			{35 to: 38}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028836_
		coverAll:
			{40 to: 51. 58 to: 60}
		evaluating: [
			receiver1
				drawIconFor:
					(#_coverageTracker173028836_
						cover: (53 to: 56)
						declaredAt: (16 to: 19)
						by: aRow)
				in:
					(#_coverageTracker173028836_
						cover: (62 to: 68)
						declaredAt: (25 to: 31)
						by: aCanvas) ]
		thatSends: #drawIconFor:in:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028836_
		coverAll:
			{72 to: 75}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028836_
		coverAll:
			{77 to: 94. 101 to: 103}
		evaluating: [
			receiver2
				drawChangeTextFor:
					(#_coverageTracker173028836_
						cover: (96 to: 99)
						declaredAt: (16 to: 19)
						by: aRow)
				in:
					(#_coverageTracker173028836_
						cover: (105 to: 111)
						declaredAt: (25 to: 31)
						by: aCanvas) ]
		thatSends: #drawChangeTextFor:in:
		to: receiver2 ] value.! !
!Behavior method!
printString
	#_coverageTracker173028843_ markAsExecuted.
	^ #_coverageTracker173028843_
		coverAll:
			{16 to: 20}
		byLiteralOrPseudoVariable: 'Red'.! !
!Behavior method!
shouldStyle: aText with: aSHTextStylerST80
	| changeClass |
	#_coverageTracker173028847_ markAsExecuted.
	[ | receiver12 |
	receiver12 _ [ | receiver6 |
	receiver6 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028847_
		coverAll:
			{67 to: 70}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028847_
		coverAll:
			{72 to: 84}
		evaluating: [ receiver1 selectedEvent ]
		thatSends: #selectedEvent
		to: receiver1 ] value.
	#_coverageTracker173028847_
		coverAll:
			{86 to: 91}
		evaluating: [ receiver2 notNil ]
		thatSends: #notNil
		to: receiver2 ] value.
	#_coverageTracker173028847_
		coverAll:
			{93 to: 96}
		evaluating: [
			receiver6 and: [
				[ | receiver5 |
				receiver5 _ [ | receiver4 |
				receiver4 _ [ | receiver3 |
				receiver3 _ #_coverageTracker173028847_
					coverAll:
						{100 to: 103}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028847_
					coverAll:
						{105 to: 117}
					evaluating: [ receiver3 selectedEvent ]
					thatSends: #selectedEvent
					to: receiver3 ] value.
				#_coverageTracker173028847_
					coverAll:
						{119 to: 122}
					evaluating: [ receiver4 type ]
					thatSends: #type
					to: receiver4 ] value.
				#_coverageTracker173028847_
					coverAll:
						{124 to: 124}
					evaluating: [
						receiver5 =
							(#_coverageTracker173028847_
								coverAll:
									{126 to: 132}
								byLiteralOrPseudoVariable: #change) ]
					thatSends: #=
					to: receiver5 ] value ]]
		thatSends: #and:
		to: receiver6 ] value.
	#_coverageTracker173028847_
		coverAll:
			{140 to: 146}
		evaluating: [
			receiver12 ifTrue: [
				#_coverageTracker173028847_
					cover: (154 to: 164)
					declaredAt: (48 to: 58)
					by:
						(changeClass _ [ | receiver9 |
						receiver9 _ [ | receiver8 |
						receiver8 _ [ | receiver7 |
						receiver7 _ #_coverageTracker173028847_
							coverAll:
								{169 to: 172}
							byLiteralOrPseudoVariable: self.
						#_coverageTracker173028847_
							coverAll:
								{174 to: 186}
							evaluating: [ receiver7 selectedEvent ]
							thatSends: #selectedEvent
							to: receiver7 ] value.
						#_coverageTracker173028847_
							coverAll:
								{188 to: 193}
							evaluating: [ receiver8 change ]
							thatSends: #change
							to: receiver8 ] value.
						#_coverageTracker173028847_
							coverAll:
								{195 to: 205}
							evaluating: [ receiver9 changeClass ]
							thatSends: #changeClass
							to: receiver9 ] value).
				[ | receiver11 |
				receiver11 _ #_coverageTracker173028847_
					cover: (211 to: 221)
					declaredAt: (48 to: 58)
					by: changeClass.
				#_coverageTracker173028847_
					coverAll:
						{223 to: 231}
					evaluating: [
						receiver11 ifNotNil: [
							[ | receiver10 |
							receiver10 _ #_coverageTracker173028847_
								cover: (240 to: 256)
								declaredAt: (26 to: 42)
								by: aSHTextStylerST80.
							#_coverageTracker173028847_
								coverAll:
									{258 to: 274}
								evaluating: [
									receiver10 classOrMetaClass:
										(#_coverageTracker173028847_
											cover: (276 to: 286)
											declaredAt: (48 to: 58)
											by: changeClass) ]
								thatSends: #classOrMetaClass:
								to: receiver10 ] value.
							^ #_coverageTracker173028847_
								coverAll:
									{296 to: 299}
								byLiteralOrPseudoVariable: true ]]
					thatSends: #ifNotNil:
					to: receiver11 ] value ]]
		thatSends: #ifTrue:
		to: receiver12 ] value.
	^ #_coverageTracker173028847_
		coverAll:
			{310 to: 314}
		byLiteralOrPseudoVariable: false.! !
!Behavior method!
reportError: aString
	#_coverageTracker173028868_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028868_
		cover: (24 to: 30)
		declaredAt: (24 to: 30)
		by: context.
	#_coverageTracker173028868_
		coverAll:
			{32 to: 43}
		evaluating: [
			receiver1 reportError:
				(#_coverageTracker173028868_
					cover: (45 to: 51)
					declaredAt: (14 to: 20)
					by: aString) ]
		thatSends: #reportError:
		to: receiver1 ] value.! !
!Behavior method!
initialize
	#_coverageTracker173028871_ markAsExecuted.
	#_coverageTracker173028871_
		cover: (13 to: 23)
		declaredAt: (13 to: 23)
		by:
			(testClasses _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028871_
				coverAll:
					{28 to: 30}
				by: Set.
			#_coverageTracker173028871_
				coverAll:
					{32 to: 34}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	#_coverageTracker173028871_
		cover: (38 to: 42)
		declaredAt: (38 to: 42)
		by:
			(tests _ [ | receiver2 |
			receiver2 _ #_coverageTracker173028871_
				coverAll:
					{47 to: 49}
				by: Set.
			#_coverageTracker173028871_
				coverAll:
					{51 to: 53}
				evaluating: [ receiver2 new ]
				thatSends: #new
				to: receiver2 ] value).! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173028876_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028876_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173028876_
		coverAll:
			{34 to: 51}
		evaluating: [
			receiver2 modelClassRemoved:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028876_
					cover: (53 to: 64)
					declaredAt: (53 to: 64)
					by: changeRecord.
				#_coverageTracker173028876_
					coverAll:
						{66 to: 80}
					evaluating: [ receiver1 changeClassName ]
					thatSends: #changeClassName
					to: receiver1 ] value ]
		thatSends: #modelClassRemoved:
		to: receiver2 ] value.! !
!Behavior method!
detectChangeIn: aChangeList ifTrue: aBlock
	| changeRecordsToInspect |
	#_coverageTracker173028880_ markAsExecuted.
	#_coverageTracker173028880_
		cover: (74 to: 95)
		declaredAt: (47 to: 68)
		by:
			(changeRecordsToInspect _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028880_
				coverAll:
					{100 to: 103}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173028880_
				coverAll:
					{105 to: 125}
				evaluating: [
					receiver1 lookaheadRecordsFrom:
						(#_coverageTracker173028880_
							cover: (127 to: 137)
							declaredAt: (17 to: 27)
							by: aChangeList) ]
				thatSends: #lookaheadRecordsFrom:
				to: receiver1 ] value).
	[ | receiver6 |
	receiver6 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028880_
		coverAll:
			{144 to: 147}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028880_
		coverAll:
			{149 to: 164}
		evaluating: [
			receiver2 canBeDetectedIn:
				(#_coverageTracker173028880_
					cover: (166 to: 187)
					declaredAt: (47 to: 68)
					by: changeRecordsToInspect) ]
		thatSends: #canBeDetectedIn:
		to: receiver2 ] value.
	#_coverageTracker173028880_
		coverAll:
			{193 to: 199}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver3 |
				receiver3 _ #_coverageTracker173028880_
					cover: (207 to: 217)
					declaredAt: (17 to: 27)
					by: aChangeList.
				#_coverageTracker173028880_
					coverAll:
						{219 to: 228}
					evaluating: [
						receiver3 removeAll:
							(#_coverageTracker173028880_
								cover: (230 to: 251)
								declaredAt: (47 to: 68)
								by: changeRecordsToInspect) ]
					thatSends: #removeAll:
					to: receiver3 ] value.
				[ | receiver5 |
				receiver5 _ #_coverageTracker173028880_
					cover: (257 to: 262)
					declaredAt: (37 to: 42)
					by: aBlock.
				#_coverageTracker173028880_
					coverAll:
						{264 to: 269}
					evaluating: [
						receiver5 value:
							[ | receiver4 |
							receiver4 _ #_coverageTracker173028880_
								coverAll:
									{272 to: 275}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173028880_
								coverAll:
									{277 to: 290}
								evaluating: [
									receiver4 newChangeFrom:
										(#_coverageTracker173028880_
											cover: (292 to: 313)
											declaredAt: (47 to: 68)
											by: changeRecordsToInspect) ]
								thatSends: #newChangeFrom:
								to: receiver4 ] value ]
					thatSends: #value:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.! !
!Behavior method!
classCategoryOfTestData
	#_coverageTracker173028892_ markAsExecuted.
	^ #_coverageTracker173028892_
		coverAll:
			{29 to: 50}
		byLiteralOrPseudoVariable: '__TDDGuru-TestData__'.! !
!Behavior method!
changeClass
	#_coverageTracker173028894_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028894_
		cover: (16 to: 34)
		declaredAt: (16 to: 34)
		by: newTestChangeRecord.
	#_coverageTracker173028894_
		coverAll:
			{36 to: 46}
		evaluating: [ receiver1 changeClass ]
		thatSends: #changeClass
		to: receiver1 ] value.! !
!Behavior method!
category
	#_coverageTracker173028896_ markAsExecuted.
	^ #_coverageTracker173028896_
		coverAll:
			{13 to: 20}
		byLiteralOrPseudoVariable: #newTest.! !
!Behavior method!
transitionTo: aTDDState
	#_coverageTracker173028899_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173028899_
		coverAll:
			{26 to: 29}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028899_
		coverAll:
			{31 to: 56}
		evaluating: [ receiver1 checkIfItWasAValidRefactor ]
		thatSends: #checkIfItWasAValidRefactor
		to: receiver1 ] value.
	#_coverageTracker173028899_
		coverAll:
			{66 to: 78}
		evaluating: [
			super transitionTo:
				(#_coverageTracker173028899_
					cover: (80 to: 88)
					declaredAt: (15 to: 23)
					by: aTDDState) ]
		thatSends: #transitionTo:
		to: super.! !
!Behavior method!
description
	#_coverageTracker173028903_ markAsExecuted.
	^ [ | receiver8 |
	receiver8 _ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028903_
		coverAll:
			{16 to: 39}
		byLiteralOrPseudoVariable: 'Test was renamed from '.
	#_coverageTracker173028903_
		coverAll:
			{40 to: 40}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028903_
					coverAll:
						{42 to: 45}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028903_
					coverAll:
						{47 to: 50}
					evaluating: [ receiver1 from ]
					thatSends: #from
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173028903_
		coverAll:
			{51 to: 51}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173028903_
					coverAll:
						{53 to: 58}
					byLiteralOrPseudoVariable: ' to ') ]
		thatSends: #,
		to: receiver3 ] value.
	#_coverageTracker173028903_
		coverAll:
			{59 to: 59}
		evaluating: [
			receiver5 ,
				[ | receiver4 |
				receiver4 _ #_coverageTracker173028903_
					coverAll:
						{61 to: 64}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028903_
					coverAll:
						{66 to: 67}
					evaluating: [ receiver4 to ]
					thatSends: #to
					to: receiver4 ] value ]
		thatSends: #,
		to: receiver5 ] value.
	#_coverageTracker173028903_
		coverAll:
			{68 to: 68}
		evaluating: [
			receiver6 ,
				(#_coverageTracker173028903_
					coverAll:
						{70 to: 75}
					byLiteralOrPseudoVariable: ' in ') ]
		thatSends: #,
		to: receiver6 ] value.
	#_coverageTracker173028903_
		coverAll:
			{76 to: 76}
		evaluating: [
			receiver8 ,
				[ | receiver7 |
				receiver7 _ #_coverageTracker173028903_
					coverAll:
						{78 to: 81}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028903_
					coverAll:
						{83 to: 97}
					evaluating: [ receiver7 changeClassName ]
					thatSends: #changeClassName
					to: receiver7 ] value ]
		thatSends: #,
		to: receiver8 ] value.! !
!Behavior method!
category
	#_coverageTracker173028909_ markAsExecuted.
	^ #_coverageTracker173028909_
		coverAll:
			{13 to: 31}
		byLiteralOrPseudoVariable: #modelMethodChanged.! !
!Behavior method!
printString
	#_coverageTracker173028912_ markAsExecuted.
	^ #_coverageTracker173028912_
		coverAll:
			{16 to: 68}
		byLiteralOrPseudoVariable: 'Writing a failing test - More than one test written'.! !
!Behavior method!
isOneOfTheCurrentTests: aMethodReference
	#_coverageTracker173028915_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028915_
		cover: (46 to: 54)
		declaredAt: (46 to: 54)
		by: firstTest.
	#_coverageTracker173028915_
		coverAll:
			{56 to: 56}
		evaluating: [
			receiver1 =
				(#_coverageTracker173028915_
					cover: (58 to: 73)
					declaredAt: (25 to: 40)
					by: aMethodReference) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173028915_
		coverAll:
			{75 to: 77}
		evaluating: [
			receiver3 or: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173028915_
					cover: (81 to: 90)
					declaredAt: (81 to: 90)
					by: secondTest.
				#_coverageTracker173028915_
					coverAll:
						{93 to: 93}
					evaluating: [
						receiver2 =
							(#_coverageTracker173028915_
								cover: (95 to: 110)
								declaredAt: (25 to: 40)
								by: aMethodReference) ]
					thatSends: #=
					to: receiver2 ] value ]]
		thatSends: #or:
		to: receiver3 ] value.! !
!Behavior method!
methodReference
	#_coverageTracker173028922_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ #_coverageTracker173028922_
		coverAll:
			{20 to: 45}
		by: UninstalledMethodReference.
	#_coverageTracker173028922_
		coverAll:
			{47 to: 55. 77 to: 82. 105 to: 115. 127 to: 136}
		evaluating: [
			receiver5
				selector:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173028922_
						coverAll:
							{57 to: 60}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028922_
						coverAll:
							{62 to: 75}
						evaluating: [ receiver1 methodSelector ]
						thatSends: #methodSelector
						to: receiver1 ] value
				class:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173028922_
						coverAll:
							{84 to: 87}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028922_
						coverAll:
							{89 to: 103}
						evaluating: [ receiver2 changeClassName ]
						thatSends: #changeClassName
						to: receiver2 ] value
				sourceCode:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173028922_
						coverAll:
							{117 to: 120}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028922_
						coverAll:
							{122 to: 125}
						evaluating: [ receiver3 code ]
						thatSends: #code
						to: receiver3 ] value
				overrides:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173028922_
						coverAll:
							{138 to: 141}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028922_
						coverAll:
							{143 to: 168}
						evaluating: [ receiver4 overridesASuperclassMethod ]
						thatSends: #overridesASuperclassMethod
						to: receiver4 ] value ]
		thatSends: #selector:class:sourceCode:overrides:
		to: receiver5 ] value.! !
!Behavior method!
buildMorphicWindow
	| listPane |
	#_coverageTracker173028929_ markAsExecuted.
	#_coverageTracker173028929_
		cover: (35 to: 42)
		declaredAt: (23 to: 30)
		by:
			(listPane _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028929_
				coverAll:
					{46 to: 63}
				by: PluggableListMorph.
			#_coverageTracker173028929_
				coverAll:
					{68 to: 73. 83 to: 93. 103 to: 114. 129 to: 140. 162 to: 170. 179 to: 189. 203 to: 218}
				evaluating: [
					receiver1
						model:
							(#_coverageTracker173028929_
								cover: (75 to: 79)
								declaredAt: (75 to: 79)
								by: model)
						listGetter:
							(#_coverageTracker173028929_
								coverAll:
									{95 to: 99}
								byLiteralOrPseudoVariable: #list)
						indexGetter:
							(#_coverageTracker173028929_
								coverAll:
									{116 to: 125}
								byLiteralOrPseudoVariable: #listIndex)
						indexSetter:
							(#_coverageTracker173028929_
								coverAll:
									{142 to: 158}
								byLiteralOrPseudoVariable: #toggleListIndex:)
						mainView:
							(#_coverageTracker173028929_
								coverAll:
									{172 to: 175}
								byLiteralOrPseudoVariable: self)
						menuGetter:
							(#_coverageTracker173028929_
								coverAll:
									{191 to: 199}
								byLiteralOrPseudoVariable: #listMenu)
						keystrokeAction:
							(#_coverageTracker173028929_
								coverAll:
									{220 to: 239}
								byLiteralOrPseudoVariable: #changeListKey:from:) ]
				thatSends: #model:listGetter:indexGetter:indexSetter:mainView:menuGetter:keystrokeAction:
				to: receiver1 ] value).
	[ | cascadeReceiver |
	cascadeReceiver _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028929_
		coverAll:
			{245 to: 248}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028929_
		coverAll:
			{250 to: 260}
		evaluating: [ receiver2 layoutMorph ]
		thatSends: #layoutMorph
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173028929_
		coverAll:
			{264 to: 272. 283 to: 301}
		evaluating: [
			receiver3
				addMorph:
					(#_coverageTracker173028929_
						cover: (274 to: 281)
						declaredAt: (23 to: 30)
						by: listPane)
				proportionalHeight:
					(#_coverageTracker173028929_
						coverAll:
							{303 to: 305}
						byLiteralOrPseudoVariable: 0.4) ]
		thatSends: #addMorph:proportionalHeight:
		to: receiver3 ] value.
	[ | receiver5 |
	receiver5 _ cascadeReceiver.
	#_coverageTracker173028929_
		coverAll:
			{310 to: 329. 352 to: 370}
		evaluating: [
			receiver5
				addAdjusterAndMorph:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173028929_
						coverAll:
							{331 to: 334}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173028929_
						coverAll:
							{336 to: 350}
						evaluating: [ receiver4 buildLowerPanes ]
						thatSends: #buildLowerPanes
						to: receiver4 ] value
				proportionalHeight:
					(#_coverageTracker173028929_
						coverAll:
							{372 to: 374}
						byLiteralOrPseudoVariable: 0.6) ]
		thatSends: #addAdjusterAndMorph:proportionalHeight:
		to: receiver5 ] value ] value.! !
!Behavior method!
tearDown
	#_coverageTracker173028944_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028944_
		coverAll:
			{13 to: 16}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028944_
		coverAll:
			{18 to: 36}
		evaluating: [ receiver1 changesFileForTests ]
		thatSends: #changesFileForTests
		to: receiver1 ] value.
	#_coverageTracker173028944_
		coverAll:
			{38 to: 48}
		evaluating: [ receiver2 asFileEntry ]
		thatSends: #asFileEntry
		to: receiver2 ] value.
	#_coverageTracker173028944_
		coverAll:
			{50 to: 55}
		evaluating: [ receiver3 delete ]
		thatSends: #delete
		to: receiver3 ] value.
	[ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173028944_
		coverAll:
			{59 to: 62}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028944_
		coverAll:
			{64 to: 92}
		evaluating: [ receiver4 tddGuruTestDefaultChangesFile ]
		thatSends: #tddGuruTestDefaultChangesFile
		to: receiver4 ] value.
	#_coverageTracker173028944_
		coverAll:
			{94 to: 104}
		evaluating: [ receiver5 asFileEntry ]
		thatSends: #asFileEntry
		to: receiver5 ] value.
	#_coverageTracker173028944_
		coverAll:
			{106 to: 111}
		evaluating: [ receiver6 delete ]
		thatSends: #delete
		to: receiver6 ] value.
	[ | receiver8 |
	receiver8 _ #_coverageTracker173028944_
		coverAll:
			{115 to: 132}
		by: SystemOrganization.
	#_coverageTracker173028944_
		coverAll:
			{134 to: 154}
		evaluating: [
			receiver8 removeSystemCategory:
				[ | receiver7 |
				receiver7 _ #_coverageTracker173028944_
					coverAll:
						{156 to: 159}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028944_
					coverAll:
						{161 to: 183}
					evaluating: [ receiver7 classCategoryOfTestData ]
					thatSends: #classCategoryOfTestData
					to: receiver7 ] value ]
		thatSends: #removeSystemCategory:
		to: receiver8 ] value.
	[ | receiver9 |
	receiver9 _ #_coverageTracker173028944_
		coverAll:
			{187 to: 197}
		by: Preferences.
	#_coverageTracker173028944_
		coverAll:
			{199 to: 201. 233 to: 236}
		evaluating: [
			receiver9
				at:
					(#_coverageTracker173028944_
						coverAll:
							{203 to: 231}
						byLiteralOrPseudoVariable: #userChangesFileNameExtension)
				put:
					(#_coverageTracker173028944_
						cover: (238 to: 265)
						declaredAt: (238 to: 265)
						by: previousUserChangesExtension) ]
		thatSends: #at:put:
		to: receiver9 ] value.! !
!Behavior method!
testChanged: aTestReference
	#_coverageTracker173028954_ markAsExecuted.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173028956_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173028956_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173028956_
		coverAll:
			{34 to: 46}
		evaluating: [
			receiver2 newTestClass:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028956_
					coverAll:
						{48 to: 51}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173028956_
					coverAll:
						{53 to: 67}
					evaluating: [ receiver1 changeClassName ]
					thatSends: #changeClassName
					to: receiver1 ] value ]
		thatSends: #newTestClass:
		to: receiver2 ] value.! !
!Behavior method!
eventBefore: anEvent
	#_coverageTracker173028960_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028960_
		coverAll:
			{27 to: 30}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173028960_
		coverAll:
			{32 to: 46}
		evaluating: [
			receiver2 eventsWithType:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173028960_
					cover: (48 to: 54)
					declaredAt: (14 to: 20)
					by: anEvent.
				#_coverageTracker173028960_
					coverAll:
						{56 to: 59}
					evaluating: [ receiver1 type ]
					thatSends: #type
					to: receiver1 ] value ]
		thatSends: #eventsWithType:
		to: receiver2 ] value.
	#_coverageTracker173028960_
		coverAll:
			{62 to: 68. 78 to: 84}
		evaluating: [
			receiver3
				before:
					(#_coverageTracker173028960_
						cover: (70 to: 76)
						declaredAt: (14 to: 20)
						by: anEvent)
				ifNone: [ ^ #_coverageTracker173028960_
						coverAll:
							{90 to: 92}
						byLiteralOrPseudoVariable: nil ]]
		thatSends: #before:ifNone:
		to: receiver3 ] value.! !
!Behavior method!
category
	#_coverageTracker173028965_ markAsExecuted.
	^ #_coverageTracker173028965_
		coverAll:
			{13 to: 25}
		byLiteralOrPseudoVariable: #classRenamed.! !
!Behavior method!
stamp
	#_coverageTracker173028966_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173028966_
		cover: (10 to: 28)
		declaredAt: (10 to: 28)
		by: newTestChangeRecord.
	#_coverageTracker173028966_
		coverAll:
			{30 to: 34}
		evaluating: [ receiver1 stamp ]
		thatSends: #stamp
		to: receiver1 ] value.! !
!Behavior method!
newChangeFrom: changeRecords
	#_coverageTracker173028973_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173028973_
		cover: (32 to: 44)
		declaredAt: (16 to: 28)
		by: changeRecords.
	#_coverageTracker173028973_
		coverAll:
			{46 to: 49}
		evaluating: [ receiver1 size ]
		thatSends: #size
		to: receiver1 ] value.
	#_coverageTracker173028973_
		coverAll:
			{51 to: 51}
		evaluating: [
			receiver2 =
				(#_coverageTracker173028973_
					coverAll:
						{53 to: 53}
					byLiteralOrPseudoVariable: 1) ]
		thatSends: #=
		to: receiver2 ] value.
	#_coverageTracker173028973_
		coverAll:
			{56 to: 62}
		evaluating: [ receiver5 ifTrue: [ ^ [ | receiver4 |
				receiver4 _ #_coverageTracker173028973_
					cover: (68 to: 78)
					declaredAt: (68 to: 78)
					by: changeClass.
				#_coverageTracker173028973_
					coverAll:
						{80 to: 86}
					evaluating: [
						receiver4 newFor:
							[ | receiver3 |
							receiver3 _ #_coverageTracker173028973_
								cover: (88 to: 100)
								declaredAt: (16 to: 28)
								by: changeRecords.
							#_coverageTracker173028973_
								coverAll:
									{102 to: 106}
								evaluating: [ receiver3 first ]
								thatSends: #first
								to: receiver3 ] value ]
					thatSends: #newFor:
					to: receiver4 ] value ]]
		thatSends: #ifTrue:
		to: receiver5 ] value.
	[ | receiver11 |
	receiver11 _ [ | receiver7 |
	receiver7 _ [ | receiver6 |
	receiver6 _ #_coverageTracker173028973_
		cover: (113 to: 125)
		declaredAt: (16 to: 28)
		by: changeRecords.
	#_coverageTracker173028973_
		coverAll:
			{127 to: 130}
		evaluating: [ receiver6 size ]
		thatSends: #size
		to: receiver6 ] value.
	#_coverageTracker173028973_
		coverAll:
			{132 to: 132}
		evaluating: [
			receiver7 =
				(#_coverageTracker173028973_
					coverAll:
						{134 to: 134}
					byLiteralOrPseudoVariable: 2) ]
		thatSends: #=
		to: receiver7 ] value.
	#_coverageTracker173028973_
		coverAll:
			{137 to: 143}
		evaluating: [ receiver11 ifTrue: [ ^ [ | receiver10 |
				receiver10 _ #_coverageTracker173028973_
					cover: (149 to: 159)
					declaredAt: (68 to: 78)
					by: changeClass.
				#_coverageTracker173028973_
					coverAll:
						{161 to: 167. 189 to: 192}
					evaluating: [
						receiver10
							newFor:
								[ | receiver8 |
								receiver8 _ #_coverageTracker173028973_
									cover: (169 to: 181)
									declaredAt: (16 to: 28)
									by: changeRecords.
								#_coverageTracker173028973_
									coverAll:
										{183 to: 187}
									evaluating: [ receiver8 first ]
									thatSends: #first
									to: receiver8 ] value
							and:
								[ | receiver9 |
								receiver9 _ #_coverageTracker173028973_
									cover: (194 to: 206)
									declaredAt: (16 to: 28)
									by: changeRecords.
								#_coverageTracker173028973_
									coverAll:
										{208 to: 213}
									evaluating: [ receiver9 second ]
									thatSends: #second
									to: receiver9 ] value ]
					thatSends: #newFor:and:
					to: receiver10 ] value ]]
		thatSends: #ifTrue:
		to: receiver11 ] value.! !
!Behavior method!
pickStartPositionFromSnapshots: userChangesFileName
	"Prompt with a menu of how far back to go when browsing a changes file."
	| banners positions pos chunk i startPosition |
	#_coverageTracker173028990_ markAsExecuted.
	#_coverageTracker173028990_
		cover: (183 to: 195)
		declaredAt: (164 to: 176)
		by:
			(startPosition _ [ | receiver1 |
			receiver1 _ #_coverageTracker173028990_
				coverAll:
					{200 to: 203}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173028990_
				coverAll:
					{205 to: 225}
				evaluating: [
					receiver1 lastSnapshotPosition:
						(#_coverageTracker173028990_
							cover: (227 to: 245)
							declaredAt: (33 to: 51)
							by: userChangesFileName) ]
				thatSends: #lastSnapshotPosition:
				to: receiver1 ] value).
	[ | receiver23 |
	receiver23 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173028990_
		cover: (249 to: 267)
		declaredAt: (33 to: 51)
		by: userChangesFileName.
	#_coverageTracker173028990_
		coverAll:
			{269 to: 279}
		evaluating: [ receiver2 asFileEntry ]
		thatSends: #asFileEntry
		to: receiver2 ] value.
	#_coverageTracker173028990_
		coverAll:
			{281 to: 293}
		evaluating: [
			receiver23 readStreamDo: [ :changesFile |
				#_coverageTracker173028990_
					cover: (314 to: 320)
					declaredAt: (134 to: 140)
					by:
						(banners _ [ | receiver3 |
						receiver3 _ #_coverageTracker173028990_
							coverAll:
								{324 to: 340}
							by: OrderedCollection.
						#_coverageTracker173028990_
							coverAll:
								{342 to: 344}
							evaluating: [ receiver3 new ]
							thatSends: #new
							to: receiver3 ] value).
				#_coverageTracker173028990_
					cover: (349 to: 357)
					declaredAt: (142 to: 150)
					by:
						(positions _ [ | receiver4 |
						receiver4 _ #_coverageTracker173028990_
							coverAll:
								{361 to: 377}
							by: OrderedCollection.
						#_coverageTracker173028990_
							coverAll:
								{379 to: 381}
							evaluating: [ receiver4 new ]
							thatSends: #new
							to: receiver4 ] value).
				#_coverageTracker173028990_
					cover: (386 to: 388)
					declaredAt: (152 to: 154)
					by:
						(pos _ #_coverageTracker173028990_
							cover: (392 to: 404)
							declaredAt: (164 to: 176)
							by: startPosition).
				[ | receiver22 |
				receiver22 _ [
				[ | receiver8 |
				receiver8 _ [ | receiver5 |
				receiver5 _ #_coverageTracker173028990_
					cover: (410 to: 412)
					declaredAt: (152 to: 154)
					by: pos.
				#_coverageTracker173028990_
					coverAll:
						{414 to: 414}
					evaluating: [
						receiver5 =
							(#_coverageTracker173028990_
								coverAll:
									{416 to: 416}
								byLiteralOrPseudoVariable: 0) ]
					thatSends: #=
					to: receiver5 ] value.
				#_coverageTracker173028990_
					coverAll:
						{421 to: 423}
					evaluating: [
						receiver8 or: [
							[ | receiver7 |
							receiver7 _ [ | receiver6 |
							receiver6 _ #_coverageTracker173028990_
								cover: (426 to: 432)
								declaredAt: (134 to: 140)
								by: banners.
							#_coverageTracker173028990_
								coverAll:
									{434 to: 437}
								evaluating: [ receiver6 size ]
								thatSends: #size
								to: receiver6 ] value.
							#_coverageTracker173028990_
								coverAll:
									{439 to: 439}
								evaluating: [
									receiver7 >
										(#_coverageTracker173028990_
											coverAll:
												{441 to: 442}
											byLiteralOrPseudoVariable: 20) ]
								thatSends: #>
								to: receiver7 ] value ]
						"Go back at most 20 image exits" ]
					thatSends: #or:
					to: receiver8 ] value ].
				#_coverageTracker173028990_
					coverAll:
						{484 to: 494}
					evaluating: [
						receiver22 whileFalse: [
							[ | receiver9 |
							receiver9 _ #_coverageTracker173028990_
								cover: (502 to: 512)
								declaredAt: (298 to: 308)
								by: changesFile.
							#_coverageTracker173028990_
								coverAll:
									{514 to: 522}
								evaluating: [
									receiver9 position:
										(#_coverageTracker173028990_
											cover: (524 to: 526)
											declaredAt: (152 to: 154)
											by: pos) ]
								thatSends: #position:
								to: receiver9 ] value.
							#_coverageTracker173028990_
								cover: (533 to: 537)
								declaredAt: (156 to: 160)
								by:
									(chunk _ [ | receiver10 |
									receiver10 _ #_coverageTracker173028990_
										cover: (541 to: 551)
										declaredAt: (298 to: 308)
										by: changesFile.
									#_coverageTracker173028990_
										coverAll:
											{553 to: 561}
										evaluating: [ receiver10 nextChunk ]
										thatSends: #nextChunk
										to: receiver10 ] value).
							#_coverageTracker173028990_
								cover: (568 to: 568)
								declaredAt: (162 to: 162)
								by:
									(i _ [ | receiver11 |
									receiver11 _ #_coverageTracker173028990_
										cover: (572 to: 576)
										declaredAt: (156 to: 160)
										by: chunk.
									#_coverageTracker173028990_
										coverAll:
											{578 to: 598. 616 to: 626}
										evaluating: [
											receiver11
												indexOfSubCollection:
													(#_coverageTracker173028990_
														coverAll:
															{600 to: 614}
														byLiteralOrPseudoVariable: 'priorSource: ')
												startingAt:
													(#_coverageTracker173028990_
														coverAll:
															{628 to: 628}
														byLiteralOrPseudoVariable: 1) ]
										thatSends: #indexOfSubCollection:startingAt:
										to: receiver11 ] value).
							[ | receiver21 |
							receiver21 _ [ | receiver12 |
							receiver12 _ #_coverageTracker173028990_
								cover: (635 to: 635)
								declaredAt: (162 to: 162)
								by: i.
							#_coverageTracker173028990_
								coverAll:
									{637 to: 637}
								evaluating: [
									receiver12 >
										(#_coverageTracker173028990_
											coverAll:
												{639 to: 639}
											byLiteralOrPseudoVariable: 0) ]
								thatSends: #>
								to: receiver12 ] value.
							#_coverageTracker173028990_
								coverAll:
									{646 to: 652. 815 to: 822}
								evaluating: [
									receiver21
										ifTrue: [
											[ | receiver13 |
											receiver13 _ #_coverageTracker173028990_
												cover: (662 to: 670)
												declaredAt: (142 to: 150)
												by: positions.
											#_coverageTracker173028990_
												coverAll:
													{672 to: 679}
												evaluating: [
													receiver13 addLast:
														(#_coverageTracker173028990_
															cover: (681 to: 683)
															declaredAt: (152 to: 154)
															by: pos) ]
												thatSends: #addLast:
												to: receiver13 ] value.
											[ | receiver16 |
											receiver16 _ #_coverageTracker173028990_
												cover: (692 to: 698)
												declaredAt: (134 to: 140)
												by: banners.
											#_coverageTracker173028990_
												coverAll:
													{700 to: 707}
												evaluating: [
													receiver16 addLast:
														[ | receiver15 |
														receiver15 _ #_coverageTracker173028990_
															cover: (710 to: 714)
															declaredAt: (156 to: 160)
															by: chunk.
														#_coverageTracker173028990_
															coverAll:
																{716 to: 724. 728 to: 730}
															evaluating: [
																receiver15
																	copyFrom:
																		(#_coverageTracker173028990_
																			coverAll:
																				{726 to: 726}
																			byLiteralOrPseudoVariable: 5)
																	to:
																		[ | receiver14 |
																		receiver14 _ #_coverageTracker173028990_
																			cover: (732 to: 732)
																			declaredAt: (162 to: 162)
																			by: i.
																		#_coverageTracker173028990_
																			coverAll:
																				{734 to: 734}
																			evaluating: [
																				receiver14 -
																					(#_coverageTracker173028990_
																						coverAll:
																							{736 to: 736}
																						byLiteralOrPseudoVariable: 2) ]
																			thatSends: #-
																			to: receiver14 ] value ]
															thatSends: #copyFrom:to:
															to: receiver15 ] value ]
												thatSends: #addLast:
												to: receiver16 ] value.
											#_coverageTracker173028990_
												cover: (746 to: 748)
												declaredAt: (152 to: 154)
												by:
													(pos _ [ | receiver20 |
													receiver20 _ #_coverageTracker173028990_
														coverAll:
															{752 to: 757}
														by: Number.
													#_coverageTracker173028990_
														coverAll:
															{759 to: 767}
														evaluating: [
															receiver20 readFrom:
																[ | receiver19 |
																receiver19 _ #_coverageTracker173028990_
																	cover: (770 to: 774)
																	declaredAt: (156 to: 160)
																	by: chunk.
																#_coverageTracker173028990_
																	coverAll:
																		{776 to: 784. 793 to: 795}
																	evaluating: [
																		receiver19
																			copyFrom:
																				[ | receiver17 |
																				receiver17 _ #_coverageTracker173028990_
																					cover: (786 to: 786)
																					declaredAt: (162 to: 162)
																					by: i.
																				#_coverageTracker173028990_
																					coverAll:
																						{788 to: 788}
																					evaluating: [
																						receiver17 +
																							(#_coverageTracker173028990_
																								coverAll:
																									{790 to: 791}
																								byLiteralOrPseudoVariable: 13) ]
																					thatSends: #+
																					to: receiver17 ] value
																			to:
																				[ | receiver18 |
																				receiver18 _ #_coverageTracker173028990_
																					cover: (797 to: 801)
																					declaredAt: (156 to: 160)
																					by: chunk.
																				#_coverageTracker173028990_
																					coverAll:
																						{803 to: 806}
																					evaluating: [ receiver18 size ]
																					thatSends: #size
																					to: receiver18 ] value ]
																	thatSends: #copyFrom:to:
																	to: receiver19 ] value ]
														thatSends: #readFrom:
														to: receiver20 ] value) ]
										ifFalse: [
											#_coverageTracker173028990_
												cover: (832 to: 834)
												declaredAt: (152 to: 154)
												by:
													(pos _ #_coverageTracker173028990_
														coverAll:
															{838 to: 838}
														byLiteralOrPseudoVariable: 0) ]]
								thatSends: #ifTrue:ifFalse:
								to: receiver21 ] value ]]
					thatSends: #whileFalse:
					to: receiver22 ] value ]]
		thatSends: #readStreamDo:
		to: receiver23 ] value.
	[ | receiver24 |
	receiver24 _ #_coverageTracker173028990_
		cover: (848 to: 856)
		declaredAt: (142 to: 150)
		by: positions.
	#_coverageTracker173028990_
		coverAll:
			{858 to: 865}
		evaluating: [
			receiver24 addLast:
				(#_coverageTracker173028990_
					coverAll:
						{867 to: 867}
					byLiteralOrPseudoVariable: 0) ]
		thatSends: #addLast:
		to: receiver24 ] value.
	[ | receiver25 |
	receiver25 _ #_coverageTracker173028990_
		cover: (871 to: 877)
		declaredAt: (134 to: 140)
		by: banners.
	#_coverageTracker173028990_
		coverAll:
			{879 to: 886}
		evaluating: [
			receiver25 addLast:
				(#_coverageTracker173028990_
					coverAll:
						{888 to: 899}
					byLiteralOrPseudoVariable: 'Whole file') ]
		thatSends: #addLast:
		to: receiver25 ] value.
	^ [ | receiver27 |
	receiver27 _ [ | receiver26 |
	receiver26 _ #_coverageTracker173028990_
		coverAll:
			{906 to: 918}
		by: SelectionMenu.
	#_coverageTracker173028990_
		coverAll:
			{920 to: 929. 939 to: 949}
		evaluating: [
			receiver26
				labelList:
					(#_coverageTracker173028990_
						cover: (931 to: 937)
						declaredAt: (134 to: 140)
						by: banners)
				selections:
					(#_coverageTracker173028990_
						cover: (951 to: 959)
						declaredAt: (142 to: 150)
						by: positions) ]
		thatSends: #labelList:selections:
		to: receiver26 ] value.
	#_coverageTracker173028990_
		coverAll:
			{966 to: 984}
		evaluating: [
			receiver27 startUpWithCaption:
				(#_coverageTracker173028990_
					coverAll:
						{986 to: 1011}
					byLiteralOrPseudoVariable: 'Browse as far back as...') ]
		thatSends: #startUpWithCaption:
		to: receiver27 ] value.! !
!Behavior method!
code
	#_coverageTracker173029065_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029065_
		cover: (11 to: 22)
		declaredAt: (11 to: 22)
		by: changeRecord.
	#_coverageTracker173029065_
		coverAll:
			{24 to: 29}
		evaluating: [ receiver1 string ]
		thatSends: #string
		to: receiver1 ] value.! !
!Behavior method!
from: previousTDDState to: currentTDDState in: aTimeline
	#_coverageTracker173029068_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029068_
		coverAll:
			{61 to: 64}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029068_
		coverAll:
			{66 to: 68}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029068_
		coverAll:
			{73 to: 77}
		evaluating: [
			receiver2 from:
				(#_coverageTracker173029068_
					cover: (79 to: 94)
					declaredAt: (7 to: 22)
					by: previousTDDState) ]
		thatSends: #from:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173029068_
		coverAll:
			{100 to: 102}
		evaluating: [
			receiver3 to:
				(#_coverageTracker173029068_
					cover: (104 to: 118)
					declaredAt: (28 to: 42)
					by: currentTDDState) ]
		thatSends: #to:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ cascadeReceiver.
	#_coverageTracker173029068_
		coverAll:
			{123 to: 131}
		evaluating: [
			receiver4 timeline:
				(#_coverageTracker173029068_
					cover: (133 to: 141)
					declaredAt: (48 to: 56)
					by: aTimeline) ]
		thatSends: #timeline:
		to: receiver4 ] value ] value.! !
!Behavior method!
initialize
	#_coverageTracker173029075_ markAsExecuted.
	#_coverageTracker173029075_
		cover: (13 to: 22)
		declaredAt: (13 to: 22)
		by:
			(newMethods _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029075_
				coverAll:
					{27 to: 29}
				by: Set.
			#_coverageTracker173029075_
				coverAll:
					{31 to: 33}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	#_coverageTracker173029075_
		cover: (37 to: 50)
		declaredAt: (37 to: 50)
		by:
			(changedMethods _ [ | receiver2 |
			receiver2 _ #_coverageTracker173029075_
				coverAll:
					{55 to: 57}
				by: Set.
			#_coverageTracker173029075_
				coverAll:
					{59 to: 61}
				evaluating: [ receiver2 new ]
				thatSends: #new
				to: receiver2 ] value).
	#_coverageTracker173029075_
		coverAll:
			{73 to: 82}
		evaluating: [ super initialize ]
		thatSends: #initialize
		to: super.! !
!Behavior method!
errors
	#_coverageTracker173029080_ markAsExecuted.
	^ #_coverageTracker173029080_
		cover: (11 to: 16)
		declaredAt: (11 to: 16)
		by: errors.! !
!Behavior method!
rerun
	#_coverageTracker173029081_ markAsExecuted.
	[ | cascadeReceiver |
	cascadeReceiver _ #_coverageTracker173029081_
		cover: (8 to: 14)
		declaredAt: (8 to: 14)
		by: tddGuru.
	[ | receiver1 |
	receiver1 _ cascadeReceiver.
	#_coverageTracker173029081_
		coverAll:
			{16 to: 20}
		evaluating: [ receiver1 rerun ]
		thatSends: #rerun
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029081_
		coverAll:
			{23 to: 40}
		evaluating: [ receiver2 showAnalysisResult ]
		thatSends: #showAnalysisResult
		to: receiver2 ] value ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173029081_
		coverAll:
			{44 to: 47}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029081_
		coverAll:
			{49 to: 54}
		evaluating: [ receiver3 delete ]
		thatSends: #delete
		to: receiver3 ] value.! !
!Behavior method!
code
	| changeClass sourceString |
	#_coverageTracker173029096_ markAsExecuted.
	#_coverageTracker173029096_
		cover: (37 to: 48)
		declaredAt: (21 to: 32)
		by:
			(sourceString _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029096_
				cover: (53 to: 64)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173029096_
				coverAll:
					{66 to: 71}
				evaluating: [ receiver1 string ]
				thatSends: #string
				to: receiver1 ] value).
	#_coverageTracker173029096_
		cover: (75 to: 85)
		declaredAt: (9 to: 19)
		by:
			(changeClass _ [ | receiver2 |
			receiver2 _ #_coverageTracker173029096_
				cover: (90 to: 101)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173029096_
				coverAll:
					{103 to: 113}
				evaluating: [ receiver2 changeClass ]
				thatSends: #changeClass
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173029096_
		cover: (117 to: 127)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173029096_
		coverAll:
			{129 to: 134}
		evaluating: [ receiver3 ifNil: [ ^ #_coverageTracker173029096_
					cover: (140 to: 151)
					declaredAt: (21 to: 32)
					by: sourceString ]]
		thatSends: #ifNil:
		to: receiver3 ] value.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173029096_
		cover: (161 to: 171)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173029096_
		coverAll:
			{173 to: 185}
		evaluating: [ receiver4 compilerClass ]
		thatSends: #compilerClass
		to: receiver4 ] value.
	#_coverageTracker173029096_
		coverAll:
			{187 to: 189}
		evaluating: [ receiver5 new ]
		thatSends: #new
		to: receiver5 ] value.
	#_coverageTracker173029096_
		coverAll:
			{193 to: 199. 214 to: 216. 230 to: 239}
		evaluating: [
			receiver6
				format:
					(#_coverageTracker173029096_
						cover: (201 to: 212)
						declaredAt: (21 to: 32)
						by: sourceString)
				in:
					(#_coverageTracker173029096_
						cover: (218 to: 228)
						declaredAt: (9 to: 19)
						by: changeClass)
				notifying:
					(#_coverageTracker173029096_
						coverAll:
							{241 to: 243}
						byLiteralOrPseudoVariable: nil) ]
		thatSends: #format:in:notifying:
		to: receiver6 ] value.! !
!Behavior method!
update: aSection
	#_coverageTracker173029108_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029108_
		coverAll:
			{19 to: 22}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029108_
		coverAll:
			{24 to: 31}
		evaluating: [
			receiver1 changed:
				(#_coverageTracker173029108_
					cover: (33 to: 40)
					declaredAt: (9 to: 16)
					by: aSection) ]
		thatSends: #changed:
		to: receiver1 ] value.! !
!Behavior method!
methodSelector
	#_coverageTracker173029110_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029110_
		cover: (19 to: 30)
		declaredAt: (19 to: 30)
		by: changeRecord.
	#_coverageTracker173029110_
		coverAll:
			{32 to: 45}
		evaluating: [ receiver1 methodSelector ]
		thatSends: #methodSelector
		to: receiver1 ] value.! !
!Behavior method!
testPassed: aTestReference
	#_coverageTracker173029114_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029114_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029114_
		coverAll:
			{34 to: 45}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173029114_
		coverAll:
			{47 to: 57}
		evaluating: [
			receiver2 testPassed:
				(#_coverageTracker173029114_
					cover: (59 to: 72)
					declaredAt: (13 to: 26)
					by: aTestReference) ]
		thatSends: #testPassed:
		to: receiver2 ] value.! !
!Behavior method!
on: aFileName
	#_coverageTracker173029118_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029118_
		coverAll:
			{19 to: 22}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029118_
		coverAll:
			{24 to: 26}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173029118_
		coverAll:
			{28 to: 39}
		evaluating: [
			receiver2 changesFile:
				(#_coverageTracker173029118_
					cover: (41 to: 49)
					declaredAt: (5 to: 13)
					by: aFileName) ]
		thatSends: #changesFile:
		to: receiver2 ] value.! !
!Behavior method!
context: aContext
	#_coverageTracker173029122_ markAsExecuted.
	#_coverageTracker173029122_
		cover: (20 to: 26)
		declaredAt: (20 to: 26)
		by:
			(context _ #_coverageTracker173029122_
				cover: (31 to: 38)
				declaredAt: (10 to: 17)
				by: aContext).! !
!Behavior method!
code
	#_coverageTracker173029125_ markAsExecuted.
	#_coverageTracker173029125_
		cover: (7 to: 16)
		declaredAt: (7 to: 16)
		by:
			(changeCode _ [ | receiver2 |
			receiver2 _ #_coverageTracker173029125_
				coverAll:
					{21 to: 34}
				by: TextModelMorph.
			#_coverageTracker173029125_
				coverAll:
					{36 to: 48. 65 to: 75}
				evaluating: [
					receiver2
						textProvider:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173029125_
								cover: (50 to: 54)
								declaredAt: (50 to: 54)
								by: model.
							#_coverageTracker173029125_
								coverAll:
									{56 to: 63}
								evaluating: [ receiver1 timeline ]
								thatSends: #timeline
								to: receiver1 ] value
						textGetter:
							(#_coverageTracker173029125_
								coverAll:
									{77 to: 89}
								byLiteralOrPseudoVariable: #selectedCode) ]
				thatSends: #textProvider:textGetter:
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173029125_
		cover: (93 to: 102)
		declaredAt: (7 to: 16)
		by: changeCode.
	#_coverageTracker173029125_
		coverAll:
			{104 to: 117}
		evaluating: [ receiver3 disableEditing ]
		thatSends: #disableEditing
		to: receiver3 ] value.
	^ #_coverageTracker173029125_
		cover: (125 to: 134)
		declaredAt: (7 to: 16)
		by: changeCode.! !
!Behavior method!
newModelMethod: aMethodReference
	#_coverageTracker173029132_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029132_
		coverAll:
			{35 to: 38}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029132_
		coverAll:
			{40 to: 51}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173029132_
		coverAll:
			{53 to: 67}
		evaluating: [
			receiver2 newModelMethod:
				(#_coverageTracker173029132_
					cover: (69 to: 84)
					declaredAt: (17 to: 32)
					by: aMethodReference) ]
		thatSends: #newModelMethod:
		to: receiver2 ] value.! !
!Behavior method!
testChangedWhileThisTestWasBeingWritten: testSelector in: className
	#_coverageTracker173029136_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029136_
		coverAll:
			{74 to: 77}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029136_
		coverAll:
			{79 to: 90. 105 to: 110}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173029136_
						cover: (92 to: 103)
						declaredAt: (42 to: 53)
						by: testSelector)
				class:
					(#_coverageTracker173029136_
						cover: (112 to: 120)
						declaredAt: (59 to: 67)
						by: className) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173029136_
		coverAll:
			{122 to: 122}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173029136_
					coverAll:
						{124 to: 172}
					byLiteralOrPseudoVariable: ' was changed while other test was being written') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
removeMethodWithSelector: aSymbol from: className
	#_coverageTracker173029144_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029144_
		coverAll:
			{54 to: 57}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029144_
		coverAll:
			{59 to: 69}
		evaluating: [
			receiver1 classNamed:
				(#_coverageTracker173029144_
					cover: (71 to: 79)
					declaredAt: (41 to: 49)
					by: className) ]
		thatSends: #classNamed:
		to: receiver1 ] value.
	#_coverageTracker173029144_
		coverAll:
			{82 to: 96}
		evaluating: [
			receiver2 removeSelector:
				(#_coverageTracker173029144_
					cover: (98 to: 104)
					declaredAt: (27 to: 33)
					by: aSymbol) ]
		thatSends: #removeSelector:
		to: receiver2 ] value.! !
!Behavior method!
methodWasNotUsedError: aMethodReference
	| changeWhenMethodWasAdded errorMessage |
	#_coverageTracker173029149_ markAsExecuted.
	#_coverageTracker173029149_
		cover: (85 to: 108)
		declaredAt: (44 to: 67)
		by:
			(changeWhenMethodWasAdded _ [ | receiver4 |
			receiver4 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029149_
				cover: (113 to: 119)
				declaredAt: (113 to: 119)
				by: context.
			#_coverageTracker173029149_
				coverAll:
					{121 to: 134}
				evaluating: [ receiver1 analysisResult ]
				thatSends: #analysisResult
				to: receiver1 ] value.
			#_coverageTracker173029149_
				coverAll:
					{136 to: 160. 188 to: 190}
				evaluating: [
					receiver4
						changeWhenMethodWasAdded:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173029149_
								cover: (162 to: 177)
								declaredAt: (24 to: 39)
								by: aMethodReference.
							#_coverageTracker173029149_
								coverAll:
									{179 to: 186}
								evaluating: [ receiver2 selector ]
								thatSends: #selector
								to: receiver2 ] value
						in:
							[ | receiver3 |
							receiver3 _ #_coverageTracker173029149_
								cover: (192 to: 207)
								declaredAt: (24 to: 39)
								by: aMethodReference.
							#_coverageTracker173029149_
								coverAll:
									{209 to: 219}
								evaluating: [ receiver3 methodClass ]
								thatSends: #methodClass
								to: receiver3 ] value ]
				thatSends: #changeWhenMethodWasAdded:in:
				to: receiver4 ] value).
	#_coverageTracker173029149_
		cover: (223 to: 234)
		declaredAt: (69 to: 80)
		by:
			(errorMessage _ [ | receiver7 |
			receiver7 _ #_coverageTracker173029149_
				coverAll:
					{239 to: 245}
				by: TDDGuru.
			#_coverageTracker173029149_
				coverAll:
					{247 to: 282. 310 to: 315}
				evaluating: [
					receiver7
						modelMethodWasNotUsedDuringRefactor:
							[ | receiver5 |
							receiver5 _ #_coverageTracker173029149_
								cover: (284 to: 299)
								declaredAt: (24 to: 39)
								by: aMethodReference.
							#_coverageTracker173029149_
								coverAll:
									{301 to: 308}
								evaluating: [ receiver5 selector ]
								thatSends: #selector
								to: receiver5 ] value
						class:
							[ | receiver6 |
							receiver6 _ #_coverageTracker173029149_
								cover: (317 to: 332)
								declaredAt: (24 to: 39)
								by: aMethodReference.
							#_coverageTracker173029149_
								coverAll:
									{334 to: 344}
								evaluating: [ receiver6 methodClass ]
								thatSends: #methodClass
								to: receiver6 ] value ]
				thatSends: #modelMethodWasNotUsedDuringRefactor:class:
				to: receiver7 ] value).
	[ | receiver8 |
	receiver8 _ #_coverageTracker173029149_
		coverAll:
			{350 to: 353}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029149_
		coverAll:
			{355 to: 368. 395 to: 399}
		evaluating: [
			receiver8
				reportErrorIn:
					(#_coverageTracker173029149_
						cover: (370 to: 393)
						declaredAt: (44 to: 67)
						by: changeWhenMethodWasAdded)
				with:
					(#_coverageTracker173029149_
						cover: (401 to: 412)
						declaredAt: (69 to: 80)
						by: errorMessage) ]
		thatSends: #reportErrorIn:with:
		to: receiver8 ] value.! !
!Behavior method!
classRenamedFrom: previousClassName to: currentClassName
	#_coverageTracker173029163_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029163_
		cover: (61 to: 71)
		declaredAt: (61 to: 71)
		by: testClasses.
	#_coverageTracker173029163_
		coverAll:
			{73 to: 81}
		evaluating: [
			receiver1 includes:
				(#_coverageTracker173029163_
					cover: (83 to: 99)
					declaredAt: (19 to: 35)
					by: previousClassName) ]
		thatSends: #includes:
		to: receiver1 ] value.
	#_coverageTracker173029163_
		coverAll:
			{102 to: 108}
		evaluating: [
			receiver5 ifTrue: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173029163_
					cover: (114 to: 124)
					declaredAt: (61 to: 71)
					by: testClasses.
				#_coverageTracker173029163_
					coverAll:
						{126 to: 132}
					evaluating: [
						receiver2 remove:
							(#_coverageTracker173029163_
								cover: (134 to: 150)
								declaredAt: (19 to: 35)
								by: previousClassName) ]
					thatSends: #remove:
					to: receiver2 ] value.
				[ | receiver3 |
				receiver3 _ #_coverageTracker173029163_
					cover: (155 to: 165)
					declaredAt: (61 to: 71)
					by: testClasses.
				#_coverageTracker173029163_
					coverAll:
						{167 to: 170}
					evaluating: [
						receiver3 add:
							(#_coverageTracker173029163_
								cover: (172 to: 187)
								declaredAt: (41 to: 56)
								by: currentClassName) ]
					thatSends: #add:
					to: receiver3 ] value.
				[ | receiver4 |
				receiver4 _ #_coverageTracker173029163_
					coverAll:
						{192 to: 195}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029163_
					coverAll:
						{197 to: 210. 230 to: 234}
					evaluating: [
						receiver4
							replaceTestOf:
								(#_coverageTracker173029163_
									cover: (212 to: 228)
									declaredAt: (19 to: 35)
									by: previousClassName)
							with:
								(#_coverageTracker173029163_
									cover: (236 to: 251)
									declaredAt: (41 to: 56)
									by: currentClassName) ]
					thatSends: #replaceTestOf:with:
					to: receiver4 ] value ]]
		thatSends: #ifTrue:
		to: receiver5 ] value.! !
!Behavior method!
font
	#_coverageTracker173029174_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029174_
		coverAll:
			{9 to: 19}
		by: Preferences.
	#_coverageTracker173029174_
		coverAll:
			{21 to: 23}
		evaluating: [
			receiver1 at:
				(#_coverageTracker173029174_
					coverAll:
						{25 to: 41}
					byLiteralOrPseudoVariable: #standardListFont) ]
		thatSends: #at:
		to: receiver1 ] value.! !
!Behavior method!
currentState
	#_coverageTracker173029175_ markAsExecuted.
	^ #_coverageTracker173029175_
		cover: (17 to: 21)
		declaredAt: (17 to: 21)
		by: state.! !
!Behavior method!
runAllTestsOf: aSymbol
	| testClass |
	#_coverageTracker173029179_ markAsExecuted.
	#_coverageTracker173029179_
		cover: (43 to: 51)
		declaredAt: (28 to: 36)
		by:
			(testClass _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029179_
				coverAll:
					{56 to: 59}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173029179_
				coverAll:
					{61 to: 71}
				evaluating: [
					receiver1 classNamed:
						(#_coverageTracker173029179_
							cover: (73 to: 79)
							declaredAt: (16 to: 22)
							by: aSymbol) ]
				thatSends: #classNamed:
				to: receiver1 ] value).
	[ | receiver4 |
	receiver4 _ [
	[ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029179_
		cover: (85 to: 93)
		declaredAt: (28 to: 36)
		by: testClass.
	#_coverageTracker173029179_
		coverAll:
			{95 to: 120}
		evaluating: [ receiver2 buildSuiteFromAllSelectors ]
		thatSends: #buildSuiteFromAllSelectors
		to: receiver2 ] value.
	#_coverageTracker173029179_
		coverAll:
			{122 to: 124}
		evaluating: [ receiver3 run ]
		thatSends: #run
		to: receiver3 ] value ].
	#_coverageTracker173029179_
		coverAll:
			{128 to: 130. 142 to: 144}
		evaluating: [
			receiver4
				on:
					(#_coverageTracker173029179_
						coverAll:
							{132 to: 140}
						by: Exception)
				do: [ ]]
		thatSends: #on:do:
		to: receiver4 ] value.! !
!Behavior method!
pickAChangeAndAnalyze: userChangesFileName
	| changeList fileStream startPosition |
	#_coverageTracker173029186_ markAsExecuted.
	#_coverageTracker173029186_
		cover: (88 to: 100)
		declaredAt: (70 to: 82)
		by:
			(startPosition _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029186_
				coverAll:
					{105 to: 108}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173029186_
				coverAll:
					{110 to: 140}
				evaluating: [
					receiver1 pickStartPositionFromSnapshots:
						(#_coverageTracker173029186_
							cover: (142 to: 160)
							declaredAt: (24 to: 42)
							by: userChangesFileName) ]
				thatSends: #pickStartPositionFromSnapshots:
				to: receiver1 ] value).
	[ | receiver8 |
	receiver8 _ #_coverageTracker173029186_
		cover: (166 to: 178)
		declaredAt: (70 to: 82)
		by: startPosition.
	#_coverageTracker173029186_
		coverAll:
			{180 to: 188}
		evaluating: [
			receiver8 ifNotNil: [
				#_coverageTracker173029186_
					cover: (194 to: 203)
					declaredAt: (59 to: 68)
					by:
						(fileStream _ [ | receiver3 |
						receiver3 _ [ | receiver2 |
						receiver2 _ #_coverageTracker173029186_
							cover: (208 to: 226)
							declaredAt: (24 to: 42)
							by: userChangesFileName.
						#_coverageTracker173029186_
							coverAll:
								{228 to: 238}
							evaluating: [ receiver2 asFileEntry ]
							thatSends: #asFileEntry
							to: receiver2 ] value.
						#_coverageTracker173029186_
							coverAll:
								{240 to: 249}
							evaluating: [ receiver3 readStream ]
							thatSends: #readStream
							to: receiver3 ] value).
				#_coverageTracker173029186_
					cover: (254 to: 263)
					declaredAt: (48 to: 57)
					by:
						(changeList _ [ | receiver6 |
						receiver6 _ [ | receiver4 |
						receiver4 _ #_coverageTracker173029186_
							coverAll:
								{268 to: 277}
							by: ChangeList.
						#_coverageTracker173029186_
							coverAll:
								{279 to: 281}
							evaluating: [ receiver4 new ]
							thatSends: #new
							to: receiver4 ] value.
						#_coverageTracker173029186_
							coverAll:
								{283 to: 291. 304 to: 308. 324 to: 326}
							evaluating: [
								receiver6
									scanFile:
										(#_coverageTracker173029186_
											cover: (293 to: 302)
											declaredAt: (59 to: 68)
											by: fileStream)
									from:
										(#_coverageTracker173029186_
											cover: (310 to: 322)
											declaredAt: (70 to: 82)
											by: startPosition)
									to:
										[ | receiver5 |
										receiver5 _ #_coverageTracker173029186_
											cover: (328 to: 337)
											declaredAt: (59 to: 68)
											by: fileStream.
										#_coverageTracker173029186_
											coverAll:
												{339 to: 342}
											evaluating: [ receiver5 size ]
											thatSends: #size
											to: receiver5 ] value ]
							thatSends: #scanFile:from:to:
							to: receiver6 ] value).
				[ | receiver7 |
				receiver7 _ #_coverageTracker173029186_
					coverAll:
						{348 to: 364}
					by: PickAChangeWindow.
				#_coverageTracker173029186_
					coverAll:
						{366 to: 370. 383 to: 396}
					evaluating: [
						receiver7
							open:
								(#_coverageTracker173029186_
									cover: (372 to: 381)
									declaredAt: (48 to: 57)
									by: changeList)
							startPosition:
								(#_coverageTracker173029186_
									cover: (398 to: 410)
									declaredAt: (70 to: 82)
									by: startPosition) ]
					thatSends: #open:startPosition:
					to: receiver7 ] value ]]
		thatSends: #ifNotNil:
		to: receiver8 ] value.! !
!Behavior method!
openFor: anAnalysisResult analyzedBy: tddGuru
	| window |
	#_coverageTracker173029202_ markAsExecuted.
	#_coverageTracker173029202_
		cover: (60 to: 65)
		declaredAt: (50 to: 55)
		by:
			(window _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029202_
				coverAll:
					{70 to: 73}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173029202_
				coverAll:
					{75 to: 79. 98 to: 103}
				evaluating: [
					receiver1
						open:
							(#_coverageTracker173029202_
								cover: (81 to: 96)
								declaredAt: (10 to: 25)
								by: anAnalysisResult)
						label:
							(#_coverageTracker173029202_
								coverAll:
									{105 to: 113}
								byLiteralOrPseudoVariable: 'TDDGuru') ]
				thatSends: #open:label:
				to: receiver1 ] value).
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029202_
		cover: (117 to: 122)
		declaredAt: (50 to: 55)
		by: window.
	#_coverageTracker173029202_
		coverAll:
			{124 to: 134}
		evaluating: [
			receiver2 analyzedBy:
				(#_coverageTracker173029202_
					cover: (136 to: 142)
					declaredAt: (39 to: 45)
					by: tddGuru) ]
		thatSends: #analyzedBy:
		to: receiver2 ] value.! !
!Behavior method!
modelClassRemoved: className
	#_coverageTracker173029208_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029208_
		coverAll:
			{31 to: 34}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029208_
		coverAll:
			{36 to: 47}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173029208_
		coverAll:
			{49 to: 66}
		evaluating: [
			receiver2 modelClassRemoved:
				(#_coverageTracker173029208_
					cover: (68 to: 76)
					declaredAt: (20 to: 28)
					by: className) ]
		thatSends: #modelClassRemoved:
		to: receiver2 ] value.! !
!Behavior method!
initializeInventory
	#_coverageTracker173029212_ markAsExecuted.
	^ #_coverageTracker173029212_
		cover: (25 to: 33)
		declaredAt: (25 to: 33)
		by:
			(inventory _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029212_
				coverAll:
					{38 to: 50}
				by: TestInventory.
			#_coverageTracker173029212_
				coverAll:
					{52 to: 54}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).! !
!Behavior method!
changeWhenMethodWasAdded: aSelector in: className
	#_coverageTracker173029215_ markAsExecuted.
	^ [ | receiver9 |
	receiver9 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029215_
		coverAll:
			{55 to: 58}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029215_
		coverAll:
			{60 to: 66}
		evaluating: [ receiver1 changes ]
		thatSends: #changes
		to: receiver1 ] value.
	#_coverageTracker173029215_
		coverAll:
			{68 to: 74}
		evaluating: [
			receiver9 detect: [ :aChange |
				[ | receiver8 |
				receiver8 _ [ | receiver3 |
				receiver3 _ [ | receiver2 |
				receiver2 _ #_coverageTracker173029215_
					cover: (92 to: 98)
					declaredAt: (79 to: 85)
					by: aChange.
				#_coverageTracker173029215_
					coverAll:
						{100 to: 107}
					evaluating: [ receiver2 category ]
					thatSends: #category
					to: receiver2 ] value.
				#_coverageTracker173029215_
					coverAll:
						{109 to: 109}
					evaluating: [
						receiver3 =
							(#_coverageTracker173029215_
								coverAll:
									{111 to: 125}
								byLiteralOrPseudoVariable: #newModelMethod) ]
					thatSends: #=
					to: receiver3 ] value.
				#_coverageTracker173029215_
					coverAll:
						{133 to: 136. 180 to: 183}
					evaluating: [
						receiver8
							and: [
								[ | receiver5 |
								receiver5 _ [ | receiver4 |
								receiver4 _ #_coverageTracker173029215_
									cover: (140 to: 146)
									declaredAt: (79 to: 85)
									by: aChange.
								#_coverageTracker173029215_
									coverAll:
										{148 to: 161}
									evaluating: [ receiver4 methodSelector ]
									thatSends: #methodSelector
									to: receiver4 ] value.
								#_coverageTracker173029215_
									coverAll:
										{163 to: 163}
									evaluating: [
										receiver5 =
											(#_coverageTracker173029215_
												cover: (165 to: 173)
												declaredAt: (27 to: 35)
												by: aSelector) ]
									thatSends: #=
									to: receiver5 ] value ]
							and: [
								[ | receiver7 |
								receiver7 _ [ | receiver6 |
								receiver6 _ #_coverageTracker173029215_
									cover: (187 to: 193)
									declaredAt: (79 to: 85)
									by: aChange.
								#_coverageTracker173029215_
									coverAll:
										{195 to: 209}
									evaluating: [ receiver6 changeClassName ]
									thatSends: #changeClassName
									to: receiver6 ] value.
								#_coverageTracker173029215_
									coverAll:
										{211 to: 211}
									evaluating: [
										receiver7 =
											(#_coverageTracker173029215_
												cover: (213 to: 221)
												declaredAt: (41 to: 49)
												by: className) ]
									thatSends: #=
									to: receiver7 ] value ]]
					thatSends: #and:and:
					to: receiver8 ] value ]]
		thatSends: #detect:
		to: receiver9 ] value.! !
!Behavior method!
changesFile: aFileName from: startPosition
	#_coverageTracker173029229_ markAsExecuted.
	#_coverageTracker173029229_
		cover: (45 to: 68)
		declaredAt: (45 to: 68)
		by:
			(changesFileStartPosition _ #_coverageTracker173029229_
				cover: (73 to: 85)
				declaredAt: (30 to: 42)
				by: startPosition).
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029229_
		coverAll:
			{89 to: 92}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029229_
		coverAll:
			{94 to: 105}
		evaluating: [
			receiver1 changesFile:
				(#_coverageTracker173029229_
					cover: (107 to: 115)
					declaredAt: (14 to: 22)
					by: aFileName) ]
		thatSends: #changesFile:
		to: receiver1 ] value.! !
!Behavior method!
classRenamedFrom: aSymbol to: aSymbol2
	#_coverageTracker173029232_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029232_
		coverAll:
			{42 to: 45}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029232_
		coverAll:
			{47 to: 59}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029232_
					coverAll:
						{61 to: 68}
					by: Refactor.
				#_coverageTracker173029232_
					coverAll:
						{70 to: 72}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
for: aChangeClass withLookahead: lookaheadNumber detectsWhen: detectionBlock
	#_coverageTracker173029238_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029238_
		coverAll:
			{81 to: 84}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029238_
		coverAll:
			{86 to: 88}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029238_
		coverAll:
			{90 to: 101}
		evaluating: [
			receiver2 changeClass:
				(#_coverageTracker173029238_
					cover: (103 to: 114)
					declaredAt: (6 to: 17)
					by: aChangeClass) ]
		thatSends: #changeClass:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173029238_
		coverAll:
			{117 to: 126}
		evaluating: [
			receiver3 lookahead:
				(#_coverageTracker173029238_
					cover: (128 to: 142)
					declaredAt: (34 to: 48)
					by: lookaheadNumber) ]
		thatSends: #lookahead:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ cascadeReceiver.
	#_coverageTracker173029238_
		coverAll:
			{145 to: 156}
		evaluating: [
			receiver4 detectBlock:
				(#_coverageTracker173029238_
					cover: (158 to: 171)
					declaredAt: (63 to: 76)
					by: detectionBlock) ]
		thatSends: #detectBlock:
		to: receiver4 ] value ] value.! !
!Behavior method!
isATestClass: className
	#_coverageTracker173029252_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029252_
		cover: (29 to: 37)
		declaredAt: (29 to: 37)
		by: inventory.
	#_coverageTracker173029252_
		coverAll:
			{39 to: 57}
		evaluating: [
			receiver1 hasATestClassNamed:
				(#_coverageTracker173029252_
					cover: (59 to: 67)
					declaredAt: (15 to: 23)
					by: className) ]
		thatSends: #hasATestClassNamed:
		to: receiver1 ] value.! !
!Behavior method!
testFailed: aTestSelector
	#_coverageTracker173029257_ markAsExecuted.! !
!Behavior method!
newTest: testReference
	#_coverageTracker173029259_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029259_
		coverAll:
			{25 to: 28}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029259_
		coverAll:
			{30 to: 42}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029259_
					coverAll:
						{45 to: 63}
					by: WritingAFailingTest.
				#_coverageTracker173029259_
					coverAll:
						{65 to: 76}
					evaluating: [
						receiver1 currentTest:
							(#_coverageTracker173029259_
								cover: (78 to: 90)
								declaredAt: (10 to: 22)
								by: testReference) ]
					thatSends: #currentTest:
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
timeline
	#_coverageTracker173029263_ markAsExecuted.
	^ #_coverageTracker173029263_
		cover: (13 to: 20)
		declaredAt: (13 to: 20)
		by: timeline.! !
!Behavior method!
testUtilityChangeDetector
	#_coverageTracker173029266_ markAsExecuted.
	^ [ | receiver9 |
	receiver9 _ #_coverageTracker173029266_
		coverAll:
			{30 to: 43}
		by: ChangeDetector.
	#_coverageTracker173029266_
		coverAll:
			{45 to: 48. 69 to: 82. 86 to: 97}
		evaluating: [
			receiver9
				for:
					(#_coverageTracker173029266_
						coverAll:
							{50 to: 67}
						by: TestUtilityChanged)
				withLookahead:
					(#_coverageTracker173029266_
						coverAll:
							{84 to: 84}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver8 |
					receiver8 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173029266_
						cover: (118 to: 130)
						declaredAt: (102 to: 114)
						by: aChangeRecord.
					#_coverageTracker173029266_
						coverAll:
							{132 to: 141}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173029266_
						coverAll:
							{143 to: 143}
						evaluating: [
							receiver2 =
								(#_coverageTracker173029266_
									coverAll:
										{145 to: 151}
									byLiteralOrPseudoVariable: #method) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173029266_
						coverAll:
							{156 to: 159. 216 to: 219}
						evaluating: [
							receiver8
								and: [
									[ | receiver4 |
									receiver4 _ #_coverageTracker173029266_
										coverAll:
											{163 to: 166}
										byLiteralOrPseudoVariable: self.
									#_coverageTracker173029266_
										coverAll:
											{168 to: 180}
										evaluating: [
											receiver4 isATestClass:
												[ | receiver3 |
												receiver3 _ #_coverageTracker173029266_
													cover: (182 to: 194)
													declaredAt: (102 to: 114)
													by: aChangeRecord.
												#_coverageTracker173029266_
													coverAll:
														{196 to: 210}
													evaluating: [ receiver3 changeClassName ]
													thatSends: #changeClassName
													to: receiver3 ] value ]
										thatSends: #isATestClass:
										to: receiver4 ] value ]
								and: [
									[ | receiver7 |
									receiver7 _ [ | receiver6 |
									receiver6 _ [ | receiver5 |
									receiver5 _ #_coverageTracker173029266_
										cover: (224 to: 236)
										declaredAt: (102 to: 114)
										by: aChangeRecord.
									#_coverageTracker173029266_
										coverAll:
											{238 to: 251}
										evaluating: [ receiver5 methodSelector ]
										thatSends: #methodSelector
										to: receiver5 ] value.
									#_coverageTracker173029266_
										coverAll:
											{253 to: 266}
										evaluating: [ receiver6 isTestSelector ]
										thatSends: #isTestSelector
										to: receiver6 ] value.
									#_coverageTracker173029266_
										coverAll:
											{269 to: 271}
										evaluating: [ receiver7 not ]
										thatSends: #not
										to: receiver7 ] value ]]
						thatSends: #and:and:
						to: receiver8 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver9 ] value.! !
!Behavior method!
testIsTracked: selector class: className
	#_coverageTracker173029278_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029278_
		cover: (45 to: 53)
		declaredAt: (45 to: 53)
		by: inventory.
	#_coverageTracker173029278_
		coverAll:
			{55 to: 74. 85 to: 93}
		evaluating: [
			receiver1
				hasTestWithSelector:
					(#_coverageTracker173029278_
						cover: (76 to: 83)
						declaredAt: (16 to: 23)
						by: selector)
				andClass:
					(#_coverageTracker173029278_
						cover: (95 to: 103)
						declaredAt: (32 to: 40)
						by: className) ]
		thatSends: #hasTestWithSelector:andClass:
		to: receiver1 ] value.! !
!Behavior method!
changes
	#_coverageTracker173029282_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173029282_
		cover: (10 to: 16)
		declaredAt: (10 to: 16)
		by: changes.
	#_coverageTracker173029282_
		coverAll:
			{18 to: 23}
		evaluating: [
			receiver4 ifNil: [
				#_coverageTracker173029282_
					cover: (27 to: 33)
					declaredAt: (10 to: 16)
					by:
						(changes _ [ | receiver3 |
						receiver3 _ [ | receiver1 |
						receiver1 _ #_coverageTracker173029282_
							coverAll:
								{38 to: 41}
							byLiteralOrPseudoVariable: self.
						#_coverageTracker173029282_
							coverAll:
								{43 to: 54}
							evaluating: [ receiver1 changeEvents ]
							thatSends: #changeEvents
							to: receiver1 ] value.
						#_coverageTracker173029282_
							coverAll:
								{56 to: 63}
							evaluating: [
								receiver3 collect: [ :changeEvent |
									[ | receiver2 |
									receiver2 _ #_coverageTracker173029282_
										cover: (82 to: 92)
										declaredAt: (68 to: 78)
										by: changeEvent.
									#_coverageTracker173029282_
										coverAll:
											{94 to: 99}
										evaluating: [ receiver2 change ]
										thatSends: #change
										to: receiver2 ] value ]]
							thatSends: #collect:
							to: receiver3 ] value) ]]
		thatSends: #ifNil:
		to: receiver4 ] value.
	^ #_coverageTracker173029282_
		cover: (111 to: 117)
		declaredAt: (10 to: 16)
		by: changes.! !
!Behavior method!
modelClassRemoved: aSymbol
	#_coverageTracker173029289_ markAsExecuted.! !
!Behavior method!
sourceCode: aString
	#_coverageTracker173029290_ markAsExecuted.
	#_coverageTracker173029290_
		cover: (22 to: 31)
		declaredAt: (22 to: 31)
		by:
			(sourceCode _ #_coverageTracker173029290_
				cover: (36 to: 42)
				declaredAt: (13 to: 19)
				by: aString).! !
!Behavior method!
canBeDetectedIn: lookaheadChangeRecords
	#_coverageTracker173029294_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173029294_
		cover: (44 to: 54)
		declaredAt: (44 to: 54)
		by: detectBlock.
	#_coverageTracker173029294_
		coverAll:
			{56 to: 74}
		evaluating: [
			receiver2 valueWithArguments:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029294_
					cover: (76 to: 97)
					declaredAt: (18 to: 39)
					by: lookaheadChangeRecords.
				#_coverageTracker173029294_
					coverAll:
						{99 to: 105}
					evaluating: [ receiver1 asArray ]
					thatSends: #asArray
					to: receiver1 ] value ]
		thatSends: #valueWithArguments:
		to: receiver2 ] value.! !
!Behavior method!
sendsMessageWithSelector: aSymbol
	| methodNode |
	#_coverageTracker173029300_ markAsExecuted.
	#_coverageTracker173029300_
		cover: (52 to: 61)
		declaredAt: (38 to: 47)
		by:
			(methodNode _ [ | receiver4 |
			receiver4 _ [
			[ | receiver2 |
			receiver2 _ #_coverageTracker173029300_
				coverAll:
					{69 to: 74}
				by: Parser.
			#_coverageTracker173029300_
				coverAll:
					{76 to: 81. 94 to: 99}
				evaluating: [
					receiver2
						parse:
							(#_coverageTracker173029300_
								cover: (83 to: 92)
								declaredAt: (83 to: 92)
								by: sourceCode)
						class:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173029300_
								coverAll:
									{101 to: 104}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173029300_
								coverAll:
									{106 to: 127}
								evaluating: [ receiver1 methodClassIfInstalled ]
								thatSends: #methodClassIfInstalled
								to: receiver1 ] value ]
				thatSends: #parse:class:
				to: receiver2 ] value ].
			#_coverageTracker173029300_
				coverAll:
					{133 to: 135. 167 to: 169}
				evaluating: [
					receiver4
						on:
							(#_coverageTracker173029300_
								coverAll:
									{137 to: 163}
								by: InMidstOfFileinNotification)
						do: [ :anException |
							[ | receiver3 |
							receiver3 _ #_coverageTracker173029300_
								cover: (188 to: 198)
								declaredAt: (174 to: 184)
								by: anException.
							#_coverageTracker173029300_
								coverAll:
									{200 to: 206}
								evaluating: [
									receiver3 resume:
										(#_coverageTracker173029300_
											coverAll:
												{208 to: 211}
											byLiteralOrPseudoVariable: true) ]
								thatSends: #resume:
								to: receiver3 ] value ]]
				thatSends: #on:do:
				to: receiver4 ] value).
	[ | receiver9 |
	receiver9 _ #_coverageTracker173029300_
		cover: (219 to: 228)
		declaredAt: (38 to: 47)
		by: methodNode.
	#_coverageTracker173029300_
		coverAll:
			{230 to: 237}
		evaluating: [
			receiver9 nodesDo: [ :aNode |
				[ | receiver8 |
				receiver8 _ [ | receiver7 |
				receiver7 _ [ | receiver5 |
				receiver5 _ #_coverageTracker173029300_
					cover: (254 to: 258)
					declaredAt: (242 to: 246)
					by: aNode.
				#_coverageTracker173029300_
					coverAll:
						{260 to: 272}
					evaluating: [ receiver5 isMessageNode ]
					thatSends: #isMessageNode
					to: receiver5 ] value.
				#_coverageTracker173029300_
					coverAll:
						{274 to: 277}
					evaluating: [
						receiver7 and: [
							[ | receiver6 |
							receiver6 _ #_coverageTracker173029300_
								cover: (281 to: 285)
								declaredAt: (242 to: 246)
								by: aNode.
							#_coverageTracker173029300_
								coverAll:
									{287 to: 301}
								evaluating: [
									receiver6 isMessageNamed:
										(#_coverageTracker173029300_
											cover: (303 to: 309)
											declaredAt: (27 to: 33)
											by: aSymbol) ]
								thatSends: #isMessageNamed:
								to: receiver6 ] value ]]
					thatSends: #and:
					to: receiver7 ] value.
				#_coverageTracker173029300_
					coverAll:
						{314 to: 320}
					evaluating: [ receiver8 ifTrue: [ ^ #_coverageTracker173029300_
								coverAll:
									{326 to: 329}
								byLiteralOrPseudoVariable: true ]]
					thatSends: #ifTrue:
					to: receiver8 ] value ]]
		thatSends: #nodesDo:
		to: receiver9 ] value.
	^ #_coverageTracker173029300_
		coverAll:
			{340 to: 344}
		byLiteralOrPseudoVariable: false.! !
!Behavior method!
selector: aSymbol
	#_coverageTracker173029317_ markAsExecuted.
	#_coverageTracker173029317_
		cover: (21 to: 28)
		declaredAt: (21 to: 28)
		by:
			(selector _ #_coverageTracker173029317_
				cover: (33 to: 39)
				declaredAt: (11 to: 17)
				by: aSymbol).! !
!Behavior method!
change: aChange
	#_coverageTracker173029320_ markAsExecuted.
	#_coverageTracker173029320_
		cover: (18 to: 23)
		declaredAt: (18 to: 23)
		by:
			(change _ #_coverageTracker173029320_
				cover: (28 to: 34)
				declaredAt: (9 to: 15)
				by: aChange).! !
!Behavior method!
allTests
	#_coverageTracker173029322_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029322_
		cover: (13 to: 19)
		declaredAt: (13 to: 19)
		by: context.
	#_coverageTracker173029322_
		coverAll:
			{21 to: 28}
		evaluating: [ receiver1 allTests ]
		thatSends: #allTests
		to: receiver1 ] value.! !
!Behavior method!
printString
	#_coverageTracker173029325_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029325_
		coverAll:
			{16 to: 19}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029325_
		coverAll:
			{21 to: 27}
		evaluating: [ receiver1 stateTo ]
		thatSends: #stateTo
		to: receiver1 ] value.
	#_coverageTracker173029325_
		coverAll:
			{29 to: 39}
		evaluating: [ receiver2 printString ]
		thatSends: #printString
		to: receiver2 ] value.! !
!Behavior method!
changesFileForTests
	#_coverageTracker173029329_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ #_coverageTracker173029329_
		coverAll:
			{25 to: 28}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029329_
		coverAll:
			{30 to: 53}
		evaluating: [
			receiver2 changeFileWithExtension:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029329_
					coverAll:
						{55 to: 58}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029329_
					coverAll:
						{60 to: 90}
					evaluating: [ receiver1 userChangesForTestFileExtension ]
					thatSends: #userChangesForTestFileExtension
					to: receiver1 ] value ]
		thatSends: #changeFileWithExtension:
		to: receiver2 ] value.! !
!Behavior method!
to
	#_coverageTracker173029331_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029331_
		cover: (7 to: 25)
		declaredAt: (7 to: 25)
		by: newTestChangeRecord.
	#_coverageTracker173029331_
		coverAll:
			{27 to: 40}
		evaluating: [ receiver1 methodSelector ]
		thatSends: #methodSelector
		to: receiver1 ] value.! !
!Behavior method!
isRecognized
	#_coverageTracker173029333_ markAsExecuted.
	^ #_coverageTracker173029333_
		coverAll:
			{17 to: 21}
		byLiteralOrPseudoVariable: false.! !
!Behavior method!
currentTest: aSelector
	#_coverageTracker173029335_ markAsExecuted.
	#_coverageTracker173029335_
		cover: (25 to: 28)
		declaredAt: (25 to: 28)
		by:
			(test _ #_coverageTracker173029335_
				cover: (33 to: 41)
				declaredAt: (14 to: 22)
				by: aSelector).! !
!Behavior method!
category
	#_coverageTracker173029338_ markAsExecuted.
	^ #_coverageTracker173029338_
		coverAll:
			{13 to: 24}
		byLiteralOrPseudoVariable: #testChanged.! !
!Behavior method!
from
	#_coverageTracker173029342_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029342_
		cover: (9 to: 31)
		declaredAt: (9 to: 31)
		by: testRemovedChangeRecord.
	#_coverageTracker173029342_
		coverAll:
			{33 to: 46}
		evaluating: [ receiver1 methodSelector ]
		thatSends: #methodSelector
		to: receiver1 ] value.! !
!Behavior method!
testRemoved: aMethodReference
	#_coverageTracker173029344_ markAsExecuted.! !
!Behavior method!
changeAt: index
	#_coverageTracker173029345_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029345_
		coverAll:
			{20 to: 23}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029345_
		coverAll:
			{25 to: 36}
		evaluating: [ receiver1 changeEvents ]
		thatSends: #changeEvents
		to: receiver1 ] value.
	#_coverageTracker173029345_
		coverAll:
			{38 to: 40}
		evaluating: [
			receiver2 at:
				(#_coverageTracker173029345_
					cover: (42 to: 46)
					declaredAt: (11 to: 15)
					by: index) ]
		thatSends: #at:
		to: receiver2 ] value.! !
!Behavior method!
startPosition: startPosition
	#_coverageTracker173029350_ markAsExecuted.
	#_coverageTracker173029350_
		cover: (31 to: 54)
		declaredAt: (31 to: 54)
		by:
			(changesFileStartPosition _ #_coverageTracker173029350_
				cover: (59 to: 71)
				declaredAt: (16 to: 28)
				by: startPosition).! !
!Behavior method!
isCorrect
	#_coverageTracker173029353_ markAsExecuted.
	^ #_coverageTracker173029353_
		coverAll:
			{14 to: 17}
		byLiteralOrPseudoVariable: true.! !
!Behavior method!
withTestClasses: aCollection
	#_coverageTracker173029365_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029365_
		coverAll:
			{33 to: 36}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029365_
		coverAll:
			{38 to: 40}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173029365_
		coverAll:
			{42 to: 53}
		evaluating: [
			receiver2 testClasses:
				(#_coverageTracker173029365_
					cover: (55 to: 65)
					declaredAt: (18 to: 28)
					by: aCollection) ]
		thatSends: #testClasses:
		to: receiver2 ] value.! !
!Behavior method!
from: aChangeCollection using: aTestInventory
	#_coverageTracker173029371_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029371_
		coverAll:
			{51 to: 54}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029371_
		coverAll:
			{56 to: 58}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029371_
		coverAll:
			{60 to: 70}
		evaluating: [
			receiver2 changeList:
				(#_coverageTracker173029371_
					cover: (72 to: 88)
					declaredAt: (7 to: 23)
					by: aChangeCollection) ]
		thatSends: #changeList:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173029371_
		coverAll:
			{91 to: 100}
		evaluating: [
			receiver3 inventory:
				(#_coverageTracker173029371_
					cover: (102 to: 115)
					declaredAt: (32 to: 45)
					by: aTestInventory) ]
		thatSends: #inventory:
		to: receiver3 ] value ] value.! !
!Behavior method!
for: anAnalysisResult
	#_coverageTracker173029384_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029384_
		coverAll:
			{26 to: 29}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029384_
		coverAll:
			{31 to: 33}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173029384_
		coverAll:
			{35 to: 49}
		evaluating: [
			receiver2 analysisResult:
				(#_coverageTracker173029384_
					cover: (51 to: 66)
					declaredAt: (6 to: 21)
					by: anAnalysisResult) ]
		thatSends: #analysisResult:
		to: receiver2 ] value.! !
!Behavior method!
class: aSymbol
	#_coverageTracker173029390_ markAsExecuted.
	#_coverageTracker173029390_
		cover: (18 to: 26)
		declaredAt: (18 to: 26)
		by:
			(className _ #_coverageTracker173029390_
				cover: (31 to: 37)
				declaredAt: (8 to: 14)
				by: aSymbol).! !
!Behavior method!
assertHasNoErrors: aResult
	#_coverageTracker173029392_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029392_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029392_
		coverAll:
			{34 to: 40. 50 to: 60}
		evaluating: [
			receiver1
				assert:
					(#_coverageTracker173029392_
						cover: (42 to: 48)
						declaredAt: (20 to: 26)
						by: aResult)
				hasNErrors:
					(#_coverageTracker173029392_
						coverAll:
							{62 to: 62}
						byLiteralOrPseudoVariable: 0) ]
		thatSends: #assert:hasNErrors:
		to: receiver1 ] value.! !
!Behavior method!
markAsChanged: aMethodReference
	#_coverageTracker173029397_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029397_
		cover: (35 to: 48)
		declaredAt: (35 to: 48)
		by: changedMethods.
	#_coverageTracker173029397_
		coverAll:
			{50 to: 56. 75 to: 83}
		evaluating: [
			receiver1
				remove:
					(#_coverageTracker173029397_
						cover: (58 to: 73)
						declaredAt: (16 to: 31)
						by: aMethodReference)
				ifAbsent: [ ]]
		thatSends: #remove:ifAbsent:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029397_
		cover: (90 to: 103)
		declaredAt: (35 to: 48)
		by: changedMethods.
	#_coverageTracker173029397_
		coverAll:
			{105 to: 108}
		evaluating: [
			receiver2 add:
				(#_coverageTracker173029397_
					cover: (110 to: 125)
					declaredAt: (16 to: 31)
					by: aMethodReference) ]
		thatSends: #add:
		to: receiver2 ] value.! !
!Behavior method!
printOn: aStream
	#_coverageTracker173029402_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029402_
		cover: (19 to: 25)
		declaredAt: (10 to: 16)
		by: aStream.
	#_coverageTracker173029402_
		coverAll:
			{27 to: 37}
		evaluating: [
			receiver1 nextPutAll:
				(#_coverageTracker173029402_
					coverAll:
						{39 to: 54}
					byLiteralOrPseudoVariable: 'TestReference ') ]
		thatSends: #nextPutAll:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029402_
		cover: (58 to: 64)
		declaredAt: (10 to: 16)
		by: aStream.
	#_coverageTracker173029402_
		coverAll:
			{66 to: 76}
		evaluating: [
			receiver2 nextPutAll:
				(#_coverageTracker173029402_
					cover: (78 to: 86)
					declaredAt: (78 to: 86)
					by: className) ]
		thatSends: #nextPutAll:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173029402_
		cover: (90 to: 96)
		declaredAt: (10 to: 16)
		by: aStream.
	#_coverageTracker173029402_
		coverAll:
			{98 to: 108}
		evaluating: [
			receiver3 nextPutAll:
				(#_coverageTracker173029402_
					coverAll:
						{110 to: 113}
					byLiteralOrPseudoVariable: '>>') ]
		thatSends: #nextPutAll:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173029402_
		cover: (117 to: 124)
		declaredAt: (117 to: 124)
		by: selector.
	#_coverageTracker173029402_
		coverAll:
			{126 to: 133}
		evaluating: [
			receiver4 printOn:
				(#_coverageTracker173029402_
					cover: (135 to: 141)
					declaredAt: (10 to: 16)
					by: aStream) ]
		thatSends: #printOn:
		to: receiver4 ] value.! !
!Behavior method!
analyzeWholeFile: userChangesFileName
	#_coverageTracker173029418_ markAsExecuted.
	[ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029418_
		coverAll:
			{41 to: 47}
		by: TDDGuru.
	#_coverageTracker173029418_
		coverAll:
			{49 to: 51}
		evaluating: [
			receiver1 on:
				(#_coverageTracker173029418_
					cover: (53 to: 71)
					declaredAt: (19 to: 37)
					by: userChangesFileName) ]
		thatSends: #on:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029418_
		coverAll:
			{74 to: 76}
		evaluating: [ receiver2 run ]
		thatSends: #run
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173029418_
		coverAll:
			{79 to: 96}
		evaluating: [ receiver3 showAnalysisResult ]
		thatSends: #showAnalysisResult
		to: receiver3 ] value ] value.! !
!Behavior method!
hasError: aChange
	#_coverageTracker173029424_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029424_
		cover: (22 to: 27)
		declaredAt: (22 to: 27)
		by: errors.
	#_coverageTracker173029424_
		coverAll:
			{29 to: 40}
		evaluating: [
			receiver1 includesKey:
				(#_coverageTracker173029424_
					cover: (42 to: 48)
					declaredAt: (11 to: 17)
					by: aChange) ]
		thatSends: #includesKey:
		to: receiver1 ] value.! !
!Behavior method!
dateString
	#_coverageTracker173029426_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029426_
		coverAll:
			{15 to: 18}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029426_
		coverAll:
			{20 to: 24}
		evaluating: [ receiver1 stamp ]
		thatSends: #stamp
		to: receiver1 ] value.
	#_coverageTracker173029426_
		coverAll:
			{26 to: 35}
		evaluating: [ receiver2 substrings ]
		thatSends: #substrings
		to: receiver2 ] value.
	#_coverageTracker173029426_
		coverAll:
			{37 to: 42}
		evaluating: [ receiver3 second ]
		thatSends: #second
		to: receiver3 ] value.! !
!Behavior method!
newModelMethod: methodReference
	#_coverageTracker173029429_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173029429_
		coverAll:
			{35 to: 38}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029429_
		coverAll:
			{40 to: 51. 146 to: 161}
		evaluating: [
			receiver5
				reportError:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173029429_
						coverAll:
							{54 to: 60}
						by: TDDGuru.
					#_coverageTracker173029429_
						coverAll:
							{62 to: 83. 110 to: 115}
						evaluating: [
							receiver3
								methodAddedBeforeTest:
									[ | receiver1 |
									receiver1 _ #_coverageTracker173029429_
										cover: (85 to: 99)
										declaredAt: (17 to: 31)
										by: methodReference.
									#_coverageTracker173029429_
										coverAll:
											{101 to: 108}
										evaluating: [ receiver1 selector ]
										thatSends: #selector
										to: receiver1 ] value
								class:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173029429_
										cover: (117 to: 131)
										declaredAt: (17 to: 31)
										by: methodReference.
									#_coverageTracker173029429_
										coverAll:
											{133 to: 143}
										evaluating: [ receiver2 methodClass ]
										thatSends: #methodClass
										to: receiver2 ] value ]
						thatSends: #methodAddedBeforeTest:class:
						to: receiver3 ] value
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173029429_
						coverAll:
							{163 to: 173}
						by: NotDoingTDD.
					#_coverageTracker173029429_
						coverAll:
							{175 to: 177}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
testClassRemoved: aSymbol
	#_coverageTracker173029444_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029444_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029444_
		coverAll:
			{34 to: 51}
		evaluating: [
			receiver1 modelClassRemoved:
				(#_coverageTracker173029444_
					cover: (53 to: 59)
					declaredAt: (19 to: 25)
					by: aSymbol) ]
		thatSends: #modelClassRemoved:
		to: receiver1 ] value.! !
!Behavior method!
newTest: methodSelector
	#_coverageTracker173029447_ markAsExecuted.! !
!Behavior method!
currentTestIsDefined
	#_coverageTracker173029449_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029449_
		cover: (25 to: 28)
		declaredAt: (25 to: 28)
		by: test.
	#_coverageTracker173029449_
		coverAll:
			{30 to: 34}
		evaluating: [ receiver1 isNil ]
		thatSends: #isNil
		to: receiver1 ] value.
	#_coverageTracker173029449_
		coverAll:
			{36 to: 38}
		evaluating: [ receiver2 not ]
		thatSends: #not
		to: receiver2 ] value.! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173029452_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029452_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173029452_
		coverAll:
			{34 to: 52}
		evaluating: [
			receiver2 modelMethodChanged:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029452_
					coverAll:
						{54 to: 57}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029452_
					coverAll:
						{59 to: 73}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #modelMethodChanged:
		to: receiver2 ] value.! !
!Behavior method!
testFailed: aSymbol
	#_coverageTracker173029457_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029457_
		coverAll:
			{23 to: 26}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029457_
		coverAll:
			{28 to: 40}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029457_
					coverAll:
						{42 to: 44}
					by: Red.
				#_coverageTracker173029457_
					coverAll:
						{46 to: 48}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
to: aTDDState
	#_coverageTracker173029463_ markAsExecuted.
	#_coverageTracker173029463_
		cover: (16 to: 22)
		declaredAt: (16 to: 22)
		by:
			(toState _ #_coverageTracker173029463_
				cover: (27 to: 35)
				declaredAt: (5 to: 13)
				by: aTDDState).! !
!Behavior method!
optionalButtonRow
	| row runButton buttonColor |
	#_coverageTracker173029474_ markAsExecuted.
	#_coverageTracker173029474_
		cover: (54 to: 64)
		declaredAt: (37 to: 47)
		by:
			(buttonColor _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029474_
				coverAll:
					{68 to: 71}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173029474_
				coverAll:
					{73 to: 83}
				evaluating: [ receiver1 buttonColor ]
				thatSends: #buttonColor
				to: receiver1 ] value).
	#_coverageTracker173029474_
		cover: (87 to: 95)
		declaredAt: (26 to: 34)
		by:
			(runButton _ [ | receiver2 |
			receiver2 _ #_coverageTracker173029474_
				coverAll:
					{100 to: 119}
				by: PluggableButtonMorph.
			#_coverageTracker173029474_
				coverAll:
					{127 to: 132. 144 to: 155. 166 to: 172}
				evaluating: [
					receiver2
						model:
							(#_coverageTracker173029474_
								coverAll:
									{134 to: 137}
								byLiteralOrPseudoVariable: self)
						stateGetter:
							(#_coverageTracker173029474_
								coverAll:
									{157 to: 159}
								byLiteralOrPseudoVariable: nil)
						action:
							(#_coverageTracker173029474_
								coverAll:
									{174 to: 195}
								byLiteralOrPseudoVariable: #runFromSelectedChange) ]
				thatSends: #model:stateGetter:action:
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173029474_
		cover: (199 to: 207)
		declaredAt: (26 to: 34)
		by: runButton.
	#_coverageTracker173029474_
		coverAll:
			{209 to: 214}
		evaluating: [
			receiver3 color:
				(#_coverageTracker173029474_
					cover: (216 to: 226)
					declaredAt: (37 to: 47)
					by: buttonColor) ]
		thatSends: #color:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ #_coverageTracker173029474_
		cover: (230 to: 238)
		declaredAt: (26 to: 34)
		by: runButton.
	#_coverageTracker173029474_
		coverAll:
			{240 to: 245}
		evaluating: [
			receiver4 label:
				(#_coverageTracker173029474_
					coverAll:
						{247 to: 261}
					byLiteralOrPseudoVariable: 'Run from here') ]
		thatSends: #label:
		to: receiver4 ] value.
	#_coverageTracker173029474_
		cover: (267 to: 269)
		declaredAt: (22 to: 24)
		by:
			(row _ [ | receiver5 |
			receiver5 _ #_coverageTracker173029474_
				coverAll:
					{273 to: 283}
				by: LayoutMorph.
			#_coverageTracker173029474_
				coverAll:
					{285 to: 290}
				evaluating: [ receiver5 newRow ]
				thatSends: #newRow
				to: receiver5 ] value).
	[ | receiver6 |
	receiver6 _ #_coverageTracker173029474_
		cover: (294 to: 296)
		declaredAt: (22 to: 24)
		by: row.
	#_coverageTracker173029474_
		coverAll:
			{298 to: 316}
		evaluating: [ receiver6 doAdoptWidgetsColor ]
		thatSends: #doAdoptWidgetsColor
		to: receiver6 ] value.
	[ | receiver7 |
	receiver7 _ #_coverageTracker173029474_
		cover: (320 to: 322)
		declaredAt: (22 to: 24)
		by: row.
	#_coverageTracker173029474_
		coverAll:
			{324 to: 329}
		evaluating: [
			receiver7 color:
				(#_coverageTracker173029474_
					cover: (331 to: 341)
					declaredAt: (37 to: 47)
					by: buttonColor) ]
		thatSends: #color:
		to: receiver7 ] value.
	[ | receiver8 |
	receiver8 _ #_coverageTracker173029474_
		cover: (345 to: 347)
		declaredAt: (22 to: 24)
		by: row.
	#_coverageTracker173029474_
		coverAll:
			{349 to: 357}
		evaluating: [
			receiver8 addMorph:
				(#_coverageTracker173029474_
					cover: (359 to: 367)
					declaredAt: (26 to: 34)
					by: runButton) ]
		thatSends: #addMorph:
		to: receiver8 ] value.
	^ #_coverageTracker173029474_
		cover: (372 to: 374)
		declaredAt: (22 to: 24)
		by: row.! !
!Behavior method!
testRemovedDetector
	| isATest |
	#_coverageTracker173029491_ markAsExecuted.
	#_coverageTracker173029491_
		cover: (35 to: 41)
		declaredAt: (24 to: 30)
		by:
			(isATest _ [ :changeRecord |
			[ | receiver3 |
			receiver3 _ #_coverageTracker173029491_
				coverAll:
					{64 to: 67}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173029491_
				coverAll:
					{69 to: 82. 112 to: 117}
				evaluating: [
					receiver3
						testIsTracked:
							[ | receiver1 |
							receiver1 _ #_coverageTracker173029491_
								cover: (84 to: 95)
								declaredAt: (49 to: 60)
								by: changeRecord.
							#_coverageTracker173029491_
								coverAll:
									{97 to: 110}
								evaluating: [ receiver1 methodSelector ]
								thatSends: #methodSelector
								to: receiver1 ] value
						class:
							[ | receiver2 |
							receiver2 _ #_coverageTracker173029491_
								cover: (119 to: 130)
								declaredAt: (49 to: 60)
								by: changeRecord.
							#_coverageTracker173029491_
								coverAll:
									{132 to: 146}
								evaluating: [ receiver2 changeClassName ]
								thatSends: #changeClassName
								to: receiver2 ] value ]
				thatSends: #testIsTracked:class:
				to: receiver3 ] value ]).
	^ [ | receiver7 |
	receiver7 _ #_coverageTracker173029491_
		coverAll:
			{155 to: 168}
		by: ChangeDetector.
	#_coverageTracker173029491_
		coverAll:
			{170 to: 173. 187 to: 200. 204 to: 215}
		evaluating: [
			receiver7
				for:
					(#_coverageTracker173029491_
						coverAll:
							{175 to: 185}
						by: TestRemoved)
				withLookahead:
					(#_coverageTracker173029491_
						coverAll:
							{202 to: 202}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver6 |
					receiver6 _ [ | receiver4 |
					receiver4 _ #_coverageTracker173029491_
						cover: (236 to: 248)
						declaredAt: (220 to: 232)
						by: aChangeRecord.
					#_coverageTracker173029491_
						coverAll:
							{250 to: 265}
						evaluating: [ receiver4 isMethodDeletion ]
						thatSends: #isMethodDeletion
						to: receiver4 ] value.
					#_coverageTracker173029491_
						coverAll:
							{267 to: 270}
						evaluating: [
							receiver6 and: [
								[ | receiver5 |
								receiver5 _ #_coverageTracker173029491_
									cover: (274 to: 280)
									declaredAt: (24 to: 30)
									by: isATest.
								#_coverageTracker173029491_
									coverAll:
										{282 to: 287}
									evaluating: [
										receiver5 value:
											(#_coverageTracker173029491_
												cover: (289 to: 301)
												declaredAt: (220 to: 232)
												by: aChangeRecord) ]
									thatSends: #value:
									to: receiver5 ] value ]]
						thatSends: #and:
						to: receiver6 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver7 ] value.! !
!Behavior method!
newModelClass: aSymbol
	#_coverageTracker173029509_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029509_
		coverAll:
			{26 to: 29}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029509_
		coverAll:
			{31 to: 43}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029509_
					coverAll:
						{45 to: 52}
					by: Refactor.
				#_coverageTracker173029509_
					coverAll:
						{54 to: 56}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
newTestClassDetector
	#_coverageTracker173029514_ markAsExecuted.
	^ [ | receiver5 |
	receiver5 _ #_coverageTracker173029514_
		coverAll:
			{25 to: 38}
		by: ChangeDetector.
	#_coverageTracker173029514_
		coverAll:
			{40 to: 43. 58 to: 71. 75 to: 86}
		evaluating: [
			receiver5
				for:
					(#_coverageTracker173029514_
						coverAll:
							{45 to: 56}
						by: NewTestClass)
				withLookahead:
					(#_coverageTracker173029514_
						coverAll:
							{73 to: 73}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver4 |
					receiver4 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173029514_
						cover: (107 to: 119)
						declaredAt: (91 to: 103)
						by: aChangeRecord.
					#_coverageTracker173029514_
						coverAll:
							{121 to: 130}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173029514_
						coverAll:
							{132 to: 132}
						evaluating: [
							receiver2 =
								(#_coverageTracker173029514_
									coverAll:
										{134 to: 149}
									byLiteralOrPseudoVariable: #classDefinition) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173029514_
						coverAll:
							{151 to: 154}
						evaluating: [
							receiver4 and: [
								[ | receiver3 |
								receiver3 _ #_coverageTracker173029514_
									cover: (158 to: 170)
									declaredAt: (91 to: 103)
									by: aChangeRecord.
								#_coverageTracker173029514_
									coverAll:
										{172 to: 188}
									evaluating: [ receiver3 isTestClassChange ]
									thatSends: #isTestClassChange
									to: receiver3 ] value ]]
						thatSends: #and:
						to: receiver4 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver5 ] value.! !
!Behavior method!
newTest: aTestReference
	#_coverageTracker173029525_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029525_
		cover: (26 to: 34)
		declaredAt: (26 to: 34)
		by: inventory.
	#_coverageTracker173029525_
		coverAll:
			{36 to: 43}
		evaluating: [
			receiver1 newTest:
				(#_coverageTracker173029525_
					cover: (45 to: 58)
					declaredAt: (10 to: 23)
					by: aTestReference) ]
		thatSends: #newTest:
		to: receiver1 ] value.
	[ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029525_
		coverAll:
			{63 to: 66}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029525_
		coverAll:
			{68 to: 79}
		evaluating: [ receiver2 currentState ]
		thatSends: #currentState
		to: receiver2 ] value.
	#_coverageTracker173029525_
		coverAll:
			{81 to: 88}
		evaluating: [
			receiver3 newTest:
				(#_coverageTracker173029525_
					cover: (90 to: 103)
					declaredAt: (10 to: 23)
					by: aTestReference) ]
		thatSends: #newTest:
		to: receiver3 ] value.! !
!Behavior method!
isRecognized
	#_coverageTracker173029529_ markAsExecuted.
	^ #_coverageTracker173029529_
		coverAll:
			{17 to: 20}
		byLiteralOrPseudoVariable: true.! !
!Behavior method!
testAddedBeforeRunningTheRestOfTheTests: aSymbol class: className
	#_coverageTracker173029537_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029537_
		coverAll:
			{70 to: 76}
		byLiteralOrPseudoVariable: 'Test '.
	#_coverageTracker173029537_
		coverAll:
			{77 to: 77}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029537_
					coverAll:
						{80 to: 83}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029537_
					coverAll:
						{85 to: 96. 106 to: 111}
					evaluating: [
						receiver1
							printMethod:
								(#_coverageTracker173029537_
									cover: (98 to: 104)
									declaredAt: (42 to: 48)
									by: aSymbol)
							class:
								(#_coverageTracker173029537_
									cover: (113 to: 121)
									declaredAt: (57 to: 65)
									by: className) ]
					thatSends: #printMethod:class:
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173029537_
		coverAll:
			{123 to: 123}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173029537_
					coverAll:
						{125 to: 180}
					byLiteralOrPseudoVariable: ' was added without running the rest of the tests first') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
classRenamedDetector
	#_coverageTracker173029545_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ #_coverageTracker173029545_
		coverAll:
			{25 to: 38}
		by: ChangeDetector.
	#_coverageTracker173029545_
		coverAll:
			{40 to: 43. 58 to: 71. 75 to: 86}
		evaluating: [
			receiver3
				for:
					(#_coverageTracker173029545_
						coverAll:
							{45 to: 56}
						by: ClassRenamed)
				withLookahead:
					(#_coverageTracker173029545_
						coverAll:
							{73 to: 73}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173029545_
						cover: (107 to: 119)
						declaredAt: (91 to: 103)
						by: aChangeRecord.
					#_coverageTracker173029545_
						coverAll:
							{121 to: 130}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173029545_
						coverAll:
							{132 to: 132}
						evaluating: [
							receiver2 =
								(#_coverageTracker173029545_
									coverAll:
										{134 to: 146}
									byLiteralOrPseudoVariable: #classRenamed) ]
						thatSends: #=
						to: receiver2 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver3 ] value.! !
!Behavior method!
testFailed: aTestReference
	#_coverageTracker173029550_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173029550_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029550_
		coverAll:
			{35 to: 46. 152 to: 167}
		evaluating: [
			receiver5
				reportError:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173029550_
						coverAll:
							{49 to: 55}
						by: TDDGuru.
					#_coverageTracker173029550_
						coverAll:
							{57 to: 91. 117 to: 122}
						evaluating: [
							receiver3
								testUnexpectedlyFailedErrorMessage:
									[ | receiver1 |
									receiver1 _ #_coverageTracker173029550_
										cover: (93 to: 106)
										declaredAt: (13 to: 26)
										by: aTestReference.
									#_coverageTracker173029550_
										coverAll:
											{108 to: 115}
										evaluating: [ receiver1 selector ]
										thatSends: #selector
										to: receiver1 ] value
								class:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173029550_
										cover: (124 to: 137)
										declaredAt: (13 to: 26)
										by: aTestReference.
									#_coverageTracker173029550_
										coverAll:
											{139 to: 149}
										evaluating: [ receiver2 methodClass ]
										thatSends: #methodClass
										to: receiver2 ] value ]
						thatSends: #testUnexpectedlyFailedErrorMessage:class:
						to: receiver3 ] value
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173029550_
						coverAll:
							{169 to: 171}
						by: Red.
					#_coverageTracker173029550_
						coverAll:
							{173 to: 175}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
hasATestClassNamed: aSymbol
	#_coverageTracker173029559_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029559_
		cover: (32 to: 42)
		declaredAt: (32 to: 42)
		by: testClasses.
	#_coverageTracker173029559_
		coverAll:
			{44 to: 52}
		evaluating: [
			receiver1 includes:
				(#_coverageTracker173029559_
					cover: (54 to: 60)
					declaredAt: (21 to: 27)
					by: aSymbol) ]
		thatSends: #includes:
		to: receiver1 ] value.! !
!Behavior method!
modelMethodRemoved: methodReference
	#_coverageTracker173029570_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173029570_
		coverAll:
			{39 to: 42}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029570_
		coverAll:
			{44 to: 55. 160 to: 175}
		evaluating: [
			receiver5
				reportError:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173029570_
						coverAll:
							{58 to: 64}
						by: TDDGuru.
					#_coverageTracker173029570_
						coverAll:
							{66 to: 97. 124 to: 129}
						evaluating: [
							receiver3
								methodRemovedBeforeRunningTests:
									[ | receiver1 |
									receiver1 _ #_coverageTracker173029570_
										cover: (99 to: 113)
										declaredAt: (21 to: 35)
										by: methodReference.
									#_coverageTracker173029570_
										coverAll:
											{115 to: 122}
										evaluating: [ receiver1 selector ]
										thatSends: #selector
										to: receiver1 ] value
								class:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173029570_
										cover: (131 to: 145)
										declaredAt: (21 to: 35)
										by: methodReference.
									#_coverageTracker173029570_
										coverAll:
											{147 to: 157}
										evaluating: [ receiver2 methodClass ]
										thatSends: #methodClass
										to: receiver2 ] value ]
						thatSends: #methodRemovedBeforeRunningTests:class:
						to: receiver3 ] value
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173029570_
						coverAll:
							{177 to: 187}
						by: NotDoingTDD.
					#_coverageTracker173029570_
						coverAll:
							{189 to: 191}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
changesFile: aFileName
	#_coverageTracker173029578_ markAsExecuted.
	#_coverageTracker173029578_
		cover: (26 to: 36)
		declaredAt: (26 to: 36)
		by:
			(changesFile _ #_coverageTracker173029578_
				cover: (41 to: 49)
				declaredAt: (14 to: 22)
				by: aFileName).! !
!Behavior method!
reportChangeTo: tddGuru
	#_coverageTracker173029582_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029582_
		cover: (26 to: 32)
		declaredAt: (17 to: 23)
		by: tddGuru.
	#_coverageTracker173029582_
		coverAll:
			{34 to: 45}
		evaluating: [
			receiver2 testChanged:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029582_
					coverAll:
						{47 to: 50}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029582_
					coverAll:
						{52 to: 66}
					evaluating: [ receiver1 methodReference ]
					thatSends: #methodReference
					to: receiver1 ] value ]
		thatSends: #testChanged:
		to: receiver2 ] value.! !
!Behavior method!
context: aContext
	#_coverageTracker173029584_ markAsExecuted.
	#_coverageTracker173029584_
		coverAll:
			{26 to: 33}
		evaluating: [
			super context:
				(#_coverageTracker173029584_
					cover: (35 to: 42)
					declaredAt: (10 to: 17)
					by: aContext) ]
		thatSends: #context:
		to: super.
	#_coverageTracker173029584_
		cover: (46 to: 60)
		declaredAt: (46 to: 60)
		by:
			(testAddedChange _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029584_
				cover: (65 to: 72)
				declaredAt: (10 to: 17)
				by: aContext.
			#_coverageTracker173029584_
				coverAll:
					{74 to: 86}
				evaluating: [ receiver1 currentChange ]
				thatSends: #currentChange
				to: receiver1 ] value).! !
!Behavior method!
newModelMethod: aMethodReference
	#_coverageTracker173029594_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029594_
		coverAll:
			{37 to: 40}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029594_
		coverAll:
			{42 to: 44}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173029594_
		coverAll:
			{46 to: 60}
		evaluating: [
			receiver2 newModelMethod:
				(#_coverageTracker173029594_
					cover: (62 to: 77)
					declaredAt: (17 to: 32)
					by: aMethodReference) ]
		thatSends: #newModelMethod:
		to: receiver2 ] value.! !
!Behavior method!
with: anUninstalledMethodReference and: anUninstalledMethodReference2
	#_coverageTracker173029598_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029598_
		coverAll:
			{75 to: 78}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029598_
		coverAll:
			{80 to: 82}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173029598_
		coverAll:
			{84 to: 93. 124 to: 134}
		evaluating: [
			receiver2
				firstTest:
					(#_coverageTracker173029598_
						cover: (95 to: 122)
						declaredAt: (7 to: 34)
						by: anUninstalledMethodReference)
				secondTest:
					(#_coverageTracker173029598_
						cover: (136 to: 164)
						declaredAt: (41 to: 69)
						by: anUninstalledMethodReference2) ]
		thatSends: #firstTest:secondTest:
		to: receiver2 ] value.! !
!Behavior method!
initialize
	#_coverageTracker173029602_ markAsExecuted.
	#_coverageTracker173029602_
		cover: (13 to: 23)
		declaredAt: (13 to: 23)
		by:
			(passedTests _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029602_
				coverAll:
					{28 to: 30}
				by: Set.
			#_coverageTracker173029602_
				coverAll:
					{32 to: 34}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).! !
!Behavior method!
testRemoved: anUninstalledMethodReference
	#_coverageTracker173029614_ markAsExecuted.
	[ | receiver5 |
	receiver5 _ #_coverageTracker173029614_
		coverAll:
			{45 to: 48}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029614_
		coverAll:
			{50 to: 61. 182 to: 197}
		evaluating: [
			receiver5
				reportError:
					[ | receiver3 |
					receiver3 _ #_coverageTracker173029614_
						coverAll:
							{64 to: 70}
						by: TDDGuru.
					#_coverageTracker173029614_
						coverAll:
							{72 to: 93. 133 to: 138}
						evaluating: [
							receiver3
								testRemovedWhileInRed:
									[ | receiver1 |
									receiver1 _ #_coverageTracker173029614_
										cover: (95 to: 122)
										declaredAt: (14 to: 41)
										by: anUninstalledMethodReference.
									#_coverageTracker173029614_
										coverAll:
											{124 to: 131}
										evaluating: [ receiver1 selector ]
										thatSends: #selector
										to: receiver1 ] value
								class:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173029614_
										cover: (140 to: 167)
										declaredAt: (14 to: 41)
										by: anUninstalledMethodReference.
									#_coverageTracker173029614_
										coverAll:
											{169 to: 179}
										evaluating: [ receiver2 methodClass ]
										thatSends: #methodClass
										to: receiver2 ] value ]
						thatSends: #testRemovedWhileInRed:class:
						to: receiver3 ] value
				andTransitionTo:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173029614_
						coverAll:
							{199 to: 209}
						by: NotDoingTDD.
					#_coverageTracker173029614_
						coverAll:
							{211 to: 213}
						evaluating: [ receiver4 new ]
						thatSends: #new
						to: receiver4 ] value ]
		thatSends: #reportError:andTransitionTo:
		to: receiver5 ] value.! !
!Behavior method!
innerMorphClass
	#_coverageTracker173029622_ markAsExecuted.
	^ #_coverageTracker173029622_
		coverAll:
			{20 to: 39}
		by: InnerChangeListMorph.! !
!Behavior method!
updateCodeSection
	#_coverageTracker173029632_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029632_
		cover: (20 to: 29)
		declaredAt: (20 to: 29)
		by: changeCode.
	#_coverageTracker173029632_
		coverAll:
			{31 to: 37}
		evaluating: [
			receiver1 update:
				(#_coverageTracker173029632_
					coverAll:
						{39 to: 55}
					byLiteralOrPseudoVariable: #acceptedContents) ]
		thatSends: #update:
		to: receiver1 ] value.! !
!Behavior method!
drawChangeTextFor: aRow in: aCanvas
	#_coverageTracker173029635_ markAsExecuted.
	[ | receiver6 |
	receiver6 _ #_coverageTracker173029635_
		cover: (38 to: 44)
		declaredAt: (29 to: 35)
		by: aCanvas.
	#_coverageTracker173029635_
		coverAll:
			{48 to: 58. 100 to: 102. 136 to: 140. 149 to: 154}
		evaluating: [
			receiver6
				drawString:
					[ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173029635_
						coverAll:
							{61 to: 64}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173029635_
						coverAll:
							{66 to: 70}
						evaluating: [
							receiver1 item:
								(#_coverageTracker173029635_
									cover: (72 to: 75)
									declaredAt: (20 to: 23)
									by: aRow) ]
						thatSends: #item:
						to: receiver1 ] value.
					#_coverageTracker173029635_
						coverAll:
							{78 to: 96}
						evaluating: [ receiver2 displayStringOrText ]
						thatSends: #displayStringOrText
						to: receiver2 ] value
				at:
					[ | receiver4 |
					receiver4 _ #_coverageTracker173029635_
						coverAll:
							{104 to: 105}
						byLiteralOrPseudoVariable: 25.
					#_coverageTracker173029635_
						coverAll:
							{107 to: 107}
						evaluating: [
							receiver4 @
								[ | receiver3 |
								receiver3 _ #_coverageTracker173029635_
									coverAll:
										{110 to: 113}
									byLiteralOrPseudoVariable: self.
								#_coverageTracker173029635_
									coverAll:
										{115 to: 126}
									evaluating: [
										receiver3 drawYForRow:
											(#_coverageTracker173029635_
												cover: (128 to: 131)
												declaredAt: (20 to: 23)
												by: aRow) ]
									thatSends: #drawYForRow:
									to: receiver3 ] value ]
						thatSends: #@
						to: receiver4 ] value
				font:
					(#_coverageTracker173029635_
						cover: (142 to: 145)
						declaredAt: (142 to: 145)
						by: font)
				color:
					[ | receiver5 |
					receiver5 _ #_coverageTracker173029635_
						coverAll:
							{157 to: 160}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173029635_
						coverAll:
							{162 to: 173}
						evaluating: [
							receiver5 colorForRow:
								(#_coverageTracker173029635_
									cover: (175 to: 178)
									declaredAt: (20 to: 23)
									by: aRow) ]
						thatSends: #colorForRow:
						to: receiver5 ] value ]
		thatSends: #drawString:at:font:color:
		to: receiver6 ] value.! !
!Behavior method!
testClassRemoved: className
	#_coverageTracker173029646_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029646_
		cover: (32 to: 42)
		declaredAt: (32 to: 42)
		by: testClasses.
	#_coverageTracker173029646_
		coverAll:
			{44 to: 52}
		evaluating: [
			receiver1 includes:
				(#_coverageTracker173029646_
					cover: (54 to: 62)
					declaredAt: (19 to: 27)
					by: className) ]
		thatSends: #includes:
		to: receiver1 ] value.
	#_coverageTracker173029646_
		coverAll:
			{65 to: 71}
		evaluating: [
			receiver4 ifTrue: [
				[ | receiver2 |
				receiver2 _ #_coverageTracker173029646_
					coverAll:
						{78 to: 81}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029646_
					coverAll:
						{83 to: 96}
					evaluating: [
						receiver2 removeTestsOf:
							(#_coverageTracker173029646_
								cover: (98 to: 106)
								declaredAt: (19 to: 27)
								by: className) ]
					thatSends: #removeTestsOf:
					to: receiver2 ] value.
				[ | receiver3 |
				receiver3 _ #_coverageTracker173029646_
					cover: (111 to: 121)
					declaredAt: (32 to: 42)
					by: testClasses.
				#_coverageTracker173029646_
					coverAll:
						{123 to: 129}
					evaluating: [
						receiver3 remove:
							(#_coverageTracker173029646_
								cover: (131 to: 139)
								declaredAt: (19 to: 27)
								by: className) ]
					thatSends: #remove:
					to: receiver3 ] value ]]
		thatSends: #ifTrue:
		to: receiver4 ] value.! !
!Behavior method!
testClassRemovedWhileInRed: aSymbol
	#_coverageTracker173029652_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029652_
		coverAll:
			{41 to: 53}
		byLiteralOrPseudoVariable: 'Test class '.
	#_coverageTracker173029652_
		coverAll:
			{54 to: 54}
		evaluating: [
			receiver1 ,
				(#_coverageTracker173029652_
					cover: (56 to: 62)
					declaredAt: (29 to: 35)
					by: aSymbol) ]
		thatSends: #,
		to: receiver1 ] value.
	#_coverageTracker173029652_
		coverAll:
			{63 to: 63}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173029652_
					coverAll:
						{65 to: 91}
					byLiteralOrPseudoVariable: ' was removed while in Red') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
isCorrect
	#_coverageTracker173029664_ markAsExecuted.
	^ #_coverageTracker173029664_
		coverAll:
			{14 to: 18}
		byLiteralOrPseudoVariable: false.! !
!Behavior method!
modelClassRemoved: aSymbol
	#_coverageTracker173029668_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029668_
		coverAll:
			{30 to: 33}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029668_
		coverAll:
			{35 to: 47}
		evaluating: [
			receiver2 transitionTo:
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029668_
					coverAll:
						{49 to: 56}
					by: Refactor.
				#_coverageTracker173029668_
					coverAll:
						{58 to: 60}
					evaluating: [ receiver1 new ]
					thatSends: #new
					to: receiver1 ] value ]
		thatSends: #transitionTo:
		to: receiver2 ] value.! !
!Behavior method!
methodChangedBeforeTest: aSelector class: className
	#_coverageTracker173029672_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029672_
		coverAll:
			{57 to: 65}
		byLiteralOrPseudoVariable: 'Method '.
	#_coverageTracker173029672_
		coverAll:
			{66 to: 66}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029672_
					coverAll:
						{69 to: 72}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029672_
					coverAll:
						{74 to: 85. 97 to: 102}
					evaluating: [
						receiver1
							printMethod:
								(#_coverageTracker173029672_
									cover: (87 to: 95)
									declaredAt: (26 to: 34)
									by: aSelector)
							class:
								(#_coverageTracker173029672_
									cover: (104 to: 112)
									declaredAt: (43 to: 51)
									by: className) ]
					thatSends: #printMethod:class:
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173029672_
		coverAll:
			{114 to: 114}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173029672_
					coverAll:
						{116 to: 151}
					byLiteralOrPseudoVariable: ' was changed before writing a test') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
selector: testSelector class: className
	#_coverageTracker173029685_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029685_
		coverAll:
			{45 to: 48}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029685_
		coverAll:
			{50 to: 52}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029685_
		coverAll:
			{54 to: 62}
		evaluating: [
			receiver2 selector:
				(#_coverageTracker173029685_
					cover: (64 to: 75)
					declaredAt: (11 to: 22)
					by: testSelector) ]
		thatSends: #selector:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173029685_
		coverAll:
			{78 to: 83}
		evaluating: [
			receiver3 class:
				(#_coverageTracker173029685_
					cover: (85 to: 93)
					declaredAt: (31 to: 39)
					by: className) ]
		thatSends: #class:
		to: receiver3 ] value ] value.! !
!Behavior method!
classRenamedFrom: aSymbol to: aSymbol2
	#_coverageTracker173029691_ markAsExecuted.! !
!Behavior method!
newModelClass: aSymbol
	#_coverageTracker173029691_ markAsExecuted.! !
!Behavior method!
testFailed: aTestReference
	#_coverageTracker173029693_ markAsExecuted.
	[ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029693_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029693_
		coverAll:
			{34 to: 45}
		evaluating: [ receiver1 currentState ]
		thatSends: #currentState
		to: receiver1 ] value.
	#_coverageTracker173029693_
		coverAll:
			{47 to: 57}
		evaluating: [
			receiver2 testFailed:
				(#_coverageTracker173029693_
					cover: (59 to: 72)
					declaredAt: (13 to: 26)
					by: aTestReference) ]
		thatSends: #testFailed:
		to: receiver2 ] value.! !
!Behavior method!
testUnexpectedlyFailedErrorMessage: aSymbol class: className
	| testAsString |
	#_coverageTracker173029699_ markAsExecuted.
	#_coverageTracker173029699_
		cover: (81 to: 92)
		declaredAt: (65 to: 76)
		by:
			(testAsString _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029699_
				coverAll:
					{97 to: 100}
				byLiteralOrPseudoVariable: self.
			#_coverageTracker173029699_
				coverAll:
					{102 to: 113. 123 to: 128}
				evaluating: [
					receiver1
						printMethod:
							(#_coverageTracker173029699_
								cover: (115 to: 121)
								declaredAt: (37 to: 43)
								by: aSymbol)
						class:
							(#_coverageTracker173029699_
								cover: (130 to: 138)
								declaredAt: (52 to: 60)
								by: className) ]
				thatSends: #printMethod:class:
				to: receiver1 ] value).
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029699_
		coverAll:
			{144 to: 150}
		byLiteralOrPseudoVariable: 'Test '.
	#_coverageTracker173029699_
		coverAll:
			{151 to: 151}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173029699_
					cover: (153 to: 164)
					declaredAt: (65 to: 76)
					by: testAsString) ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173029699_
		coverAll:
			{165 to: 165}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173029699_
					coverAll:
						{166 to: 202}
					byLiteralOrPseudoVariable: ' had passed and failed unexpectedly') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
printString
	#_coverageTracker173029706_ markAsExecuted.
	^ [ | receiver11 |
	receiver11 _ [ | receiver9 |
	receiver9 _ [ | receiver8 |
	receiver8 _ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029706_
		coverAll:
			{16 to: 18}
		byLiteralOrPseudoVariable: '['.
	#_coverageTracker173029706_
		coverAll:
			{19 to: 19}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029706_
					coverAll:
						{21 to: 24}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029706_
					coverAll:
						{26 to: 35}
					evaluating: [ receiver1 changeTime ]
					thatSends: #changeTime
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173029706_
		coverAll:
			{36 to: 36}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173029706_
					coverAll:
						{38 to: 40}
					byLiteralOrPseudoVariable: ' ') ]
		thatSends: #,
		to: receiver3 ] value.
	#_coverageTracker173029706_
		coverAll:
			{41 to: 41}
		evaluating: [
			receiver5 ,
				[ | receiver4 |
				receiver4 _ #_coverageTracker173029706_
					coverAll:
						{43 to: 46}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029706_
					coverAll:
						{48 to: 79}
					evaluating: [ receiver4 timeDifferenceWithPreviousChange ]
					thatSends: #timeDifferenceWithPreviousChange
					to: receiver4 ] value ]
		thatSends: #,
		to: receiver5 ] value.
	#_coverageTracker173029706_
		coverAll:
			{80 to: 80}
		evaluating: [
			receiver6 ,
				(#_coverageTracker173029706_
					coverAll:
						{82 to: 86}
					byLiteralOrPseudoVariable: '] [') ]
		thatSends: #,
		to: receiver6 ] value.
	#_coverageTracker173029706_
		coverAll:
			{87 to: 87}
		evaluating: [
			receiver8 ,
				[ | receiver7 |
				receiver7 _ #_coverageTracker173029706_
					coverAll:
						{89 to: 92}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029706_
					coverAll:
						{94 to: 107}
					evaluating: [ receiver7 changeCategory ]
					thatSends: #changeCategory
					to: receiver7 ] value ]
		thatSends: #,
		to: receiver8 ] value.
	#_coverageTracker173029706_
		coverAll:
			{108 to: 108}
		evaluating: [
			receiver9 ,
				(#_coverageTracker173029706_
					coverAll:
						{110 to: 113}
					byLiteralOrPseudoVariable: '] ') ]
		thatSends: #,
		to: receiver9 ] value.
	#_coverageTracker173029706_
		coverAll:
			{114 to: 114}
		evaluating: [
			receiver11 ,
				[ | receiver10 |
				receiver10 _ #_coverageTracker173029706_
					coverAll:
						{116 to: 119}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029706_
					coverAll:
						{121 to: 137}
					evaluating: [ receiver10 changeDescription ]
					thatSends: #changeDescription
					to: receiver10 ] value ]
		thatSends: #,
		to: receiver11 ] value.! !
!Behavior method!
overrides: aBoolean
	#_coverageTracker173029721_ markAsExecuted.
	#_coverageTracker173029721_
		cover: (22 to: 30)
		declaredAt: (22 to: 30)
		by:
			(overrides _ #_coverageTracker173029721_
				cover: (35 to: 42)
				declaredAt: (12 to: 19)
				by: aBoolean).! !
!Behavior method!
testClassRemoved: aSymbol
	#_coverageTracker173029724_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029724_
		cover: (29 to: 33)
		declaredAt: (29 to: 33)
		by: state.
	#_coverageTracker173029724_
		coverAll:
			{35 to: 51}
		evaluating: [
			receiver1 testClassRemoved:
				(#_coverageTracker173029724_
					cover: (53 to: 59)
					declaredAt: (19 to: 25)
					by: aSymbol) ]
		thatSends: #testClassRemoved:
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ #_coverageTracker173029724_
		cover: (63 to: 71)
		declaredAt: (63 to: 71)
		by: inventory.
	#_coverageTracker173029724_
		coverAll:
			{73 to: 89}
		evaluating: [
			receiver2 testClassRemoved:
				(#_coverageTracker173029724_
					cover: (91 to: 97)
					declaredAt: (19 to: 25)
					by: aSymbol) ]
		thatSends: #testClassRemoved:
		to: receiver2 ] value.
	[ | receiver6 |
	receiver6 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173029724_
		coverAll:
			{103 to: 106}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029724_
		coverAll:
			{108 to: 118}
		evaluating: [ receiver3 noTestsLeft ]
		thatSends: #noTestsLeft
		to: receiver3 ] value.
	#_coverageTracker173029724_
		coverAll:
			{120 to: 126}
		evaluating: [
			receiver6 ifTrue: [
				[ | receiver5 |
				receiver5 _ [ | receiver4 |
				receiver4 _ #_coverageTracker173029724_
					coverAll:
						{130 to: 133}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029724_
					coverAll:
						{135 to: 146}
					evaluating: [ receiver4 currentState ]
					thatSends: #currentState
					to: receiver4 ] value.
				#_coverageTracker173029724_
					coverAll:
						{148 to: 158}
					evaluating: [ receiver5 noMoreTests ]
					thatSends: #noMoreTests
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.! !
!Behavior method!
newFor: aChangeRecord
	#_coverageTracker173029732_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029732_
		coverAll:
			{26 to: 29}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029732_
		coverAll:
			{31 to: 33}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	#_coverageTracker173029732_
		coverAll:
			{35 to: 47}
		evaluating: [
			receiver2 changeRecord:
				(#_coverageTracker173029732_
					cover: (49 to: 61)
					declaredAt: (9 to: 21)
					by: aChangeRecord) ]
		thatSends: #changeRecord:
		to: receiver2 ] value.! !
!Behavior method!
changeDescription
	#_coverageTracker173029741_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029741_
		coverAll:
			{23 to: 26}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029741_
		coverAll:
			{28 to: 33}
		evaluating: [ receiver1 change ]
		thatSends: #change
		to: receiver1 ] value.
	#_coverageTracker173029741_
		coverAll:
			{35 to: 45}
		evaluating: [ receiver2 description ]
		thatSends: #description
		to: receiver2 ] value.! !
!Behavior method!
classNamed: className
	#_coverageTracker173029743_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029743_
		cover: (27 to: 39)
		declaredAt: (27 to: 39)
		by: classesByName.
	#_coverageTracker173029743_
		coverAll:
			{41 to: 43}
		evaluating: [
			receiver1 at:
				(#_coverageTracker173029743_
					cover: (45 to: 53)
					declaredAt: (13 to: 21)
					by: className) ]
		thatSends: #at:
		to: receiver1 ] value.! !
!Behavior method!
stateAfter: aChange
	| eventForChange eventAfter stateAfter |
	#_coverageTracker173029750_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173029750_
		cover: (67 to: 84)
		declaredAt: (67 to: 84)
		by: statesAfterChanges.
	#_coverageTracker173029750_
		coverAll:
			{86 to: 88. 98 to: 107}
		evaluating: [
			receiver1
				at:
					(#_coverageTracker173029750_
						cover: (90 to: 96)
						declaredAt: (13 to: 19)
						by: aChange)
				ifPresent: [ :aState |
					^ #_coverageTracker173029750_
						cover: (123 to: 128)
						declaredAt: (112 to: 117)
						by: aState ]]
		thatSends: #at:ifPresent:
		to: receiver1 ] value.
	#_coverageTracker173029750_
		cover: (136 to: 149)
		declaredAt: (25 to: 38)
		by:
			(eventForChange _ [ | receiver7 |
			receiver7 _ #_coverageTracker173029750_
				cover: (154 to: 159)
				declaredAt: (154 to: 159)
				by: events.
			#_coverageTracker173029750_
				coverAll:
					{161 to: 167}
				evaluating: [
					receiver7 detect: [ :event |
						[ | receiver6 |
						receiver6 _ [ | receiver3 |
						receiver3 _ [ | receiver2 |
						receiver2 _ #_coverageTracker173029750_
							cover: (180 to: 184)
							declaredAt: (172 to: 176)
							by: event.
						#_coverageTracker173029750_
							coverAll:
								{186 to: 189}
							evaluating: [ receiver2 type ]
							thatSends: #type
							to: receiver2 ] value.
						#_coverageTracker173029750_
							coverAll:
								{191 to: 191}
							evaluating: [
								receiver3 =
									(#_coverageTracker173029750_
										coverAll:
											{193 to: 199}
										byLiteralOrPseudoVariable: #change) ]
							thatSends: #=
							to: receiver3 ] value.
						#_coverageTracker173029750_
							coverAll:
								{201 to: 204}
							evaluating: [
								receiver6 and: [
									[ | receiver5 |
									receiver5 _ [ | receiver4 |
									receiver4 _ #_coverageTracker173029750_
										cover: (208 to: 212)
										declaredAt: (172 to: 176)
										by: event.
									#_coverageTracker173029750_
										coverAll:
											{214 to: 219}
										evaluating: [ receiver4 change ]
										thatSends: #change
										to: receiver4 ] value.
									#_coverageTracker173029750_
										coverAll:
											{221 to: 221}
										evaluating: [
											receiver5 =
												(#_coverageTracker173029750_
													cover: (223 to: 229)
													declaredAt: (13 to: 19)
													by: aChange) ]
										thatSends: #=
										to: receiver5 ] value ]]
							thatSends: #and:
							to: receiver6 ] value ]]
				thatSends: #detect:
				to: receiver7 ] value).
	#_coverageTracker173029750_
		cover: (236 to: 245)
		declaredAt: (40 to: 49)
		by:
			(eventAfter _ [ | receiver10 |
			receiver10 _ #_coverageTracker173029750_
				cover: (250 to: 255)
				declaredAt: (154 to: 159)
				by: events.
			#_coverageTracker173029750_
				coverAll:
					{257 to: 262. 279 to: 285}
				evaluating: [
					receiver10
						after:
							(#_coverageTracker173029750_
								cover: (264 to: 277)
								declaredAt: (25 to: 38)
								by: eventForChange)
						ifNone: [ ^ [ | receiver9 |
							receiver9 _ [ | receiver8 |
							receiver8 _ #_coverageTracker173029750_
								coverAll:
									{292 to: 295}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173029750_
								coverAll:
									{297 to: 322}
								evaluating: [
									receiver8 lastStateTransitionBefore:
										(#_coverageTracker173029750_
											cover: (324 to: 330)
											declaredAt: (13 to: 19)
											by: aChange) ]
								thatSends: #lastStateTransitionBefore:
								to: receiver8 ] value.
							#_coverageTracker173029750_
								coverAll:
									{333 to: 339}
								evaluating: [ receiver9 stateTo ]
								thatSends: #stateTo
								to: receiver9 ] value ]]
				thatSends: #after:ifNone:
				to: receiver10 ] value).
	[ | receiver16 |
	receiver16 _ [ | receiver12 |
	receiver12 _ [ | receiver11 |
	receiver11 _ #_coverageTracker173029750_
		cover: (349 to: 358)
		declaredAt: (40 to: 49)
		by: eventAfter.
	#_coverageTracker173029750_
		coverAll:
			{360 to: 363}
		evaluating: [ receiver11 type ]
		thatSends: #type
		to: receiver11 ] value.
	#_coverageTracker173029750_
		coverAll:
			{365 to: 365}
		evaluating: [
			receiver12 =
				(#_coverageTracker173029750_
					coverAll:
						{367 to: 382}
					byLiteralOrPseudoVariable: #stateTransition) ]
		thatSends: #=
		to: receiver12 ] value.
	#_coverageTracker173029750_
		coverAll:
			{388 to: 394. 436 to: 443}
		evaluating: [
			receiver16
				ifTrue: [
					#_coverageTracker173029750_
						cover: (398 to: 407)
						declaredAt: (51 to: 60)
						by:
							(stateAfter _ [ | receiver13 |
							receiver13 _ #_coverageTracker173029750_
								cover: (412 to: 421)
								declaredAt: (40 to: 49)
								by: eventAfter.
							#_coverageTracker173029750_
								coverAll:
									{423 to: 429}
								evaluating: [ receiver13 stateTo ]
								thatSends: #stateTo
								to: receiver13 ] value) ]
				ifFalse: [
					#_coverageTracker173029750_
						cover: (447 to: 456)
						declaredAt: (51 to: 60)
						by:
							(stateAfter _ [ | receiver15 |
							receiver15 _ [ | receiver14 |
							receiver14 _ #_coverageTracker173029750_
								coverAll:
									{462 to: 465}
								byLiteralOrPseudoVariable: self.
							#_coverageTracker173029750_
								coverAll:
									{467 to: 492}
								evaluating: [
									receiver14 lastStateTransitionBefore:
										(#_coverageTracker173029750_
											cover: (494 to: 500)
											declaredAt: (13 to: 19)
											by: aChange) ]
								thatSends: #lastStateTransitionBefore:
								to: receiver14 ] value.
							#_coverageTracker173029750_
								coverAll:
									{503 to: 509}
								evaluating: [ receiver15 stateTo ]
								thatSends: #stateTo
								to: receiver15 ] value) ]]
		thatSends: #ifTrue:ifFalse:
		to: receiver16 ] value.
	[ | receiver17 |
	receiver17 _ #_coverageTracker173029750_
		cover: (518 to: 535)
		declaredAt: (67 to: 84)
		by: statesAfterChanges.
	#_coverageTracker173029750_
		coverAll:
			{537 to: 539. 549 to: 552}
		evaluating: [
			receiver17
				at:
					(#_coverageTracker173029750_
						cover: (541 to: 547)
						declaredAt: (13 to: 19)
						by: aChange)
				put:
					(#_coverageTracker173029750_
						cover: (554 to: 563)
						declaredAt: (51 to: 60)
						by: stateAfter) ]
		thatSends: #at:put:
		to: receiver17 ] value.
	^ #_coverageTracker173029750_
		cover: (569 to: 578)
		declaredAt: (51 to: 60)
		by: stateAfter.! !
!Behavior method!
methodRemovedWhileWritingATest: aSymbol class: aSymbol2
	#_coverageTracker173029786_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029786_
		coverAll:
			{62 to: 65}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029786_
		coverAll:
			{67 to: 78. 88 to: 93}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173029786_
						cover: (80 to: 86)
						declaredAt: (33 to: 39)
						by: aSymbol)
				class:
					(#_coverageTracker173029786_
						cover: (95 to: 102)
						declaredAt: (48 to: 55)
						by: aSymbol2) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173029786_
		coverAll:
			{104 to: 104}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173029786_
					coverAll:
						{106 to: 140}
					byLiteralOrPseudoVariable: ' was removed while writing a test') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
modelMethodWasNotUsedDuringRefactor: aSymbol class: aSymbol2
	#_coverageTracker173029800_ markAsExecuted.
	^ [ | receiver2 |
	receiver2 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029800_
		coverAll:
			{67 to: 70}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029800_
		coverAll:
			{72 to: 83. 93 to: 98}
		evaluating: [
			receiver1
				printMethod:
					(#_coverageTracker173029800_
						cover: (85 to: 91)
						declaredAt: (38 to: 44)
						by: aSymbol)
				class:
					(#_coverageTracker173029800_
						cover: (100 to: 107)
						declaredAt: (53 to: 60)
						by: aSymbol2) ]
		thatSends: #printMethod:class:
		to: receiver1 ] value.
	#_coverageTracker173029800_
		coverAll:
			{109 to: 109}
		evaluating: [
			receiver2 ,
				(#_coverageTracker173029800_
					coverAll:
						{111 to: 178}
					byLiteralOrPseudoVariable: ' was added but never used during Refactor. Probably not doing TDD.') ]
		thatSends: #,
		to: receiver2 ] value.! !
!Behavior method!
testRenamedFrom: aTestSelector to: aTestSelector2
	#_coverageTracker173029805_ markAsExecuted.! !
!Behavior method!
selectedChangeDetail
	| detail currentChange correctLabel errorLabel |
	#_coverageTracker173029809_ markAsExecuted.
	#_coverageTracker173029809_
		cover: (76 to: 81)
		declaredAt: (26 to: 31)
		by:
			(detail _ #_coverageTracker173029809_
				coverAll:
					{86 to: 87}
				byLiteralOrPseudoVariable: '').
	#_coverageTracker173029809_
		cover: (91 to: 102)
		declaredAt: (47 to: 58)
		by:
			(correctLabel _ [ | receiver4 |
			receiver4 _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029809_
				coverAll:
					{107 to: 115}
				byLiteralOrPseudoVariable: 'CORRECT'.
			#_coverageTracker173029809_
				coverAll:
					{117 to: 122}
				evaluating: [ receiver1 asText ]
				thatSends: #asText
				to: receiver1 ] value.
			#_coverageTracker173029809_
				coverAll:
					{124 to: 136}
				evaluating: [
					receiver4 addAttribute:
						[ | receiver3 |
						receiver3 _ #_coverageTracker173029809_
							coverAll:
								{139 to: 147}
							by: TextColor.
						#_coverageTracker173029809_
							coverAll:
								{149 to: 154}
							evaluating: [
								receiver3 color:
									[ | receiver2 |
									receiver2 _ #_coverageTracker173029809_
										coverAll:
											{156 to: 175}
										by: AnalysisResultWindow.
									#_coverageTracker173029809_
										coverAll:
											{177 to: 188}
										evaluating: [ receiver2 successColor ]
										thatSends: #successColor
										to: receiver2 ] value ]
							thatSends: #color:
							to: receiver3 ] value ]
				thatSends: #addAttribute:
				to: receiver4 ] value).
	#_coverageTracker173029809_
		cover: (193 to: 202)
		declaredAt: (60 to: 69)
		by:
			(errorLabel _ [ | receiver8 |
			receiver8 _ [ | receiver5 |
			receiver5 _ #_coverageTracker173029809_
				coverAll:
					{207 to: 213}
				byLiteralOrPseudoVariable: 'ERROR'.
			#_coverageTracker173029809_
				coverAll:
					{215 to: 220}
				evaluating: [ receiver5 asText ]
				thatSends: #asText
				to: receiver5 ] value.
			#_coverageTracker173029809_
				coverAll:
					{222 to: 234}
				evaluating: [
					receiver8 addAttribute:
						[ | receiver7 |
						receiver7 _ #_coverageTracker173029809_
							coverAll:
								{237 to: 245}
							by: TextColor.
						#_coverageTracker173029809_
							coverAll:
								{247 to: 252}
							evaluating: [
								receiver7 color:
									[ | receiver6 |
									receiver6 _ #_coverageTracker173029809_
										coverAll:
											{254 to: 273}
										by: AnalysisResultWindow.
									#_coverageTracker173029809_
										coverAll:
											{275 to: 284}
										evaluating: [ receiver6 errorColor ]
										thatSends: #errorColor
										to: receiver6 ] value ]
							thatSends: #color:
							to: receiver7 ] value ]
				thatSends: #addAttribute:
				to: receiver8 ] value).
	[ | receiver21 |
	receiver21 _ [ | receiver9 |
	receiver9 _ #_coverageTracker173029809_
		coverAll:
			{292 to: 295}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029809_
		coverAll:
			{297 to: 309}
		evaluating: [ receiver9 selectedEvent ]
		thatSends: #selectedEvent
		to: receiver9 ] value.
	#_coverageTracker173029809_
		coverAll:
			{311 to: 319}
		evaluating: [
			receiver21 ifNotNil: [
				#_coverageTracker173029809_
					cover: (325 to: 337)
					declaredAt: (33 to: 45)
					by:
						(currentChange _ [ | receiver10 |
						receiver10 _ #_coverageTracker173029809_
							cover: (342 to: 354)
							declaredAt: (342 to: 354)
							by: selectedEvent.
						#_coverageTracker173029809_
							coverAll:
								{356 to: 361}
							evaluating: [ receiver10 change ]
							thatSends: #change
							to: receiver10 ] value).
				[ | receiver16 |
				receiver16 _ [ | receiver11 |
				receiver11 _ #_coverageTracker173029809_
					cover: (367 to: 380)
					declaredAt: (367 to: 380)
					by: analysisResult.
				#_coverageTracker173029809_
					coverAll:
						{382 to: 391}
					evaluating: [
						receiver11 isCorrect:
							(#_coverageTracker173029809_
								cover: (393 to: 405)
								declaredAt: (33 to: 45)
								by: currentChange) ]
					thatSends: #isCorrect:
					to: receiver11 ] value.
				#_coverageTracker173029809_
					coverAll:
						{411 to: 417. 472 to: 479}
					evaluating: [
						receiver16
							ifTrue: [
								#_coverageTracker173029809_
									cover: (421 to: 426)
									declaredAt: (26 to: 31)
									by:
										(detail _ [ | receiver13 |
										receiver13 _ #_coverageTracker173029809_
											cover: (431 to: 442)
											declaredAt: (47 to: 58)
											by: correctLabel.
										#_coverageTracker173029809_
											coverAll:
												{443 to: 443}
											evaluating: [
												receiver13 ,
													[ | receiver12 |
													receiver12 _ #_coverageTracker173029809_
														coverAll:
															{445 to: 450}
														by: String.
													#_coverageTracker173029809_
														coverAll:
															{452 to: 464}
														evaluating: [ receiver12 newLineString ]
														thatSends: #newLineString
														to: receiver12 ] value ]
											thatSends: #,
											to: receiver13 ] value) ]
							ifFalse: [
								#_coverageTracker173029809_
									cover: (483 to: 488)
									declaredAt: (26 to: 31)
									by:
										(detail _ [ | receiver15 |
										receiver15 _ #_coverageTracker173029809_
											cover: (493 to: 502)
											declaredAt: (60 to: 69)
											by: errorLabel.
										#_coverageTracker173029809_
											coverAll:
												{503 to: 503}
											evaluating: [
												receiver15 ,
													[ | receiver14 |
													receiver14 _ #_coverageTracker173029809_
														coverAll:
															{505 to: 510}
														by: String.
													#_coverageTracker173029809_
														coverAll:
															{512 to: 524}
														evaluating: [ receiver14 newLineString ]
														thatSends: #newLineString
														to: receiver14 ] value ]
											thatSends: #,
											to: receiver15 ] value) ]]
					thatSends: #ifTrue:ifFalse:
					to: receiver16 ] value.
				[ | receiver20 |
				receiver20 _ [ | receiver17 |
				receiver17 _ #_coverageTracker173029809_
					cover: (536 to: 549)
					declaredAt: (367 to: 380)
					by: analysisResult.
				#_coverageTracker173029809_
					coverAll:
						{551 to: 559}
					evaluating: [
						receiver17 hasError:
							(#_coverageTracker173029809_
								cover: (561 to: 573)
								declaredAt: (33 to: 45)
								by: currentChange) ]
					thatSends: #hasError:
					to: receiver17 ] value.
				#_coverageTracker173029809_
					coverAll:
						{576 to: 582}
					evaluating: [
						receiver20 ifTrue: [
							#_coverageTracker173029809_
								cover: (600 to: 605)
								declaredAt: (26 to: 31)
								by:
									(detail _ [ | receiver19 |
									receiver19 _ #_coverageTracker173029809_
										cover: (590 to: 595)
										declaredAt: (26 to: 31)
										by: detail.
									#_coverageTracker173029809_
										coverAll:
											{606 to: 606}
										evaluating: [
											receiver19 ,
												[ | receiver18 |
												receiver18 _ #_coverageTracker173029809_
													cover: (609 to: 622)
													declaredAt: (367 to: 380)
													by: analysisResult.
												#_coverageTracker173029809_
													coverAll:
														{624 to: 631}
													evaluating: [
														receiver18 errorIn:
															(#_coverageTracker173029809_
																cover: (633 to: 645)
																declaredAt: (33 to: 45)
																by: currentChange) ]
													thatSends: #errorIn:
													to: receiver18 ] value ]
										thatSends: #,
										to: receiver19 ] value) ]]
					thatSends: #ifTrue:
					to: receiver20 ] value ]]
		thatSends: #ifNotNil:
		to: receiver21 ] value.
	^ [ | receiver22 |
	receiver22 _ #_coverageTracker173029809_
		cover: (659 to: 664)
		declaredAt: (26 to: 31)
		by: detail.
	#_coverageTracker173029809_
		coverAll:
			{666 to: 671}
		evaluating: [ receiver22 asText ]
		thatSends: #asText
		to: receiver22 ] value.! !
!Behavior method!
overridesASuperclassMethod
	#_coverageTracker173029855_ markAsExecuted.
	^ #_coverageTracker173029855_
		cover: (31 to: 39)
		declaredAt: (31 to: 39)
		by: overrides.! !
!Behavior method!
category
	#_coverageTracker173029857_ markAsExecuted.
	^ #_coverageTracker173029857_
		coverAll:
			{13 to: 20}
		byLiteralOrPseudoVariable: #testRun.! !
!Behavior method!
productionMethodChangedDetector
	#_coverageTracker173029859_ markAsExecuted.
	^ [ | receiver14 |
	receiver14 _ #_coverageTracker173029859_
		coverAll:
			{36 to: 49}
		by: ChangeDetector.
	#_coverageTracker173029859_
		coverAll:
			{51 to: 54. 75 to: 88. 92 to: 103}
		evaluating: [
			receiver14
				for:
					(#_coverageTracker173029859_
						coverAll:
							{56 to: 73}
						by: ModelMethodChanged)
				withLookahead:
					(#_coverageTracker173029859_
						coverAll:
							{90 to: 90}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver13 |
					receiver13 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173029859_
						cover: (124 to: 136)
						declaredAt: (108 to: 120)
						by: aChangeRecord.
					#_coverageTracker173029859_
						coverAll:
							{138 to: 147}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173029859_
						coverAll:
							{149 to: 149}
						evaluating: [
							receiver2 =
								(#_coverageTracker173029859_
									coverAll:
										{151 to: 157}
									byLiteralOrPseudoVariable: #method) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173029859_
						coverAll:
							{162 to: 165. 209 to: 212. 270 to: 273. 308 to: 311}
						evaluating: [
							receiver13
								and: [
									[ | receiver4 |
									receiver4 _ [ | receiver3 |
									receiver3 _ #_coverageTracker173029859_
										cover: (169 to: 181)
										declaredAt: (108 to: 120)
										by: aChangeRecord.
									#_coverageTracker173029859_
										coverAll:
											{183 to: 198}
										evaluating: [ receiver3 isMethodDeletion ]
										thatSends: #isMethodDeletion
										to: receiver3 ] value.
									#_coverageTracker173029859_
										coverAll:
											{200 to: 202}
										evaluating: [ receiver4 not ]
										thatSends: #not
										to: receiver4 ] value ]
								and: [
									[ | receiver7 |
									receiver7 _ [ | receiver6 |
									receiver6 _ [ | receiver5 |
									receiver5 _ #_coverageTracker173029859_
										cover: (217 to: 229)
										declaredAt: (108 to: 120)
										by: aChangeRecord.
									#_coverageTracker173029859_
										coverAll:
											{231 to: 244}
										evaluating: [ receiver5 methodSelector ]
										thatSends: #methodSelector
										to: receiver5 ] value.
									#_coverageTracker173029859_
										coverAll:
											{246 to: 259}
										evaluating: [ receiver6 isTestSelector ]
										thatSends: #isTestSelector
										to: receiver6 ] value.
									#_coverageTracker173029859_
										coverAll:
											{262 to: 264}
										evaluating: [ receiver7 not ]
										thatSends: #not
										to: receiver7 ] value ]
								and: [
									[ | receiver9 |
									receiver9 _ [ | receiver8 |
									receiver8 _ #_coverageTracker173029859_
										cover: (277 to: 289)
										declaredAt: (108 to: 120)
										by: aChangeRecord.
									#_coverageTracker173029859_
										coverAll:
											{291 to: 295}
										evaluating: [ receiver8 prior ]
										thatSends: #prior
										to: receiver8 ] value.
									#_coverageTracker173029859_
										coverAll:
											{297 to: 302}
										evaluating: [ receiver9 notNil ]
										thatSends: #notNil
										to: receiver9 ] value ]
								and: [
									[ | receiver12 |
									receiver12 _ [ | receiver11 |
									receiver11 _ #_coverageTracker173029859_
										coverAll:
											{316 to: 319}
										byLiteralOrPseudoVariable: self.
									#_coverageTracker173029859_
										coverAll:
											{321 to: 333}
										evaluating: [
											receiver11 isATestClass:
												[ | receiver10 |
												receiver10 _ #_coverageTracker173029859_
													cover: (335 to: 347)
													declaredAt: (108 to: 120)
													by: aChangeRecord.
												#_coverageTracker173029859_
													coverAll:
														{349 to: 363}
													evaluating: [ receiver10 changeClassName ]
													thatSends: #changeClassName
													to: receiver10 ] value ]
										thatSends: #isATestClass:
										to: receiver11 ] value.
									#_coverageTracker173029859_
										coverAll:
											{366 to: 368}
										evaluating: [ receiver12 not ]
										thatSends: #not
										to: receiver12 ] value ]]
						thatSends: #and:and:and:and:
						to: receiver13 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver14 ] value.! !
!Behavior method!
lookaheadRecordsFrom: aChangeList
	| lookaheads |
	#_coverageTracker173029889_ markAsExecuted.
	#_coverageTracker173029889_
		cover: (54 to: 63)
		declaredAt: (38 to: 47)
		by:
			(lookaheads _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029889_
				coverAll:
					{68 to: 84}
				by: OrderedCollection.
			#_coverageTracker173029889_
				coverAll:
					{86 to: 88}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	[ | receiver4 |
	receiver4 _ #_coverageTracker173029889_
		coverAll:
			{94 to: 94}
		byLiteralOrPseudoVariable: 1.
	#_coverageTracker173029889_
		coverAll:
			{96 to: 98. 110 to: 112}
		evaluating: [
			receiver4
				to:
					(#_coverageTracker173029889_
						cover: (100 to: 108)
						declaredAt: (100 to: 108)
						by: lookahead)
				do: [ :index |
					[ | receiver3 |
					receiver3 _ #_coverageTracker173029889_
						cover: (125 to: 134)
						declaredAt: (38 to: 47)
						by: lookaheads.
					#_coverageTracker173029889_
						coverAll:
							{136 to: 139}
						evaluating: [
							receiver3 add:
								[ | receiver2 |
								receiver2 _ #_coverageTracker173029889_
									cover: (142 to: 152)
									declaredAt: (23 to: 33)
									by: aChangeList.
								#_coverageTracker173029889_
									coverAll:
										{154 to: 156. 164 to: 172}
									evaluating: [
										receiver2
											at:
												(#_coverageTracker173029889_
													cover: (158 to: 162)
													declaredAt: (117 to: 121)
													by: index)
											ifAbsent: [
												#_coverageTracker173029889_
													coverAll:
														{176 to: 178}
													byLiteralOrPseudoVariable: nil ]]
									thatSends: #at:ifAbsent:
									to: receiver2 ] value ]
						thatSends: #add:
						to: receiver3 ] value ]]
		thatSends: #to:do:
		to: receiver4 ] value.
	^ #_coverageTracker173029889_
		cover: (191 to: 200)
		declaredAt: (38 to: 47)
		by: lookaheads.! !
!Behavior method!
successColor
	#_coverageTracker173029896_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173029896_
		coverAll:
			{17 to: 21}
		by: Color.
	#_coverageTracker173029896_
		coverAll:
			{23 to: 36}
		evaluating: [
			receiver1 fromHexString:
				(#_coverageTracker173029896_
					coverAll:
						{38 to: 46}
					byLiteralOrPseudoVariable: '#006200') ]
		thatSends: #fromHexString:
		to: receiver1 ] value.! !
!Behavior method!
stateTransitionColor: aTDDState
	#_coverageTracker173029903_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029903_
		cover: (34 to: 42)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{44 to: 44}
		evaluating: [
			receiver1 =
				(#_coverageTracker173029903_
					coverAll:
						{46 to: 50}
					by: Green) ]
		thatSends: #=
		to: receiver1 ] value.
	#_coverageTracker173029903_
		coverAll:
			{52 to: 58}
		evaluating: [ receiver3 ifTrue: [ ^ [ | receiver2 |
				receiver2 _ #_coverageTracker173029903_
					coverAll:
						{64 to: 68}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{70 to: 83}
					evaluating: [
						receiver2 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{85 to: 93}
								byLiteralOrPseudoVariable: '#28a745') ]
					thatSends: #fromHexString:
					to: receiver2 ] value ]]
		thatSends: #ifTrue:
		to: receiver3 ] value.
	[ | receiver6 |
	receiver6 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173029903_
		cover: (99 to: 107)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{109 to: 109}
		evaluating: [
			receiver4 =
				(#_coverageTracker173029903_
					coverAll:
						{111 to: 113}
					by: Red) ]
		thatSends: #=
		to: receiver4 ] value.
	#_coverageTracker173029903_
		coverAll:
			{115 to: 121}
		evaluating: [ receiver6 ifTrue: [ ^ [ | receiver5 |
				receiver5 _ #_coverageTracker173029903_
					coverAll:
						{127 to: 131}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{133 to: 146}
					evaluating: [
						receiver5 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{148 to: 156}
								byLiteralOrPseudoVariable: '#dc3545') ]
					thatSends: #fromHexString:
					to: receiver5 ] value ]]
		thatSends: #ifTrue:
		to: receiver6 ] value.
	[ | receiver9 |
	receiver9 _ [ | receiver7 |
	receiver7 _ #_coverageTracker173029903_
		cover: (162 to: 170)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{172 to: 172}
		evaluating: [
			receiver7 =
				(#_coverageTracker173029903_
					coverAll:
						{174 to: 192}
					by: WritingAFailingTest) ]
		thatSends: #=
		to: receiver7 ] value.
	#_coverageTracker173029903_
		coverAll:
			{194 to: 200}
		evaluating: [ receiver9 ifTrue: [ ^ [ | receiver8 |
				receiver8 _ #_coverageTracker173029903_
					coverAll:
						{206 to: 210}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{212 to: 225}
					evaluating: [
						receiver8 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{227 to: 235}
								byLiteralOrPseudoVariable: '#ffc107') ]
					thatSends: #fromHexString:
					to: receiver8 ] value ]]
		thatSends: #ifTrue:
		to: receiver9 ] value.
	[ | receiver12 |
	receiver12 _ [ | receiver10 |
	receiver10 _ #_coverageTracker173029903_
		cover: (241 to: 249)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{251 to: 251}
		evaluating: [
			receiver10 =
				(#_coverageTracker173029903_
					coverAll:
						{253 to: 274}
					by: MoreThanOneTestWritten) ]
		thatSends: #=
		to: receiver10 ] value.
	#_coverageTracker173029903_
		coverAll:
			{276 to: 282}
		evaluating: [ receiver12 ifTrue: [ ^ [ | receiver11 |
				receiver11 _ #_coverageTracker173029903_
					coverAll:
						{288 to: 292}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{294 to: 307}
					evaluating: [
						receiver11 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{309 to: 317}
								byLiteralOrPseudoVariable: '#ffc107') ]
					thatSends: #fromHexString:
					to: receiver11 ] value ]]
		thatSends: #ifTrue:
		to: receiver12 ] value.
	[ | receiver15 |
	receiver15 _ [ | receiver13 |
	receiver13 _ #_coverageTracker173029903_
		cover: (323 to: 331)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{333 to: 333}
		evaluating: [
			receiver13 =
				(#_coverageTracker173029903_
					coverAll:
						{335 to: 345}
					by: NotDoingTDD) ]
		thatSends: #=
		to: receiver13 ] value.
	#_coverageTracker173029903_
		coverAll:
			{347 to: 353}
		evaluating: [ receiver15 ifTrue: [ ^ [ | receiver14 |
				receiver14 _ #_coverageTracker173029903_
					coverAll:
						{359 to: 363}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{365 to: 378}
					evaluating: [
						receiver14 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{380 to: 388}
								byLiteralOrPseudoVariable: '#343a40') ]
					thatSends: #fromHexString:
					to: receiver14 ] value ]]
		thatSends: #ifTrue:
		to: receiver15 ] value.
	[ | receiver18 |
	receiver18 _ [ | receiver16 |
	receiver16 _ #_coverageTracker173029903_
		cover: (394 to: 402)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{404 to: 404}
		evaluating: [
			receiver16 =
				(#_coverageTracker173029903_
					coverAll:
						{406 to: 413}
					by: Refactor) ]
		thatSends: #=
		to: receiver16 ] value.
	#_coverageTracker173029903_
		coverAll:
			{415 to: 421}
		evaluating: [ receiver18 ifTrue: [ ^ [ | receiver17 |
				receiver17 _ #_coverageTracker173029903_
					coverAll:
						{427 to: 431}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{433 to: 446}
					evaluating: [
						receiver17 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{448 to: 456}
								byLiteralOrPseudoVariable: '#007bff') ]
					thatSends: #fromHexString:
					to: receiver17 ] value ]]
		thatSends: #ifTrue:
		to: receiver18 ] value.
	[ | receiver21 |
	receiver21 _ [ | receiver19 |
	receiver19 _ #_coverageTracker173029903_
		cover: (462 to: 470)
		declaredAt: (23 to: 31)
		by: aTDDState.
	#_coverageTracker173029903_
		coverAll:
			{472 to: 472}
		evaluating: [
			receiver19 =
				(#_coverageTracker173029903_
					coverAll:
						{474 to: 483}
					by: NotStarted) ]
		thatSends: #=
		to: receiver19 ] value.
	#_coverageTracker173029903_
		coverAll:
			{485 to: 491}
		evaluating: [ receiver21 ifTrue: [ ^ [ | receiver20 |
				receiver20 _ #_coverageTracker173029903_
					coverAll:
						{497 to: 501}
					by: Color.
				#_coverageTracker173029903_
					coverAll:
						{503 to: 516}
					evaluating: [
						receiver20 fromHexString:
							(#_coverageTracker173029903_
								coverAll:
									{518 to: 526}
								byLiteralOrPseudoVariable: '#17a2b8') ]
					thatSends: #fromHexString:
					to: receiver20 ] value ]]
		thatSends: #ifTrue:
		to: receiver21 ] value.
	^ [ | receiver22 |
	receiver22 _ #_coverageTracker173029903_
		coverAll:
			{536 to: 540}
		by: Color.
	#_coverageTracker173029903_
		coverAll:
			{542 to: 546}
		evaluating: [ receiver22 green ]
		thatSends: #green
		to: receiver22 ] value.! !
!Behavior method!
newFor: aNewTestChangeRecord and: aTestRemovedChangeRecord
	#_coverageTracker173029946_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173029946_
		coverAll:
			{63 to: 66}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173029946_
		coverAll:
			{68 to: 70}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173029946_
		coverAll:
			{72 to: 91}
		evaluating: [
			receiver2 newTestChangeRecord:
				(#_coverageTracker173029946_
					cover: (93 to: 112)
					declaredAt: (9 to: 28)
					by: aNewTestChangeRecord) ]
		thatSends: #newTestChangeRecord:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173029946_
		coverAll:
			{115 to: 138}
		evaluating: [
			receiver3 testRemovedChangeRecord:
				(#_coverageTracker173029946_
					cover: (140 to: 163)
					declaredAt: (35 to: 58)
					by: aTestRemovedChangeRecord) ]
		thatSends: #testRemovedChangeRecord:
		to: receiver3 ] value ] value.! !
!Behavior method!
firstTest: aMethodReference secondTest: anotherMethodReference
	#_coverageTracker173029953_ markAsExecuted.
	#_coverageTracker173029953_
		cover: (65 to: 73)
		declaredAt: (65 to: 73)
		by:
			(firstTest _ #_coverageTracker173029953_
				cover: (78 to: 93)
				declaredAt: (12 to: 27)
				by: aMethodReference).
	#_coverageTracker173029953_
		cover: (97 to: 106)
		declaredAt: (97 to: 106)
		by:
			(secondTest _ #_coverageTracker173029953_
				cover: (111 to: 132)
				declaredAt: (41 to: 62)
				by: anotherMethodReference).
	#_coverageTracker173029953_
		cover: (136 to: 144)
		declaredAt: (136 to: 144)
		by:
			(isCorrect _ #_coverageTracker173029953_
				coverAll:
					{149 to: 152}
				byLiteralOrPseudoVariable: true).! !
!Behavior method!
newModelClass: aSymbol
	#_coverageTracker173029958_ markAsExecuted.! !
!Behavior method!
modelMethodAddedBeforeRunningTests: aSymbol class: aSymbol2
	#_coverageTracker173029959_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ [ | receiver2 |
	receiver2 _ #_coverageTracker173029959_
		coverAll:
			{65 to: 79}
		byLiteralOrPseudoVariable: 'Model method '.
	#_coverageTracker173029959_
		coverAll:
			{80 to: 80}
		evaluating: [
			receiver2 ,
				[ | receiver1 |
				receiver1 _ #_coverageTracker173029959_
					coverAll:
						{83 to: 86}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173029959_
					coverAll:
						{88 to: 99. 109 to: 114}
					evaluating: [
						receiver1
							printMethod:
								(#_coverageTracker173029959_
									cover: (101 to: 107)
									declaredAt: (37 to: 43)
									by: aSymbol)
							class:
								(#_coverageTracker173029959_
									cover: (116 to: 123)
									declaredAt: (52 to: 59)
									by: aSymbol2) ]
					thatSends: #printMethod:class:
					to: receiver1 ] value ]
		thatSends: #,
		to: receiver2 ] value.
	#_coverageTracker173029959_
		coverAll:
			{125 to: 125}
		evaluating: [
			receiver3 ,
				(#_coverageTracker173029959_
					coverAll:
						{127 to: 169}
					byLiteralOrPseudoVariable: ' was added before running the tests first') ]
		thatSends: #,
		to: receiver3 ] value.! !
!Behavior method!
description
	#_coverageTracker173029965_ markAsExecuted.
	^ #_coverageTracker173029965_
		coverAll:
			{16 to: 31}
		byLiteralOrPseudoVariable: 'Unknown change'.! !
!Behavior method!
initializeChangeLog
	| fileStream changeList file changes |
	#_coverageTracker173029970_ markAsExecuted.
	#_coverageTracker173029970_
		cover: (64 to: 72)
		declaredAt: (64 to: 72)
		by:
			(changeLog _ [ | receiver1 |
			receiver1 _ #_coverageTracker173029970_
				coverAll:
					{77 to: 93}
				by: OrderedCollection.
			#_coverageTracker173029970_
				coverAll:
					{95 to: 97}
				evaluating: [ receiver1 new ]
				thatSends: #new
				to: receiver1 ] value).
	#_coverageTracker173029970_
		cover: (101 to: 104)
		declaredAt: (46 to: 49)
		by:
			(file _ [ | receiver2 |
			receiver2 _ #_coverageTracker173029970_
				cover: (109 to: 119)
				declaredAt: (109 to: 119)
				by: changesFile.
			#_coverageTracker173029970_
				coverAll:
					{121 to: 131}
				evaluating: [ receiver2 asFileEntry ]
				thatSends: #asFileEntry
				to: receiver2 ] value).
	[ | receiver12 |
	receiver12 _ [ | receiver3 |
	receiver3 _ #_coverageTracker173029970_
		cover: (137 to: 140)
		declaredAt: (46 to: 49)
		by: file.
	#_coverageTracker173029970_
		coverAll:
			{142 to: 147}
		evaluating: [ receiver3 exists ]
		thatSends: #exists
		to: receiver3 ] value.
	#_coverageTracker173029970_
		coverAll:
			{149 to: 155}
		evaluating: [
			receiver12 ifTrue: [
				#_coverageTracker173029970_
					cover: (161 to: 170)
					declaredAt: (24 to: 33)
					by:
						(fileStream _ [ | receiver4 |
						receiver4 _ #_coverageTracker173029970_
							cover: (175 to: 178)
							declaredAt: (46 to: 49)
							by: file.
						#_coverageTracker173029970_
							coverAll:
								{180 to: 189}
							evaluating: [ receiver4 readStream ]
							thatSends: #readStream
							to: receiver4 ] value).
				#_coverageTracker173029970_
					cover: (194 to: 203)
					declaredAt: (35 to: 44)
					by:
						(changeList _ [ | receiver8 |
						receiver8 _ [ | receiver7 |
						receiver7 _ [ | receiver5 |
						receiver5 _ #_coverageTracker173029970_
							coverAll:
								{209 to: 218}
							by: ChangeList.
						#_coverageTracker173029970_
							coverAll:
								{220 to: 222}
							evaluating: [ receiver5 new ]
							thatSends: #new
							to: receiver5 ] value.
						#_coverageTracker173029970_
							coverAll:
								{224 to: 232. 245 to: 249. 276 to: 278}
							evaluating: [
								receiver7
									scanFile:
										(#_coverageTracker173029970_
											cover: (234 to: 243)
											declaredAt: (24 to: 33)
											by: fileStream)
									from:
										(#_coverageTracker173029970_
											cover: (251 to: 274)
											declaredAt: (251 to: 274)
											by: changesFileStartPosition)
									to:
										[ | receiver6 |
										receiver6 _ #_coverageTracker173029970_
											cover: (280 to: 289)
											declaredAt: (24 to: 33)
											by: fileStream.
										#_coverageTracker173029970_
											coverAll:
												{291 to: 294}
											evaluating: [ receiver6 size ]
											thatSends: #size
											to: receiver6 ] value ]
							thatSends: #scanFile:from:to:
							to: receiver7 ] value.
						#_coverageTracker173029970_
							coverAll:
								{297 to: 306}
							evaluating: [ receiver8 changeList ]
							thatSends: #changeList
							to: receiver8 ] value).
				#_coverageTracker173029970_
					cover: (311 to: 317)
					declaredAt: (51 to: 57)
					by:
						(changes _ [ | receiver10 |
						receiver10 _ #_coverageTracker173029970_
							cover: (322 to: 331)
							declaredAt: (35 to: 44)
							by: changeList.
						#_coverageTracker173029970_
							coverAll:
								{333 to: 341. 357 to: 359}
							evaluating: [
								receiver10
									copyFrom:
										(#_coverageTracker173029970_
											cover: (343 to: 355)
											declaredAt: (343 to: 355)
											by: startingPoint)
									to:
										[ | receiver9 |
										receiver9 _ #_coverageTracker173029970_
											cover: (361 to: 370)
											declaredAt: (35 to: 44)
											by: changeList.
										#_coverageTracker173029970_
											coverAll:
												{372 to: 375}
											evaluating: [ receiver9 size ]
											thatSends: #size
											to: receiver9 ] value ]
							thatSends: #copyFrom:to:
							to: receiver10 ] value).
				#_coverageTracker173029970_
					cover: (380 to: 388)
					declaredAt: (64 to: 72)
					by:
						(changeLog _ [ | receiver11 |
						receiver11 _ #_coverageTracker173029970_
							coverAll:
								{393 to: 401}
							by: ChangeLog.
						#_coverageTracker173029970_
							coverAll:
								{403 to: 407. 417 to: 422}
							evaluating: [
								receiver11
									from:
										(#_coverageTracker173029970_
											cover: (409 to: 415)
											declaredAt: (51 to: 57)
											by: changes)
									using:
										(#_coverageTracker173029970_
											cover: (424 to: 432)
											declaredAt: (424 to: 432)
											by: inventory) ]
							thatSends: #from:using:
							to: receiver11 ] value) ]]
		thatSends: #ifTrue:
		to: receiver12 ] value.! !
!Behavior method!
newProductionMethodDetector
	#_coverageTracker173030000_ markAsExecuted.
	^ [ | receiver11 |
	receiver11 _ #_coverageTracker173030000_
		coverAll:
			{32 to: 45}
		by: ChangeDetector.
	#_coverageTracker173030000_
		coverAll:
			{47 to: 50. 67 to: 80. 84 to: 95}
		evaluating: [
			receiver11
				for:
					(#_coverageTracker173030000_
						coverAll:
							{52 to: 65}
						by: NewModelMethod)
				withLookahead:
					(#_coverageTracker173030000_
						coverAll:
							{82 to: 82}
						byLiteralOrPseudoVariable: 1)
				detectsWhen: [ :aChangeRecord |
					[ | receiver10 |
					receiver10 _ [ | receiver2 |
					receiver2 _ [ | receiver1 |
					receiver1 _ #_coverageTracker173030000_
						cover: (116 to: 128)
						declaredAt: (100 to: 112)
						by: aChangeRecord.
					#_coverageTracker173030000_
						coverAll:
							{130 to: 139}
						evaluating: [ receiver1 changeType ]
						thatSends: #changeType
						to: receiver1 ] value.
					#_coverageTracker173030000_
						coverAll:
							{141 to: 141}
						evaluating: [
							receiver2 =
								(#_coverageTracker173030000_
									coverAll:
										{143 to: 149}
									byLiteralOrPseudoVariable: #method) ]
						thatSends: #=
						to: receiver2 ] value.
					#_coverageTracker173030000_
						coverAll:
							{154 to: 157. 201 to: 204. 267 to: 270}
						evaluating: [
							receiver10
								and: [
									[ | receiver4 |
									receiver4 _ [ | receiver3 |
									receiver3 _ #_coverageTracker173030000_
										cover: (161 to: 173)
										declaredAt: (100 to: 112)
										by: aChangeRecord.
									#_coverageTracker173030000_
										coverAll:
											{175 to: 190}
										evaluating: [ receiver3 isMethodDeletion ]
										thatSends: #isMethodDeletion
										to: receiver3 ] value.
									#_coverageTracker173030000_
										coverAll:
											{192 to: 194}
										evaluating: [ receiver4 not ]
										thatSends: #not
										to: receiver4 ] value ]
								and: [
									[ | receiver7 |
									receiver7 _ [ | receiver6 |
									receiver6 _ #_coverageTracker173030000_
										coverAll:
											{209 to: 212}
										byLiteralOrPseudoVariable: self.
									#_coverageTracker173030000_
										coverAll:
											{214 to: 226}
										evaluating: [
											receiver6 isATestClass:
												[ | receiver5 |
												receiver5 _ #_coverageTracker173030000_
													cover: (228 to: 240)
													declaredAt: (100 to: 112)
													by: aChangeRecord.
												#_coverageTracker173030000_
													coverAll:
														{242 to: 256}
													evaluating: [ receiver5 changeClassName ]
													thatSends: #changeClassName
													to: receiver5 ] value ]
										thatSends: #isATestClass:
										to: receiver6 ] value.
									#_coverageTracker173030000_
										coverAll:
											{259 to: 261}
										evaluating: [ receiver7 not ]
										thatSends: #not
										to: receiver7 ] value ]
								and: [
									[ | receiver9 |
									receiver9 _ [ | receiver8 |
									receiver8 _ #_coverageTracker173030000_
										cover: (274 to: 286)
										declaredAt: (100 to: 112)
										by: aChangeRecord.
									#_coverageTracker173030000_
										coverAll:
											{288 to: 292}
										evaluating: [ receiver8 prior ]
										thatSends: #prior
										to: receiver8 ] value.
									#_coverageTracker173030000_
										coverAll:
											{294 to: 298}
										evaluating: [ receiver9 isNil ]
										thatSends: #isNil
										to: receiver9 ] value ]]
						thatSends: #and:and:and:
						to: receiver10 ] value ]]
		thatSends: #for:withLookahead:detectsWhen:
		to: receiver11 ] value.! !
!Behavior method!
reportChangeTo: aTDDGuru
	#_coverageTracker173030022_ markAsExecuted.
	[ | receiver3 |
	receiver3 _ #_coverageTracker173030022_
		cover: (28 to: 35)
		declaredAt: (17 to: 24)
		by: aTDDGuru.
	#_coverageTracker173030022_
		coverAll:
			{37 to: 52. 76 to: 78}
		evaluating: [
			receiver3
				testRenamedFrom:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173030022_
						coverAll:
							{54 to: 57}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173030022_
						coverAll:
							{59 to: 74}
						evaluating: [ receiver1 oldTestReference ]
						thatSends: #oldTestReference
						to: receiver1 ] value
				to:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173030022_
						coverAll:
							{80 to: 83}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173030022_
						coverAll:
							{85 to: 100}
						evaluating: [ receiver2 newTestReference ]
						thatSends: #newTestReference
						to: receiver2 ] value ]
		thatSends: #testRenamedFrom:to:
		to: receiver3 ] value.! !
!Behavior method!
oldTestReference
	#_coverageTracker173030027_ markAsExecuted.
	^ [ | receiver3 |
	receiver3 _ #_coverageTracker173030027_
		coverAll:
			{21 to: 46}
		by: UninstalledMethodReference.
	#_coverageTracker173030027_
		coverAll:
			{48 to: 56. 68 to: 73}
		evaluating: [
			receiver3
				selector:
					[ | receiver1 |
					receiver1 _ #_coverageTracker173030027_
						coverAll:
							{58 to: 61}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173030027_
						coverAll:
							{63 to: 66}
						evaluating: [ receiver1 from ]
						thatSends: #from
						to: receiver1 ] value
				class:
					[ | receiver2 |
					receiver2 _ #_coverageTracker173030027_
						coverAll:
							{75 to: 78}
						byLiteralOrPseudoVariable: self.
					#_coverageTracker173030027_
						coverAll:
							{80 to: 94}
						evaluating: [ receiver2 changeClassName ]
						thatSends: #changeClassName
						to: receiver2 ] value ]
		thatSends: #selector:class:
		to: receiver3 ] value.! !
!Behavior method!
selector: testSelector class: className sourceCode: aSourceCodeString overrides: anOverridenMethodOrNil
	#_coverageTracker173030031_ markAsExecuted.
	^ [ | cascadeReceiver |
	cascadeReceiver _ [ | receiver1 |
	receiver1 _ #_coverageTracker173030031_
		coverAll:
			{108 to: 111}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173030031_
		coverAll:
			{113 to: 115}
		evaluating: [ receiver1 new ]
		thatSends: #new
		to: receiver1 ] value.
	[ | receiver2 |
	receiver2 _ cascadeReceiver.
	#_coverageTracker173030031_
		coverAll:
			{117 to: 125}
		evaluating: [
			receiver2 selector:
				(#_coverageTracker173030031_
					cover: (127 to: 138)
					declaredAt: (11 to: 22)
					by: testSelector) ]
		thatSends: #selector:
		to: receiver2 ] value.
	[ | receiver3 |
	receiver3 _ cascadeReceiver.
	#_coverageTracker173030031_
		coverAll:
			{141 to: 146}
		evaluating: [
			receiver3 class:
				(#_coverageTracker173030031_
					cover: (148 to: 156)
					declaredAt: (31 to: 39)
					by: className) ]
		thatSends: #class:
		to: receiver3 ] value.
	[ | receiver4 |
	receiver4 _ cascadeReceiver.
	#_coverageTracker173030031_
		coverAll:
			{159 to: 169}
		evaluating: [
			receiver4 sourceCode:
				(#_coverageTracker173030031_
					cover: (171 to: 187)
					declaredAt: (53 to: 69)
					by: aSourceCodeString) ]
		thatSends: #sourceCode:
		to: receiver4 ] value.
	[ | receiver5 |
	receiver5 _ cascadeReceiver.
	#_coverageTracker173030031_
		coverAll:
			{190 to: 199}
		evaluating: [
			receiver5 overrides:
				(#_coverageTracker173030031_
					cover: (201 to: 222)
					declaredAt: (82 to: 103)
					by: anOverridenMethodOrNil) ]
		thatSends: #overrides:
		to: receiver5 ] value ] value.! !
!Behavior method!
testClassRemoved: aSymbol
	#_coverageTracker173030052_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173030052_
		coverAll:
			{29 to: 32}
		byLiteralOrPseudoVariable: self.
	#_coverageTracker173030052_
		coverAll:
			{34 to: 51}
		evaluating: [
			receiver1 modelClassRemoved:
				(#_coverageTracker173030052_
					cover: (53 to: 59)
					declaredAt: (19 to: 25)
					by: aSymbol) ]
		thatSends: #modelClassRemoved:
		to: receiver1 ] value.! !
!Behavior method!
changeClassName
	#_coverageTracker173030054_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173030054_
		cover: (20 to: 31)
		declaredAt: (20 to: 31)
		by: changeRecord.
	#_coverageTracker173030054_
		coverAll:
			{33 to: 47}
		evaluating: [ receiver1 changeClassName ]
		thatSends: #changeClassName
		to: receiver1 ] value.! !
!Behavior method!
category
	#_coverageTracker173030057_ markAsExecuted.
	^ #_coverageTracker173030057_
		coverAll:
			{13 to: 27}
		byLiteralOrPseudoVariable: #newModelMethod.! !
!Behavior method!
testSelector
	#_coverageTracker173030061_ markAsExecuted.
	^ [ | receiver1 |
	receiver1 _ #_coverageTracker173030061_
		cover: (17 to: 28)
		declaredAt: (17 to: 28)
		by: changeRecord.
	#_coverageTracker173030061_
		coverAll:
			{30 to: 43}
		evaluating: [ receiver1 methodSelector ]
		thatSends: #methodSelector
		to: receiver1 ] value.! !
!Behavior method!
code
	| changeClass sourceString |
	#_coverageTracker173030063_ markAsExecuted.
	#_coverageTracker173030063_
		cover: (37 to: 48)
		declaredAt: (21 to: 32)
		by:
			(sourceString _ [ | receiver1 |
			receiver1 _ #_coverageTracker173030063_
				cover: (53 to: 64)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173030063_
				coverAll:
					{66 to: 71}
				evaluating: [ receiver1 string ]
				thatSends: #string
				to: receiver1 ] value).
	#_coverageTracker173030063_
		cover: (75 to: 85)
		declaredAt: (9 to: 19)
		by:
			(changeClass _ [ | receiver2 |
			receiver2 _ #_coverageTracker173030063_
				cover: (90 to: 101)
				declaredAt: (53 to: 64)
				by: changeRecord.
			#_coverageTracker173030063_
				coverAll:
					{103 to: 113}
				evaluating: [ receiver2 changeClass ]
				thatSends: #changeClass
				to: receiver2 ] value).
	[ | receiver3 |
	receiver3 _ #_coverageTracker173030063_
		cover: (117 to: 127)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173030063_
		coverAll:
			{129 to: 134}
		evaluating: [ receiver3 ifNil: [ ^ #_coverageTracker173030063_
					cover: (140 to: 151)
					declaredAt: (21 to: 32)
					by: sourceString ]]
		thatSends: #ifNil:
		to: receiver3 ] value.
	^ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ [ | receiver4 |
	receiver4 _ #_coverageTracker173030063_
		cover: (161 to: 171)
		declaredAt: (9 to: 19)
		by: changeClass.
	#_coverageTracker173030063_
		coverAll:
			{173 to: 185}
		evaluating: [ receiver4 compilerClass ]
		thatSends: #compilerClass
		to: receiver4 ] value.
	#_coverageTracker173030063_
		coverAll:
			{187 to: 189}
		evaluating: [ receiver5 new ]
		thatSends: #new
		to: receiver5 ] value.
	#_coverageTracker173030063_
		coverAll:
			{193 to: 199. 214 to: 216. 230 to: 239}
		evaluating: [
			receiver6
				format:
					(#_coverageTracker173030063_
						cover: (201 to: 212)
						declaredAt: (21 to: 32)
						by: sourceString)
				in:
					(#_coverageTracker173030063_
						cover: (218 to: 228)
						declaredAt: (9 to: 19)
						by: changeClass)
				notifying:
					(#_coverageTracker173030063_
						coverAll:
							{241 to: 243}
						byLiteralOrPseudoVariable: nil) ]
		thatSends: #format:in:notifying:
		to: receiver6 ] value.! !
!Behavior method!
analysisFinished
	#_coverageTracker173030082_ markAsExecuted.! !
!Behavior method!
unmarkAsNew: aMethodReference
	#_coverageTracker173030084_ markAsExecuted.
	[ | receiver1 |
	receiver1 _ #_coverageTracker173030084_
		cover: (33 to: 42)
		declaredAt: (33 to: 42)
		by: newMethods.
	#_coverageTracker173030084_
		coverAll:
			{44 to: 50. 69 to: 77}
		evaluating: [
			receiver1
				remove:
					(#_coverageTracker173030084_
						cover: (52 to: 67)
						declaredAt: (14 to: 29)
						by: aMethodReference)
				ifAbsent: [ ]]
		thatSends: #remove:ifAbsent:
		to: receiver1 ] value.! !
!Behavior method!
changeClass: aChangeClass
	#_coverageTracker173030096_ markAsExecuted.
	#_coverageTracker173030096_
		cover: (28 to: 38)
		declaredAt: (28 to: 38)
		by:
			(changeClass _ #_coverageTracker173030096_
				cover: (43 to: 54)
				declaredAt: (14 to: 25)
				by: aChangeClass).! !
!Behavior method!
timeline: aTimeline
	#_coverageTracker173030099_ markAsExecuted.
	#_coverageTracker173030099_
		cover: (22 to: 29)
		declaredAt: (22 to: 29)
		by:
			(timeline _ #_coverageTracker173030099_
				cover: (34 to: 42)
				declaredAt: (11 to: 19)
				by: aTimeline).! !
!Behavior method!
= anObject
	#_coverageTracker173030102_ markAsExecuted.
	[ | receiver4 |
	receiver4 _ [ | receiver3 |
	receiver3 _ [ | receiver1 |
	receiver1 _ #_coverageTracker173030102_
		cover: (14 to: 21)
		declaredAt: (3 to: 10)
		by: anObject.
	#_coverageTracker173030102_
		coverAll:
			{23 to: 27}
		evaluating: [ receiver1 class ]
		thatSends: #class
		to: receiver1 ] value.
	#_coverageTracker173030102_
		coverAll:
			{29 to: 30}
		evaluating: [
			receiver3 ==
				[ | receiver2 |
				receiver2 _ #_coverageTracker173030102_
					coverAll:
						{32 to: 35}
					byLiteralOrPseudoVariable: self.
				#_coverageTracker173030102_
					coverAll:
						{37 to: 41}
					evaluating: [ receiver2 class ]
					thatSends: #class
					to: receiver2 ] value ]
		thatSends: #==
		to: receiver3 ] value.
	#_coverageTracker173030102_
		coverAll:
			{44 to: 51}
		evaluating: [ receiver4 ifFalse: [ ^ #_coverageTracker173030102_
					coverAll:
						{57 to: 61}
					byLiteralOrPseudoVariable: false ]]
		thatSends: #ifFalse:
		to: receiver4 ] value.
	^ [ | receiver9 |
	receiver9 _ [ | receiver6 |
	receiver6 _ [ | receiver5 |
	receiver5 _ #_coverageTracker173030102_
		cover: (71 to: 78)
		declaredAt: (3 to: 10)
		by: anObject.
	#_coverageTracker173030102_
		coverAll:
			{80 to: 87}
		evaluating: [ receiver5 selector ]
		thatSends: #selector
		to: receiver5 ] value.
	#_coverageTracker173030102_
		coverAll:
			{89 to: 89}
		evaluating: [
			receiver6 =
				(#_coverageTracker173030102_
					cover: (91 to: 98)
					declaredAt: (91 to: 98)
					by: selector) ]
		thatSends: #=
		to: receiver6 ] value.
	#_coverageTracker173030102_
		coverAll:
			{100 to: 103}
		evaluating: [
			receiver9 and:
				[ | receiver8 |
				receiver8 _ [ | receiver7 |
				receiver7 _ #_coverageTracker173030102_
					cover: (105 to: 112)
					declaredAt: (3 to: 10)
					by: anObject.
				#_coverageTracker173030102_
					coverAll:
						{114 to: 124}
					evaluating: [ receiver7 methodClass ]
					thatSends: #methodClass
					to: receiver7 ] value.
				#_coverageTracker173030102_
					coverAll:
						{126 to: 126}
					evaluating: [
						receiver8 =
							(#_coverageTracker173030102_
								cover: (128 to: 136)
								declaredAt: (128 to: 136)
								by: className) ]
					thatSends: #=
					to: receiver8 ] value ]
		thatSends: #and:
		to: receiver9 ] value.! !

!testRun: #LogTestChangesTest #test01RunningAPassingTestShouldBeLogged stamp: 'JFGO 10/10/2024 19:28:43'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:28:44'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test02RunningAFailingTestShouldBeLogged stamp: 'JFGO 10/10/2024 19:28:44'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:28:44'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test03RunningATestWithAnErrorShouldBeLogged stamp: 'JFGO 10/10/2024 19:28:45'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:28:45'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test04OverridingAMethodShouldBeLoggedWithAReferenceToTheOverridenMethod stamp: 'JFGO 10/10/2024 19:28:46'!
PASSED!

!classRemoval: #SubclassTestDataClass__ stamp: 'JFGO 10/10/2024 19:28:46'!
TestChangesTestClass__ subclass: #SubclassTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:28:46'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #SubclassTestDataClass__ stamp: 'JFGO 10/10/2024 19:28:47'!
TestChangesTestClass__ subclass: #SubclassTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:28:47'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:28:48'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test01ScanPassingTestChange stamp: 'JFGO 10/10/2024 19:32:54'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:32:54'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test02ScanFailedTestChange stamp: 'JFGO 10/10/2024 19:32:55'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'JFGO 10/10/2024 19:32:55'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test03ScanNewTestClass stamp: 'JFGO 10/10/2024 19:32:56'!
PASSED!

!classRemoval: #TestClassA stamp: 'JFGO 10/10/2024 19:32:56'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test04ScanOverridenMethod stamp: 'JFGO 10/10/2024 19:32:57'!
PASSED!

!classRemoval: #AClass__ stamp: 'JFGO 10/10/2024 19:32:57'!
TestChangesTestClass__ subclass: #AClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:32:57'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test05ScanAMethodThatIsNotOverriden stamp: 'JFGO 10/10/2024 19:32:58'!
PASSED!

!classRemoval: #AClass__ stamp: 'JFGO 10/10/2024 19:32:58'!
TestChangesTestClass__ subclass: #AClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'JFGO 10/10/2024 19:32:59'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #TestChangesTest #testDataClassName stamp: 'JFGO 10/10/2024 19:32:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test01ManyMethodsCanBeTypeChecked stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test02ClassesCanBeTypeChecked stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test04AlertsDetectIfNone stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test05AlertsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test07ErrorsDetectIfNone stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test10WarningsDetectIfNone stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'JFGO 10/10/2024 19:40:18'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test15HasErrorsOrWarnings stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test14TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test17TypeCastManyVariablesNestedRejectionsRejectsEachLevelCastedTypeForEachVariable stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/10/2024 19:40:19'!
PASSED!

!classRemoval: #Room stamp: 'JFGO 10/10/2024 19:40:25'!
Object subclass: #Room
	instanceVariableNames: 'guest'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Catedra-ISW1-2024-1C-Parcial'!

!classRemoval: #Hotel stamp: 'JFGO 10/10/2024 19:40:25'!
Object subclass: #Hotel
	instanceVariableNames: 'floors availableRoomsCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Catedra-ISW1-2024-1C-Parcial'!

!classRemoval: #Floor stamp: 'JFGO 10/10/2024 19:40:26'!
Object subclass: #Floor
	instanceVariableNames: 'rooms prices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Catedra-ISW1-2024-1C-Parcial'!

!classRemoval: #RoomTest stamp: 'JFGO 10/10/2024 19:40:26'!
TestCase subclass: #RoomTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Catedra-ISW1-2024-1C-Parcial'!

!classRemoval: #HotelTest stamp: 'JFGO 10/10/2024 19:40:26'!
TestCase subclass: #HotelTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Catedra-ISW1-2024-1C-Parcial'!

!classRemoval: #FloorTest stamp: 'JFGO 10/10/2024 19:40:26'!
TestCase subclass: #FloorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Catedra-ISW1-2024-1C-Parcial'!
Morphic view for MessageSet models. See category 'GUI building'.!
Morphic view for MessageSet models. See category 'GUI building'.!

----QUIT----(10 October 2024 19:41:10) CuisUniversity-6169.image priorSource: 6245038!

----STARTUP---- (11 October 2024 18:45:04) as C:\Users\juli_\Tesis\TO_UPLOAD\windows64\CuisUniversity-6169.image!

!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16783272 overrides: 16782889!
is: aSymbol
	^ aSymbol == #ArrayOfCharactersAndCodePoints or: [ super is: aSymbol ]! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16783244!
encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left := (self lastIndexOf: `Character newLineCharacter` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr := (self indexOf: `Character newLineCharacter` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).
	rightNull := (self indexOf: `Character null` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	^left to: (rightCr min: rightNull)! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16783218!
encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left := (self lastIndexOf: `Character newLineCharacter` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr := (self indexOf: `Character newLineCharacter` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	rightNull := (self indexOf: `Character null` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	^left to: (rightCr min: rightNull)! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16783212 overrides: 16947448!
asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	^UnicodeString newFrom: self! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16783206 overrides: 16913349!
at: index
	"Full compatibility with String"
	^(super at: index) ifNil: [ `Character null` ].! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16784282 overrides: 16914834!
printOn: aStream
	aStream
		nextPutAll: 'replaced attributes'! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16784287!
old: oldAttributes new: newAttributes start: startIndex stop: stopIndex
	old := oldAttributes.
	new := newAttributes.
	start := startIndex.
	stop := stopIndex! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16784274 overrides: 16979162!
undoOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing"

	aTextModel basicReplaceAttributesFrom: start to: stop with: old.
	^nil! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16784266 overrides: 16979156!
doOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing"

	aTextModel basicReplaceAttributesFrom: start to: stop with: new.
	^nil! !
!AttributesReplaceCommand class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16784302!
old: oldAttributes new: newAttributes start: startIndex stop: stopIndex
	^self basicNew old: oldAttributes new: newAttributes start: startIndex stop: stopIndex! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826630!
didCodeChangeElsewhere
	"Determine whether the code for the currently selected method and class has been changed somewhere else."

	| aClass aSelector aCompiledMethod |
	currentCompiledMethod ifNil: [^ false].
	(aClass := self selectedClassOrMetaClass) ifNil: [^ false].
	(aSelector := self selectedMessageName) ifNil: [^ false].

	aSelector == #Comment ifTrue:
		[^ currentCompiledMethod ~~ aClass organization commentRemoteStr].
	^ ((aCompiledMethod := aClass compiledMethodAt: aSelector ifAbsent: [^ false]) ~~ currentCompiledMethod)
		and: [aCompiledMethod last ~= 0 "either not yet installed"
				or: [currentCompiledMethod last = 0 "or these methods don't have source pointers"]]
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825995!
annotationForSystemCategory: aCategory
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'System Category: ';
			nextPutAll: aCategory.
		(Preferences at: #systemCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#classCount] -> [
					strm
						print: (SystemOrganization fullListAtCategoryNamed: aCategory) size;
						nextPutAll: ' classes' ].
				[#instanceMethodsCount] -> [
					strm
						print: (SystemOrganization instanceMethodCountOf: aCategory);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (SystemOrganization classMethodCountOf: aCategory);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (SystemOrganization linesOfCodeOf: aCategory);
						nextPutAll: ' total lines of code' ].
				[#messageSendsCount] -> [
					strm
						print: (SystemOrganization messageSendsCountOf: aCategory);
						nextPutAll: ' total message sends' ].
			}]].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826107 overrides: 16983534!
acceptedContentsChanged

	self changed: #acceptedContents.
	self triggerEvent: #decorateButtons.
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826427!
showingAnyKindOfDiffs
	"Answer whether the receiver is currently set to show any kind of diffs"

	^ #(lineDiffs prettyLineDiffs wordDiffs prettyWordDiffs) includes: self contentsSymbol! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826443!
showingLineDiffs
	"Answer whether the receiver is showing regular diffs of source code"

	^ self contentsSymbol == #lineDiffs
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826519!
togglePlainSource
	"Toggle whether plain source shown in the code pane"
	self showingPlainSource
		ifTrue: [
			self contentsSymbol: #documentation]
		ifFalse: [
			self contentsSymbol: #source]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826919!
timeStamp
	"Answer the time stamp for the chosen class and method, if any, else an empty string"

	|  selector  |
	(selector := self selectedMessageName) ifNotNil: [
		^self selectedClassOrMetaClass 
			ifNil: [
				String new]
			ifNotNil: [
				self selectedClassOrMetaClass stampAt: selector]].
	^ String new! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826479!
showingPrettyWordDiffsString
	"Answer a string representing whether I'm showing pretty diffs"

	^ self showingPrettyWordDiffs asMenuItemTextPrefix,
		'wordPrettyDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16827005 overrides: 16983613!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	False, for instance, in all code Browsers.
	True in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826307!
sourceAndDiffsQuintsOnly
	"Answer a list of quintuplets representing information on the alternative views available in the code pane for the case where the only plausible choices are showing source or either of the two kinds of diffs"

	^ #(
(source				togglePlainSource 			showingPlainSourceString
														'source'			'the textual source code as writen')
(lineDiffs				toggleLineDiffing			showingLineDiffsString
														'lineDiffs'			'the textual source diffed from its prior version')
(wordDiffs			toggleWordDiffing			showingWordDiffsString
														'wordDiffs'			'the textual source words diffed from its prior version')
(prettyLineDiffs		togglePrettyLineDiffing	showingPrettyLineDiffsString
														'linePrettyDiffs'		'formatted source diffed from formatted prior version')
(prettyWordDiffs	togglePrettyWordDiffing	showingPrettyWordDiffsString
														'linePrettyDiffs'		'formatted source words diffed from prior version')
	)! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826487!
showingWordDiffs
	"Answer whether the receiver is showing regular diffs (alternative algorithm) of source code"

	^ self contentsSymbol == #wordDiffs
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826970!
selectedClass
	^ nil! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826851!
sourceStringPrettifiedAndDiffed
	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"
	| class selector sourceString |
	class := self selectedClassOrMetaClass.
	selector := self selectedMessageName.
	(class isNil or: [ selector isNil ]) ifTrue: [ ^ 'missing' ].
	sourceString := class
		ultimateSourceCodeAt: selector
		ifAbsent: [ ^ 'error' ].
	(self showingPrettyPrint or: [ self showingAnyKindOfPrettyDiffs ]) ifTrue: [
		sourceString := class compilerClass new
			format: sourceString
			in: class
			notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		sourceString := self diffFromPriorSourceFor: sourceString ].
	^ sourceString! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826608!
priorSourceOrNil
	"If the currently-selected method has a previous version, return its source, else return nil"
	| aClass aSelector  changeRecords |
	(aClass := self selectedClassOrMetaClass) ifNil: [^ nil].
	(aSelector := self selectedMessageName) ifNil: [^ nil].
	changeRecords := aClass changeRecordsAt: aSelector.
	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].
	^ (changeRecords at: 2) string 
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50540951!
typeCheckMethod
		
	| typeChecker |
	typeChecker := self currentCompiledMethod typeCheck.
	typeChecker showResultsWith:  typeChecker method classAndSelector 
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825746!
addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream
	"add an annotation detailing the prior versions count"
	| versionsCount |

	versionsCount := VersionsBrowser versionCountForSelector: aSelector class: aClass.
	aStream nextPutAll: 
				((versionsCount > 1
					ifTrue:
						[versionsCount = 2 ifTrue:
							['1 prior version']
							ifFalse:
								[versionsCount printString, ' prior versions']]
					ifFalse:
						['no prior versions']))! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826769!
toggleDecompile
	"Toggle the setting of the showingDecompile flag, unless there are unsubmitted edits that the user declines to discard"

	self showDecompile: self showingDecompile not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826512!
toggleLineDiffing
	"Toggle whether regular-diffing should be shown in the code pane"

	self showLineDiffs: self showingLineDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826501!
toggleDiffing
	"Toggle whether diffs should be shown in the code pane.  If any kind of diffs were being shown, stop showing diffs.  If no kind of diffs were being shown, start showing whatever kind of diffs are called for by default."

	self showDiffs: self showingAnyKindOfDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826195!
hierarchyBrowser
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |
	(selectedClassOrMetaClass := self selectedClassOrMetaClass)
		ifNil: [^ nil].
	newBrowser := HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.
	((aSymbol := self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])
		ifTrue: [
			aBehavior := selectedClassOrMetaClass.
			messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.
			messageCatIndex = 0 ifFalse: [
				newBrowser messageCategoryListIndex: messageCatIndex + 1.
				newBrowser messageListIndex:
					((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol) ]].
	^newBrowser! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826749!
showingPlainSourceString
	"Answer a string telling whether the receiver is showing plain source"

	^ self showingPlainSource asMenuItemTextPrefix,
		'source'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826719!
showingDecompileString
	"Answer a string characerizing whether decompilation is showing"

	^ self showingDecompile asMenuItemTextPrefix,
		'decompile'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826340!
defaultDiffsSymbol
	"Answer the code symbol to use when generically switching to diffing"

	^ (Preferences at: #diffsWithPrettyPrint)
		ifTrue: [
			#prettyLineDiffs]
		ifFalse: [
			#lineDiffs]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826528!
togglePrettyLineDiffing
	"Toggle whether pretty-diffing should be shown in the code pane"

	self showPrettyLineDiffs: self showingPrettyLineDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826813!
selectedBytecodes
	"Answer text to show in a code pane when in showing-byte-codes mode"

	^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName ifAbsent: [^ '' asText]) symbolic asText! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826372!
showDiffs: aBoolean
	"Set whether I'm showing diffs as indicated; use the global preference to determine which kind of diffs to institute."

	self showingAnyKindOfDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: self defaultDiffsSymbol]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826171!
contentsSymbol: aSymbol
	"Set the contentsSymbol as indicated.  #source means to show source code, #comment means to show the first comment found in the source code"

	contentsSymbol := aSymbol.
	self acceptedContentsChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16827019 overrides: 16983559!
autoCompleterClassFor: textGetter
	currentCompiledMethod ifNotNil: [ :cm |
		^cm compilerClass autoCompleterClass ].
	^SmalltalkCompleter! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826973!
selectedClassOrMetaClass

	^ self selectedClass	"I don't know any better"! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826364!
shouldDiffWords
	"Answer whether the receiver is currently set to use the word based differ"

	^ #(wordDiffs prettyWordDiffs) includes: self contentsSymbol! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826181!
currentMethodRefactored

	self acceptedContentsChanged
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826893!
inspectCompiledMethod
	"Open an Inspector on the CompiledMethod itself"

	self selectedMessageName ifNotNil: [
		(self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)
			inspect ]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825778!
annotationForClassCommentFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the clas comment of the given class."

	| aStamp nonMeta |
	aStamp :=  (nonMeta := aClass theNonMetaClass) organization commentStamp.
	^ aStamp
		ifNil:
			[nonMeta name, ' has no class comment']
		ifNotNil:
			['class comment for ', nonMeta name,
				(aStamp = '<historical>'
					ifFalse:
						[' - ', aStamp]
					ifTrue:
						[''])]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826763!
showingSource
	"Answer whether the receiver is currently showing source code"

	^ self contentsSymbol == #source
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826684!
showDecompile: aBoolean
	"Set the decompile toggle as indicated"

	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#decompile])! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826902!
revertToPreviousVersion
	"Revert to the previous version of the current method"
	| aClass aSelector  changeRecords |
	aClass := self selectedClassOrMetaClass.
	aClass ifNil: [^ self changed: #flash].
	aSelector := self selectedMessageName.
	changeRecords := aClass changeRecordsAt: aSelector.
	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Smalltalk beep].
	changeRecords second fileIn.
	self acceptedContentsChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826450!
showingLineDiffsString
	"Answer a string representing whether I'm showing regular diffs"

	^ self showingLineDiffs asMenuItemTextPrefix,
		'lineDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826654!
updateIfNeeded
	self didCodeChangeElsewhere
		ifTrue: [
			self acceptedContentsChanged]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50504273!
resetMethodTypes
	
	self currentCompiledMethod initializeTypeInformation.
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826156!
contentsSymbol
	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"

	^ contentsSymbol ifNil: [
		contentsSymbol := (Preferences at: #browseWithPrettyPrint)
					ifTrue:
						[#prettyPrint]
					ifFalse:
						[#source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826584!
okayToAccept
	"Answer whether it is okay to accept the receiver's input"

	self showingByteCodes ifTrue: [
		self inform: 
'Sorry, you can only submit changes here 
when you are showing source.'.
		^ false].

	self showingDocumentation ifTrue: [
		self inform: 
'Sorry, you can only submit changes here 
when you are showing source.'.
		^ false].

	self showingAnyKindOfDiffs ifTrue: [
		^ SelectionMenu confirm: 
'Caution!!  You are "showing diffs" here, so 
there is a danger that some of the text in the
code pane is contaminated by the "diff" display'
		trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider' icons: #(acceptIcon cancelIcon)
	].

	^ true! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826966!
currentCompiledMethod
	^currentCompiledMethod! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826223!
removeClass
	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."

	| message  className classToRemove result |
	classToRemove := self selectedClassOrMetaClass ifNil: [Smalltalk beep. ^ false].
	classToRemove := classToRemove theNonMetaClass.
	className := classToRemove name.
	message := 'Are you certain that you
want to REMOVE the class ', className, '
from the system?'.
	(result := self confirm: message)
		ifTrue: [
			classToRemove subclasses notEmpty
				ifTrue: [(self confirm: 'class has subclasses: ' , message)
					ifFalse: [^ false]].
			classToRemove removeFromSystem.
			self changed: #classList.
			true].
	^ result! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826996!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer false if showing difs, to veto the styling."
	
	^self showingAnyKindOfDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826691!
showDocumentation: aBoolean
	"Set the showDocumentation toggle as indicated"

	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#documentation])! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826039!
categoryFromUserWithPrompt: aPrompt for: aClass
	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"

	^(MethodCategoriesPrompter 
		staringFrom: aClass 
		rejectingFirst: false) prompt: aPrompt ifNone: [ nil ]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16827026 overrides: 16983563!
editorClassFor: textGetter
	(#(acceptedContents classCommentText) statePointsTo: textGetter) ifFalse: [
		^super editorClassFor: textGetter ].
	currentCompiledMethod ifNotNil: [ :cm |
		^cm compilerClass editorClass ].
	^SmalltalkEditor! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826124!
commentContents
	"documentation for the selected method"

	| poss aClass aSelector |
	^ (poss := (aClass := self selectedClassOrMetaClass)
						ifNil:
							['----']
						ifNotNil:
							[(aSelector := self selectedMessageName)
								ifNil:
									['---']
								ifNotNil:
									[(aClass precodeCommentOrInheritedCommentFor: aSelector)", String crString, String crString, self timeStamp"
"which however misses comments that are between the temps  declaration and the body of the method; those are picked up by [aClass commentOrInheritedCommentFor: aSelector] but that method will get false positives from comments *anywhere* in the method source"]])
		isEmptyOrNil
			ifTrue:
				[aSelector
					ifNotNil:
						[((aClass methodHeaderFor: aSelector), '

Has no comment') ]
					ifNil:
						['Hamna']]
			ifFalse:	[aSelector
				ifNotNil: [((aClass methodHeaderFor: aSelector), '

', poss) ]
				ifNil: [poss]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826385!
showLineDiffs: aBoolean
	"Set whether I'm showing regular diffs as indicated"

	self showingLineDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #lineDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826558!
isThereAnOverride
	"Answer whether any subclass of my selected class implements my 
	selected selector"
	| aName aClass |
	aName := self selectedMessageName
				ifNil: [^ false].
	aClass := self selectedClassOrMetaClass ifNil: [ ^ false ].
	aClass allSubclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].
	^ false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826033!
annotationSeparator
	"Answer the separator to be used between annotations"

	^ ' ° '! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826932!
unusedMethods
	| classes unsent messageList cls |

	(cls := self selectedClass) ifNil: [^ nil].
	classes := Array with: cls with: cls class.
	unsent := Set new.
	classes do: [:c | unsent addAll: c selectors].
	unsent := Smalltalk allUnSentMessagesIn: unsent.
	messageList := OrderedCollection new.
	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asArray sort
					do: [:sel | messageList add: 
						(MethodReference class: c selector: sel) ]].
	^messageList! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826950!
canShowMultipleMessageCategories
	"Answer whether the receiver is capable of showing multiple message categories"

	^ false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826535!
togglePrettyPrint
	"Toggle whether pretty-print is in effectin the code pane"

	self showingPrettyPrint
		ifTrue: [
			self contentsSymbol: #source]
		ifFalse: [
			self contentsSymbol: #prettyPrint]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16827037 overrides: 16983573!
textStylerClassFor: textGetter
	textGetter = #acceptedContents ifFalse: [
		^super textStylerClassFor: textGetter ].
	currentCompiledMethod ifNotNil: [ :cm |
		^cm compilerClass textStylerClass ].
	^SHTextStylerST80! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826660!
prettyPrintString
	"Answer whether the receiver is showing pretty-print"

	^ self showingPrettyPrint asMenuItemTextPrefix,
		'prettyPrint'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826093!
methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826186 overrides: 16983550!
methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ self selectedClassOrMetaClass methodNodeFor: aSourceCode ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826667!
showByteCodes: aBoolean
	"Get into or out of bytecode-showoing mode"

	aBoolean
		ifTrue: [
			self contentsSymbol: #byteCodes]
		ifFalse: [
			self contentsSymbol == #byteCodes ifTrue: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826988!
isModeStyleable
	"determine if Shout can style in the current mode"
	^ self showingSource or: [self showingPrettyPrint or: [self showingDecompile]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826073!
letUserReclassify: anElement in: aClass
	"Put up a list of categories and solicit one from the user.  
	Answer true if user indeed made a change, else false"
	

	| currentCat newCat |
	currentCat := aClass organization categoryOfElement: anElement.
	newCat := self 
				categoryFromUserWithPrompt: 'choose category (currently "', currentCat, '")' 
				for: aClass.
	(newCat notNil and: [newCat ~= currentCat])
		ifTrue: [
			aClass organization classify: anElement under: newCat suppressIfDefault: false.
			^ true]
		ifFalse: [
			^ false]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826417!
showWordDiffs: aBoolean
	"Set whether I'm showing regular diffs as indicated"

	self showingWordDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #wordDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825827!
annotationForMessageCategory: aCategory ofClass: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."
	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Message Category: ';
			nextPutAll: aCategory.
		(Preferences at: #messageCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#messagesCount] -> [
					strm
						print: (aClass messagesCountInCategory: aCategory);
						nextPutAll: ' total messages' ].
				[#messageSendsCount] -> [
					strm
						print: (aClass messageSendsCountInCategory: aCategory);
						nextPutAll: ' total message sends' ].
			}]].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826624 overrides: 16914636!
releaseCachedState
	"Can always be found again.  Don't write on a file."
	currentCompiledMethod := nil.! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826957 overrides: 16915189!
is: aSymbol
	^ aSymbol == #CodeProvider or: [ super is: aSymbol ]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825795!
annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name.
		(Preferences at: #classAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#instanceMethodsCount] -> [
					strm
						print: (aClass theNonMetaClass selectors size);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (aClass theMetaClass selectors size);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (aClass theNonMetaClass linesOfCode);
						nextPutAll: ' total lines of code' ].
				[#messageSendsCount] -> [
					strm
						print: (aClass theNonMetaClass messageSendsCount);
						nextPutAll: ' total message sends' ].
			}]].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826705!
showingByteCodesString
	"Answer whether the receiver is showing bytecodes"

	^ self showingByteCodes asMenuItemTextPrefix,
		'byteCodes'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826049!
categoryOfCurrentMethod
	"Answer the category that owns the current method.  If unable to determine a category, answer nil."

	^ self selectedClassOrMetaClass ifNotNil: [ :cls | 
		self selectedMessageName ifNotNil: [ :sel |
			cls whichCategoryIncludesSelector: sel]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826876!
copySelector
	"Copy the selected selector to the clipboard"

	| selector |
	(selector := self selectedMessageName) ifNotNil: [
		Clipboard storeObject: selector asPlainString]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826787!
toggleShowingByteCodes
	"Toggle whether the receiver is showing bytecodes"

	self showByteCodes: self showingByteCodes not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825852!
annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826494!
showingWordDiffsString
	"Answer a string representing whether I'm showing regular diffs"

	^ self showingWordDiffs asMenuItemTextPrefix,
		'wordDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826406!
showPrettyWordDiffs: aBoolean
	"Set whether I'm showing pretty diffs as indicated"

	self showingPrettyWordDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #prettyWordDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826978!
selectedMessageName

	^ nil! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826571!
isThisAnOverride
	"Answer whether any superclass of my selected class implements my selected selector"
	| aName aClass |
	aName := self selectedMessageName ifNil: [^ false].
	aClass := self selectedClassOrMetaClass ifNil: [^false ].
	aClass allSuperclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].
	^ false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826712!
showingDecompile
	"Answer whether the receiver should show decompile rather than, say, source code"

	^ self contentsSymbol == #decompile
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826735!
showingDocumentationString
	"Answer a string characerizing whether documentation is showing"

	^ self showingDocumentation asMenuItemTextPrefix,
		'documentation'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826464!
showingPrettyLineDiffsString
	"Answer a string representing whether I'm showing pretty diffs"

	^ self showingPrettyLineDiffs asMenuItemTextPrefix,
		'linePrettyDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826884!
fileOutMessage
	"Put a description of the selected message on a file"

	self selectedMessageName ifNotNil: [
		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16825763!
annotation
	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."

	|  aSelector aClass |

	((aSelector := self selectedMessageName) == nil or: [(aClass := self selectedClassOrMetaClass) == nil])
		ifTrue: [^ ''].
	^ self annotationForSelector: aSelector ofClass: aClass! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826699!
showingByteCodes
	"Answer whether the receiver is showing bytecodes"

	^ self contentsSymbol == #byteCodes! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826457!
showingPrettyLineDiffs
	"Answer whether the receiver is showing pretty diffs of source code"

	^ self contentsSymbol == #prettyLineDiffs! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826250!
contentsSymbolQuints
	"Answer a list of quintuplets representing information on the alternative views available in the code pane
		first element:	the contentsSymbol used
		second element:	the selector to call when this item is chosen.
		third element:	the selector to call to obtain the wording of the menu item.
		fourth element:	the wording to represent this view
		fifth element:	balloon help
	A hypen indicates a need for a seperator line in a menu of such choices"

	^ #(
(source				togglePlainSource 			showingPlainSourceString
														'source'			'the textual source code as writen')
(documentation		toggleShowDocumentation showingDocumentationString
														'documentation'	'the first comment in the method')
-
(prettyPrint			togglePrettyPrint 			prettyPrintString
														'prettyPrint'			'the method source presented in a standard text format')
-
(lineDiffs				toggleLineDiffing			showingLineDiffsString
														'lineDiffs'			'the textual source lines diffed from its prior version')
(wordDiffs			toggleWordDiffing			showingWordDiffsString
														'wordDiffs'			'the textual source words diffed from its prior version')
(prettyLineDiffs		togglePrettyLineDiffing	showingPrettyLineDiffsString
														'prettyLineDiffs'		'formatted source lines diffed from formatted prior version')
(prettyWordDiffs	togglePrettyWordDiffing	showingPrettyWordDiffsString
														'prettyWordDiffs'	'formatted source words diffed from prior version')
-
(decompile			toggleDecompile			showingDecompileString
														'decompile'			'source code decompiled from byteCodes')
(byteCodes			toggleShowingByteCodes	showingByteCodesString
														'byteCodes'		'the bytecodes that comprise the compiled method')
	)! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826743!
showingPlainSource
	"Answer whether the receiver is showing plain source"

	^ self contentsSymbol == #source! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826349!
diffFromPriorSourceFor: sourceCode 
	"If there is a prior version of source for the selected method, return a diff, else just return the source code"

	^ self priorSourceOrNil
		ifNil: [ sourceCode ]
		ifNotNil: [ :prior |
			DifferenceFinder
				displayPatchFrom: prior to: sourceCode
				tryWords: self shouldDiffWords
				prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [self selectedClass])]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826822!
selectedMessage
	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."

	| class selector method |

	self showingDecompile ifTrue: [
		^ self decompiledSource ].

	class := self selectedClassOrMetaClass.
	(class isNil or: [(selector := self selectedMessageName) isNil]) ifTrue: [^ ''].
	method := class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"
	currentCompiledMethod := method.

	^ (self showComment
		ifFalse: [self sourceStringPrettifiedAndDiffed]
		ifTrue:	[ self commentContents])
			copy! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826551!
toggleWordDiffing
	"Toggle whether regular-diffing should be shown in the code pane"

	self showWordDiffs: self showingWordDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826677!
showComment
	"Answer whether the receiver should show documentation rather than, say, source code"

	^ self contentsSymbol == #documentation
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826544!
togglePrettyWordDiffing
	"Toggle whether pretty-diffing should be shown in the code pane"

	self showPrettyWordDiffs: self showingPrettyWordDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826472!
showingPrettyWordDiffs
	"Answer whether the receiver is showing pretty diffs of source code"

	^ self contentsSymbol == #prettyWordDiffs
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826098!
selectedMessageCategoryName
	"Answer the name of the message category of the message of the currently selected context."

	^ self selectedClass organization categoryOfElement: self selectedMessageName! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826727!
showingDocumentation
	"Answer whether the receiver should show documentation rather than, say, source code"

	^ self contentsSymbol == #documentation
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826757!
showingPrettyPrint
	"Answer whether the receiver is showing pretty-print"

	^ self contentsSymbol == #prettyPrint! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826435!
showingAnyKindOfPrettyDiffs
	"Answer whether the receiver is currently set to show any kind of pretty diffs"

	^ #(prettyLineDiffs prettyWordDiffs) includes: self contentsSymbol! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826962!
isEditingMethod

	^false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826114 overrides: 16983539!
acceptedStringOrText
	"Answer the source code or documentation for the selected method"

	self showingByteCodes ifTrue: [
		^ self selectedBytecodes].

	self showingDocumentation ifTrue: [
		^ self commentContents].

	^ self selectedMessage! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826395!
showPrettyLineDiffs: aBoolean
	"Set whether I'm showing pretty diffs as indicated"

	self showingPrettyLineDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #prettyLineDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826794!
decompiledSource
	"Obtain a source string by decompiling the method's code.
	Also return the string."
	| class selector method answer |
	class := self selectedClassOrMetaClass.
	selector := self selectedMessageName.
	"Was method deleted while in another project?"
	method := class
		compiledMethodAt: selector
		ifAbsent: [ ^ '' ].
	currentCompiledMethod := method.
	"decompile without temp names "
	answer := (class decompilerClass new
		decompile: selector
		in: class
		method: method) decompileString.
	^ answer copy! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826982!
doItContext
	"Answer the context in which a text selection can be evaluated."

	^nil! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826060!
changeCategory
	"Present a menu of the categories of messages for the current class, 
	and let the user choose a new category for the current message"

	self selectedClassOrMetaClass ifNotNil: [ :cls |
		self selectedMessageName ifNotNil: [ :sel |
			(self letUserReclassify: sel in: cls) ifTrue: [
				self methodCategoryChanged]]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16826778!
toggleShowDocumentation
	"Toggle the setting of the showingDocumentation flag, unless there are unsubmitted edits that the user declines to discard"

	self showDocumentation: self showingDocumentation not! !
!CodeProvider class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16827052!
normalizeCodeForCodeFiles: aTextOrString
	"Adapt edited code to be suitable or logging.
	Answer is a plain text.
	Additionally, if code was modified for better look and edition experience, normalize it.
	This may include reverting to ':=' for assignment, '^' for return, and any replacements of
	ASCII by Unicode symbols done by Shout.
	See also SHTextStylerST80 >> #privateConvert
	See also Clipboard >> #storeObject:"

	| answer |
	answer := aTextOrString asPlainString.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString, UnicodeCodePoint zeroWidthSpace asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkUpArrow asString` with: '^'.
	^answer! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852148!
help
	^self class help! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852378!
selectWord
	"Select exactly one word.
	See also #selectWordOrDelimitedText"

	| wordRange |
	wordRange := self wordRangeIncluding: self pointIndex.
	self selectFrom: wordRange first to: wordRange last! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852151!
morph
	^ morph! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852741!
moveCursor: directionBlock forward: forward event: aKeyboardEvent
	"Private - Move cursor.
	directionBlock is a one argument Block that computes the new Position from a given one."
	| shift indices newPosition |
	shift := aKeyboardEvent notNil and: [aKeyboardEvent shiftPressed].
	indices := self
		setIndices: shift
		forward: forward.
	newPosition := directionBlock value: (indices at: #moving).
	shift
		ifTrue: [
			self
				selectMark: (indices at: #fixed)
				point: newPosition - 1 ]
		ifFalse: [ self deselectAndPlaceCursorAt: newPosition ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852894!
offerMenuFromEsc: aKeyboardEvent
	"The escape key was hit while the receiver has the keyboard focus; take action"

	^ aKeyboardEvent shiftPressed ifFalse: [
		morph mouseButton2Activity ]; not! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852174!
pointIndex

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852243!
pasteString
	"Paste the text's string from the shared buffer over the current selection and 
	redisplay if necessary.
	Pasting a string means using destination current attributes if appropriate."

	self replaceSelectionWith: self clipboardStringOrText asPlainString! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852367!
selectMark: mark point: point
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse: [
		self selectInvisiblyMark: mark point: point ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852579!
enter: aKeyboardEvent
	"Enter / return key was pressed"
	"Process the various Enter / Return keystrokes"
	"Not sure if this is ever called"
	
	^self returnKey: aKeyboardEvent! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852683!
beginningOfNextParagraph: position
	| s |
	s := self privateCurrentString.
	^ (s
		indexOf: Character newLineCharacter
		startingAt: position
		ifAbsent: [ s size ])
			+ 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852719!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this.
	
	Do not push down this method. It is used in SimpleEditor of package Widgets-Extras
	"

	"if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [
		self selectLine ].
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^ returnBlock value ].! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852570!
cursorTopHome: aKeyboardEvent
	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."

	self deselectAndPlaceCursorAt: 1.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852593!
normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |
	"Convert strings like '\+161 ' (š) to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		string at: index :: = $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			key size > 2 and: [ key at: 1 :: = $+ ] ::
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := UnicodeCodePoint codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsability to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) = $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `UnicodeCodePoint codePoint: 16r300` ] -> [ '`' ].
				[ `UnicodeCodePoint codePoint: 16r301` ] -> [ '''' ].
				[ `UnicodeCodePoint codePoint: 16r302` ] -> [ '^' ].
				[ `UnicodeCodePoint codePoint: 16r303` ] -> [ '~' ].
				[ `UnicodeCodePoint codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852340!
selectInterval: anInterval
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	self selectFrom: anInterval first to: anInterval last! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852691!
beginningOfParagraph: position
	| s |
	s := self privateCurrentString.
	^ (s
		lastIndexOf: Character newLineCharacter
		startingAt: (position-1 min: s size)
		ifAbsent: [ 0 ])
			+ 1.! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852489!
cursorPageUp: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo - self pageHeight]
				forward: false]
		forward: false
		event: aKeyboardEvent.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852229!
paste: aKeyboardEvent 
	"Replace the current text selection by the text in the shared buffer."

	self paste.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852525!
cursorUp: aKeyboardEvent 
	"Private - Move cursor from position in current line to same position in
	prior line. If prior line too short, put at end"

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line - 1] forward: false.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [
						newPos := self beginningOfParagraph: newPos-1 ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self beginningOfText ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852170!
markIndex

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852160!
userHasEdited
	"Note that my text is not free of user edits."

	morph hasUnacceptedEdits: true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852708!
endOfParagraph: position
	| s |
	s := self privateCurrentString.
	^ s
		indexOf: Character newLineCharacter
		startingAt: position
		ifAbsent: [ s size + 1 ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852184!
selectionIsEmptyOrSeparators
	"Answer true if no selection or selection is just separators (whitespace)"

	self subclassResponsibility! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852699!
beginningOfText
	^1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852671!
selectAll: aKeyboardEvent 
	"select everything, invoked by cmd-a.  1/17/96 sw"

	self selectAll.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852235!
paste
	"Paste the text from the shared buffer over the current selection and 
	redisplay if necessary."

	self replaceSelectionWith: self clipboardStringOrText! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852852!
sameColumn: start newLine: lineBlock forward: isForward
	"See comment in other implementors."
	self subclassResponsibility! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852178!
selectionInterval
	"Answer the interval that is currently selected."

	^self startIndex to: self stopIndex - 1 ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852715!
endOfText
	^self privateCurrentString size + 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852807!
nextWordStartFrom: aPosition goingForwards: goingForwardsBoolean
	
	"Answer the position of the start of the next word on the current line going
	forwards (or backwards).
	If the given position is the end (or beginning) of the line then answer the
	beginning (or end) of the next (or previous) line."
	
	| string beginningOfLine endOfLine step offset index newPosition |
	
	string := self privateCurrentString.
	beginningOfLine := self beginningOfLine: aPosition.
	endOfLine := self endOfLine: aPosition.
	step := goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	offset := goingForwardsBoolean ifTrue: [0] ifFalse: [-1].
	
	index := aPosition.
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers]]
			whileTrue: [index := index + step].
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers not]]
			whileTrue: [index := index + step].
	
	newPosition := index = aPosition ifTrue: [index + step] ifFalse: [index].
	^newPosition min: string size + 1 max: 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852219!
cut: aKeyboardEvent 
	"Cut out the current text selection."

	self cut.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852903!
cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^self class cmdShortcuts! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852677!
beginningOfLine: position
	"Redefined in subclasses using TextComposition"
	^ self beginningOfParagraph: position! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852453!
cursorLeft: aKeyboardEvent
	"Private - Move cursor left one character if nothing selected, otherwise move cursor to beginning of selection. If the shift key is down, start selecting or extending current selection.
	Don't allow cursor past beginning of text"

	self
		moveCursor: [ :position | | newPos |
			newPos := position - 1.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ newPos := self previousWordStart: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self beginningOfLine: position ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852254!
delimitedRangeAt: index hitOnRightHalf: hitOnRightHalfOfDelimiter leftDelimiters: leftDelimiters rightDelimiters: rightDelimiters simpleDelimiters: simpleDelimiters
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter finalDelimiter direction leftMatch rightMatch simpleMatch includeDelimiters level string hitOnRightHalf here hereChar start stop sSize |
	string := self privateCurrentString.
	sSize := string size.
	sSize < 2 ifTrue: [^1 to: 1].
	hitOnRightHalf := hitOnRightHalfOfDelimiter.
	here := index min: sSize max: 2.
	((string at: here) isLineSeparator and: [ here > 2 ]) ifTrue: [
		here := here - 1.
		hitOnRightHalf := true ].
	initialDelimiter := string at: here.
	leftMatch := leftDelimiters indexOf: initialDelimiter.
	rightMatch := rightDelimiters indexOf: initialDelimiter.
	simpleMatch := simpleDelimiters  indexOf: initialDelimiter.
	leftMatch + rightMatch + simpleMatch = 0 ifTrue: [
		"no delimiters, then just select word."
		^self wordRangeIncluding: index ].

	(simpleMatch > 0 & hitOnRightHalf or: [leftMatch > 0])
		ifTrue: [	"Hit on right half of simple delimiter or is a left delimiter -- match to the right"
			start := here.
			direction := 1 ]
		ifFalse: [ 	"Hit on left half of simple delimiter or is a right delimiter-- match to the left"
			stop := here.
			direction :=  -1 ].
	
	simpleMatch > 0
		ifTrue: [
			finalDelimiter := initialDelimiter.
			includeDelimiters := false ]
		ifFalse: [
			leftMatch > 0
				ifTrue: [
					finalDelimiter := rightDelimiters at: leftMatch.
					includeDelimiters := hitOnRightHalf not ]
				ifFalse: [
					finalDelimiter := leftDelimiters at: rightMatch.
					includeDelimiters := hitOnRightHalf ]].

	level := 1.
	[ level > 0 and: [ direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			here := here + direction.
			hereChar := string at: here.
			"delimiter match just counts nesting level"
			hereChar = finalDelimiter
				ifTrue: [level := level - 1"leaving nest"]
				ifFalse: [
					hereChar = initialDelimiter 
						ifTrue: [level := level + 1"entering deeper nest" ]]].
	level > 0 ifTrue: [
		"If we failed to find final delimiter, then just select word."
		^self wordRangeIncluding: index ].
	direction > 0
		ifTrue: [ stop := here ]
		ifFalse: [ start := here ].
	^includeDelimiters
		ifTrue: [ start to: stop ]
		ifFalse: [ start+1 to: stop-1 ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852355!
selectInvisiblyMark: mark point: point
	"Select the designated characters, inclusive.  Make no visual changes."

	self markIndex: mark pointIndex: point + 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852209!
clipboardTextPut: textOrString

	^ Clipboard storeObject: textOrString! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852387!
wordRangeIncluding: aPositionInText
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter direction level string here hereChar start sSize |
	string := self privateCurrentString.
	sSize := string size.
	sSize < 2 ifTrue: [^1 to: 1].
	here := aPositionInText min: sSize max: 2.
	initialDelimiter := string at: here.
	"no delimiters -- select a token"
	direction := -1.
	level := 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar := string at: (here := here + direction).
			"token scan goes left, then right"
			hereChar isValidInIdentifiers 	"Consider $: as a word separator"
				ifTrue: [
					here = 1
						ifTrue: [
							start := 1.
							"go right if hit string start"
							direction := 1]]
				ifFalse: [
					direction < 0
						ifTrue: [
							start := here + 1.
							"go right if hit non-token"
							direction := 1]
						ifFalse: [level := 0]]].
	level > 0 ifTrue: [
		here := here + direction ].
	"If a word ends with $: (a keyword), consider it part of the word"
	hereChar = $: ifTrue: [here := here + 1].
	^start to: here - 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50430553!
codeCoverageInfoAt: mousePositionInText 
	
	^ [
		(morph owningWindow model isKindOf: CodeCoverageAnalyzerBrowser)
			ifTrue: [ morph owningWindow model codeCoverageInfoAt: mousePositionInText ]
			ifFalse: [ '' ] ]
		on: Error do: [ '' ] ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852549!
selectWord: aKeyboardEvent

	self selectWord.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852214!
copySelection: aKeyboardEvent
	"Copy the current text selection."

	self copySelection.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852479!
cursorPageDown: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo + self pageHeight]
				forward: true]
		forward: true
		event: aKeyboardEvent.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852587!
newLine: aKeyboardEvent

	self addString: (UnicodeString with: Character newLineCharacter).
	^false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852858!
setIndices: shiftPressed forward: forward
	"Little helper method that sets the moving and fixed indices according to some flags."
	| indices |
	indices := Dictionary new.
	(shiftPressed and:[Preferences at: #selectionsMayShrink])
		ifTrue: [
			indices at: #moving put: self pointIndex.
			indices at: #fixed put: self markIndex
		] ifFalse: [
			forward
				ifTrue:[
					indices at: #moving put: self stopIndex.
					indices at: #fixed put: self startIndex.
				] ifFalse: [
					indices at: #moving put: self startIndex.
					indices at: #fixed put: self stopIndex.
				]
		].
	^indices! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852879!
wordSelectAndEmptyCheck: returnBlock
	"Ensure selecting the entire current word; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectWord.  "Select exactly a whole word"
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^ returnBlock value ].! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852666!
selectAll

	self selectFrom: 1 to: self privateCurrentString size! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852331!
deselectAndPlaceCursorAt: characterIndex 
	"Deselect, then place the text cursor before the character at characterIndex.
	 Be sure it is in view."

	self selectFrom: characterIndex to: characterIndex - 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852363!
selectLine

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852348!
selectInvisiblyFrom: start to: stop
	"Select the designated characters, inclusive.  Make no visual changes."

	self markIndex: start pointIndex: stop + 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852843!
previousWordStart: aPosition
	
	^self nextWordEndFrom: aPosition goingForwards: false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852761!
nextWordEnd: aPosition
	
	^self nextWordEndFrom: aPosition goingForwards: true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852848!
privateCurrentString

	self subclassResponsibility! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852426!
cursorDown: aKeyboardEvent
	"Private - Move cursor from position in current line to same position in
	next line. If next line too short, put at end. If shift key down,
	select."

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line + 1 ] forward: true.
			"Mac standard keystroke"
			aKeyboardEvent rawMacOptionKeyPressed ifTrue: [
				newPos := self endOfParagraph: position+1 ].
			"Windows / Linux standard keystroke"
			aKeyboardEvent controlKeyPressed ifTrue: [
				newPos := self beginningOfNextParagraph: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self endOfText ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852554!
backspace: aKeyboardEvent
	"Backspace over the last character."
	"This is a user command, and generates undo"

	| startIndex |
	(aKeyboardEvent rawMacOptionKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [ ^ self backWord: aKeyboardEvent ].
	startIndex := self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).
	startIndex := 1 max: startIndex - 1.
	self backTo: startIndex.
	^ false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852499!
cursorRight: aKeyboardEvent 
	"Private - Move cursor right one character if nothing selected, otherwise move cursor to end of selection. If the shift key is down, start selecting characters or extending already selected characters. 
	Don't allow cursor past end of text"

	self
		moveCursor: [ :position | | newPos |
			newPos := position + 1.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ newPos := self nextWordEnd: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self endOfLine: position ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852166!
hasSelection

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852199!
clipboardStringOrText

	| clipContents |
	clipContents := Clipboard retrieveStringOrText.
	^ ((clipContents is: #Text) and: [ clipContents respondsTo: #asNonStyledText ])
		ifTrue: [ clipContents asNonStyledText ]
		ifFalse: [ clipContents ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852802!
nextWordStart: aPosition
	
	^self nextWordStartFrom: aPosition goingForwards: true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852224!
noop: aKeyboardEvent 
	"Unimplemented keyboard command; just ignore it."

	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852766!
nextWordEndFrom: aPosition goingForwards: goingForwardsBoolean
	
	"Answer the position of the end of the next word on the current line going
	forwards (or backwards).
	If the given position is the end (or beginning) of the line then answer the
	beginning (or end) of the next (or previous) line."
	
	| string beginningOfLine endOfLine step offset index newPosition |
	
	string := self privateCurrentString.
	beginningOfLine := self beginningOfLine: aPosition.
	endOfLine := self endOfLine: aPosition.
	step := goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	offset := goingForwardsBoolean ifTrue: [0] ifFalse: [-1].
	
	index := aPosition.
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers not]]
			whileTrue: [index := index + step].
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers]]
			whileTrue: [index := index + step].
	
	newPosition := index = aPosition ifTrue: [index + step] ifFalse: [index].
	^newPosition min: string size + 1 max: 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852143!
currentAttributes
	"Redefined by subclasses that handle TextAttributes"
	^nil! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852910!
shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^self class shortcuts! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852702!
endOfLine: position
	"Redefined in subclasses using TextComposition"
	^self endOfParagraph: position! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852650!
returnKey: aKeyboardEvent
	"Return / Enter / key was pressed"
	"Process the various Return / Enter keystrokes"
	
	morph acceptOnCR ifTrue: [
		^ true].
	aKeyboardEvent commandAltKeyPressed ifTrue: [
		(aKeyboardEvent controlKeyPressed | aKeyboardEvent rawMacOptionKeyPressed) ifTrue: [
			self addString: UnicodeString crString.
			^false ].
		self addString: UnicodeString crlfString.
		^false ].
	^ self newLine: aKeyboardEvent! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852191!
startIndex

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852154!
morph: aMorph
	"Install a link back to the morph being edited (esp for text links)"
	morph := aMorph ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852195!
stopIndex

	self subclassResponsibility ! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852974!
initializeShortcuts
	"Initialize the table for regular (i.e. non-command) keystroke dispatch"
	"
	self initializeShortcuts
	"
	| actions |
	actions := Array new: 256 withAll: #normalCharacter:.
	0 to: 31 do: [ :i | actions at: i+1 put: #noop: ].
	actions at: 1 + 1 put: #cursorHome:.				"home key"
	actions at: 3 + 1 put: #enter:.						"enter / return key"
	actions at: 4 + 1 put: #cursorEnd:.				"end key"
	actions at: 5 + 1 put: #noop:.						"insert key"
	actions at: 8 + 1 put: #backspace:.				"macDelete winBackspace key"
	actions at: 9 + 1 put: #normalCharacter:.		"tab"
	actions at: 11 + 1 put: #cursorPageUp:.			"page up key"
	actions at: 12 + 1 put: #cursorPageDown:.		"page down key"
	actions
		at:  InputSensor returnKey + 1
		put: #returnKey:.									"return (sometimes labelled enter) key"
	actions at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"
	actions at: 28 + 1 put: #cursorLeft:.				"left arrow key"
	actions at: 29 + 1 put: #cursorRight:.				"right arrow key"
	actions at: 30 + 1 put: #cursorUp:.				"up arrow key"
	actions at: 31 + 1 put: #cursorDown:.			"down arrow key"
	actions at: 127 + 1 put: #forwardDelete:.		"winDelete key"
	shortcuts := actions! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853089!
help
	"
	TextEditor help edit
	SmalltalkEditor help edit
	"
	^ (self formatShortcutsUsingModifierKey: 'Shift' andSpecs: self allShiftShortcutsSpec) ,
		(self formatShortcutsUsingModifierKey: 'Cmd' andSpecs: self allCmdShortcutsSpec).
! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852949 overrides: 16916096!
initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c basicInitialize ]! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852930!
collectCmdShortcutsSpecUsing: anInitializationMessage

	| shortcutsSpec dynamicInitializationMessage |
	
	shortcutsSpec := self perform: anInitializationMessage.

	dynamicInitializationMessage := (self name asPlainString uncapitalized, anInitializationMessage asPlainString capitalized) asSymbol.
	(Smalltalk allClassesImplementing: dynamicInitializationMessage) do: [ :aClass | 
		shortcutsSpec := shortcutsSpec, (aClass soleInstance perform: dynamicInitializationMessage) ].

	^shortcutsSpec

! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853037!
allShiftShortcutsSpec

	^ self shiftShortcutsSpec! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853099 overrides: 16789356!
releaseClassCachedState

	shortcuts := nil.
	cmdShortcuts := nil.! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853029!
allCmdShortcutsSpec

	^ (self collectCmdShortcutsSpecUsing: #basicCmdShortcutsSpec), (self collectCmdShortcutsSpecUsing: #cmdShortcutsSpec)! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853042!
basicCmdShortcutsSpec

	^#()! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853059!
shiftShortcutsSpec
	"Only for help. See senders."

	^#(
		#(		'Enter' 	#globalFindClass: 'Global Find class name or fragment')
	)! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853055!
cmdShortcutsSpec

	^#()! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853014!
putIntoCmdShortcuts: shortcutsSpec

	shortcutsSpec do: [ :ary | | i previous |
		i := ary first numericValue + 1.
		previous := cmdShortcuts at: i.
		previous = #noop:
			ifTrue: [
				cmdShortcuts at: i put: ary second ]
			ifFalse: [ 
				('Editor shortcut: ', ary first printString, ' already taken for: ', previous, 
				'. Override request for: ', ary second, '  ignored') print ]].! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852923!
basicInitialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c initializeShortcuts; initializeCmdShortcuts ]! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16852955!
initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table.
	If you want to add a new shortcut for an specific editor, for example SmalltalkEditor, you should
	define the message #smalltalkEditorCmdShortcutsSpec in a class of your category and it will
	be dynamically send"

	"NOTE: if you don't know what your keyboard generates, use Sensor test"

	"
	Editor initialize
	"

	cmdShortcuts := Array new: 256 withAll: #noop:.

	self putIntoCmdShortcuts: self allCmdShortcutsSpec
! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853074!
formatShortcutsUsingModifierKey: aModifierKey andSpecs: aSpecs
	"Format shortcuts specs with a modifier key"
	^ String streamContents: [ :strm |
		aSpecs do: [ :triplet | | c |
			c := triplet first = Character space
				ifFalse: [ triplet first asString, '   	' ]
				ifTrue: [ 'Space'].
			strm nextPutAll: (aModifierKey, '-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853066!
shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	
	shortcuts ifNil: [ self initializeShortcuts ].
	
	^shortcuts! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16853046!
cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	
	cmdShortcuts ifNil: [self initializeCmdShortcuts ].
	
	^cmdShortcuts! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899763!
createCategories

	| classCategories |
	
	categories := OrderedCollection with: 'new ...'.
	lines := OrderedCollection with: 1. 
	classCategories := startClass methodCategoriesAsSortedCollection.
	
	reject := classCategories asSet.
	reject
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	
	startClass isMeta ifTrue: [ self initializeCategoriesWhenMeta: classCategories].
	rejectingFirst ifFalse: [ categories addAll: classCategories ]! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899787!
initializeCategoriesWhenMeta: classCategories

	categories add: Categorizer instanceCreation.
	classCategories remove: Categorizer instanceCreation ifAbsent: [].
	reject add: Categorizer instanceCreation! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899808!
requestNewCategory
	
	^self request: 'New category name?' initialAnswer: 'category-name'! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899781!
initializeCategories
	
	self 
		createCategories;
		addCategories! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899818!
lines

	^lines ! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899742!
addCategories

	startClass allSuperclasses do: [ :superclass | self addCategoriesOf: superclass ]! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899718!
initializeStaringFrom: aClass rejectingFirst: aRejectingFirst

	startClass := aClass.
	rejectingFirst := aRejectingFirst.
	
	self initializeCategories ! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899726!
prompt: aPrompt ifNone: aNoneBlock

	| selectedCategoryIndex categoryName |
	
	selectedCategoryIndex := self promptCategory: aPrompt.
	selectedCategoryIndex = 0 ifTrue: [^ aNoneBlock value].
	
	categoryName := selectedCategoryIndex = 1 ifTrue: [ self requestNewCategory ] ifFalse: [ categories at: selectedCategoryIndex ].
	categoryName isEmpty ifTrue: [ ^aNoneBlock value ].
	
	^categoryName
	! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899814!
categories

	^categories! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899797!
promptCategory: aPrompt
	
	| selectedLabelIndex |
	
	selectedLabelIndex := categories size = 1 
		ifTrue: [ 1 ]
	 	ifFalse: [ (PopUpMenu labelArray: categories lines: lines) startUpWithCaption: aPrompt ].
	
	^selectedLabelIndex! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899749!
addCategoriesOf: aSuperclass

	| superclassCategories |
	
	superclassCategories := aSuperclass methodCategoriesAsSortedCollection reject: [ :category | reject includes: category].
	
	superclassCategories isEmpty ifFalse: [
		lines add: categories size.
		categories addAll: superclassCategories.
		reject addAll: superclassCategories]! !
!MethodCategoriesPrompter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16899828!
staringFrom: aClass rejectingFirst: rejectingFirst 
	
	^self new initializeStaringFrom: aClass rejectingFirst: rejectingFirst 
! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925701 overrides: 16913521!
bindingOf: aString

	^textProvider bindingOf: aString! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925531!
textProvider
	^textProvider! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925587 overrides: 16982534!
acceptContentsFrom: aTextModelMorph
	textSetter ifNil: [ ^ true ].
	^ textSetter numArgs = 2
		ifTrue: [
			textProvider
				perform: textSetter
				with: actualContents
				with: aTextModelMorph ]
		ifFalse: [
			textProvider
				perform: textSetter
				with: actualContents ].! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925686 overrides: 16982844!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925549 overrides: 16982502!
getSelection
	"Answer the model's selection interval."

	^selectionGetter ifNotNil: [
		textProvider perform: selectionGetter ]! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925678 overrides: 16982837!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925637 overrides: 16982724!
autoCompleterClass
	^textProvider autoCompleterClassFor: textGetter! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925613 overrides: 16982810!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	This is useful in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^textProvider styleByParagraphs! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925575 overrides: 16915792!
update: aSymbol
	"We are being notified of a change in our provider.
	Notify our dependents"
	"
	self changed: aSymbol
	"
	aSymbol == textGetter ifTrue: [ ^self changed: #acceptedContents ].
	aSymbol == selectionGetter ifTrue: [ ^self changed: #initialSelection ].
	self changed: aSymbol! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925626!
initWith: aTextProvider
	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."

	textProvider := aTextProvider.
	undoRedoCommands := ReadWriteStream on: #().
	lastEditTimeStamp := nil! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925654 overrides: 16982801!
textStylerClass
	^textProvider textStylerClassFor: textGetter! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925694 overrides: 16982851!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925642 overrides: 16982787!
editorClass
	^textProvider editorClassFor: textGetter! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925570 overrides: 16914636!
releaseCachedState
	textProvider releaseCachedState! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925535 overrides: 16982517!
is: aSymbol
	^ aSymbol == #hasTextProvider or: [ super is: aSymbol ]! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925556 overrides: 16982507!
refetch
	"Answer true if actualContents was actually fetched."
	textGetter
		ifNil: [
			actualContents ifNil: [
				self actualContents: Text new ].
			^false ]
		ifNotNil: [
			self actualContents: (Text
				initialFont: (Preferences at: #standardCodeFont)
				stringOrText: (textProvider perform: textGetter)).
			self changed: #refetched.
			^true ]! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925524!
textGetter: symbol1 textSetter: symbol2 selectionGetter: symbol3
	textGetter := symbol1.
	textSetter := symbol2.
	selectionGetter := symbol3! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925599 overrides: 16982805!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	^textProvider shouldStyle: text with: anSHTextStyler! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925659 overrides: 16982822!
classOfThisContext

	^ textProvider classOfThisContext ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925545 overrides: 16982530!
wantsFrameAdornments

	^textSetter notNil! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925647 overrides: 16982795!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^textProvider shouldAutoHighlight! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925664 overrides: 16982826!
classOfWorkspaceVarNamed: aName

	^ textProvider classOfWorkspaceVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925519 overrides: 16982458!
actualContents
	actualContents ifNil: [ self refetch ].
	^actualContents! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925670 overrides: 16982830!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925540!
refusesToAccept
	^textProvider is: #refusingToAccept! !
!PluggableTextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16925712!
on: aTextProvider
	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."
	^self basicNew initWith: aTextProvider! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954312!
extractToTemporary

	self performCodeExtractionRefactoringWith: ExtractToTemporaryApplier! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506906!
actualLocalImplementorsOfIt: aKeyboardEvent

	self actualLocalImplementorsOfIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506982!
showSelectionTypeInfo

	self isEditingClassDefinition 
		ifTrue: [ self showTypeInfoOfInstanceVariable ]
		ifFalse: [ self showSelectionTypeInfoInMethod ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50507025!
showTypeInfoOfInstanceVariable

	| instVarName typeInfo |
	
	instVarName := self wordUnderCursor asString.
	typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^morph flash].

	^(InstanceVariableTypesDisplay typeInfo: typeInfo) showTypes 
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953004!
changeSelectorOf: aMessageNode in: aSelectedClass at: aSelectedSelector using: aChangeSelectorApplier

	aChangeSelectorApplier
		on: aMessageNode
		createAndValueHandlingExceptionsOn: model textProvider
		in: aSelectedClass
		at: aSelectedSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419307!
moveInstanceVariable: aNodeUnderCursor in: aSelectedClass at: aMethodNode

	aNodeUnderCursor isTempOrArg ifTrue: [ ^morph flash ].

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		aNodeUnderCursor isInstanceVariableNode 
			ifTrue: [^self moveInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aSelectedClass ]
			ifFalse: [^morph flash]. ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954853!
argNext: aKeyboardEvent
	"Invoked by cmd-A.
	 Search forward from the end of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the end of the text.."

	| start t |
	t := model actualContents.
	start := t findString: ': ' startingAt: self startIndex.
	start = 0 ifTrue: [ start := t size + 1].
	self deselectAndPlaceCursorAt: start + 2.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953583!
selectForInspection: aNodeUnderCursor in: aMethodNode 
	
	(aNodeUnderCursor isLiteralNode or: [ aNodeUnderCursor isVariableNode ]) ifTrue: [ ^self selectNodeRange: aNodeUnderCursor in: aMethodNode ].
	aNodeUnderCursor isMessageNode ifTrue: [ ^self selectMessageNode: aNodeUnderCursor in: aMethodNode ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953038!
contextualChangeSelectorInMethodUsing: aChangeSelectorApplier
	
	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualChangeSelectorOf: methodNode in: selectedClass using: aChangeSelectorApplier ]
		ifErrorsParsing: [ :anError | morph flash ]		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506957!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955031!
hoverHelpToShowEvaluating: aNodeUnderCursor

	^ [[ self hoverHelpStringOfEvaluating: aNodeUnderCursor]
		on: MessageNotUnderstood 
		do: [ :mnu | | receiverPrintString | 
			"just guessing if the real receiver is the one in the message node to show a nicer error message.
			This will not be correct in cases such as: v1 xx: (v2 xx: 1). In this case will show that v1 does not understand xx: 
			when it is v2 the one that does not understand it, but this is so rare that I leave it anyway - Hernan"
			receiverPrintString := mnu message selector = aNodeUnderCursor selectorSymbol 
				ifTrue: [ aNodeUnderCursor originalReceiver printSourceCode ]
				ifFalse: [ mnu receiver printString ].
			mnu return: receiverPrintString, ' does not understand ', mnu message selector]]
		on: Error 
		do: [ :anError | anError return: anError messageText ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954515!
implementorsOfItWhenErrorsParsing

	"Open an implementors browser on the selected selector"

	| aSelector |

	self lineSelectAndEmptyCheck: [^ self].
	(aSelector := self selectedSelector) ifNil: [^ morph flash].
	Smalltalk browseAllImplementorsOf: aSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954323!
extractMethod

	self performCodeExtractionRefactoringWith: ExtractMethodApplier! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953691!
acceptAndTestAll: aKeyboardEvent

	^self acceptAndTestAll! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953015!
changeSelectorTo: aSelector in: aClassToRefactor using: aChangeSelectorApplier
	
	aChangeSelectorApplier 
		createAndValueHandlingExceptionsOn: model textProvider 
		for: aSelector 
		in: aClassToRefactor ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954979!
lineOrNodeSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, either
		- expand it to be the entire current line
		- or expand it to a meaningful chunk of code.
	If after that's done the selection is still empty, then evaluate the returnBlock."

	self hasSelection ifFalse: [
		(model actualContents isLineEndAt: self pointIndex)
			ifTrue: [ self selectLine ]
			ifFalse: [
				self
					withMethodNodeAndClassDo: [ :methodNode :selectedClass |
						self selectNodeUnderCursorForInspectionIn: methodNode ]
					ifErrorsParsing: [ :anError | ]]].
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^returnBlock value ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506890!
actualImplementorsOfIt: aKeyboardEvent

	self actualImplementorsOfIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954936 overrides: 50578750!
normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string := self privateCurrentString.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	self pointIndex - 1 to: (self pointIndex - 20 max: 1) by: -1 do: [:i|
		(string at: i) = $\ ifTrue: 
			[key := string copyFrom: i + 1 to: self pointIndex - 1.
			UnicodeCodePoint namedCharactersMap at: key ifPresent: [:value| self selectFrom: i to: self pointIndex - 1; replaceSelectionWith: (UnicodeString with: value)].
			^ super normalCharacter: aKeyboardEvent]].
	^ super normalCharacter: aKeyboardEvent! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954870!
argPrev: aKeyboardEvent
	"Invoked by cmd-Q.
	 Search backwards from the start of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the start of the text.."

	| t i |
	t := model actualContents.
	i := self stopIndex.
	i > 1 ifTrue: [
		i := i -2.
		[i > 0 and: [ (t at: i) ~= $  or: [(t at: i-1) ~= $: ]]] whileTrue: [
			i := i -1 ].
		self deselectAndPlaceCursorAt: i + 1.
	].
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50507037!
typeCheckMethod
	
	self hasUnacceptedEdits ifTrue: [ ^self inform: 'The method can not be typed check because source code is not saved' ].
	
	self codeProvider typeCheckMethod.
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953533!
exploreIt

	self lineOrNodeSelectAndEmptyCheck: [^ self ].
	self
		evaluateSelectionAndDo: [ :result | result explore ]
		ifFail: [ ^morph flash ]
		profiled: false.
	morph convertAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953498!
doItSourceCodeFor: aSourceCode in: anEvaluationContext

	^UnicodeString streamContents: [ :stream |
		Scanner doItSourceCodeHeaderWithContext: anEvaluationContext notNil into: stream.
		stream nextPutAll: aSourceCode		]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419322!
moveInstanceVariableOn: aBrowser at: aClassToRefactor
	self moveInstanceVariableOn: aBrowser for: nil at: aClassToRefactor.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954016!
explainCtxt: symbol 
	"Is symbol a context variable?"

	| reply classes text cls provider |
	symbol = #nil ifTrue: [reply := ' is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables.'].
	symbol = #true ifTrue: [reply := ' is a constant.  It is the only instance of class True and is the receiver of many control messages.'].
	symbol = #false ifTrue: [reply := ' is a constant.  It is the only instance of class False and is the receiver of many control messages.'].
	symbol = #thisContext ifTrue: [reply := ' is a context variable.  Its value is always the MethodContext which is executing this method.'].
	provider := self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [
		cls := provider selectedClassOrMetaClass].
	cls ifNil: [^ reply].	  "no class known"
	symbol = #self ifTrue: 
			[classes := cls withAllSubclasses.
			classes size > 12
				ifTrue: [text := cls printString , ' or a subclass']
				ifFalse: 
					[classes := classes printString.
					text := 'one of these classes' , (classes copyFrom: 4 to: classes size)].
			reply := ' is the receiver of this message; an instance of ' , text ].
	symbol = #super ifTrue: [reply := 'is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')'].
	^reply ifNotNil: [symbol, reply]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954649!
sendersOfItWhenErrorsParsing

	"Open a senders browser on the selected selector"

	| aSelector |

	self lineSelectAndEmptyCheck: [^ self].
	(aSelector := self selectedSelector) ifNil: [^ morph flash].
	Smalltalk browseAllCallsOn: aSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954724!
selectPrecedingIdentifier
	"Invisibly select the identifier that ends at the end of the selection, if any."

	| string sep stop tok |
	tok := false.
	string := self privateCurrentString.
	stop := self stopIndex - 1.
	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop := stop - 1].
	sep := stop.
	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok := true. sep := sep - 1].
	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953838!
explainChar: string
	"Does string start with a special character?"

	| char |
	char := string at: 1.
	char = $. ifTrue: [^'Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float).'].
	char = $' ifTrue: [^'The characters between two single quotes are made into an instance of class String'].
	char = $" ifTrue: [^'Double quotes enclose a comment.  Smalltalk ignores everything between double quotes.'].
	char = $# ifTrue: [^'The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants.'].
	(char = $( or: [char = $)]) ifTrue: [^'Expressions enclosed in parenthesis are evaluated first'].
	(char = $[ or: [char = $]]) ifTrue: [^'The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockClosure and is usually passed as an argument.'].
	(char = ${ or: [char = $}]) ifTrue: [^ 'A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array'].
	(char = $< or: [char = $>]) ifTrue: [^'<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails.'].
	char = $^ ifTrue: [^'Up arrow means return from this method.  The value returned is the expression following the ^'].
	char = $| ifTrue: [^'Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code.'].
	char = $_ ifTrue: [^'Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it.'].
	char = $; ifTrue: [^'Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon.'].
	char = $: ifTrue: [^'A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withNewLines, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon).'].
	char = $$ ifTrue: [^'The single character following a dollar sign is made into an instance of class Character'].
	char = $- ifTrue: [^'A minus sign in front of a number means a negative number.'].
	char = $e ifTrue: [^'An e in the middle of a number means that the exponent follows.'].
	char = $r ifTrue: [^'An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base.'].
	char = Character space ifTrue: [^'the space Character'].
	char = Character tab ifTrue: [^'the tab Character'].
	char = Character cr ifTrue: [^'the carriage return Character'].
	char = Character lf ifTrue: [^'newline. The line feed Character'].
	^nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954834!
temporaryToInstanceVariable: aKeyboardEvent

	self temporaryToInstanceVariable.

	^true.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419329!
moveInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor
	"self halt."
	(RefactoringApplier moveInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954149!
explainInst: string 
	"Is string an instance variable of this class?"
	| classes cls provider |
	provider := self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [
		cls := provider selectedClassOrMetaClass].
	cls ifNil: [^ nil].	  "no class known"
	classes := (Array with: cls)
				, cls allSuperclasses.
	classes := classes detect: [:each | (each instVarNames
			detect: [:name | name = string] ifNone: nil)
			notNil] ifNone: [^nil].
	classes := classes printString.
	^ String streamContents: [:str |
		str
			nextPutAll: string;
			nextPutAll: ' is an instance variable of the receiver; defined in class ';
			nextPutAll: classes, '\' withNewLines;
			nextPutAll: 'Smalltalk browseAllAccessesTo: ''';
			nextPutAll: string;
			nextPutAll: ''' from: ';
			nextPutAll: classes;
			nextPut: $.]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953377!
selectedClassOrMetaClassOrUndefinedObject

	"I have to do this because some codeProviders do not answer selectedClassOrMetaClass like the Workspace - Hernan"
	
	^ [ self codeProvider selectedClassOrMetaClass ] 
		on: Error 
		do: [ :anError | anError return: UndefinedObject ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953328!
renameGlobalOn: aBrowser for: anOldName

	(RenameGlobalApplier on: aBrowser for: anOldName) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955061!
implementorsOfNodeUnder: aMousePosition

	| mousePositionInText |
	
	mousePositionInText := morph positionInTextOf: aMousePosition.
	self browseImplementorsAt: mousePositionInText ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953420!
afterCompiling: aSourceCode do: aBlock for: aReceiver in: anEvaluationContext ifFail: aFailBlock
	
	| methodNode method sourceCode compiler |

	sourceCode := self doItSourceCodeFor: aSourceCode in: anEvaluationContext.
	
	methodNode := [
		compiler := Compiler new.
		compiler		
			compileDoIt: sourceCode
			in: aReceiver class
			context: anEvaluationContext
			notifying: self
			ifFail: [ ^ aFailBlock value ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method := methodNode generate.
	method methodNode: methodNode.

	^aBlock value: compiler value: method value: aReceiver value: anEvaluationContext 
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955165!
inlineTemporaryVariable: aKeyboardEvent

	self inlineTemporaryVariable.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954617!
selectedSymbol
	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"

	| aString |
	self hasSelection ifFalse: [^ nil].
	aString := self selectedString withoutSeparators.
	aString isEmpty ifTrue: [^ nil].
	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].

	^ nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954547 overrides: 50578906!
paste
	| objectName |
	
	model canBindVariables ifTrue: [
		"Not a copy!!!!!!"
		Clipboard contentsOriginalObject ifNotNil: [ :object |
			objectName := model nameForObject: object.
			(model bindingOf: objectName) value: object.
			self replaceSelectionWith: objectName.
			^ self ]].
	^ super paste! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954822!
temporaryToInstanceVariable

	self
		withNodeUnderCursorDo: [ :nodeUnderCursor |
			(nodeUnderCursor isTemp and: [nodeUnderCursor isArg not])
				ifTrue: [ TemporaryToInstanceVariableApplier on: self for: nodeUnderCursor name :: value ]
				ifFalse: [ morph flash ]]
		ifAbsent: [ morph flash ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419228!
contextualMoveInstanceVariable
	"self halt."
	self isEditingClassDefinition 
		ifTrue: [ self contextualMoveInstanceVariableInClassDefinition ]
		ifFalse: [ self contextualMoveInstanceVariableInMethod ].
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50541521!
balloonTypeInfoOf: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class) 
		calculateTypesWithContext; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954800!
testSuiteForCategoryOf: aClass

	| selectedSystemCategory |
	
	"If we are in a senders or implementors window, a MessageSet, the selectedSystemCategory is nil.
	In that case most of those cases the user wants to run the tests of the category of the selected method class - Hernan"
	selectedSystemCategory := self codeProvider selectedSystemCategory ifNil: [ aClass category ].
	^TestSuite forSystemCategoryNamed: selectedSystemCategory using: SystemOrganization 
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954501!
implementorsOfIt
	"Open an implementors browser.
	If text selection defines a selector, take it. Otherwise, try finding selector under cursor. If this fails, consider the whole line."

	^self selectedSelector 
		ifNil: [ self browseImplementorsAt: self startIndex ]
		ifNotNil: [ :selector | Smalltalk browseAllImplementorsOf: selector ].
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955087!
contextualInlineMethod

	self isEditingClassDefinition ifTrue: [ ^morph flash ].
	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualInlineMethodOf: methodNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]	]	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954691!
withSelectorUnderCursorDo: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock

	self withSelectorAt: self startIndex do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954104!
explainGlobal: symbol 
	"Is symbol a global variable?"
	| reply classes |
	reply := Smalltalk at: symbol ifAbsent: [^nil].
	(reply class == Dictionary or:[reply isKindOf: SharedPool class])
		ifTrue: 
			[classes := Set new.
			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]
					ifNone: nil)
					ifNotNil: [classes add: each]].
			classes := classes printString.
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a global variable.  It is a pool which is used by the following classes ';
					nextPutAll: (classes allButFirst: 5) ]].
	(reply isKindOf: Behavior)
		ifTrue: [^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a global variable.  ';
				nextPutAll: symbol;
				nextPutAll: ' is a class in category ';
				nextPutAll: reply category, '.', '\' withNewLines;
				nextPutAll: 'BrowserWindow fullOnClass: ';
				nextPutAll: symbol;
				nextPutAll: ' selector: nil';
				nextPut: $.]].
	symbol == #Smalltalk 
		ifTrue: [^ symbol, ' is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables.'].
	^ String streamContents: [:str |
		str
			nextPutAll: symbol;
			nextPutAll: ' is a global variable.  ';
			nextPutAll: symbol;
			nextPutAll: ' is ';
			nextPutAll: reply printString ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954370!
browseImplementorsAt: aPosition

	self 
		withSelectorAt: aPosition 
		do: [ :selector | Smalltalk browseAllImplementorsOf: selector ]
		ifBehavior: [ :behavior | BrowserWindow fullOnClass: behavior selector: nil ]
		otherwise: [ self implementorsOfItWhenErrorsParsing ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953363!
renameTemporary: aTemporaryNode at: aMethodNode

	self codeProvider isEditingMethod ifTrue: [ | applier |
		[ applier := RenameTemporaryApplier on: self for: aTemporaryNode at: aMethodNode ]
			on: SyntaxErrorNotification
			do: [:anError | ^self inform: (RenameTemporaryApplier errorMessageForCanNotParseMethod: anError) ].
		applier value ].
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954966!
codeProvider
	^ (model is: #hasTextProvider)
		ifTrue: [ model textProvider ]
		ifFalse: [ model ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955002!
performCodeExtractionRefactoringWith: aRefactoringApplierClass

	"To prevent the refactoring to be evaluated on editors w/o methods like the workspace - Nahuel"
	self hasValidCurrentCompiledMethod ifFalse: [ ^ nil ].

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		
	aRefactoringApplierClass createAndValueHandlingExceptions: [
		aRefactoringApplierClass
			on: self codeProvider
			for: self selectionInterval asSourceCodeInterval
			of: self codeProvider currentCompiledMethod ] ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954741!
acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ 
			aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953610!
selectNodeRange: aNodeUnderCursor in: aMethodNode 
	
	| range ranges |
	
	ranges := aMethodNode rangeForNode: aNodeUnderCursor ifAbsent: [ ^ self ].
	range := (aMethodNode isMultipleRanges: ranges) 
		ifTrue: [ ranges detect: [ :aRange | aRange includes: self startIndex ] ifNone: [ ^self ]]
		ifFalse: [ ranges ].
		
	self selectFrom: range first to: range last
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953136!
contextualPushDownInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushDownInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass ) value ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954409!
classCommentsContainingIt
	"Open a browser class comments which contain the current selection somewhere in them."

	self lineSelectAndEmptyCheck: [^ self].
	Smalltalk browseClassCommentsWithString: self selectedString! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953248!
contextualRenameInMethod

	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualRenameOf: methodNode in: selectedClass]
		ifErrorsParsing: [ :anError | morph flash ]		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419238!
contextualMoveInstanceVariable: aKeyboardEvent
	self contextualMoveInstanceVariable.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953784!
printIt: aKeyboardEvent
	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw
	 2/29/96 sw: don't call selectLine now, since it's called by doIt"

	self printIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506912!
actualSendersOfIt
	
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			BrowseActualSenders browseOf: methodNode definedIn: class withCursorAt: self startIndex in: morph ]
		ifErrorsParsing: [ :anError | morph flash ].


	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954061!
explainDelimitor: string
	"Is string enclosed in delimitors?"

	| str |
	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"
	(string first = string last) ifTrue:
			[^ self explainChar: (String with: string first)]
		ifFalse:
			[(string first = $( and: [string last = $)]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = $[ and: [string last = $]]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = ${ and: [string last = $}]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = $< and: [string last = $>]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = $# and: [string last = $)]) ifTrue:
				[^'An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array.'].
			string first = $# ifTrue:
				[^'An instance of class Symbol.'].
			(string first = $$ and: [string size = 2]) ifTrue:
				[^'An instance of class Character.  This one is the character ', (String with: string last), '.'].
			(string first = $:) ifTrue:
				[str := string allButFirst.
				(self explainTemp: str) ifNotNil: [
					^'An argument to this block will be bound to the temporary variable ',
						str, '.']]].
	^ nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50507046!
typeCheckMethod: aKeyboardEvent 
	
	self typeCheckMethod.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953802!
sendersOfIt: aKeyboardEvent
	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"

	self sendersOfIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953389!
withClassDefinitionNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self codeProvider selectedClassOrMetaClass.
	methodNode := [ selectedClass methodNodeFor: model actualContents string noPattern: true ]
		on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953763!
methodStringsContainingIt: aKeyboardEvent
	"Triggered by Cmd-E"

	self methodStringsContainingIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954759!
acceptAndTestAll
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ].
	^true
	
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953202!
contextualRenameInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self contextualRenameInClassDefinitionOf: classDefinitionNode in: selectedClass]
			ifErrorsParsing: [ :anError | morph flash ] ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953522!
evaluateSelectionAndDo: aBlock ifFail: failBlock profiled: doProfile
	"Treat the current selection as an expression; evaluate it and evaluate aBlock with the result
	3 + 4
	"	

	self evaluate: self selection string andDo: aBlock ifFail: failBlock profiled: doProfile! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953747!
inspectIt: aKeyboardEvent
	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw
	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"

	self inspectIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953197!
contextualRename: aKeyboardEvent

	self contextualRename.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953343!
renameSelectorFor: aSelector in: aClassToRefactor

	RefactoringApplier renameSelectorApplier createAndValueHandlingExceptionsOn: model textProvider for: aSelector in: aClassToRefactor ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953624!
selectNodeUnderCursorForInspectionIn: aMethodNode 
	
	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self selectForInspection: nodeUnderCursor in: aMethodNode ]
		ifAbsent: []


! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953795!
referencesToIt: aKeyboardEvent
	"Triggered by Cmd-N; browse references to the current selection"

	self referencesToIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953458!
debug: aCompiledMethod receiver: anObject in: evalContext

	Debugger
		openDebugging: [
			aCompiledMethod
				valueWithReceiver: anObject
				arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ])]
		to: aCompiledMethod
		label: 'Debug it'.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955070!
quickPrintOfNodeUnder: aMousePosition

	| mousePositionInText |
	
	mousePositionInText := morph positionInTextOf: aMousePosition.

	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | morph showBalloon: (self hoverHelpToShowEvaluating: aNodeUnderCursor)]
				ifAbsent: [  morph flash  ]]
		ifErrorsParsing: [ :anError | morph showBalloon: anError messageText ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955100!
contextualInlineMethod: aKeyboardEvent

	self contextualInlineMethod.
	^true.

	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954711!
notify: aString at: anInteger in: aStream 
	"The compilation of text failed. The syntax error is noted as the argument, 
	aString. Insert it in the text at starting character position anInteger."
	"This is a user command, and generates undo"
	model startNewUndoRedoCommand.
	self insertAndSelect: aString at: (anInteger max: 1).! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419293!
contextualMoveInstanceVariableOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self moveInstanceVariable: nodeUnderCursor in: aSelectedClass at: aMethodNode ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifFalse: [ morph flash ]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953595!
selectMessageNode: aMessageNodeUnderCursor in: aMethodNode
	
	| messageRange |
	
	self 
		withReceiverRangeOf: aMessageNodeUnderCursor 
		in: aMethodNode 
		selectorPosition: self startIndex 
		do: [ :receiverRange |
			messageRange := aMethodNode rangeForNode: aMessageNodeUnderCursor ifAbsent: [ ^ self ].
			self selectFrom: receiverRange first to: messageRange last ]
		
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419283!
contextualMoveInstanceVariableInMethod
	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualMoveInstanceVariableOf: methodNode in: selectedClass ]
		ifErrorsParsing: [ :anError | morph flash ]		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954285!
explainTemp: string 
	"Is string the name of a temporary variable (method or block argument or temporary)?"

	| provider selectedClass methodNode tempNode |
	provider := self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	provider selectedMessageName ifNil: [^nil].	"not in a method"
	selectedClass := provider selectedClassOrMetaClass.
	methodNode := selectedClass parserClass new parse: provider selectedMessage class: selectedClass.
	tempNode := methodNode encoder tempNodes detect: [ :n | n name = string ] ifNone: [^nil].
	^(tempNode isArg
		ifTrue: [string, ' is an argument to this ']
		ifFalse: [string, ' is a temporary variable in this ']),
	   (tempNode isDeclaredAtMethodLevel
		ifTrue: ['method ']
		ifFalse: ['block '])! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953769!
pasteInitials: aKeyboardEvent 
	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor."
	"This is a user command, and generates undo"

	| i |
	i := self stopIndex.
	self replaceSelectionWith: (Text fromString: Utilities changeStamp).
	self deselectAndPlaceCursorAt: i.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954840!
withNodeUnderCursorDo: aDoBlock ifAbsent: anAbsentBlock

	self 
		withMethodNodeAndClassDo: [ :currentMethodNode :currentClass |
			currentMethodNode 
				withParseNodeIncluding: self startIndex
				do: aDoBlock
				ifAbsent: anAbsentBlock ] 
		ifErrorsParsing: [ :arg1 | anAbsentBlock value ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953080!
contextualExtractAsParameter

	self isEditingClassDefinition 
		ifTrue: [ morph flash ]
		ifFalse: [ self ifSourceCodeRefactoringCanBeAppliedDo: [ self extractAsParameter ]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506922!
actualSendersOfIt: aKeyboardEvent

	self actualSendersOfIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954766!
acceptAndWithMethodDo: aBlock
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod := self codeProvider currentCompiledMethod.
	^potencialTestMethod 
		ifNil: [ false ]
		ifNotNil: [
			aBlock value: potencialTestMethod.
			true]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953696!
browseIt: aKeyboardEvent
	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"

	self browseIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953334!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor

	(RenameInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954592!
referencesToSelectedLiteral
	"Evaluate the selected text and browse methods that reference the same literal"
	[
		self
			evaluateSelectionAndDo: [ :result |
				Smalltalk
					browseMessageList: (Smalltalk allReferencesToLiteral: result)
					name: 'Users of literal: ' , result asString
					autoHighlight: self selection
					allOccurrences: true ]
			ifFail: nil
			profiled: false ]
	on: UndeclaredVariableReference , UnknownSelector
	do: [ :ex |
		morph flash ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954660!
withSelectorAt: aPosition do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock
	| methodNode nodeAtRange nodeUnderCursor  |

	methodNode := self codeProvider
		methodNodeOf: model actualContents string
		ifErrorsParsing: [ :anError | ^ failBlock value ].

	aPosition < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: aPosition ifAbsent: [ ^ failBlock value ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ])
		ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].
	(nodeUnderCursor isLiteralVariableNode and: [ nodeUnderCursor isReferencingBehavior ])
		ifTrue: [ ^aBehaviorBlock value: nodeUnderCursor key value ].

	^ failBlock value.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953633!
withReceiverRangeOf: aMessageNode in: aMethodNode selectorPosition: aSelectorPosition do: aBlock   
	
	| receiverRange receiverRangeOrRanges messageNodeReceiver |
	
	"If aMessageNode receiver isNil it means that it is a cascade receiver so this imposes the question on how to inspect
	a cascade message send. We could inspect the result of sending all the messages up to the cursor but the problem is
	that when looking for the cascade receiver range it does not find it because it is a different node that the used in the source
	ranges... we could do the trick of looking for printString in the sourceRanges keys, but that is too much - Hernan"
	aMessageNode isCascade ifFalse: [ 
		messageNodeReceiver := aMessageNode receiver.
		messageNodeReceiver isMessageNode ifTrue: [ 
			^self withReceiverRangeOf: messageNodeReceiver in: aMethodNode selectorPosition: (messageNodeReceiver keywordPositionAt: 1) first do: aBlock ].
		
		receiverRangeOrRanges := aMethodNode rangeForNode: messageNodeReceiver ifAbsent: [ ^ self ].
		
		receiverRange := (aMethodNode isMultipleRanges: receiverRangeOrRanges)
			ifTrue: [ | closestRange |
				closestRange := receiverRangeOrRanges first.
				receiverRangeOrRanges do: [ :aRange |  (aRange last < aSelectorPosition and: [ aRange last > closestRange last ]) ifTrue: [ closestRange := aRange ]].
				closestRange ]
			ifFalse: [ receiverRangeOrRanges ].

		aBlock value: receiverRange ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506990!
showSelectionTypeInfo: aKeyboardEvent

	self showSelectionTypeInfo.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953469!
debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selection string
		do: [ :compiler :method :receiver :context |
			(method notNil and: [method isQuick not]) ifTrue: [
				self debug: method receiver: receiver in: context ]]
		ifFail: [].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954559!
referencesToIt
	"Open a references browser on the selected symbol: a variable name or class name"

	| selectedSymbol provider environment selectedString |
	self hasSelection ifFalse: [ self selectWord ].
	selectedSymbol := self selectedSymbol.

	"convenient access to class variables, including those in SharedPools"
	provider := self codeProvider.
	environment := (provider respondsTo: #selectedClassOrMetaClass) ifTrue: [ provider selectedClassOrMetaClass ].
	environment := environment ifNil: [ Smalltalk ].

	(selectedSymbol ifNotNil: [environment bindingOf: selectedSymbol]) ifNotNil: [ :reference |
		Smalltalk browseAllCallsOn: reference.
		^ self ].

	selectedString := self selectedString withoutSeparators.
	(environment ~= Smalltalk and: [ environment definesInstanceVariableNamedInHierarchy: selectedString ]) ifTrue: [
		Smalltalk browseAllAccessesTo: selectedString from: environment.
		^ self ].

	self referencesToSelectedLiteral! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954353!
browseClassFromIt
	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."

	| aClass |
	self wordSelectAndEmptyCheck: [^ self].

	aClass := Utilities
		classFromPattern: self selectedString withBlanksCondensed
		withCaption: 'choose a class to browse...'.
	aClass ifNil: [^ morph flash].

	HierarchyBrowserWindow
		onClass: aClass
		selector: nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954348!
openMenu: aMenu
	
	aMenu popUpInWorld: morph world! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954382!
browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry |
	(Preferences at: #alternativeBrowseIt) ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol := self selectedSymbol ifNil: [
		self
			evaluate: self selection string
			andDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false ].

	aSymbol first isUppercase
		ifTrue: [
			anEntry := (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry := anEntry class].
			BrowserWindow fullOnClass: anEntry selector: nil]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953352!
renameSelectorOf: aMessageNode in: aSelectedClass at: aSelectedSelector

	RefactoringApplier renameSelectorApplier
		on: aMessageNode
		createAndValueHandlingExceptionsOn: model textProvider
		in: aSelectedClass
		at: aSelectedSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953189!
contextualRename

	self isEditingClassDefinition 
		ifTrue: [ self contextualRenameInClassDefinition ]
		ifFalse: [ self contextualRenameInMethod ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419244!
contextualMoveInstanceVariableInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self contextualMoveInstanceVariableInClassDefinitionOf: classDefinitionNode in: selectedClass]
			ifErrorsParsing: [ :anError | morph flash ] ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50535240!
balloonTypeInfoOfInstanceVariableAt: mousePositionInText

	| instVarName typeInfo types |
	
	instVarName := (self wordUnder: mousePositionInText) asString.
	"typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^'']."
	types := self codeProvider selectedClass 
				liveTypesOfInstanceVariableNamed: instVarName 
				storingGenericsInfoIn: (LiveTyping getGenericsStorage) 
				ifAbsent: [`EmptyType new`].
	typeInfo := InstanceVariableTypeInfo of: instVarName in: self codeProvider selectedClass are: types asArray.
	^typeInfo printTypesUpTo: 5! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954343 overrides: 16981836!
getMenu
	
	^self createMenuCollectingOptionsWith: #smalltalkEditorMenuOptions! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955140!
inlineMethodInUsage: aMessageNodeReference

	RefactoringApplier inlineMethodApplier
		createAndValueHandlingExceptionsOn: model textProvider
		forMessageSend: aMessageNodeReference.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954177!
explainMySel: symbol 
	"Is symbol the selector of this method?  Is it sent by this method?  If 
	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 
	selector sent here.  If not, explain will call (explainAnySel:) to catch any 
	selector. "

	| provider lits classes msg |
	provider := self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg := provider selectedMessageName) ifNil: [^nil].	"not in a message"
	classes := Smalltalk allClassesImplementing: symbol.
	classes size > 12
		ifTrue: [classes := 'many classes']
		ifFalse: [classes := 'these classes ' , classes printString].
	msg = symbol
		ifTrue: [
			^ String streamContents: [:str |
				str
					nextPut: $#;
					nextPutAll: symbol;
					nextPutAll: ' is the selector of this very method!!  It is defined in ';
					nextPutAll: classes;
					nextPutAll: self class plateA]]
		ifFalse: [
			lits := (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(lits detect: [:each | each == symbol]
				ifNone: nil)
					ifNil: [^nil].
			^ String streamContents: [:str |
				str
					nextPut: $#;
					nextPutAll: symbol;
					nextPutAll: ' is a message selector which is defined in ';
					nextPutAll: classes;
					nextPutAll: self class plateA]]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953404!
withMethodNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self selectedClassOrMetaClassOrUndefinedObject.
	[ 
		[ methodNode := selectedClass methodNodeFor: model actualContents string ]
			on: UndeclaredVariableWarning do: [ :ex | ex resume ]
	] on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953723!
exploreIt: aKeyboardEvent
	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."

	self exploreIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954817!
testSuiteOf: aClass

	^TestSuite forClass: aClass
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953757!
methodSourceContainingIt: aKeyboardEvent
	"Triggered by Cmd-e"

	self methodSourceContainingIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954318!
extractToTemporary: aKeyboardEvent

	self extractToTemporary.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953942!
explainClass: symbol 
	"Is symbol a class variable or a pool variable?"
	| provider class reply classes |
	provider := self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass)
		ifFalse: [^ nil].
	(class := provider selectedClassOrMetaClass) ifNil: [^ nil].
	"no class is selected"
	(class isKindOf: Metaclass)
		ifTrue: [class := class soleInstance].
	classes := (Array with: class)
				, class allSuperclasses.
	"class variables"
	reply := classes detect: [:each | (each classVarNames detect: [:name | symbol = name]
					ifNone: nil)
					notNil]
				ifNone: nil.
	reply ifNotNil: [
		^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a class variable, defined in class ';
				nextPutAll: reply printString, '\' withNewLines;
				nextPutAll: 'Smalltalk browseAllCallsOn: (';
				nextPutAll: reply printString;
				nextPutAll: ' classPool associationAt: #';
				nextPutAll: symbol;
				nextPutAll: ').']].
	"pool variables"
	classes do: [:each | (each sharedPools
			detect: [:pool | (pool includesKey: symbol)
					and: 
						[reply := pool.
						true]]
			ifNone: nil)
			notNil].
	reply
		ifNil: [(Undeclared includesKey: symbol)
				ifTrue: [
					^ String streamContents: [:str |
						str
							nextPutAll: symbol;
							nextPutAll: ' is an undeclared variable.';
							nextPutAll: 'Smalltalk browseAllCallsOn: (Undeclared associationAt: #';
							nextPutAll: symbol;
							nextPutAll: ').']]]
		ifNotNil: 
			[classes := Array streamContents: [ :strm |
				Smalltalk
					allBehaviorsDo: [:each | (each sharedPools
							detect: 
								[:pool | 
								pool == reply]
							ifNone: nil)
							notNil ifTrue: [strm nextPut: each]]].
			"Perhaps not print whole list of classes if too long. (unlikely)"
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a pool variable from the pool ';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ', which is used by the following classes ';
					nextPutAll: classes printString , '\' withNewLines;
					nextPutAll: 'Smalltalk browseAllCallsOn: (';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ' bindingOf: #';
					nextPutAll: symbol;
					nextPutAll: ').']].
	^ nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953102!
contextualRemoveParameter: aKeyboardEvent 
	
	self contextualRemoveParameter.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953710!
debugIt: aKeyboardEvent

	self debugIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953738!
implementorsOfIt: aKeyboardEvent
	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"

	self implementorsOfIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954537!
methodStringsContainingIt
	"Open a browser on methods which contain the current selection as part of a string constant."

	self lineSelectAndEmptyCheck: [^ self].
	Smalltalk browseMethodsWithString: self selectedString! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953686!
acceptAndTest: aKeyboardEvent

	^self acceptAndTest! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953714!
doIt: aKeyboardEvent
	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.
	2/29/96 sw: don't call selectLine; it's done by doIt now"

	self doIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954753!
acceptAndTest
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ].
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506995!
showSelectionTypeInfoInMethod
		
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | | cursorPosition |
			cursorPosition := self startIndex.
			methodNode 
				withParseNodeIncluding: cursorPosition 
				do: [ :aNodeUnderCursor | self showTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class ]
				ifAbsent: [ 
					cursorPosition <= methodNode selectorLastPosition 
						ifTrue: [ self showTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ morph flash ]]]
		ifErrorsParsing: [ :anError | morph flash ]

! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954888!
displayIfFalse: aKeyboardEvent
	"Replace the current text selection with the text 'ifFalse:'--initiated by 
	cmd-F."

	self addString: 'ifFalse:'.
	^false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954630!
sendersOfIt
	"Open a senders browser.
	If text selection defines a selector, take it. Otherwise, try finding selector under cursor. If this fails, consider the whole line."

	self selectedSelector ifNotNil: [ :selector |
		^ Smalltalk browseAllCallsOn: selector ].
	self
		withSelectorUnderCursorDo: [ :selector | Smalltalk browseAllCallsOn: selector ]
		ifBehavior: [:behavior | Smalltalk browseAllCallsOn: (Smalltalk bindingOf: behavior name)] 
		otherwise: [ self sendersOfItWhenErrorsParsing ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953089!
contextualExtractAsParameter: aKeyboardEvent 
	
	self contextualExtractAsParameter.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953821!
explainAnySel: symbol 
	"Is this any message selector?"

	| list reply |
	list := Smalltalk allClassesImplementing: symbol.
	list isEmpty ifTrue: [^nil].
	list size < 12
		ifTrue: [reply := ' is a message selector which is defined in these classes ' , list printString]
		ifFalse: [reply := ' is a message selector which is defined in many classes'].
	^'#' , symbol , reply , '.\' withNewLines, 'Smalltalk browseAllImplementorsOf: #' , symbol! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954700!
nextTokenFrom: start direction: dir
	"simple token-finder for compiler automated corrections"
	| loc str |
	loc := start + dir.
	str := self privateCurrentString.
	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]
		whileTrue: [loc := loc + dir].
	^ loc! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954610!
selectedSelector
	"Try to make a selector out of the current text selection"

	^ self selectedString findSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953480!
doIt

	self doItProfiling: false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953095!
contextualRemoveParameter

	self contextualChangeSelectorUsing: RefactoringApplier removeParameterApplier ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953122!
apply: aBlock inClassDefinitionOf: aClassDefinitionNode in: aSelectedClass 
	
	| analyzer cursorPosition |
	
	analyzer := ClassDefinitionNodeAnalyzer for: aClassDefinitionNode.
	cursorPosition := self startIndex.
	
	(analyzer isAtInstanceVariables: cursorPosition) 
		ifTrue: [ aBlock value: aSelectedClass ]
		ifFalse: [ morph flash ]
	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953810 overrides: 16980693!
clickAndHalfAt: localEventPosition

	| here |
	here := self pointIndex.
	(here between: 2 and: model textSize)
		ifTrue: [
			super clickAndHalfAt: localEventPosition ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506895!
actualLocalImplementorsOfIt

	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			BrowseActualLocalImplementors browseOf: methodNode definedIn: class withCursorAt: self startIndex in: morph ]
		ifErrorsParsing: [ :anError | morph flash ].

		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50541495!
balloonTypeInfoInMethodAt: mousePositionInText

	^self withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| 
					self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class 
				]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 	mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]
				]]
		ifErrorsParsing: [ :anError | '' ]


! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50507015!
showTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class 

	[ (ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) show ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | self inform: anError messageText ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506880!
actualImplementorsOfIt
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			BrowseActualImplementors browseOf: methodNode definedIn: class withCursorAt: self startIndex in: morph ]
		ifErrorsParsing: [ :anError | morph flash ].

		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953322!
renameClassOn: aBrowser for: aClassToRefactor

	(RenameClassApplier for: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954795!
runTestSuite: aTestSuite

	(ProgressiveTestRunner for: aTestSuite) value
	
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953257!
contextualRenameOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self rename: nodeUnderCursor in: aSelectedClass at: aMethodNode ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifTrue: [ self ifSourceCodeRefactoringCanBeAppliedDo: [ self renameSelectorFor: aMethodNode selector in: aSelectedClass ]]
				ifFalse: [ morph flash ]]


! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953681!
acceptAndDebugTest: aKeyboardEvent 
	
	^self acceptAndDebugTest ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953050!
contextualChangeSelectorOf: aMethodNode in: aSelectedClass using: aChangeSelectorApplier

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self changeSelector: nodeUnderCursor in: aSelectedClass at: aMethodNode selector using: aChangeSelectorApplier ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifTrue: [ self changeSelectorTo: aMethodNode selector in: aSelectedClass using: aChangeSelectorApplier ]
				ifFalse: [ morph flash ]]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953579!
profileIt

	self doItProfiling: true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954220!
explainNumber: string 
	"Is string a Number?"

	| strm c |
	(c := string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])
			ifFalse: [^nil]].
	strm := string readStream.
	c := Number readFrom: strm.
	strm atEnd ifFalse: [ ^nil ].
	c printString = string
		ifTrue: [ ^ string , ' is a ' , c class name ]
		ifFalse: [ ^ string , ' (= ' , c printString , ') is a ' , c class name ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953284!
isEditingClassDefinition

	^(self codeProvider is: #Browser) and: [ self codeProvider isEditingExistingClass ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954777!
acceptThenTestMethodAndSuite: aSuiteBuilder
	
	self acceptAndWithMethodDo: [ :aPotencialTestMethod |
		self runAndDebuggIfNecessary: aPotencialTestMethod.
		self runTestSuite: (aSuiteBuilder value: aPotencialTestMethod) ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953158!
ifEditingClassDefinitionDoOrWarn: aBlock

	self isEditingClassDefinition 
		ifTrue: aBlock
		ifFalse: [ self informRefactoringCanOnlyBeAppliedInClassDefinition ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953484!
doItProfiling: aBoolean
	"Set the context to include pool vars of the model.  Then evaluate.
	Print the result on the Transcript"

	self lineOrNodeSelectAndEmptyCheck: [^ self ].
	self evaluateSelectionAndDo: nil ifFail: nil profiled: aBoolean.
	morph convertAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955106!
contextualInlineMethodOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor |
			nodeUnderCursor isMessageNode ifFalse: [^morph flash].

			((aMethodNode completeSourceRangesOf: nodeUnderCursor ifAbsent: [self shouldNotHappen])
				detect: [ :aSourceRange | aSourceRange includes: self startIndex]
					ifFound: [ :aSourceRange | | messageNodeReference |
						messageNodeReference := MessageNodeReference
							messageNode: nodeUnderCursor
							selector: aMethodNode selector
							class: aSelectedClass
							completeSourceRange: aSourceRange.
						self inlineMethodInUsage: messageNodeReference.	]
					ifNone: [self shouldNotHappen ])]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition ifFalse: [ ^ morph flash ].

			RefactoringApplier inlineMethodApplier
				createAndValueHandlingExceptionsOn: model textProvider
				forMethod: (MethodReference class: aSelectedClass selector: aMethodNode selector)]

! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954896!
displayIfTrue: aKeyboardEvent
	"Replace the current text selection with the text 'ifTrue:'--initiated by 
	cmd-T."

	self addString: 'ifTrue:'.
	^false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953025!
contextualAddParameter
	
	self contextualChangeSelectorUsing: RefactoringApplier addParameterApplier ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954526!
methodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"

	self lineSelectAndEmptyCheck: [^ self].
	Smalltalk browseMethodsWithSourceString: self selectedString! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954904 overrides: 50579180!
newLine: aKeyboardEvent
	"Replace the current text selection with a newLine (i.e. LF) followed by as many tabs
	as there are leading tabs on the current line (+/- bracket count)."

	| char s i tabCount stopIndex newLineString |
	s := self privateCurrentString.
	stopIndex := self stopIndex.
	i := stopIndex.
	tabCount := 0.
	[ (i := i-1) > 0 and: [ (char := s at: i) isLineSeparator not ] ] whileTrue: [
		"Count brackets"
		char = $[ ifTrue: [tabCount := tabCount + 1].
		char = $] ifTrue: [tabCount := tabCount - 1]].
	[ (i := i + 1) < stopIndex and: [ (char := s at: i) isSeparator ] ] whileTrue: [
		"Count leading tabs"
		char = Character tab ifTrue: [ tabCount := tabCount + 1 ]].
	"Now inject newline with tabCount tabs, generating a new undoable command"
	newLineString := UnicodeString streamContents: [ :strm | strm newLineTab: tabCount ].
	model startNewUndoRedoCommand.
	self replaceSelectionWith: newLineString.
	^ false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953555!
printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."

	self lineSelectAndEmptyCheck: [^ self ].
	self
		evaluateSelectionAndDo: [ :result |
			| text |
			text := model fullPrintIt
				ifTrue: [result printText]
				ifFalse: [result printTextLimitedTo: 10000].
			text := text copyReplaceAll: String lfString with: String lfString, ' '.
			text := ' ', text asText shoutDisableEmphasis, ' .'.
			self afterSelectionInsertAndSelect: (text initialFontFrom: emphasisHere)]
		ifFail: [ morph flash ]
		profiled: false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955021!
hoverHelpStringOfEvaluating: aNodeUnderCursor

	^ self
		evaluate: aNodeUnderCursor printSourceCode
		andDo: [ :result | result printString ]
		ifFail: [ 
			morph flash.
			'Nothing to show' ]
		profiled: false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953291!
rename: aNodeUnderCursor in: aSelectedClass at: aMethodNode

	aNodeUnderCursor isTempOrArg ifTrue: [ ^self renameTemporary: aNodeUnderCursor at: aMethodNode ].

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		aNodeUnderCursor isMessageNode ifTrue: [
			^ self renameSelectorOf: aNodeUnderCursor in: aSelectedClass at: aMethodNode selector ].
		aNodeUnderCursor isInstanceVariableNode ifTrue: [
			^ self renameInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aSelectedClass ].
		aNodeUnderCursor isLiteralVariableNode ifTrue: [ | variableName |
			variableName := aNodeUnderCursor key key.
			(Smalltalk classNamed: variableName) ifNotNil: [ :classToRename |
				^self renameClassOn: self codeProvider for: classToRename ].
			(Smalltalk bindingOf: variableName) ifNotNil: [
				^self renameGlobalOn: self codeProvider for: variableName ] ].

		^morph flash ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16952982!
replaceUnicodeArrowsWithSmalltalkArrows
	"Useful, for instance, to paste code from TheCuisBook.pdf.
	Some day we may change our minds, or maybe add a preference."

	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16955149!
inlineTemporaryVariable

	"To prevent the refactoring to be evaluated on editors w/o methods like the workspace - Fernando"
	self hasValidCurrentCompiledMethod ifFalse: [ ^ nil ].

	InlineTemporaryVariableApplier createAndValueHandlingExceptions: [
		InlineTemporaryVariableApplier
			on: self
			for: self selectionInterval asSourceCodeInterval
			of: self codeProvider currentCompiledMethod ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953032!
contextualAddParameter: aKeyboardEvent 
	
	self contextualAddParameter.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50506928 overrides: 50506876!
balloonTypeInfoAt: mousePositionInText

	^self isEditingClassDefinition 
		ifTrue: [ self balloonTypeInfoOfInstanceVariableAt: mousePositionInText ]
		ifFalse: [ self balloonTypeInfoInMethodAt: mousePositionInText ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953182!
informRefactoringCanOnlyBeAppliedInClassDefinition

	self inform: 'This refactoring can only be applied from the class definition'! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 50419258!
contextualMoveInstanceVariableInClassDefinitionOf: aClassDefinitionNode in: aSelectedClass 
	
	| analyzer cursorPosition |
	
	analyzer := ClassDefinitionNodeAnalyzer for: aClassDefinitionNode.
	cursorPosition := self startIndex.
	
	(analyzer isAtInstanceVariables: cursorPosition) 
		ifTrue: [ |selection variableToMove|
			selection := self selectedString.
			variableToMove := selection isEmpty ifTrue: [ self wordUnderCursor ] ifFalse: [ selection ].
			^self moveInstanceVariableOn: self codeProvider for: variableToMove at: aSelectedClass ].
		
	(analyzer isAtClassName: cursorPosition)
		ifTrue: [ ^self moveInstanceVariableOn: self codeProvider at: aSelectedClass ].
	
	morph flash
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954236!
explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg provider |
	provider := self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg := provider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last = $: ifFalse: [^ nil].
	"Name of this method"
	lits := Array with: msg.
	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply := ', which is the selector of this very method!!'.
			s := self class plateA]
		ifNil: [ 
			"Selectors called from this method"
			lits := (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole := lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply := '.'.
			s := self class plateB].
		classes := Smalltalk allClassesImplementing: whole.
		classes size > 12
			ifTrue: [classes := 'many classes']
			ifFalse: [classes := 'these classes ' , classes printString].
		^ String streamContents: [:str |
			str
				nextPutAll: string;
				nextPutAll: ' is one part of the message selector ';
				nextPutAll: whole;
				nextPutAll: reply;
				nextPutAll: '  It is defined in ';
				nextPutAll: classes;
				nextPutAll: s]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954787!
runAndDebuggIfNecessary: aPotencialTestMethod

	aPotencialTestMethod isTestMethod ifTrue: [
		aPotencialTestMethod methodClass debug: aPotencialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953069!
contextualChangeSelectorUsing: aChangeSelectorApplier
	
	self isEditingClassDefinition 
		ifTrue: [ morph flash ]
		ifFalse: [ self ifSourceCodeRefactoringCanBeAppliedDo: [ self contextualChangeSelectorInMethodUsing: aChangeSelectorApplier ]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953274!
ifSourceCodeRefactoringCanBeAppliedDo: aBlock

	^(self hasUnacceptedEdits or: [morph hasEditingConflicts ])
		ifTrue: [ self inform: 'This refactoring can not be applied when there are unsaved changes' ]
		ifFalse: aBlock! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953215!
contextualRenameInClassDefinitionOf: aClassDefinitionNode in: aSelectedClass 
	
	| analyzer cursorPosition |
	
	analyzer := ClassDefinitionNodeAnalyzer for: aClassDefinitionNode.
	cursorPosition := self startIndex.
	
	(analyzer isAtSuperclass: cursorPosition) 
		ifTrue: [ ^self renameClassOn: self codeProvider for: analyzer superclass ].
	
	(analyzer isAtClassName: cursorPosition)
		ifTrue: [ ^self renameClassOn: self codeProvider for: aSelectedClass ].
		
	(analyzer isAtInstanceVariables: cursorPosition) 
		ifTrue: [ |selection variableToRename|
			selection := self selectedString.
			variableToRename := selection isEmpty ifTrue: [ self wordUnderCursor ] ifFalse: [ selection ].
			^self renameInstanceVariableOn: self codeProvider for: variableToRename at: aSelectedClass ].
		
	(analyzer isAtCategory: cursorPosition)
		ifTrue: [ 
			"I'm sure codeProvider is a Browser - Hernan"
			^self codeProvider renameSystemCategory ].
		
	morph flash
	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16953443!
afterCompiling: aSourceCode do: aBlock ifFail: failBlock

	| context provider receiver |
	
	provider := self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver := provider doItReceiver.
			context := provider doItContext]
		ifFalse: [
			receiver := context := nil].

	^self afterCompiling: aSourceCode do: aBlock for: receiver in: context ifFail: failBlock.
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:07' prior: 16954495!
fileItIn
	"Make a Stream on the text selection and fileIn it."

	self selection fileIn! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16954972!
hasValidCurrentCompiledMethod

	^ (self codeProvider respondsTo: #currentCompiledMethod)
		and: [ self codeProvider currentCompiledMethod notNil ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16952965 overrides: 50579345!
clipboardStringOrText
	| clipContents |
	clipContents := super clipboardStringOrText.
	self replaceUnicodeArrowsWithSmalltalkArrows ifTrue: [
		clipContents := clipContents copyReplaceAll: `(UnicodeCodePoint codePoint: 16r2190) asString` with: `(Character smalltalkLeftArrow ) asString`.
		clipContents := clipContents copyReplaceAll: `(UnicodeCodePoint codePoint: 16r2191) asString` with: `(Character smalltalkUpArrow ) asString`.
		].
	^clipContents.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953108!
extractAsParameter

	^ RefactoringApplier extractAsParameterApplier createAndValueHandlingExceptions: [
		RefactoringApplier extractAsParameterApplier
			from: self selectionInterval 
			on: model textProvider 
			for: self codeProvider selectedMessageName 
			in: self selectedClassOrMetaClassOrUndefinedObject  ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953544!
inspectIt

	self lineOrNodeSelectAndEmptyCheck: [^ self ].
	self
		evaluateSelectionAndDo: [ :result | result inspect ]
		ifFail: [ ^morph flash ]
		profiled: false.
	morph convertAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16954334!
createMenuCollectingOptionsWith: aMenuOptionsSelector
	
	^(DynamicMenuBuilder buildTitled: self class name targeting: self collectingMenuOptionsWith: aMenuOptionsSelector)
		addStayUpIcons;
		yourself
		
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953167!
inClassDefinitionContextuallyApply: aBlock

	self ifEditingClassDefinitionDoOrWarn: [
		self ifSourceCodeRefactoringCanBeAppliedDo: [
			self
				withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
					self apply: aBlock inClassDefinitionOf: classDefinitionNode in: selectedClass ]
				ifErrorsParsing: [ :anError | morph flash ]]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953704!
cancel: aKeyboardEvent
	"Cancel all edits done. Revert to saved version."

	model refetch.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953731!
fileItIn: aKeyboardEvent
	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."

	self fileItIn.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16952991!
changeSelector: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector using: aChangeSelectorApplier

	aNodeUnderCursor isMessageNode 
		ifTrue: [ self changeSelectorOf: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector using: aChangeSelectorApplier ]
		ifFalse: [ morph flash ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953147!
contextualPushUpInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushUpInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass) value ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16953508!
evaluate: aSourceCode andDo: aBlock ifFail: failBlock profiled: doProfile
	
	| result | 
	
	^ self 
		afterCompiling: aSourceCode 
		do: [ :compiler :method :receiver :context | method ifNotNil: [
			result := compiler evaluateMethod: method to: receiver logged: true profiled: doProfile.
			aBlock notNil ifTrue: [
				aBlock value: result ]]]
		ifFail: failBlock.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16954419!
explain
	"Try to shed some light on what kind of entity the current selection is. 
	The selection must be a single token or construct. Insert the answer after 
	the selection. Send private messages whose names begin with 'explain' 
	that return a string if they recognize the selection, else nil."

	| string tiVars cgVars selectors delimitors numbers sorry reply symbol provider |
	sorry := 'Sorry, I can''t explain that.  Please select a single
token, construct, or special character.'.
	(string := self selectedString) isEmpty
		ifTrue: [reply := '']
		ifFalse: [
			string := string withBlanksTrimmed.
			"Remove space, tab, cr"
			"Temps and Instance vars need only test strings that are all letters"
			(string detect: [:char | char isValidInIdentifiers not]
				ifNone: nil) ifNil: [
					tiVars := (self explainTemp: string)
						ifNil: [self explainInst: string]].
					
			provider := self codeProvider.
			(tiVars == nil and: [provider respondsTo: #explainSpecial:])
				ifTrue: [tiVars := provider explainSpecial: string].
			tiVars := tiVars
				ifNil: [ '']
				ifNotNil: [ tiVars , '\' withNewLines].
			"Context, Class, Pool, and Global vars, and Selectors need 
			only test symbols"
			(Symbol hasInterned: string ifTrue: [:s | symbol := s])
				ifTrue: [
					cgVars := (self explainCtxt: symbol) 
						ifNil: [ (self explainClass: symbol)
							ifNil: [ self explainGlobal: symbol]].
					"See if it is a Selector (sent here or not)"
					selectors := (self explainMySel: symbol)
						ifNil: [(self explainPartSel: string)
							ifNil: [ self explainAnySel: symbol]]]
				ifFalse: [selectors := self explainPartSel: string].
			cgVars := cgVars
				ifNil: [ '']
				ifNotNil: [cgVars , '\' withNewLines].
			selectors := selectors
				ifNil: [ '']
				ifNotNil: [ selectors , '\' withNewLines].
			delimitors := string size = 1
				ifTrue: ["single special characters"
					self explainChar: string]
				ifFalse: ["matched delimitors"
					self explainDelimitor: string].
			numbers := self explainNumber: string.
			numbers ifNil: [numbers := ''].
			delimitors ifNil: [delimitors := ''].
			reply := tiVars , cgVars , selectors , delimitors , numbers].
	reply isEmpty ifTrue: [reply := sorry].

	morph showBalloon: reply.
	self runningWorld ifNotNil: [ :w | w findATranscript ].
	reply print! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16954329!
extractMethod: aKeyboardEvent

	self extractMethod.
	^true! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955508!
plateX
	"As in boiler plate. Answer a string which appears in several explanations"
	
	^ ' go to the message list pane, get the menu, and select ''implementors of...''.'! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955486 overrides: 16981982!
releaseClassCachedState

	"We are not calling super to avoid cleansing class vars many times.
	So, repeat inherited class instVars!!"
	shortcuts := nil.
	cmdShortcuts := nil! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955501!
plateB
	"As in boiler plate. Answer a string which appears in several explanations"
	
	^ '.  To see the definitions,', self plateX! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955247!
smalltalkEditorEditingMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 			-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 			-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 			-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 			-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 			-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 			-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 			-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 			-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 			-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 			-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'Paste...'.
				#selector 			-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 			-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 			-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 			-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Set Font Size'.
				#selector 			-> 		#offerFontSizeMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
		}`.! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955177 overrides: 16981943!
cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	self flag: #definesKeyboardShortcuts.
	^#(
		#(		$0 	changeEmphasis:							'Normal')
		#(		$1 	changeEmphasis:							'Bold')
		#(		$2 	changeEmphasis:							'Italic')
		#(		$3 	changeEmphasis:							'Underline')
		#(		$4 	changeEmphasis:							'Strikeout')
		#(		$5 	changeEmphasis:							'Superscript')
		#(		$6 	changeEmphasis:							'Subscript')
		#(		$8	#offerColorMenu:							'Change color')
	
		#(		$e	#methodSourceContainingIt:							'Method source containing it')
		#(		$r	#acceptAndDebugTest:							'Saves method and debugs it')
		#(		$t	#acceptAndTest:							'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:							'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$u	#align:							'Toggle alignment')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:							'Print it (selection is a valid expression)')

		#(		$d	#doIt:							'Do it (selection is a valid expression)')
		#(		$k	#offerFontMenu:							'Set font')
		#(		$l	#cancel:							'Cancel all edits')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:							'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:							'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$Q	#argPrev:							'Previous argument')
		#(		$W	#argNext:							'Next argument')
		#(		$E	#methodStringsContainingIt:							'Method strings containing it')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$D	#debugIt:							'Debug it')

		#(		$N	#referencesToIt:							'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955360!
smalltalkEditorMenuOptions
	
	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Help...'.
				#selector 			-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 			-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 			-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 			-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 			-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		50.
				#label 			-> 		'Debug it (D)'.
				#selector 			-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		60.
				#label 			-> 		'Profile it'.
				#selector 			-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		5.
				#label 			-> 	SmalltalkEditor editMenuLabel.
				#selector 			-> 		#yourself.
				#icon 			-> 		#textEditorIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Explain'.
				#selector 			-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 			-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 			-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 			-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 			-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 			-> 		#methodStringsContainingIt.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Method Source with it (e)'.
				#selector 			-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 			-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 			-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 			-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 			-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 			-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}, SmalltalkEditor smalltalkEditorEditingMenuOptions `. ! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955243!
editMenuLabel

	^'Edit'! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16955494!
plateA
	"As in boiler plate. Answer a string which appears in several explanations"
	
	^ '.  To see the other definitions,', self plateX! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977704 overrides: 16947497!
reversed
	"Answer a copy of the receiver with element order reversed."
	
	| answer |
	answer := self class string: string reversed runs: runs reversed.
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected.
	The way it is done could be considered to be wrong. In this case, instead of making the text to take
	the ParagraphAttributes from the cr characters, it could be done the other way, making the cr's take 
	the ParagraphAttributes of the preceeding char. This way, the attributes would be mostrly preserved.
	I don't know if this is of much use anyway"
	answer fixParagraphAttributesFrom: 1 to: answer size.
	^answer

  "  It is assumed that  self size = runs size  holds. "! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978388!
green
	"Stuff like
	'Hello world' green edit
	"
	self color: Color green! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978362!
black
	"Stuff like
	'Hello world' black edit
	"
	self color: Color black! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978090 overrides: 16829096!
printOn: aStream
	aStream isText
		ifTrue: [aStream nextPutAll: self. ^ self].
	self printNameOn: aStream.
	aStream nextPutAll: ' for '; print: string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978164!
privateSetParagraphAttributes: paragraphAttributes from: start to: stop

	self privateSetRuns: (runs
		copyReplaceFrom: start
		to: stop
		with: ((runs copyFrom: start to: stop) mapValues: [ :attributes |
			Text setParagraphAttributes: paragraphAttributes toArray: attributes]))! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977500 overrides: 16828266!
size
	^runs size! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977762!
attributesAt: characterIndex
	"Answer the code for characters in the run beginning at characterIndex."

	self isEmpty
		ifTrue: [^ #()].  "null text tolerates access"
	^runs at: characterIndex! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977967!
paragraphStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self
		withAttributeValues: textAttributes
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^paragraphStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978336!
justified
	"Stuff like
	('Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. ' justified ) edit
	"
	self addAttribute: TextAlignment justified! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977587 overrides: 16947665!
grownTo: newSize
	"Accommodate for the fact that string could hold a String or an ArrayOfCharactersAndCodePoints
	when being streamed to."

	| grownText |
	grownText := Text fromString: (string class new: newSize).
	grownText replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownText! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977633!
asUnicodeStringOrText
	"Answer is either an UnicodeString or a Text including an UnicodeString"

	string isUnicodeString ifTrue: [ ^self ].
	^Text string: string asUnicodeString runs: runs! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977957!
paragraphStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ paragraphStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977753!
alignmentAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ alignment ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978403!
yellow
	"Stuff like
	'Hello world' yellow edit
	"
	self color: Color yellow! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977679!
replaceFrom: start to: stop withString: replacementString attributes: attributesArray startingAt: repStart 
	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. 
	Do it to both the string and the runs.
	The size does not change"

	| newRepRuns |
	string := string replaceFrom: start to: stop with: replacementString startingAt: repStart.
	newRepRuns := RunArray new: stop-start+1 withAll: attributesArray.
	self privateSetRuns: (runs copyReplaceFrom: start to: stop with: newRepRuns).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	self fixParagraphAttributesFrom: start to: start + replacementString size - 1! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978236!
editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978207!
canJoin: attributes1 and: attributes2
	| s |
	s := attributes1 size.
	^s = attributes2 size and: [
		(1 to: s) allSatisfy: [ :i |
			(attributes1 at: i) canBeJoinedWith: (attributes2 at: i) ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977421!
findString: aString startingAt: start 
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977369!
append: stringOrText

	^ stringOrText appendToText: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978383!
gray
	"Stuff like
	'Hello world' gray edit
	"
	self color: Color gray! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977599 overrides: 16913802!
postCopy

	string := string copy.
	runs := runs copy.
	runs mapValues: [ :attributes | attributes collect: [ :attr | attr copy ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977410!
embeddedMorphsFrom: start to: stop 
	"return the list of morphs embedded in me"

	| morphs |
	morphs := IdentitySet new.
	self attributesFrom: start to: stop do: [:attr |
		attr anchoredFormOrMorph ifNotNil: [ :m |
			(m is: #Morph) ifTrue: [
				morphs add: m]]].
	^morphs! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977581 overrides: 16947586!
copyReplaceFrom: start to: stop with: aText

	^self copy replaceFrom: start to: stop with: aText! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977729!
thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult	"
	string := string thatCanHoldCodePoints! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977883!
font: aFont
	"Apply aFont to the entire contents.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	self addAttribute: (TextFontFamily
			familyName: aFont familyName).
	self addAttribute: (TextFontSize
			pointSize: aFont pointSize).! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978300!
struck
	"Stuff like
	('Hello world' struck ) edit
	"
	self addAttribute: TextEmphasis struckThrough! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978398!
red
	"Stuff like
	'Hello world' red edit
	"
	self color: Color red! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977654 overrides: 16947300!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. 
	Do it to both the string and the runs.
	The size does not change"

	| rep newRepRuns |
	rep := replacement asText.	"might be a string"
	string replaceFrom: start to: stop with: rep string startingAt: repStart.
	newRepRuns := rep runs copyFrom: repStart to: repStart + stop - start.
	self privateSetRuns: (runs copyReplaceFrom: start to: stop with: newRepRuns).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	self fixParagraphAttributesFrom: start to: start + replacement size - 1! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978350!
leftFlush
	"Stuff like
	('Hello world' leftFlush ) edit
	"
	self addAttribute: TextAlignment leftFlush! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977548!
appendToText: aText

	| textSize start stop textResult |
	textSize := aText size.
	start := textSize + 1.
	stop := textSize.
	textResult := Text fromString: aText string , self string.
	textResult privateSetRuns: (aText runs copyReplaceFrom: start to: stop with: self runs).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	textResult fixParagraphAttributesFrom: start to: start + self size - 1.
	^ textResult
	! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978413 overrides: 16948381!
customizeExplorerContents

	^ false! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977443!
findStringCaseInsensitive: aString startingAt: start
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findStringCaseInsensitive: aString asPlainString startingAt: start! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978288!
pointSize: pointSize
	"Stuff like
	('Hello World' pointSize: 22) edit
	"
	self addAttribute: (TextFontSize pointSize: pointSize)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977373!
asUtf8Bytes
	"Answer UTF-8 bytes for the string representation of the receiver."
	^string asUtf8Bytes! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978268!
allBold
	"prefer shorter selector"
	self bold! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977404!
embeddedMorphs
	"return the list of morphs embedded in me"
	^self embeddedMorphsFrom: 1 to: self size! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977508 overrides: 16947363!
= other
	"Am I equal to the other Text or String?  
	***** Warning ***** Two Texts are considered equal if they have the same characters in them.  They might have completely different emphasis, fonts, sizes, text actions, or embedded morphs.  If you need to find out if one is a true copy of the other, you must do (text1 = text2 and: [text1 runs = text2 runs])."

	self == other ifTrue: [ ^ true ].
	(other is: #Text) ifTrue: [ "This is designed to run fast even for megabytes"
		^ string == other string or: [string = other string]].
	other isString ifTrue: [^ string == other or: [string = other]].
	^ false! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977462!
lineCount

	^ string lineCount! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978063 overrides: 16829232!
canHoldCodePoints
	"Ask our string"
	^string canHoldCodePoints! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978280!
italic
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis italic! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977483 overrides: 16947284!
replaceFrom: start to: stop with: replacement
	"newSize = oldSize - (stop-start-1) + aText size"
	
	| rep |
	rep := replacement asText.	"might be a string"
	string := string copyReplaceFrom: start to: stop with: rep string.
	self privateSetRuns: (runs copyReplaceFrom: start to: stop with: rep runs).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	self fixParagraphAttributesFrom: start to: start + replacement size - 1! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977942!
initialFontFrom: someAttributes
	"Apply aFont to those parts that are not already specifying one.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	| fontAttr |
	fontAttr := someAttributes detect: [ :any | any isFont ] ifNone: [ ^ self ].
	runs mapValues: [ :attributes |
		(attributes anySatisfy: [ :attr | attr isFont ])
			ifTrue: [ attributes ]
			ifFalse: [ attributes copyWith: fontAttr ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978074!
isLineEndAt: anIndex
	"Answer true if a line ends at position anIndex.
	Tolerates one position behind last character: 	"
	^string isLineEndAt: anIndex! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977565 overrides: 16947560!
copyFrom: start to: stop 
	"Answer with a copied subrange of this text"

	| realStart realStop |
	stop > self size
		ifTrue: [realStop := self size]		"handle selection at end of string"
		ifFalse: [realStop := stop].
	start < 1
		ifTrue: [realStart := 1]			"handle selection before start of string"
		ifFalse: [realStart := start].
	^Text 
		string: (string copyFrom: realStart to: realStop)
		runs: (runs copyFrom: realStart to: realStop)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978097 overrides: 16829104!
storeOn: aStream 
	aStream nextPutAll: '(Text string: ';
		store: string;
		nextPutAll: ' runs: ';
		store: runs;
		nextPut: $)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977503!
string
	"Answer the string representation of the receiver."
	^string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978367!
blue
	"Stuff like
	'Hello world' blue edit
	"
	self color: Color blue! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977991!
removeAttributesThat: aBlock
	runs mapValues: [ :attributes |
		attributes reject: aBlock ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978295!
shoutDisableEmphasis

	self addAttribute: ShoutDisable new! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978196!
setString: aString setRuns: anArray
	"Warning. No attempt is done to ensure the invariant that TextAttributes that answer true to
	 #isParagraphAttribute are only applied to whole paragraphs.
	Use with care. "

	string := aString.
	self privateSetRuns: anArray! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978393!
magenta
	"Stuff like
	'Hello world' magenta edit
	"
	self color: Color magenta! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977470!
rangeOf: attribute startingAt: index
	"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index."
	^ self isEmpty
		ifTrue: [ index to: index - 1 ]
		ifFalse: [
			runs
				rangeOf: attribute
				startingAt: index ].! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978378!
cyan
	"Stuff like
	'Hello world' cyan edit
	"
	self color: Color cyan! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977783!
characterStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ characterStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977465!
prepend: stringOrText

	self replaceFrom: 1 to: 0 with: stringOrText! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978322!
under
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis underlined! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978306!
sub
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis subscript! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977617 overrides: 16947448!
asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	self setString: string asStreamResult setRuns: runs.
	^self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977537 overrides: 16947518!
, aStringOrText

	^ aStringOrText appendToText: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977458!
isLastSeparator
	^string isLastSeparator! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977979!
removeAttributes: attributesToRemove from: requestedStart to: requestedStop
	"Remove the attribute over the interval start to stop.
	Turned into a command to enable reuse by undo / redo"
	
	(self
		commandForRemoveAttributes: attributesToRemove
		from: requestedStart
		to: requestedStop) doOn: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977893!
fontAt: characterIndex default: defaultFont
	"Answer the font for characters in the run beginning at characterIndex."

	^self fontIfApplying: (self attributesAt: characterIndex) default: defaultFont! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977382 overrides: 16913367!
at: index put: character

	| answer prevChar |
	prevChar := string at: index.
	answer := string at: index put: character.

	"Only fix ParagraphAttributes if there is real danger of breaking the invariant"
	(prevChar isLineSeparator and: [
			(self attributesAt: index) anySatisfy: [ :attr | attr isParagraphAttribute]]) ifTrue: [
		self fixParagraphAttributesFrom: index to: index ].
	
	^answer! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977770!
attributesFrom: start to: stop do: aBlock
	"evaluate aBlock for each attribute in the specified range.
	Warning: aBlock might be evaluated several times for each attribute, but not as many as the characters that it applies to!!."
	runs runsFrom: start to: stop do: [ :attributes |
		attributes do: [ :attribute |
			aBlock value: attribute ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977816!
commandForAddAttribute: aTextAttribute from: requestedStart to: requestedStop

	"Set the attribute for characters in the interval start to stop."
	| intervalToFix start stop new old |
	start := requestedStart.
	stop := requestedStop.
	
	"If aTextAttribute must be applied to whole paragraphs, do so."
	aTextAttribute isParagraphAttribute ifTrue: [
		intervalToFix := self encompassParagraph: (start to: stop).
		start := intervalToFix first.
		stop := intervalToFix last ].

	old := runs copyFrom: start to: stop.
	new := old copy mapValues: [ :attributes | 
			Text addAttribute: aTextAttribute toArray: attributes ].
	^AttributesReplaceCommand
		old: old
		new: new
		start: start
		stop: stop! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978246!
encompassParagraph: anInterval
	^string encompassParagraph: anInterval! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978272!
bold
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis bold! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978356!
rightFlush
	"Stuff like
	('Hello world' rightFlush ) edit
	"
	self addAttribute: TextAlignment rightFlush! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977629!
asText	
	"Answer the receiver itself."
	^self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978216!
hasAnyAttribute
	"Return false if there are no emphasis (i.e., a String would not make a difference)"

	^runs values anySatisfy: [ :emphArray | emphArray notEmpty ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978251!
paragraphStyleChunksDo: aBlock
	"Evaluate aBlock over each chunk (sequence of paragraphs) that have the same paragraphStyle"
	| start nextStart style |
	start := 1.
	nextStart := 1.
	[ start <= self size ] whileTrue: [
		style := self paragraphStyleOrNilAt: start.
		[ nextStart <= self size and: [ (self paragraphStyleOrNilAt: nextStart) = style ]] whileTrue: [
			nextStart := nextStart + 1 ].
		aBlock value: (start to: nextStart-1) value: style.
		start := nextStart ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977397!
commandForReplaceFrom: start to: stop with: replacement

	^TextReplaceCommand
		old: (self copyFrom: start to: stop)
		new: replacement
		at: start! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978067 overrides: 16829410!
is: aSymbol
	^ aSymbol == #Text or: [ super is: aSymbol ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977646!
optimizedForMutationSpeed
	"Do not use RunArray. Optimized for extensive attribute modification."
	
	(runs is: #RunArray) ifTrue: [
		^Text string: string runs: (RunNotArray withAll: runs) ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977996!
runLengthFor: characterIndex 
	"Answer the count of characters remaining in run beginning with 
	characterIndex."

	^runs runLengthAt: characterIndex! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977805!
colorAt: characterIndex
	"Answer the color for characters in the run beginning at characterIndex."

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ color ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977877!
find: attribute
	"Return the first interval over which this attribute applies"
	^ runs find: attribute! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978372!
color: aColor
	"Stuff like
	'Hello world' blue edit
	"
	self addAttribute: (TextColor color: aColor)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977613!
asPlainString
	"Answer a plain String, not a Text."
	^string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977606!
asNumber
	"Answer the number created by interpreting the receiver as the textual
	representation of a number."

	^string asNumber! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977431!
findString: aString startingAt: start caseSensitive: caseSensitive
	"Answer the index of subString within the receiver, starting at index 
	start. If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start caseSensitive: caseSensitive! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977926!
initialFont: aFont
	"Apply aFont to those parts that are not already specifying one.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	| fontAttributes |
	fontAttributes := {TextFontFamily			familyName: aFont familyName.
			TextFontSize pointSize: aFont pointSize}.
	runs mapValues: [ :attributes |
		(attributes anySatisfy: [ :attr | attr isFont ])
			ifTrue: [ attributes ]
			ifFalse: [ attributes, fontAttributes ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977865!
emphasisAt: characterIndex
	"Answer the emphasis for characters in the run beginning at characterIndex."

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ emphasis ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978084!
isSeparators
	"Answer true if the receiver contains only separators (i.e. whitespace)."
	^string isSeparators! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977793!
characterStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		^characterStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978330!
centered
	"Stuff like
	('Hello world' centered ) edit
	"
	self addAttribute: TextAlignment centered! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978113!
fixParagraphAttributesFrom: start to: end
	"Helper method to ensure the invariant that TextAttributes that answer true to
	 #isParagraphAttribute are only applied to whole paragraphs.
	See senders"
	
	| paragraphEnd paragraphInterval paragraphStart paragraphAttributes|
	self hasAnyParagraphAttribute ifFalse: [ ^self ].
	paragraphEnd := end max: start.	"end could be start-1 when new text is empty, for example, when backspacing"
	[
		paragraphInterval := self encompassParagraph: (paragraphEnd to: paragraphEnd).
		paragraphStart := paragraphInterval first.
		paragraphEnd := paragraphInterval last.
	
		"We must honor the paragraph attributes as defined in the newline (Lf) Character that ends the paragraph"
		paragraphAttributes := (self attributesAt: paragraphEnd) select: [ :attr | attr isParagraphAttribute ].

		"if paragraphEnd is inside the interval just modified, and it doesn't bring any paragraph attributes (i.e., it doesn't end in CR),
		then try to keep the paragraph attributes previously in use in this paragraph..
		This is needed, for example, when pasting an image  or a plain text at the end of the document"
		(paragraphEnd = end and: [ paragraphStart < start and: [ end > 0 and: [ (string at: end) isLineSeparator not ]]]) ifTrue: [
			paragraphAttributes := (self attributesAt: paragraphStart) select: [ :attr | attr isParagraphAttribute ]].

		self privateSetParagraphAttributes: paragraphAttributes from: paragraphStart to: paragraphEnd.
		paragraphEnd := paragraphStart - 1.
		paragraphStart > start ] whileTrue.
	runs coalesce! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978193!
runs
	^runs! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977530 overrides: 16947400!
hash
	"#hash is implemented, because #= is implemented.  We are now equal to a string with the same characters.  Hash must reflect that."

	^ string hash! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977840!
commandForRemoveAttributes: attributesToRemove from: requestedStart to: requestedStop
	"Remove the attribute over the interval start to stop."

	| intervalToFix start stop new old |
	start := requestedStart.
	stop := requestedStop.
	
	"If att must be applied to whole paragraphs, do so."
	(attributesToRemove anySatisfy: [ :att | att isParagraphAttribute ]) ifTrue: [
		intervalToFix := self encompassParagraph: (start to: stop).
		start := intervalToFix first.
		stop := intervalToFix last ].

	old := runs copyFrom: start to: stop.
	new := old copy mapValues: [ :attributes | 
			attributes copyWithoutAll: attributesToRemove].
	^AttributesReplaceCommand
		old: old
		new: new
		start: start
		stop: stop! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978081!
isRemote
	^false! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977379 overrides: 16913349!
at: index 
	^string at: index! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977902!
fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	| font fn ps |
	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		font := defaultFont ifNil: [FontFamily defaultFamilyAndPointSize].
		familyName notNil | pointSize notNil ifTrue: [
			fn := familyName ifNil: [ defaultFont familyName ].
			ps := pointSize ifNil: [ defaultFont pointSize ].
			(FontFamily familyName: fn pointSize: ps) ifNotNil: [ :f |
				font := f emphasized: defaultFont emphasis]].
		^font 	emphasized: (defaultFont emphasis bitOr: emphasis) ].! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977735!
addAttribute: att 
	self isEmpty ifTrue: [ ^self ].
	^ self addAttribute: att from: 1 to: self size! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978232!
edit

	self editLabel: 'Text Editor'! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978224!
hasAnyParagraphAttribute
	"Return false if there are no paragraph attributes"

	^runs values anySatisfy: [ :emphArray | emphArray anySatisfy: [ :attr | attr isParagraphAttribute ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978408 overrides: 16828310!
add: newObject 
	"Adding to an Interval is not allowed."

	self shouldNotImplement! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977624 overrides: 16913675!
asString
	"Answer a String representation of the textual receiver."
	^string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977454!
isLastLineSeparator
	^string isLastLineSeparator! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978175!
privateSetRuns: anArray
	"Warning. No attempt is done to ensure the invariant that TextAttributes that answer true to
	 #isParagraphAttribute are only applied to whole paragraphs.
	Use with care. Currently only used for Shout, that seems to know what it does.
	Also used for private use, replacing asignment to the ivar, to ensure that the RunArray is set to properly compare TextAttributes"

	runs := anArray.
	runs canJoinMessage: (MessageSend receiver: self selector: #canJoin:and:)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978314!
super
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis superscript! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978241!
encompassLine: anInterval
	^string encompassLine: anInterval! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977741!
addAttribute: aTextAttribute from: requestedStart to: requestedStop
	"Set the attribute for characters in the interval start to stop.
	Turned into a command to enable reuse by undo / redo"
	(self
		commandForAddAttribute: aTextAttribute
		from: requestedStart
		to: requestedStop) doOn: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978071 overrides: 16829426!
isEmpty
	^self size = 0! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977541!
appendToString: aString

	| stringSize |
	stringSize := aString size.
	^ (aString asText) 
			replaceFrom: stringSize + 1
			to: stringSize 
			with: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16977641 overrides: 16914685!
displayStringOrText
	"To be used in the UI"
	"Answer the receiver itself."

	^self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978103!
basicReplaceAttributesFrom: start to: stop with: replacement
	"Private. Does not enforce invariants.
	replacement size = (stop-start-1) "
	
	self privateSetRuns: (runs basicReplaceAttributesFrom: start to: stop with: replacement)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978003!
withAttributeValues: attributes do: aBlock
	"Evaluate aBlock with the values of various attributes that affect text formatting, applied in the correct order
	The order is (each overwriting the previous one)
	1) basic defaults
	2) ParagraphStyleReferene
	3) CharacterStyleReference
	4) TextFontReference
	5) TextEmphasis"

	| paragraphStyle characterStyle familyName pointSize emphasis alignment color backgroundColor |
	paragraphStyle := nil.
	characterStyle := nil.
	familyName := nil.
	pointSize := nil.
	emphasis := 0.
	alignment := nil.
	color := nil.
	backgroundColor := nil.
	
	"ParagraphStyle is the first to set several values"
	attributes do: [ :attribute |
		attribute forParagraphStyleReferenceDo: [ :s |
			paragraphStyle := s.
			familyName := s familyName.
			pointSize := s pointSize.
			emphasis := s emphasis.
			alignment := s alignment.
			s color ifNotNil: [ :c | color := c ]]].

	"CharacterStyle, if present, can override font and color"
	attributes do: [ :attribute |
		attribute forCharacterStyleReferenceDo: [ :s |
			characterStyle := s.
			familyName := s familyName.
			pointSize := s pointSize.
			emphasis := s emphasis.
			s color ifNotNil: [ :c | color := c ]]].

	"These will not interfere with each other, and all of them take precedence over previous values"
	attributes do: [ :attribute |
		attribute forFontFamilyDo: [ :fn | familyName := fn ].
		attribute forFontSizeDo: [ :ps | pointSize := ps ].
		attribute forTextEmphasisDo: [ :e | emphasis := emphasis bitOr: e ].
		attribute forTextColorDo: [ :c | color := c ].
		attribute forTextBackgroundColorDo: [ :c | backgroundColor := c ].
		attribute forTextAlignmentDo: [ :a | alignment := a ].
	].
	
	"Done. Now evaluate the block."
	^aBlock valueWithArguments: { familyName. pointSize. emphasis. color. alignment. characterStyle. paragraphStyle. backgroundColor }! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978462 overrides: 16787780!
new: stringSize 
	^self fromString: (String new: stringSize)! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978522!
setParagraphAttributes: paragraphAttributes toArray: others
	"Make paragraphAttributes the only paragraph attributes,
	but keep characterAttributes to an existing set"
	
	^ Array streamContents: [:strm |
		paragraphAttributes do: [ :att |
			strm nextPut: att ].
		others do: [ :other | 
			other isParagraphAttribute ifFalse: [ strm nextPut: other ]]]! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978492!
withForm: aForm
	"
	('Hello', (Text withForm: ImageMorph defaultForm), 'world') edit
	"
	^' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aForm)), ' '! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978443!
initialFont: aFont stringOrText: aStringOrText
	"Answer an instance of me whose characters are aString.
	Note: use #baseFont. If emphasis is desired, add it separatedly."

	(aStringOrText is: #Text) ifTrue: [
		^aStringOrText initialFont: aFont ].
	
	^self string: aStringOrText attributes: {
			TextFontFamily familyName: aFont familyName.
			TextFontSize pointSize: aFont pointSize }! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978422!
fromString: aString 
	"Answer an instance of me whose characters are those of the argument, aString."

	^ self string: aString attributes: #()! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978536!
string: aString runs: anArray  
	^self basicNew setString: aString setRuns: anArray! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978500!
addAttribute: newTextAttribute toArray: existingAttributes
	"Add a new text attribute to an existing set"

	| includeNew |
	includeNew := true.
	^ Array streamContents: [ :strm |
		existingAttributes do: [ :existing |
			(newTextAttribute dominates: existing) ifFalse: [
				"Keep existing unless new dominates it."
				strm nextPut: existing.
				"If new doesn't dominate existing, perhaps existing dominates new."
				(existing dominates: newTextAttribute) ifTrue: [
					"Don't add new if an existing attribute dominates it."
					includeNew := false ]
				]].
		includeNew ifTrue: [ strm nextPut: newTextAttribute ]].! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978458 overrides: 16787772!
new

	^self fromString: ''! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978467!
string: aString 
	"Answer an instance of me whose characters are those of the argument, aString."

	^ self string: aString attributes: #()! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978483!
string: aString attributes: atts
	"Answer an instance of me whose characters are those of aString.
	atts is an array of TextAttributes."

	^self string: aString runs: (RunArray new: aString size withAll: atts)! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978475!
string: aString attribute: att
	"Answer an instance of me whose characters are aString.
	att is a TextAttribute."

	^self string: aString attributes: (Array with: att)! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16978429!
initialFont: aFont string: aString attribute: aTextAttribute
	"Answer an instance of me whose characters are aString.
	Note: use #baseFont. If emphasis is desired, add it separatedly."

	^self
		string: aString
		attributes: {
			TextFontFamily familyName: aFont familyName.
			TextFontSize pointSize: aFont pointSize.
			aTextAttribute}! !
!TextCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16979162!
undoOn: aTextModel
	"Undo the command, bringing the text model to the state it had prior to doing it"
	^nil! !
!TextCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16979156!
doOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing"
	^nil! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981624 overrides: 16913521!
bindingOf: aString
	^model bindingOf: aString! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981736!
addCutAndPasteMenuSectionTo: aMenu
	"Adds  typical cut and paste operations section to a menu"

	self flag: #assumesKeyboardShortcuts.
	self hasUnacceptedEdits ifTrue: [
		aMenu
			add: 'Accept (s)'
			action: #acceptContents
			icon: #acceptIcon
	].
	
	aMenu
		add: 'Copy (c)'
		action: #copySelection
		icon: #copyIcon.
	
	aMenu
		add: 'Cut (x)'
		action: #cut
		icon: #cutIcon.

	aMenu
		add: 'Paste (v)'
		action: #paste
		icon: #pasteIcon.
		
	aMenu
		add: 'Paste without Format'
		action: #pasteString
		icon: #pasteIcon.
	
	aMenu
		add: 'Paste...'
		action: #pasteRecent
		icon: #worldIcon.
	
	^aMenu! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980296!
offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel := self selection.
	colors := #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index := (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute := TextColor color: (Color perform: (colors at: index)) ]
		ifFalse: [
			index := index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute := self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	morph updateFromTextComposition.
	^ true.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980222 overrides: 50578672!
pointIndex
	pointBlock ifNil: [^1].
	^ pointBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980703!
doubleClickAndHalf

	| here interval |
	here := self pointIndex.
	interval := self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection := false.
	doParagraphSelection := true.
	initialSelectionStart := self startBlock.
	initialSelectionStop := self stopBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981313!
addAttributesForPasting: replacement
	^ (replacement is: #Text)
		ifTrue: [ replacement ]
		ifFalse: [
			Text
				string: replacement
				attributes: emphasisHere ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981502 overrides: 50578641!
moveCursor: directionBlock forward: forward event: aKeyboardEvent

	super moveCursor: directionBlock forward: forward event: aKeyboardEvent.
	self setEmphasisHereFromTextForward: forward! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980479!
copyHiddenInfo
	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden
info.  Copy that to the clipboard.  You can paste it and see what it is.
Usually enclosed in <>."

	^ self clipboardTextPut: self hiddenInfo! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981597!
unapplyAttributes: textAttributes
	"The user selected textAttributes to be removed.
	If there is a selection, unapply the attributes to the selection.
	In any case do not use the attribute for the user input (emphasisHere)"
	"This generates undo"

	| interval |
	emphasisHere := emphasisHere copyWithoutAll: textAttributes.
	interval := self selectionInterval.
	(interval isEmpty and: [ textAttributes noneSatisfy: [ :each | each isParagraphAttribute ]])
		ifTrue: [ ^self ].
	model logUndoAndRemoveAttributes: textAttributes from: interval first to: interval last.
	textComposition recomposeFrom: interval first to: interval last delta: 0.
	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
	morph possiblyChanged! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980405!
align: aKeyboardEvent
	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"

	self align.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980094!
lastFont
	"Answer the Font for to be used if positioned at the end of the text"

	^self startIndex > model textSize
		ifTrue: [ model actualContents fontIfApplying: emphasisHere default: defaultFont ]
		ifFalse: [ model actualContents fontAt: model textSize +1 default: defaultFont ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980635!
makeUppercase: aKeyboardEvent
	"Force the current selection to uppercase.  Triggered by Cmd-Y."
	"This is a user command, and generates undo"

	self replaceSelectionWith: self selectedString asUppercase.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981108!
blinkParen
	"Used if Shout"
	lastParenLocation ifNotNil: [
		model textSize >= lastParenLocation ifTrue: [
			model privateAddBoldAt: lastParenLocation ]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981654!
removeMorph: aMorph
	"This is a user command, and generates undo"

	| range |

	"Warning: As undo will only be done for text in the model, undoing this will neither
	recreate the morph nor add it to the TextMorph!! (See senders of #insertMorph:at:
	A specific undo for inserting / removing morphs might be in order. But I doubt the
	TextModel should be responsible for that."
	self flag: #jmv.

	range := model actualContents find: (TextAnchor new anchoredFormOrMorph: aMorph).
	range ifNotNil: [
		model logUndoAndReplaceFrom: range first to: range last with: Text new.
		textComposition recomposeFrom: range first to: range first  -1 delta: range size negated ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980604!
indent: aKeyboardEvent
	"Add a tab at the front of every line occupied by the selection. Invoked from keyboard via cmd-shift-R.  2/29/96 sw"

	^ self inOutdent: aKeyboardEvent delta: 1! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980626!
makeLowercase: aKeyboardEvent
	"Force the current selection to lowercase.  Triggered by Cmd-X."
	"This is a user command, and generates undo"

	self replaceSelectionWith: self selectedString asLowercase.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981122!
blinkPrevParen: aCharacter
	"Used if not Shout"
	| closingDelimiter openingDelimiter level string here hereChar |
	string := self privateCurrentString.
	here := pointBlock stringIndex.
	closingDelimiter := aCharacter.
	openingDelimiter := '([{' at: (')]}' indexOf: closingDelimiter).
	level := 1.
	[ level > 0 and: [ here > 1 ]]
		whileTrue: [
			hereChar := string at: (here := here - 1).
			hereChar = openingDelimiter
				ifTrue: [
					level := level - 1.
					level = 0
						ifTrue: [^ self blinkParenAt: here]]
				ifFalse: [
					hereChar = closingDelimiter
						ifTrue: [ level := level + 1]]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980936!
wrapOnOff
	"Toggle WordWrap"

	morph wrapOnOff! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980394!
recomputeSelection
	"The same characters are selected but their coordinates may have changed."

	self markIndex: self markIndex pointIndex: self pointIndex.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981159!
backTo: startIndex
	"During typing, backspace to startIndex."
	"This is a user command, and generates undo"

	self markIndex: startIndex.
	self replaceSelectionWith: self nullText.
	markBlock := pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981168!
dispatchOn: aKeyboardEvent
	"Carry out the action associated with this character, if any."

	| codePoint asciiValue c |
	self clearParens.
  	codePoint := aKeyboardEvent keyValue.
	
	codePoint > 255 ifTrue: [
		^self normalCharacter: aKeyboardEvent ].

	asciiValue := codePoint.
	"Control keys are handled by #shortcuts even if they have any modifiers"
	(self shouldHandleUsingCmdShortcuts: aKeyboardEvent) ifTrue: [
		^self perform: (self cmdShortcuts at: asciiValue + 1) with: aKeyboardEvent ].

	c := aKeyboardEvent keyCharacter.
	(')]}' includes: c)
		ifTrue: [ self blinkPrevParen: c ].

	^ self perform: (self shortcuts at: asciiValue + 1) with: aKeyboardEvent.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980736!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	aMouseButtonEvent shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(textComposition characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock := textComposition characterBlockAtPoint: localEventPosition.
			cursorIndex := cursorBlock stringIndex.
			startBlock := self startBlock min: cursorBlock.
			startIndex := startBlock stringIndex.
			stopBlock := self stopBlock max: cursorBlock.
			stopIndex := stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock := startBlock.
					pointBlock := cursorBlock ]
				ifFalse: [
					markBlock := stopBlock.
					pointBlock := cursorBlock ]].
	self storeSelectionInComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981851 overrides: 16932297!
initialize
	initialSelectionStart := nil.
	initialSelectionStop := nil.
	doWordSelection := false.
	doParagraphSelection := false.
	defaultFont := FontFamily defaultFamilyAndPointSize! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980360!
offerFontStyleMenu
	"This is a user command, and generates undo"

	| emphases menuStrings entries reply code startIndex attribute |
	startIndex := self startIndex.
	code := model actualContents emphasisAt: startIndex.
	emphases := #(bold italic underlined struckThrough superscript subscript).
	menuStrings := Array streamContents: [ :strm |
		strm nextPut:(code isZero ifTrue: ['<on>'] ifFalse: ['<off>']), 'normal'.
		emphases do: [ :emph |
			strm nextPut:
				((code anyMask: (TextEmphasis perform: emph) emphasisCode)
					ifTrue: ['<on>'] ifFalse: ['<off>']),
				emph asPlainString ]].
	entries := `#(normal)`, emphases.
	reply := (SelectionMenu labelList: menuStrings lines: #(1) selections: entries) startUpMenu.
	reply ifNotNil: [
		attribute := TextEmphasis perform: reply.
		((menuStrings at: (entries indexOf: reply)) beginsWith: '<on>')
			ifTrue: [ self unapplyAttributes: {attribute} ]
			ifFalse: [ self applyAttribute:  attribute ]].
	morph updateFromTextComposition.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980201 overrides: 50578868!
markIndex
	markBlock ifNil: [^1].
	^ markBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980659!
outdent: aKeyboardEvent
	"Remove a tab from the front of every line occupied by the selection.
	Invoked from keyboard via cmd-shift-L.  2/29/96 sw"

	^ self inOutdent: aKeyboardEvent delta: -1! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980183 overrides: 50578873!
userHasEdited

	morph hasUnacceptedEdits: model isDirty! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981055!
cursorEnd: aKeyboardEvent 

	"Private - Move cursor end of current line."

	self
		moveCursor: [ :position |
			"Mac standard keystrole"		
			(aKeyboardEvent commandAltKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ self endOfText ]
					ifFalse: [ self endOfLine: position ]]
		forward: true
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980251 overrides: 50578887!
selectionIsEmptyOrSeparators
	"Answer true if no selection or selection is just separators (whitespace)"

	self hasSelection ifFalse: [ ^true ].
	^self selection isSeparators! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981283!
findAgain: aKeyboardEvent 
	"Find the desired text again.  1/24/96 sw"

	self findAgain.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981152!
addString: aString
	"Think of a better name"
	"This is a user command, and generates undo"

	self replaceSelectionWith: aString! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980885!
find
	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"

	self
		request: 'Find what?'
		initialAnswer: self class findText
		do: [:aString|
			aString isEmpty ifFalse:
				["Set focus on our text morph, so that cmd-g does the search again"
				morph world activeHand newKeyboardFocus: morph.
				self setSearch: aString.
				ChangeText := self class findText.  "Implies no replacement to againOnce: method"
				(self findAndReplaceMany: false)
					ifFalse: [ self flash ].
				morph scrollSelectionIntoView ]].

"	morph installEditorToReplace: self"! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981716!
redo: aKeyboardEvent 
	"Redo the last edit."

	self redo.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980239!
selection
	"Answer the text that is currently selected."

	| t firstIndex lastIndex |
	t := model actualContents.
	firstIndex := self startIndex.
	lastIndex := self stopIndex - 1.
	(firstIndex = 1 and: [ lastIndex = t size ])
		ifTrue: [ ^t copy ].
	^t copyFrom: firstIndex to: lastIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980873!
cut
	"Cut out the current selection and redisplay if necessary."
	"This is a user command, and generates undo"

	| selection |
	self lineSelectAndEmptyCheck: [^ self].
	selection := self selection.
	self replaceSelectionWith: self nullText.
	self clipboardTextPut: selection.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981354 overrides: 50578984!
beginningOfLine: position
	"Redefined in subclasses using TextComposition"
	^ (textComposition lines at: (textComposition lineIndexFor: position)) first! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980996!
insertAndSelect: aString at: anInteger
	"This is a user command, and generates undo"

	| newText |
	newText := (aString is: #Text) ifTrue: [aString] ifFalse: [Text string: aString attributes: emphasisHere].
	self deselectAndPlaceCursorAt: anInteger.
	self replaceSelectionWith: newText.
	self selectFrom: anInteger to: anInteger + newText size - 1! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981192!
processKeystrokeEvent: aKeyboardEvent
	"Key struck on the keyboard. Find out which one and, if special, carry 
	out the associated special action. Otherwise, add the character to the 
	stream of characters."

	(self dispatchOn: aKeyboardEvent) ifTrue: [
		self storeSelectionInComposition.
		^self].

	markBlock := pointBlock.
	self storeSelectionInComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981628!
insertMorph: aMorph at: relPt
	"This is a user command, and generates undo"
	| index newText |

	"Warning: As undo will only be done for text in the model, undoing this will neither
	kill the morph nor send it to another owner!! See implementors of #removeMorph: in TextMorphs.
	A specific undo for inserting / removing morphs might be in order. But I doubt the
	TextModel should be responsible for that."
	self flag: #jmv.

	index := (textComposition characterBlockAtPoint: relPt) stringIndex.
	newText := ' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aMorph)), ' '.
	model logUndoAndReplaceFrom: index to: index-1 with: newText.
	textComposition recomposeFrom: index to: index + newText size -1 delta: newText size.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980613!
makeCapitalized: aKeyboardEvent
	"Force the current selection to uppercase.  Triggered by Cmd-X."
	"This is a user command, and generates undo"

	| prev |
	prev := $-.  "not a letter"
	self replaceSelectionWith: 
		(self selectedString collect:
			[:c | prev := prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]]).
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981678!
flushUndoRedoCommands
	model flushUndoRedoCommands! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980344!
offerFontSizeMenu
	| startIndex currentFont fontFamily attr |
	startIndex := self startIndex.
	currentFont := model actualContents fontAt: startIndex default: defaultFont.
	fontFamily := currentFont family.
	(FontFamily
		promptUserForSize: currentFont pointSize
		fontFamily: fontFamily) ifNotNil: [ :ptSize |
			attr := TextFontSize pointSize: ptSize.
			self applyAttribute: attr.
			morph updateFromTextComposition ].! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980767!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Change the selection in response to mouse-down drag"

	| newPointBlock goingBackwards newStartBlock newStopBlock interval i1 i2 |
	newPointBlock := textComposition characterBlockAtPoint: localEventPosition.
	goingBackwards := newPointBlock stringIndex < markBlock stringIndex.

	doWordSelection ifTrue: [
		pointBlock := newPointBlock.
		self selectWord.
		newStartBlock := self startBlock min: initialSelectionStart.
		newStopBlock := self stopBlock max: initialSelectionStop.
		markBlock := goingBackwards ifTrue: [newStopBlock] ifFalse: [newStartBlock].
		pointBlock := goingBackwards ifTrue: [newStartBlock] ifFalse: [newStopBlock].
		self storeSelectionInComposition.
		^self ].

	doParagraphSelection ifTrue: [
		i1 := newPointBlock stringIndex min: initialSelectionStart stringIndex.
		i2 := newPointBlock stringIndex max: initialSelectionStop stringIndex-1.
		interval := self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		newStartBlock := self startBlock min: initialSelectionStart.
		newStopBlock := self stopBlock max: initialSelectionStop.
		markBlock := goingBackwards ifTrue: [newStopBlock] ifFalse: [newStartBlock].
		pointBlock := goingBackwards ifTrue: [newStartBlock] ifFalse: [newStopBlock].
		self storeSelectionInComposition.
		^self ].

	pointBlock := newPointBlock.
	self storeSelectionInComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980816!
acceptContents
	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"
	^morph acceptContents! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980546!
inOutdent: aKeyboardEvent delta: delta
	"Add/remove a tab at the front of every line occupied by the selection.
	This is a user command, and generates undo"

	| realStart realStop lines startLine stopLine start stop adjustStart size inStream outStream |

	"Operate on entire lines, but remember the real selection for re-highlighting later"
	realStart := self startIndex.
	realStop := self stopIndex - 1.

	"Special case: the text cursor on a line of its own, including weird case at end of paragraph"
	(realStart > realStop and: [
				realStart < 2 or: [(self privateCurrentString at: realStart - 1) isLineSeparator ]])
		ifTrue: [
			delta < 0
				ifTrue: [
					morph flash]
				ifFalse: [
					self replaceSelectionWith: Character tab asSymbol.
					self deselectAndPlaceCursorAt: realStart + 1].
			^true].

	lines := textComposition lines.
	startLine := textComposition lineIndexFor: realStart.
	stopLine := textComposition lineIndexFor: (realStart max: realStop).
	start := (lines at: startLine) first.
	stop := (lines at: stopLine) last.
	
	"Pin the start of highlighting unless the selection starts a line"
	adjustStart := realStart > start.

	size :=  stop + 1 - start.
	inStream := self privateCurrentString readStreamFrom: start to: stop.
	outStream := UnicodeString writeStream.

	"This subroutine does the actual work"
	self indent: delta fromStream: inStream toStream: outStream.

	"Adjust the range that will be highlighted later"
	adjustStart ifTrue: [realStart := (realStart + delta) max: start].
	realStop := realStop + outStream position - size.

	"Prepare for another iteration"
	self selectInvisiblyFrom: start to: stop.
	self replaceSelectionWith: outStream contents.
	self selectFrom: realStart to: realStop. 	"highlight only the original range"
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980472!
compareToClipboard: aKeyboardEvent
	"Compare the receiver to the text on the clipboard."

	self compareToClipboard.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980954!
wordUnderCursor
	
	^self wordAt: self pointIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981426!
firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine := textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine := currentLine first.
	endOfIndentation := self privateCurrentString
		skipDelimiters: (UnicodeString with: Character tab)
		startingAt: beginningOfLine.
		
	stops := OrderedCollection with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980227!
pointIndex: anIndex
	"Called, for example, when selecting text with shift+arrow keys"
	pointBlock := textComposition characterBlockForIndex: anIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980075!
currentParagraphStyle
	"Answer the ParagraphStyle for the current selection or cursor location if any"
	
	| i |
	i := self startIndex.
	^i > model textSize
		ifTrue: [ model actualContents paragraphStyleOrNilIfApplying: emphasisHere ]
		ifFalse: [ model actualContents paragraphStyleOrNilAt: i ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980206!
markIndex: anIndex
	"Called, for example, when selecting text with shift+arrow keys"
	markBlock := (textComposition characterBlockForIndex: anIndex)
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980489!
enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex := self startIndex.
	stopIndex := self stopIndex.
	oldSelection := self selection.
	which := '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left := '([<{"''`' at: which.
	right := ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left
				and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (UnicodeString with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (UnicodeString with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^ true.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980940!
model: aModel
	model := aModel! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980716!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	| b |

	initialSelectionStart := nil.
	initialSelectionStop := nil.
	doWordSelection := false.
	doParagraphSelection := false.

	b := textComposition characterBlockAtPoint: localEventPosition.
	(textComposition clickAt: localEventPosition) ifTrue: [
		markBlock := b.
		pointBlock := b.
		aMouseButtonEvent hand releaseKeyboardFocus: self.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			markBlock := b.
			pointBlock := b.	
			self setEmphasisHereFromText ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980162!
setSearch: aStringOrText
	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."

	self class findText = aStringOrText
		ifFalse: [FindText := ChangeText := aStringOrText]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980259!
startBlock
	^ pointBlock min: markBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980106!
lastParagraphStyleOrNil
	"Answer the ParagraphStyle for to be used if positioned at the end of the text"

	^self startIndex > model textSize
		ifTrue: [ model actualContents paragraphStyleOrNilIfApplying: emphasisHere ]
		ifFalse: [ model actualContents paragraphStyleOrNilAt: model textSize +1 ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980191!
characterBlockForIndex: anIndex

	^ textComposition characterBlockForIndex: anIndex ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980214!
markIndex: anIndex pointIndex: anotherIndex
	"Called, for example, when selecting text with shift+arrow keys"
	self
		markIndex: anIndex;
		pointIndex: anotherIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981510!
nullText

	^Text string: '' attributes: emphasisHere! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980674!
tabKey: aKeyboardEvent
	"Add/remove a tab at the front of every line occupied by the selection if there is one; treat as a normal character otherwise."
	
	aKeyboardEvent shiftPressed 
		ifTrue: [ ^ self outdent: aKeyboardEvent ].
	
	^ self hasSelection 
		ifTrue: [ self indent: aKeyboardEvent ]
		ifFalse: [ self normalCharacter: aKeyboardEvent ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980412!
changeEmphasis: aKeyboardEvent
	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis."
	"control 0..9 -> 0..9"
	"This is a user command, and generates undo"

	| keyCode attributeToAdd attributesToRemove oldAttributes |
	keyCode := ('0123456'
		indexOf: aKeyboardEvent keyCharacter
		ifAbsent: [ 1 ]) - 1.
	oldAttributes := emphasisHere.

	keyCode = 0
		ifTrue: [
			"Remove all TextEmphasis"
			attributeToAdd := nil.
			attributesToRemove := oldAttributes ]
		ifFalse: [
			"Toggle the indicated TextEmphasis"
			(keyCode between: 1 and: 6) ifTrue: [
				attributeToAdd := TextEmphasis perform: (
					#(#bold #italic #underlined #struckThrough #superscript #subscript)
						at: keyCode).
				oldAttributes do: [ :oldAtt |
					oldAtt = attributeToAdd ifTrue: [
						attributeToAdd := nil.
						attributesToRemove := {oldAtt} ]]]].

	attributeToAdd ifNotNil: [ self applyAttribute: attributeToAdd ].
	attributesToRemove ifNotNil: [ self unapplyAttributes: attributesToRemove ].
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980928!
setSearchString
	"Make the current selection, if any, be the current search string."
	self hasSelection ifFalse: [morph flash. ^ self].
	self setSearch: self selectedString! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980525!
hiddenInfo
	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."

	| attrList |
	attrList := model actualContents attributesAt: (self pointIndex + self markIndex)//2.
	attrList do: [:attr |
		attr forTextActionInfoDo: [ :info |
			^ self selectedString, '<', info, '>']].
	"If none of the above"
	attrList do: [:attr |
		attr forTextColorDo: [ :color |
			^ self selectedString, '<', color printString, '>']].
	^ self selectedString, '[No hidden info]'! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981454!
indent: delta fromStream: inStream toStream: outStream
	"Append the contents of inStream to outStream, adding or deleting delta or -delta
	 tabs at the beginning, and after every NewLine except a final NewLine.  Do not add tabs
	 to totally empty lines, and be sure nothing but tabs are removed from lines."

	| ch skip tab prev atEnd |
	tab := Character tab.
	delta > 0
		ifTrue: [
			"shift right"
			prev := Character newLineCharacter.
			[
			ch := (atEnd := inStream atEnd)
				ifTrue: [ Character newLineCharacter ]
				ifFalse: [ inStream next ].
			(prev isLineSeparator and: [ ch isLineSeparator not ]) ifTrue: [ delta timesRepeat: [ outStream nextPut: tab ]].
			atEnd ] whileFalse: [
				outStream nextPut: ch.
				prev := ch ]]
		ifFalse: [
			"shift left"
			skip := delta.
			"a negative number"
			[ inStream atEnd ] whileFalse: [
				((ch := inStream next) = tab and: [ skip < 0 ]) ifFalse: [ outStream nextPut: ch ].
				skip := ch isLineSeparator
					ifTrue: [ delta ]
					ifFalse: [ skip + 1 ]]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981144!
clearParens
	lastParenLocation ifNotNil: [
		model textSize >= lastParenLocation ifTrue: [
			model privateRemoveBoldAt: lastParenLocation ]].
	lastParenLocation := nil! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981372!
findAndReplaceMany: doMany
	"Subroutine of search: and again.  Use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."
	"jmvnote: We currently have no command for search&replace, but it is really easy to add, and this method supports it. See ChangeText"
	"This is a user command, and generates undo"

	|  indexStream |

	"Find and Change, recording start indices in the array"
	indexStream := WriteStream on: (Array new: 20). "an array to store change locs"
	[(self findAndReplaceOnce: indexStream) & doMany] whileTrue. "<-- this does the work"
	"Answer whether something was found"
	^indexStream notEmpty! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980846!
compareToClipboard
	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."
	| s1 s2 |
	s1 := self clipboardStringOrText string.
	s2 := self selection ifEmpty: [self privateCurrentString].
	s1 = s2 ifTrue: [^ self inform: 'Exact match'].

	(TextModel new contents:
		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))
			openLabel: 'Comparison to Clipboard Text'! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981010!
selectFrom: start to: stop
	"Select the specified characters inclusive.
	I.e. if contents is 'hello' and we want to select the $e, do 'self selectFrom: 2 to: 2'
	If we want to put cursor after e, but with no selection, do 'self selectFrom: 3 to: 2', or better yet, call #selectAt:"
	self selectInvisiblyFrom: start to: stop.
	self storeSelectionInComposition.
	"Preserve current emphasis if selection is empty"
	start > stop ifTrue: [
		self setEmphasisHereFromText ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981721!
undo

	morph disablesEditing ifTrue: [
		^ self ].

	model undoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.				"this could be made more specific..."
			morph possiblyChanged ]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980049 overrides: 50579405!
currentAttributes
	| i |
	i := self startIndex.
	^i > model textSize
		ifTrue: [
			emphasisHere ]
		ifFalse: [
			"paragraph attributes at the current paragraph will later be applied.
			include them in the answer"
			(emphasisHere reject: [ :attr | attr isParagraphAttribute ]),
				((model actualContents attributesAt: i) select: [ :attr | attr isParagraphAttribute ]) ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980277!
clearFont
	"Remove any Font attribute"
	"This is a user command, and generates undo"

	| attributesToRemove firstIndex lastIndex |
	attributesToRemove := Set new.
	firstIndex := self startIndex.
	lastIndex := self stopIndex - 1.
	model actualContents attributesFrom: firstIndex to: lastIndex do: [ :attribute |
		attribute isFont ifTrue: [ attributesToRemove add: attribute ]].

	self unapplyAttributes: attributesToRemove.
	morph resetTextComposition.
	self recomputeSelection.
	morph updateFromTextComposition.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980041!
actualContents

	^model actualContents ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980263 overrides: 50579443!
startIndex
	pointBlock ifNil: [^1].
	^ self startBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981361 overrides: 50579419!
endOfLine: position
	"Redefined in subclasses using TextComposition"
	| targetLine |
	targetLine := textComposition lines at: (textComposition lineIndexFor: position).
	^ targetLine = textComposition lastLine
		ifFalse: [ targetLine last ]
		ifTrue: [ targetLine last + 1 ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981758!
addFinderMenuSectionTo: aMenu
	"Build a submenu with finding related operations"

	self flag: #assumesKeyboardShortcuts.
	aMenu addItemsFromDictionaries:
	 `{
			{
				#label 			-> 		'Find...(f)'.
				#selector 			-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 			-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 			-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
		}`.
		^aMenu! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980402 overrides: 16914387!
flash
	^ morph flash! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980272 overrides: 50579455!
stopIndex
	pointBlock ifNil: [^1].
	^ self stopBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980833!
chooseAlignment
	"This is a user command, and generates undo"

	| aList reply  |
	aList := #(leftFlush centered justified rightFlush).
	reply := (SelectionMenu labelList: aList selections: aList) startUpMenu.
	reply ifNil: [ ^self ].
	self applyAttribute: (TextAlignment perform: reply).
	morph updateFromTextComposition.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981396!
findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where := model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [Preferences at: #caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981070!
cursorHome: aKeyboardEvent

	"Private - Move cursor from position in current line to beginning of current line or end of indentation (see #firstOfBeginningOfLineOrEndOfIndentationLeftOf:).
	If control key is pressed put cursor at beginning of text"

	self
		moveCursor: [ :position |
			"Mac standard keystrole"		
			(aKeyboardEvent commandAltKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ self beginningOfText ]
					ifFalse: [ self firstOfBeginningOfLineOrEndOfIndentationLeftOf: position ]]
		forward: false
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981092!
help: aKeyboardEvent
	"Show a help screen"

	self openHelp.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981836!
getMenu
	| aMenu | 
	aMenu := MenuMorph new defaultTarget: self.
	aMenu
		addTitle: self class name;
		addStayUpIcons.
		
	aMenu
		add: 'Help...'
		action: #openHelp
		icon: #helpIcon.
	aMenu addLine.
	
	self addFinderMenuSectionTo: aMenu.
	self addUndoMenuSectionTo: aMenu.
	aMenu addLine.
	
	self addCutAndPasteMenuSectionTo: aMenu.
	aMenu addLine.
	
	self addStyleMenuSectionTo: aMenu.
	
	^aMenu ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980179!
totalTextHeight

	^textComposition lines last bottom! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981581!
shouldHandleUsingCmdShortcuts: aKeyboardEvent 
	^ (aKeyboardEvent keyValue between: 32 and: 126) and: [ aKeyboardEvent commandAltKeyPressed ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981701!
redo

	morph disablesEditing ifTrue: [
		^ self ].

	model redoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.			"this could be made more specific..."
			morph possiblyChanged ]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980825!
align
	"Align text according to the next greater alignment value,
	cycling among leftFlush, rightFlush, center, and justified."
	self chooseAlignment! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980919!
pasteRecent
	"Paste an item chose from RecentClippings."

	| clipping |
	(clipping := Clipboard chooseRecentClipping) ifNil: [^ self].
	self clipboardTextPut: clipping.
	^ self paste! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980045!
actualContents: aString

	model actualContents: aString ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981211!
setEmphasisHereFromTextForward: f

	| i forward delta prevIsLineSeparator nextIsLineSeparator prevIsSeparator nextIsSeparator nextChar prevChar |
	i := self pointIndex.
	"Try to set emphasisHere correctly after whitespace.
	Most important after a cr, i.e. at the start of a new line"
	prevIsLineSeparator :=  i > 1 and: [ (prevChar := model actualContents at: i-1) isLineSeparator ].
	nextIsLineSeparator := i <= model textSize and: [ (nextChar := model actualContents at: i) isLineSeparator ].
	prevIsSeparator :=  i > 1 and: [ prevChar isSeparator ].
	nextIsSeparator := i <= model textSize and: [ nextChar isSeparator ].
	prevIsLineSeparator & nextIsLineSeparator
		ifTrue: [
			"Empty paragraph: take emphasis from the newLine character"
			forward := false ]
		ifFalse: [
			prevIsSeparator == nextIsSeparator
				ifTrue: [
					"Space at both sides, or non-space at both sides, take emphasis used where the cursor comes from"
					forward := f ]
				ifFalse: [
					"Space at one side and non-space at the other, take emphasis from the non-space character"
					forward := nextIsSeparator ]].
	delta := forward ifTrue: [ 1 ] ifFalse: [ 0 ].
	emphasisHere := (model actualContents attributesAt: (i - delta max: 1))
					select: [:att | att mayBeExtended].
	morph possiblyChanged! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981254!
backWord: aKeyboardEvent
	"If the selection is not empty, delete it and leave it in the backspace buffer.
	 Else, delete the word before the text cursor."
	"This is a user command, and generates undo"

	| startIndex |
	self hasSelection ifFalse: [ "No selection, delete at least one character"
		startIndex := 1 max: self markIndex - 1.
		[startIndex > 1 and:
			[(self privateCurrentString at: startIndex - 1) tokenish]]
				whileTrue: [
					startIndex := startIndex - 1]]
	ifTrue: [ "some selection, just delete it"
		startIndex := self markIndex].
	self backTo: startIndex.
	^false! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980447!
changeLineEndsToLf: aKeyboardEvent
	"Replace all CRs and CrLfs by LFs.
	Triggered by Cmd-U -- useful when getting code from FTP sites"
	"This is a user command, and generates undo"
	
	self replaceSelectionWith: self selectedString withCuisLineEndings.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981321!
applyAttribute: aTextAttribute
	"The user selected aTextAttribute via shortcut, menu or other means.
	If there is a selection, apply the attribute to the selection.
	In any case use the attribute for the user input (emphasisHere)"
	"This generates undo"
	| anythingDone interval |

	morph disablesEditing ifTrue: [
		^ self ].

	anythingDone := false.
	emphasisHere := Text addAttribute: aTextAttribute toArray: emphasisHere.

	interval := self selectionInterval.
	(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])
		ifTrue: [
			anythingDone := true.
			model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.
			textComposition recomposeFrom: interval first to: interval last delta: 0 ].

	anythingDone ifTrue: [
		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
		self userHasEdited ].

	"Even if nothing done, emphasisHere might have changed"
	morph possiblyChanged.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980907!
findAgain
	"Find the text-to-find again.  1/24/96 sw"

	(self findAndReplaceMany: false)
		ifFalse: [ self flash ].! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981778!
addStyleMenuSectionTo: aMenu
	"Adds to the given menu text styiling related operations"

	self flag: #assumesKeyboardShortcuts.
	aMenu
		addItemsFromDictionaries: 
	`{
		{
				#label 			-> 		'Toggle WordWrap'.
				#selector 			-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 			-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 			-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font Size'.
				#selector 			-> 		#offerFontSizeMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Set Style'.
				#selector 			-> 		#offerFontStyleMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Set Text Color'.
				#selector 			-> 		#offerColorMenu.
				#icon 			-> 		#graphicsIcon
			} asDictionary.
			{
				#label 			-> 		'Set Alignment...'.
				#selector 			-> 		#chooseAlignment.
				#icon 			-> 		#formatJustifyLeftIcon
			} asDictionary.
		}`.
		^aMenu! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981289!
forwardDelete: aKeyboardEvent
	"Delete forward over the next character."
	"This is a user command, and generates undo"

	| startIndex stopIndex |

	"If there was a selection"
	self hasSelection ifTrue: [
		self replaceSelectionWith: self nullText.
		^ false].

	"Exit if at end"
	startIndex := self markIndex.
	startIndex > model textSize ifTrue: [
		^ false].

	"Null selection - do the delete forward"
	stopIndex := startIndex.
	(self shouldDeleteAWordForward: aKeyboardEvent)
		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].
	self selectFrom: startIndex to: stopIndex.
	self replaceSelectionWith: self nullText.
	self deselectAndPlaceCursorAt: startIndex.
	^false! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981882!
hasUnacceptedEdits: aBoolean

	^morph hasUnacceptedEdits: aBoolean ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981816!
addUndoMenuSectionTo: aMenu
	"Adds undo operations to the given menu"

	self flag: #assumesKeyboardShortcuts.
	aMenu
		addItemsFromDictionaries: 
		`{	
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 			-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 			-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 			-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
		}`.
		
	^aMenu.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980187!
visibleHeight

	^morph owner morphHeight! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981878!
hasUnacceptedEdits

	^morph hasUnacceptedEdits ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981275!
find: aKeyboardEvent
	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"

	self find.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980863!
copySelection
	"Copy the current selection and store it in the Clipboard, unless empty."

	| multiSelection |
	self lineSelectAndEmptyCheck: [^ self].

	multiSelection := self selection.
	self clipboardTextPut: multiSelection! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980063!
currentCharacterStyleOrNil
	"Answer the CharacterStyle for the current selection or cursor location if any"

	^self hasSelection
		ifTrue: [ model actualContents characterStyleOrNilAt: self startIndex ]
		ifFalse: [ model actualContents characterStyleOrNilIfApplying: emphasisHere ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980651!
offerFontMenu: aKeyboardEvent 
	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw"

	self offerFontMenu.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981871!
textComposition: aTextComposition 
	"Install aTextComposition as the one to be edited by the receiver."

	textComposition := aTextComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981532 overrides: 50578914!
sameColumn: start newLine: lineBlock forward: isForward
	"Private - Compute the index in my text
	with the line number derived from lineBlock,"
	" a one argument block accepting the old line number.
	The position inside the line will be preserved as good as possible"
	"The boolean isForward is used in the border case to determine if
	we should move to the beginning or the end of the line."
	| column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |
	lines := textComposition lines.
	numberOfLines := textComposition numberOfLines.
	currentLineNumber  := textComposition lineIndexFor: start.
	currentLine := lines at: currentLineNumber.
	column := start - currentLine first.
	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.
	offsetAtTargetLine := (lines at: targetLineNumber) first.
	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).
	targetLineNumber = currentLineNumber
	"No movement or movement failed. Move to beginning or end of line."
		ifTrue:[
			^isForward
				ifTrue:[targetEOL]
				ifFalse:[offsetAtTargetLine]].
	^offsetAtTargetLine + column min: targetEOL.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980944!
wordAt: aPositionInText
	
	| wordUnderCursorRange |
	wordUnderCursorRange := self wordRangeIncluding: aPositionInText.
	^(model actualContents copyFrom: wordUnderCursorRange first to: wordUnderCursorRange last) asPlainString.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980693!
clickAndHalfAt: localEventPosition

	self selectWordOrDelimitedTextAt: localEventPosition.

	doWordSelection := true.
	doParagraphSelection := false.
	initialSelectionStart := self startBlock.
	initialSelectionStop := self stopBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980087!
defaultFont
	^defaultFont! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980122!
replaceSelectionWith: aTextOrString
	"Deselect, and replace the selection text by aText."
	"This is a user command, and generates undo"

	| start stop replacement |

	morph disablesEditing ifTrue: [
		^ self ].

	start := self startIndex.
	stop := self stopIndex.
	(aTextOrString isEmpty and: [stop > start]) ifTrue: [
		"If deleting, then set emphasisHere from 1st character of the deletion"
		emphasisHere := (model actualContents attributesAt: start) select: [:att |
			att mayBeExtended]].

	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [
		replacement := self addAttributesForPasting: aTextOrString.
		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.
		textComposition
			recomposeFrom: start
			to:  start + replacement size - 1
			delta: replacement size - (stop-start).
		self deselectAndPlaceCursorAt: start + replacement size.
		self userHasEdited  " -- note text now dirty" ].

	morph possiblyChanged! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981116!
blinkParenAt: parenLocation

	model privateAddBoldAt: parenLocation.
	lastParenLocation := parenLocation! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981588!
storeSelectionInComposition
	"for proper display of selected text"

	pointBlock ifNil: [ ^self ].
	textComposition
		selectionStartBlock: self startBlock
		selectionStopBlock: self stopBlock.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980268!
stopBlock
	^ pointBlock max: markBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980458!
chooseColor
	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"

	| |
	"(ColorPickerMorph new)
		choseModalityFromPreference;
		sourceHand: morph activeHand;
		target: (attribute := TextColor color: Color black);
		selector: #color:;
		originalColor: Color black;
		putUpFor: morph near: morph morphFullBoundsInWorld.
	^attribute"! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980965!
correctFrom: start to: stop with: aString
	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."
	"This is a user command, and generates undo"
	| userSelection delta loc str |
	aString = '#insert period' ifTrue: [
		loc := start.
		str := self privateCurrentString.
		[(loc := loc-1)>0 and: [(str at: loc) isSeparator]]
			whileTrue: [loc := loc-1].
		^ self correctFrom: loc+1 to: loc with: '.'].
	userSelection := self selectionInterval.

	self selectInvisiblyFrom: start to: stop.
	self replaceSelectionWith: aString.

	delta := aString size - (stop - start + 1).
	self
		selectInvisiblyFrom: userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])
		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ])
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981573!
shouldDeleteAWordForward: aKeyboardEvent

	^ aKeyboardEvent isDelete and: [
		aKeyboardEvent rawMacOptionKeyPressed or: [
			aKeyboardEvent controlKeyPressed ] ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980668!
save: aKeyboardEvent
	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw"

	self acceptContents.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980644!
offerColorMenu: aKeyboardEvent 
	"The user typed the command key that requests a font change; Offer the color menu."

	self offerColorMenu.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981682!
offerUndoHistory
	| index labels current |
	current := model undoRedoCommandsPosition.
	labels := model undoRedoCommands withIndexCollect: [ :each :i | 
		(i = current ifTrue: [ '<on>' ] ifFalse: [ '<off>' ]), each printString ].
	labels isEmpty ifFalse: [
		index := (PopUpMenu
			labelArray: labels
			lines: #()) startUpMenu.
		index = current ifTrue: [ ^self ].
		index = 0 ifTrue: [ ^self ].
		index < current
			ifTrue: [ current - index timesRepeat: [ self undo ]]
			ifFalse: [ index - current timesRepeat: [ self redo ]]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980118!
pointBlock
	^pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981097!
setSearchString: aKeyboardEvent
	"Establish the current selection as the current search string."

	| aString |
	self lineSelectAndEmptyCheck: [^ true].
	aString :=  self selectedString.
	aString isEmpty
		ifTrue: [ self flash ]
		ifFalse: [ self setSearch: aString ].
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981028 overrides: 50579241!
selectLine
	"Make the receiver's selection, encompass the current line."

	self selectInterval: (model actualContents encompassLine: self selectionInterval)! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980913!
openHelp
	"Show help screen"
	TextModel new contents: self help; openLabel: self name, ' Help'.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980090!
defaultFont: aFont
	defaultFont := aFont! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980324!
offerFontMenu
	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	"This is a user command, and generates undo"

	| currentFont attr startIndex |
	startIndex := self startIndex.
	currentFont := model actualContents fontAt: startIndex default: defaultFont.
	(FontFamily promptUser: currentFont familyName) ifNotNil: [ :fontFamily |
		attr := TextFontFamily familyName: fontFamily familyName.
		self applyAttribute: attr.
		morph updateFromTextComposition ].! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981860!
resetState
	"Establish the initial conditions for editing the paragraph: place text cursor 
	before first character and set the emphasis to that of the first character"

	markBlock := textComposition defaultCharacterBlock.
	pointBlock := markBlock.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 50506876!
balloonTypeInfoAt: mouseInTextPosition

	^''! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980154!
selectionRectangle
	"Answer a rectangle that encompasses selection.
	If no selection, answer a rectangle that includes cursor."
	^ markBlock quickMerge: pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981525 overrides: 50579266!
privateCurrentString
	"Answer the string I'm editing. Private. Just for internal Editor use."

	^model actualContents string! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980197 overrides: 50579340!
hasSelection
	^ markBlock ~= pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980958!
afterSelectionInsertAndSelect: aString
	"This is a user command, and generates undo"

	self insertAndSelect: aString at: self stopIndex ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981206!
setEmphasisHereFromText

	self setEmphasisHereFromTextForward: true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980235!
selectedString

	^self selection string! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981488!
isDisjointFrom: anInterval
	"Answer true if anInterval is empty and not touching or within the current
	 interval, or if anInterval is a not empty but it does not overlap the current
	 selection."

	| fudge |
	fudge := anInterval size = 0 ifTrue: [1] ifFalse: [0].
	^(anInterval last + fudge < self startIndex or:
			[anInterval first - fudge >= self stopIndex])
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981036!
selectWordOrDelimitedTextAt: localEventPosition
	"Select delimited text or word--the result of double-clicking."

	| hitCharacterBlock range |
	hitCharacterBlock := textComposition characterBlockIncludingPoint: localEventPosition.
	range := self
		delimitedRangeAt: hitCharacterBlock stringIndex
		hitOnRightHalf: localEventPosition x  > hitCharacterBlock center x
		leftDelimiters: '([{<'
		rightDelimiters: ')]}>'
		simpleDelimiters: '|''"`'.
	self selectFrom: range first to: range last.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980688!
undo: aKeyboardEvent 
	"Undo the last edit."

	self undo.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16980173!
text
	"The returned object should be treated as read-only, and never modified"
	^ model actualContents! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981514!
pageHeight
	| howManyLines visibleHeight totalHeight ratio |
	howManyLines := textComposition numberOfLines.
	visibleHeight := self visibleHeight.
	totalHeight := self totalTextHeight.
	ratio := visibleHeight / totalHeight.
	^(ratio * howManyLines) rounded - 2! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981963 overrides: 50579460!
initializeShortcuts
	
	super initializeShortcuts.
	shortcuts at: 9 + 1 put: #tabKey:.! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982005!
openTextEditor

	^ SystemWindow editText: TextModel new label: 'Text Editor' wrap: true! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981982 overrides: 50579543!
releaseClassCachedState

	FindText := nil.
	ChangeText := nil.
	"We are not calling super to avoid cleansing class vars many times.
	So, repeat inherited class instVars!!"
	shortcuts := nil.
	cmdShortcuts := nil! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981893 overrides: 50579557!
basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	self flag: #definesKeyboardShortcuts.
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$s 	#save:					'Save')
		#(		$f 	#find:					'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:					'Open this help')
		#(		$j 	#setSearchString:					'Set selection as search string for find again')

		#(		$z 	#undo:					'Undo (multiple levels)')
		#(		$x 	#cut:					'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:					'Copy selection to the Clipboard')
		#(		$v 	#paste:					'Paste Clipboard contents')

		#(		$U	#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:					'Move cursor to start of text')

		#(		$Z	#redo:					'Redo (multiple levels)')
		#(		$C	#compareToClipboard:		'Compare argument to clipboard')
	)! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981943 overrides: 50579570!
cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	self flag: #definesKeyboardShortcuts.
	^#(
		#(		$0 	changeEmphasis:			'Normal')
		#(		$1 	changeEmphasis:			'Bold')
		#(		$2 	changeEmphasis:			'Italic')
		#(		$3 	changeEmphasis:			'Underline')
		#(		$4 	changeEmphasis:			'Strikeout')
		#(		$5 	changeEmphasis:			'Superscript')
		#(		$6 	changeEmphasis:			'Subscript')
		#(		$8	#offerColorMenu:		'Change color')

		#(		$u	#align:				'Toggle alignment')

		#(		$k	#offerFontMenu:			'Set font')
	)! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981977!
findText
	FindText ifNil: [
		FindText := Text new ].
	^FindText! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981972!
changeText
	ChangeText ifNil: [
		ChangeText := Text new ].
	^ChangeText! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981992!
worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		10.
			#label 			->			'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16981968!
openHelp

	self new openHelp! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982526!
isTextEmpty
	^actualContents isEmpty! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982481!
contents: aTextOrString
	"Does not update any view...
	The kind of stuff that needs to be cleaned some day..."
	self basicActualContents: aTextOrString! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982774!
convertAndStyleIfNeededWith: anSHTextStyler

	anSHTextStyler ifNotNil: [
		(self shouldStyle: self actualContents with: anSHTextStyler) ifTrue: [
			self styleByParagraphs
				ifTrue: [ self convertAndStyleIByParagraphsWith: anSHTextStyler ]
				ifFalse: [ 	self convertAndStyleAllWith: anSHTextStyler ]	]]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982592!
logUndoAndAddAttribute: aTextAttribute from: requestedStart to: requestedStop
	"As requested."

	| command |
	command := actualContents commandForAddAttribute: aTextAttribute from: requestedStart to: requestedStop.
	undoRedoCommands
		nextPut: command;
		truncateAtPosition.	"To disable redo of previous commands, now invalidated."
	command doOn: self.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982534!
acceptContentsFrom: aTextModelMorph
	"Tell the owning window to save the contents if it supports that action.
	
	Also clear the user edits."
	
	aTextModelMorph owningWindow ifNotNil: [ :ow |
		ow hasSaveAs ifTrue: [ 
			ow forceSaveContents.
			self changed: #clearUserEdits ] ]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982844!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982502!
getSelection
	"Answer the model's selection interval."

	^ nil	"null selection"! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982837!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982719!
allowStylingWithEmphasis
	"Default for Smalltalk methods"

	^true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982494!
undoRedoCommands
	^undoRedoCommands contents! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982810!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	This is useful in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982522!
isDirty

	^undoRedoCommands position isZero not.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982552!
privateAddBoldAt: idx
	"Just for shout. No undo."

	actualContents 
		addAttribute: ShoutTextEmphasis bold
		from: idx
		to: idx! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982801!
textStylerClass
	^nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982704!
openLabel: aString 
	"Create a standard system view of the model, me, and open it."
	^SystemWindow editText: self label: aString wrap: true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982585!
commandForReplaceFrom: start to: stop with: replacement

	^ actualContents commandForReplaceFrom: start to: stop with: replacement! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982851!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982791!
fullPrintIt
	^true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982696 overrides: 16932297!
initialize
	"Initialize the state of the receiver with its default contents."

	undoRedoCommands := ReadWriteStream on: #().
	self basicActualContents: ''.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982462!
actualContents: aTextOrString
	self basicActualContents: aTextOrString.
	self changed: #actualContents! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982787!
editorClass
	^TextEditor! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982517 overrides: 16915189!
is: aSymbol
	^ aSymbol == #canSaveContents or: [ super is: aSymbol ]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982741!
convertAndStyleIByParagraphsWith: anSHTextStyler
	"Convert and style. Treat each paragraph (separated by an empty line) as a separate script.
	Useful for Workspaces, Inspectors, etc."
	| separator fragmentStart fragmentEnd done|

	actualContents := actualContents optimizedForMutationSpeed.	
	anSHTextStyler getReady.
	anSHTextStyler workspaceContents: actualContents.
	separator := String newLineString, String newLineString.
	fragmentStart := 1.
	done := false.
	[done] whileFalse: [
		fragmentEnd := actualContents
			indexOfSubCollection: separator
			startingAt: fragmentStart
			ifAbsent: [done := true. actualContents size].
		anSHTextStyler parseWorkspaceFrom: fragmentStart to: fragmentEnd.
		anSHTextStyler privateConvertAssignmentsOffset: fragmentStart-1.
		anSHTextStyler styleWorkspaceOffset: fragmentStart-1 allowEmphasis: self allowStylingWithEmphasis.
		fragmentStart := fragmentEnd+separator size ].
	self changed: #shoutStyled! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982711 overrides: 16779298!
postCopy
	super postCopy.
	actualContents := actualContents copy.
	undoRedoCommands := ReadWriteStream on: #().
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982607!
logUndoAndRemoveAttributes: textAttributes from: requestedStart to: requestedStop
	"As requested."

	| command |
	command := actualContents commandForRemoveAttributes: textAttributes from: requestedStart to: requestedStop.
	undoRedoCommands
		nextPut: command;
		truncateAtPosition.	"To disable redo of previous commands, now invalidated."
	command doOn: self.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982826!
classOfWorkspaceVarNamed: aName

	^ nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982514!
canBindVariables
	^ false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982690!
flushUndoRedoCommands

	undoRedoCommands := ReadWriteStream on: #().
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982468!
basicActualContents: aTextOrString
	"Do not throw events."
	| prevContents |
	prevContents := actualContents.
	actualContents := aTextOrString asText asUnicodeStringOrText.
	actualContents = prevContents ifFalse: [	"Compares only characters, not attributes"
		undoRedoCommands resetToStart.
		lastEditTimeStamp := nil ]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982668!
undoAndEvaluate: aTwoArgBlock
	| modelUpdated newCursorPos |
	modelUpdated := false.
	undoRedoCommands position > 0 ifTrue: [
		undoRedoCommands skipBack.
		newCursorPos := undoRedoCommands peek undoOn: self.
		modelUpdated := true ].
	aTwoArgBlock value: modelUpdated value: newCursorPos.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982489!
textSize
	actualContents ifNil: [ ^0 ].
	^actualContents size! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982559!
privateRemoveBoldAt: idx
	"Just for shout. No undo."

	actualContents 
		removeAttributes: { ShoutTextEmphasis bold }
		from: idx
		to: idx! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982622!
logUndoAndReplaceFrom: start to: stop with: replacement
	"As requested."

	| command now |
	"Time millisecondClockValue rolls over and is generally not adviced.
	But here, we don't care. A user edit doing during rollover would be split  in two, as if the user did a pause.
	Not a problem."
	
	now := Time millisecondClockValue.
	command := self commandForReplaceFrom: start to: stop with: replacement.
	(stop+1 = start and: [ lastEditTimeStamp notNil and: [ now - lastEditTimeStamp < 1000 and: [start = undoRedoCommands peekLast stopPosition] ]])
		ifTrue: [
			"Don't use the command we just built"
			undoRedoCommands peekLast appendToNew: replacement
			]
		ifFalse: [
			undoRedoCommands
				nextPut: command;
				truncateAtPosition.	"To disable redo of previous commands, now invalidated."
			].
	command doOn: self.
	lastEditTimeStamp := now! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982724!
autoCompleterClass
	^nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982663!
startNewUndoRedoCommand

	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982728!
convertAndStyleAllWith: anSHTextStyler
	"Convert and style all contents as a single method or script.
	Do it in a background process if too big."

	anSHTextStyler convertAndStyle: self actualContents allowBackgroundStyleProcess: true.
	self basicActualContents: anSHTextStyler convertedAndStyledText.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982498!
undoRedoCommandsPosition
	^undoRedoCommands position! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982507!
refetch
	"Nothing here. Answer true if actualContents was actually fetched."
	self basicActualContents: self actualContents.
	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982545!
saveOn: stream
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asPlainString.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982805!
shouldStyle: aText with: aSHTextStylerST80 
	
	^true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982651!
redoAndEvaluate: aTwoArgBlock
	| modelUpdated newCursorPos |
	modelUpdated := false.
	undoRedoCommands atEnd ifFalse: [
		newCursorPos := undoRedoCommands next doOn: self.
		modelUpdated := true ].
	aTwoArgBlock value: modelUpdated value: newCursorPos.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982822!
classOfThisContext

	^ MethodContext ! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982530!
wantsFrameAdornments
	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982795!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982576!
basicReplaceFrom: start to: stop with: replacement
	"As requested. Basic service used by Undo / Redo. Does not genertate undo."

	actualContents replaceFrom: start to: stop with: replacement! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982458!
actualContents
	^actualContents! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982830!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982566!
basicReplaceAttributesFrom: start to: stop with: replacement
	"As requested. Basic service used by Undo / Redo. Does not genertate undo."

	actualContents basicReplaceAttributesFrom: start to: stop with: replacement! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982681 overrides: 16914586!
convertToCurrentVersion: varDict refStream: smartRefStrm

	"Maybe old instances won't have this variable set."
	undoRedoCommands ifNil: [
		undoRedoCommands := ReadWriteStream on: #() ]! !
!TextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982873 overrides: 16916100!
windowColor
	^ Theme current textEditor! !
!TextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982868!
withText: aTextOrString
	^self new basicActualContents: aTextOrString! !
!TextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16982863!
openLabel: aString

	^self new openLabel: aString! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983543!
contentsSelection
	"Return the interval of text in the code pane to select when I set the pane's contents"

	^ nil  "null selection"! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983528!
acceptedContents
	^ Text
		initialFont: (Preferences at: #standardCodeFont)
		stringOrText: self acceptedStringOrText! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983534!
acceptedContentsChanged

	self changed: #acceptedContents! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983573 overrides: 16915686!
textStylerClassFor: textGetter
	^nil! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983577!
classOfThisContext

	^ MethodContext ! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983599!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983563 overrides: 16915680!
editorClassFor: textGetter
	^TextEditor! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983592!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983539!
acceptedStringOrText
	^self subclassResponsibility! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983581!
classOfWorkspaceVarNamed: aName

	^ nil! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983550!
methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983585!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983559 overrides: 16915674!
autoCompleterClassFor: textGetter
	^nil! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983567!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^false! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983613!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	False, for instance, in all code Browsers.
	True in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^true! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983606!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983690!
appendToNew: aStringOrText
	new := new, aStringOrText! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983652 overrides: 50584272!
undoOn: aTextModel
	"Undo the command, bringing the text model to the state it had prior to doing it.
	Answer a new position for the text cursor"

	aTextModel basicReplaceFrom: position to: position + new size-1 with: old.
	^position + old size! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983683!
old: oldStringOrText new: newStringOrText at: anInteger
	old := oldStringOrText.
	new := newStringOrText.
	position := anInteger! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983663 overrides: 16914834!
printOn: aStream
	old isEmpty ifTrue: [
		^aStream nextPutAll: 'typed: '; nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes].
	new isEmpty ifTrue: [
		^aStream nextPutAll: 'deleted: '; nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ].
	aStream
		nextPutAll: 'replaced: ';
		nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes;
		nextPutAll: ' with: ';
		nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983638!
stopPosition
	^position + new size.! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983642 overrides: 50584279!
doOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing.
	Answer a new position for the text cursor"

	aTextModel basicReplaceFrom: position to: position + old size-1 with: new.
	^position + new size! !
!TextReplaceCommand class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16983701!
old: oldStringOrText new: newStringOrText at: anInteger
	^self basicNew old: oldStringOrText new: newStringOrText at: anInteger! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989388 overrides: 16829104!
storeOn: aStream
	"Refer to the comment in Object|storeOn:."
	| noneYet |
	aStream nextPutAll: '(('.
	aStream nextPutAll: self class name.
	aStream nextPutAll: ' new)'.
	noneYet := true.
	self keysAndValuesDo: 
			[:each :val | 
			noneYet
				ifTrue: [noneYet := false]
				ifFalse: [aStream nextPut: $;].
			aStream 
				nextPutAll: ' at: ';
				store: each;
				nextPutAll: ' put: ';
				store: val].
	noneYet ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989292 overrides: 16828310!
add: aString

	self at: aString put: aString! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989285 overrides: 16913367!
at: aString put: aValue

	rootNode ifNil: [
		rootNode := TrieNode someKey: aString segmentStart: 1].
	^rootNode at: aString put: aValue characterIndex: 1! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989259!
at: aString ifAbsent: aBlock

	rootNode ifNil: [ ^aBlock value ].
	^ rootNode at: aString ifAbsent: aBlock characterIndex: 1! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989346!
keysDo: aBlock

	self keysAndValuesDo: [ :k :v | aBlock value: k ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989351!
valuesDo: aBlock

	self keysAndValuesDo: [ :k :v | aBlock value: v ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989274!
at: key ifPresent: aBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := self at: key ifAbsent: [^ nil].
	^ aBlock value: v! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989296 overrides: 16829183!
remove: aString ifAbsent: exceptionBlock
	"Consistent with Set"
	self at: aString ifPresent: [ :v |
		v = aString ifTrue: [
			self removeKey: aString ifAbsent: exceptionBlock ]]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989377 overrides: 16829426!
isEmpty
	^rootNode isNil! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989312!
removeKey: aString ifAbsent: aBlock
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| answer |
	rootNode ifNil: [ ^aBlock value ].
	answer := rootNode removeKey: aString ifAbsent: aBlock characterIndex: 1.
	rootNode isEmpty ifTrue: [
		rootNode := nil ].
	^answer! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989304!
removeKey: aString 
	"Remove key from the receiver.
	If key is not in the receiver, notify an error."

	^ self removeKey: aString ifAbsent: [ self errorKeyNotFound: aString ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989356 overrides: 16829369!
includes: aString
	"Consistent with Set, but not with Dictionary,  as in Dictionary, #includes:
	finds a value regardless of the key. To get this behavior, use #includesValue:"

	aString isString ifFalse: [ ^ false ].
	self at: aString ifPresent: [ :v | ^v = aString ].
	^false! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989265!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock value]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989327 overrides: 16828787!
do: aBlock
	"Consistent both with Set (#add:) and Dictionary (#at:put:) protocols."
	self valuesDo: aBlock! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989333!
forPrefix: aString keysAndValuesDo: twoArgBlock

	rootNode ifNotNil: [
		rootNode forPrefix: aString keysAndValuesDo: twoArgBlock characterIndex: 1]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989371!
includesValue: anObject
	"Similar to Dictionary>>#includes:"
	self do: [:each | anObject = each ifTrue: [^true]].
	^false! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989380!
errorKeyNotFound: key

	self error: (
		String streamContents: [ :strm |
			strm nextPutAll: 	'key: '.
			key printOn: strm.
			strm nextPutAll: ' not found' ])! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989253 overrides: 16913349!
at: key 
	"Answer the value associated with the key."

	^ self at: key ifAbsent: [ self errorKeyNotFound: key ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989340!
keysAndValuesDo: twoArgBlock

	rootNode ifNotNil: [
		rootNode keysAndValuesDo: twoArgBlock ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989367!
includesKey: key
	
	self at: key ifAbsent: [^false].
	^true! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989415!
at: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys isArray ifTrue: [
		keyIndex := keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock value ]
			ifFalse: [ values at: keyIndex ]].
	keys = aString ifTrue: [ ^ values ].
	^ aBlock value! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989428!
at: aString put: aValue characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys ifNil: [
		keys := aString.
		values := aValue.
		^aValue ].
	keys isArray ifFalse: [
		keys = aString
			ifFalse: [
				keys := {keys. aString }.
				values := {values. aValue}]
			ifTrue: [ values := aValue ].
		^ aValue ].
	keyIndex := keys indexOf: aString.
	keyIndex = 0
		ifTrue: [
			keys := keys copyWith: aString.
			values := values copyWith: aValue ]
		ifFalse: [ values at: keyIndex put: aValue ].
	^ aValue! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989448!
removeKey: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex answer |
	keys isArray ifTrue: [
		keyIndex := keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock value ]
			ifFalse: [
				answer := values at: keyIndex.
				keys size = 2
					ifTrue: [
						keys := keys at: 3-keyIndex.
						values := values at: 3-keyIndex ]
					ifFalse: [
						keys := (keys copyFrom: 1 to: keyIndex-1), (keys copyFrom: keyIndex+1 to: keys size).
						values := (values copyFrom: 1 to: keyIndex-1), (values copyFrom: keyIndex+1 to: values size) ].
				answer]].
	keys = aString ifTrue: [
		answer := values.
		keys := nil.
		values := nil.
		^ answer ].
	^ aBlock value! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989481!
isEmpty
	^keys isNil! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989474!
keysAndValuesDo: twoArgBlock

	keys isArray
		ifTrue: [ keys with: values do: twoArgBlock ]
		ifFalse: [ twoArgBlock value: keys value: values ]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989507!
at: aString put: aValue characterIndex: i

	| child |
	childrenFirstChars ifNotNil: [
		self splitIfNeededFor: aString characterIndex: i ].
	child := self childFor: aString characterIndex: i orAdd: true.
	^child at: aString put: aValue characterIndex: i + segmentSize! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989566!
childFor1: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil.
	This method for the case where we currently have exactly one child."
	| nextSegmentStart nextSegmentFirst answer |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	childrenFirstChars = nextSegmentFirst ifTrue: [ ^ children].

	doAdd ifFalse: [ ^ nil ].
	
	answer := nextSegmentStart > aString size
		ifTrue: [ TrieLeaf new ]
		ifFalse: [ TrieNode someKey: aString segmentStart: nextSegmentStart ].

	"Just one child, if adding, convert references to a collection"
	nextSegmentFirst < childrenFirstChars
		ifTrue: [
			children := {answer . children }.
			childrenFirstChars := Array with: nextSegmentFirst with: childrenFirstChars ]
		ifFalse: [
			children := {children . answer}.
			childrenFirstChars := Array with: childrenFirstChars with: nextSegmentFirst ].
	^answer! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989788!
setChildrenFirstChars: aString children: anArray
	"Private. To be called only from parent node"
	childrenFirstChars := aString.
	children := anArray.! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989725!
splitIfNeededFor: aString characterIndex: segmentStart
	"This method splits the self (the current node) into two nodes, such that the concatenation of their string segment equals our current string segment,
	and such that the string segment of the first node (i.e. us) equals or is a prefix of aString.
	If this latter condition is already met, do nothing."
	| oldSegmentStop newSegmentStop newNode |

	"Compute last index where both strings are equal"
	oldSegmentStop := segmentStart + segmentSize - 1.
	newSegmentStop := someKey commonPartWith: aString startAt: segmentStart stopAt: oldSegmentStop
		applying: [ :c | c asLowercase asUnaccented ].
			
	newSegmentStop = oldSegmentStop ifTrue: [
		"No need to split: our segment is already a prefix of aString"
		^self ].

	"Split node"
	newNode := TrieNode someKey: someKey setSegmentSize: oldSegmentStop - newSegmentStop.
	newNode setChildrenFirstChars: childrenFirstChars children: children.

	"As this is a split point, these will be turned into arrays soon, when the new node addition (that called us) is done."
	childrenFirstChars := (someKey at: newSegmentStop+1) asLowercase asUnaccented.
	children := newNode.
	"Update our segment"
	segmentSize := newSegmentStop - segmentStart + 1! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989497!
at: aString ifAbsent: aBlock characterIndex: i

	| child |
	child := self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock value ].
	^child at: aString ifAbsent: aBlock characterIndex: i + segmentSize! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989540!
forPrefix: aString keysAndValuesDo: twoArgBlock characterIndex: i

	i + segmentSize > aString size
		ifTrue: [
			self keysAndValuesDo: twoArgBlock ]
		ifFalse: [
			(self childFor: aString characterIndex: i orAdd: false)
				ifNotNil: [ :node |
					node
						forPrefix: aString
						keysAndValuesDo: twoArgBlock
						characterIndex: i + segmentSize ]]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989628!
childForN: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil.
	This method for the case where we currently have more than one child."
	| answer newChildren newFirstChars nextSegmentFirst nextSegmentStart s |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found | ^ children at: found ]
		ifNone: [ :a :b |
			"Already more than one child. If adding, convert to a bigger collection."
			doAdd
				ifFalse: [ ^nil]
				ifTrue: [
					 answer := nextSegmentStart > aString size
						ifTrue: [ TrieLeaf new ]
						ifFalse: [  TrieNode someKey: aString segmentStart: nextSegmentStart ].
					s := children size + 1.
					newChildren := Array new: s.
					newChildren
						replaceFrom: 1 to: a with: children startingAt: 1;
						at: a+1 put: answer;
						replaceFrom: a+2 to: s with: children startingAt: a+1.
					newFirstChars := Array new: s.
					newFirstChars
						replaceFrom: 1 to: a with: childrenFirstChars startingAt: 1;
						at: a+1 put: nextSegmentFirst;
						replaceFrom: a+2 to: s with: childrenFirstChars startingAt: a+1.
					children := newChildren.
					childrenFirstChars := newFirstChars.
					^answer ]]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989772!
getChildrenFirstChars
	"Private. To be called only from parent node"
	^childrenFirstChars! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989562!
isEmpty
	^childrenFirstChars isNil! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989604!
childFor: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."

	"No children yet"
	childrenFirstChars ifNil: [
		doAdd ifTrue: [
			children := TrieLeaf new.
			childrenFirstChars := TrieNode characterForLeaf ].
		^children ].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		^ self childFor1: aString characterIndex: i orAdd: doAdd ].

	"Already more than one child. If adding, convert to a bigger collection."
	^self childForN: aString characterIndex: i orAdd: doAdd! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989778!
getSegmentSize
	"Private. To be called only from parent node"
	^segmentSize! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989783!
getSomeKey
	"Private. To be called only from parent node"
	^someKey! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989680!
removeChildFor: aString characterIndex: i
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."
	| nextSegmentStart nextSegmentFirst |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		childrenFirstChars = nextSegmentFirst
			ifTrue: [ childrenFirstChars := nil. children := nil ].
		^self ].
	
	"Already more than one child."
	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found |
			childrenFirstChars size = 2
				ifTrue: [		"Two children: remove the arrays"
					childrenFirstChars := childrenFirstChars at: 3-found.
					children := children at: 3-found ]
				ifFalse: [	"More than two children. condense the arrays"
					childrenFirstChars := (childrenFirstChars copyFrom: 1 to: found-1), 
						(childrenFirstChars copyFrom: found+1 to: childrenFirstChars size).
					children := (children copyFrom: 1 to: found-1), (children copyFrom: found+1 to: children size) ]]
		ifNone: [].! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989767!
getChildren
	"Private. To be called only from parent node"
	^children! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989796!
setSegmentSize: anInteger someKey: aString
	"Private. To be called only from parent node"
	segmentSize := anInteger.
	someKey := aString! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989554!
keysAndValuesDo: twoArgBlock

	children isArray ifFalse: [
		^children keysAndValuesDo: twoArgBlock ].

	children do: [ :child |
		child ifNotNil: [ child keysAndValuesDo: twoArgBlock ]]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989518!
removeKey: aString ifAbsent: aBlock characterIndex: i

	| child answer |
	child := self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock value ].
	answer := child removeKey: aString ifAbsent: aBlock characterIndex: i + segmentSize.
	child isEmpty ifTrue: [
		self removeChildFor: aString characterIndex: i.
		"If child is not needed anymore, compress the path"	
		children class == TrieNode ifTrue: [
			someKey := children getSomeKey.
			segmentSize := segmentSize + children getSegmentSize.
			childrenFirstChars := children getChildrenFirstChars.
			children := children getChildren ]].
	^answer! !
!TrieNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989816!
someKey: aString segmentStart: i
	^self new setSegmentSize: aString size - i + 1 someKey: aString! !
!TrieNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989808!
characterForLeaf
	"A special character to mean leaf node. Must have lower code than alphabetic chars,
	so in the trie 'car' comes before 'cars'"
	^Character numericValue: 0! !
!TrieNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 16989822!
someKey: aString setSegmentSize: s
	^self new setSegmentSize: s someKey: aString! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007320 overrides: 16913521!
bindingOf: aString
	mustDeclareVariables ifTrue: [^ nil].
	(bindings includesKey: aString) ifFalse: [
		aString first isUppercase
			ifTrue: [^nil]
			ifFalse: [bindings at: aString put: nil]].
	^bindings associationAt: aString! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007463!
classOfBindingOf: aName
												
	^ (self bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007316!
bindingNamesDo: aBlock

	bindings keysDo: aBlock! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007334!
hasBindingThatBeginsWith: aString 

	bindings keysDo: [ :each |
		(each beginsWith: aString) ifTrue: [ ^true ] ].
	^false! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007347!
mustDeclareVariableWording
	
	^ mustDeclareVariables not
		ifTrue: ['<yes> automatically create variable declaration']
		ifFalse: ['<no> automatically create variable declaration']! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007356!
nameForObject: object
	"Answer a name suitable for a Workspace variable"
	^ (object class name, object identityHash printString) asIdentifier: false! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007341!
initializeBindings
	
	bindings := Dictionary new.
	self changed: #actualContents.
! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007378!
shouldStyle

	^shouldStyle ifNil: [ Preferences at: #shoutInWorkspaces]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007393 overrides: 50586462!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	This is useful in Workspaces, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^true! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007435 overrides: 50586691!
autoCompleterClass
	^SmalltalkCompleter! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007489!
methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007364!
toggleVariableDeclarationMode

	mustDeclareVariables := mustDeclareVariables not! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007426 overrides: 50586451!
allowStylingWithEmphasis
	"Disabled by default for faster styling of large contents, as text metrics are not affected by styling."

	^ Preferences at: #stylingWithEmphasisInWorkspaces! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007448 overrides: 50586488!
textStylerClass
	^SHTextStylerST80! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007443 overrides: 50586515!
fullPrintIt

	^fullPrintIt ifNil: [ Preferences at: #fullPrintItInWorkspaces]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007369 overrides: 50586492!
openLabel: aString 
	"Create a standard system view of the model, me, and open it."
	| window |
	window := WorkspaceWindow editText: self label: aString wrap: true.
	self changed: #actualContents.
	^window! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007474 overrides: 50586508!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForClassOrNil: (self classOfBindingOf: aName) ! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007419 overrides: 50586520!
initialize
	
	super initialize.
	self initializeBindings.
	mustDeclareVariables := false.
	fullPrintIt := false.! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007439 overrides: 50586535!
editorClass
	^SmalltalkEditor! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007330!
hasBindingOf: aString
	^bindings includesKey: aString! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007484 overrides: 50586540!
is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007412!
toggleStylingLabel

	^self shouldStyle 
		ifTrue: [ '<on> syntax highlighting' ]
		ifFalse: [ '<off> syntax highlighting' ]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007383 overrides: 50586733!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text."

	self shouldStyle ifFalse: [ ^false ].
	anSHTextStyler 
		classOrMetaClass: nil;
		workspace: self.
	^true! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007452!
toggleFullPrintIt

	fullPrintIt := self fullPrintIt not.! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007469 overrides: 50586604!
classOfWorkspaceVarNamed: aName
												
	^ self classOfBindingOf: aName ! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007405!
toggleStyling

	shouldStyle := self shouldStyle not.
	actualContents := actualContents asPlainString asText.
	self changed: #actualContents! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007481 overrides: 50586609!
canBindVariables
	^ true! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007457!
toggleFullPrintItLabel

	^self fullPrintIt 
		ifTrue: [ '<on> full printIt' ]
		ifFalse: [ '<off> full printIt' ]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 50504269!
selectedClassOrMetaClass
	
	^UndefinedObject ! !
!Workspace class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007521!
openWorkspace
	^self new
		contents: '';
		openLabel: 'Workspace'.
! !
!Workspace class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007503 overrides: 50586809!
windowColor
	^ Theme current workspace! !
!Workspace class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:12:08' prior: 17007507!
worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		20.
			#label 			->			'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!SmalltalkEditor methodsFor: '*LiveTypingGenerics' stamp: 'AC 8/6/2023 20:53:55' prior: 50581479!
balloonTypeInfoOfInstanceVariableAt: mousePositionInText

	| instVarName typeInfo types |
	
	instVarName := (self wordUnder: mousePositionInText) asString.
	"typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^'']."
	types := self codeProvider selectedClass 
				liveTypesOfInstanceVariableNamed: instVarName 
				storingGenericsInfoIn: (LiveTyping getGenericsStorage) 
				ifAbsent: [`EmptyType new`].
	typeInfo := InstanceVariableTypeInfo of: instVarName in: self codeProvider selectedClass are: types asArray.
	^typeInfo printTypesUpTo: 5! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577065 overrides: 16782889!
is: aSymbol
	^ aSymbol == #ArrayOfCharactersAndCodePoints or: [ super is: aSymbol ]! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577072!
encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left := (self lastIndexOf: `Character newLineCharacter` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr := (self indexOf: `Character newLineCharacter` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).
	rightNull := (self indexOf: `Character null` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	^left to: (rightCr min: rightNull)! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577101!
encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left := (self lastIndexOf: `Character newLineCharacter` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr := (self indexOf: `Character newLineCharacter` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	rightNull := (self indexOf: `Character null` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	^left to: (rightCr min: rightNull)! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577129 overrides: 16947448!
asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	^UnicodeString newFrom: self! !
!ArrayOfCharactersAndCodePoints methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577137 overrides: 16913349!
at: index
	"Full compatibility with String"
	^(super at: index) ifNil: [ `Character null` ].! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577145 overrides: 16914834!
printOn: aStream
	aStream
		nextPutAll: 'replaced attributes'! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577151!
old: oldAttributes new: newAttributes start: startIndex stop: stopIndex
	old := oldAttributes.
	new := newAttributes.
	start := startIndex.
	stop := stopIndex! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577161 overrides: 50584272!
undoOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing"

	aTextModel basicReplaceAttributesFrom: start to: stop with: old.
	^nil! !
!AttributesReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577171 overrides: 50584279!
doOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing"

	aTextModel basicReplaceAttributesFrom: start to: stop with: new.
	^nil! !
!AttributesReplaceCommand class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577180!
old: oldAttributes new: newAttributes start: startIndex stop: stopIndex
	^self basicNew old: oldAttributes new: newAttributes start: startIndex stop: stopIndex! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577189!
didCodeChangeElsewhere
	"Determine whether the code for the currently selected method and class has been changed somewhere else."

	| aClass aSelector aCompiledMethod |
	currentCompiledMethod ifNil: [^ false].
	(aClass := self selectedClassOrMetaClass) ifNil: [^ false].
	(aSelector := self selectedMessageName) ifNil: [^ false].

	aSelector == #Comment ifTrue:
		[^ currentCompiledMethod ~~ aClass organization commentRemoteStr].
	^ ((aCompiledMethod := aClass compiledMethodAt: aSelector ifAbsent: [^ false]) ~~ currentCompiledMethod)
		and: [aCompiledMethod last ~= 0 "either not yet installed"
				or: [currentCompiledMethod last = 0 "or these methods don't have source pointers"]]
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577214!
annotationForSystemCategory: aCategory
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'System Category: ';
			nextPutAll: aCategory.
		(Preferences at: #systemCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#classCount] -> [
					strm
						print: (SystemOrganization fullListAtCategoryNamed: aCategory) size;
						nextPutAll: ' classes' ].
				[#instanceMethodsCount] -> [
					strm
						print: (SystemOrganization instanceMethodCountOf: aCategory);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (SystemOrganization classMethodCountOf: aCategory);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (SystemOrganization linesOfCodeOf: aCategory);
						nextPutAll: ' total lines of code' ].
				[#messageSendsCount] -> [
					strm
						print: (SystemOrganization messageSendsCountOf: aCategory);
						nextPutAll: ' total message sends' ].
			}]].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577254 overrides: 50586840!
acceptedContentsChanged

	self changed: #acceptedContents.
	self triggerEvent: #decorateButtons.
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577262!
showingAnyKindOfDiffs
	"Answer whether the receiver is currently set to show any kind of diffs"

	^ #(lineDiffs prettyLineDiffs wordDiffs prettyWordDiffs) includes: self contentsSymbol! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577271!
showingLineDiffs
	"Answer whether the receiver is showing regular diffs of source code"

	^ self contentsSymbol == #lineDiffs
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577279!
togglePlainSource
	"Toggle whether plain source shown in the code pane"
	self showingPlainSource
		ifTrue: [
			self contentsSymbol: #documentation]
		ifFalse: [
			self contentsSymbol: #source]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577289!
timeStamp
	"Answer the time stamp for the chosen class and method, if any, else an empty string"

	|  selector  |
	(selector := self selectedMessageName) ifNotNil: [
		^self selectedClassOrMetaClass 
			ifNil: [
				String new]
			ifNotNil: [
				self selectedClassOrMetaClass stampAt: selector]].
	^ String new! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577302!
showingPrettyWordDiffsString
	"Answer a string representing whether I'm showing pretty diffs"

	^ self showingPrettyWordDiffs asMenuItemTextPrefix,
		'wordPrettyDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577312 overrides: 50586917!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	False, for instance, in all code Browsers.
	True in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577326!
sourceAndDiffsQuintsOnly
	"Answer a list of quintuplets representing information on the alternative views available in the code pane for the case where the only plausible choices are showing source or either of the two kinds of diffs"

	^ #(
(source				togglePlainSource 			showingPlainSourceString
														'source'			'the textual source code as writen')
(lineDiffs				toggleLineDiffing			showingLineDiffsString
														'lineDiffs'			'the textual source diffed from its prior version')
(wordDiffs			toggleWordDiffing			showingWordDiffsString
														'wordDiffs'			'the textual source words diffed from its prior version')
(prettyLineDiffs		togglePrettyLineDiffing	showingPrettyLineDiffsString
														'linePrettyDiffs'		'formatted source diffed from formatted prior version')
(prettyWordDiffs	togglePrettyWordDiffing	showingPrettyWordDiffsString
														'linePrettyDiffs'		'formatted source words diffed from prior version')
	)! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577360!
showingWordDiffs
	"Answer whether the receiver is showing regular diffs (alternative algorithm) of source code"

	^ self contentsSymbol == #wordDiffs
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577368!
selectedClass
	^ nil! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577372!
sourceStringPrettifiedAndDiffed
	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"
	| class selector sourceString |
	class := self selectedClassOrMetaClass.
	selector := self selectedMessageName.
	(class isNil or: [ selector isNil ]) ifTrue: [ ^ 'missing' ].
	sourceString := class
		ultimateSourceCodeAt: selector
		ifAbsent: [ ^ 'error' ].
	(self showingPrettyPrint or: [ self showingAnyKindOfPrettyDiffs ]) ifTrue: [
		sourceString := class compilerClass new
			format: sourceString
			in: class
			notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		sourceString := self diffFromPriorSourceFor: sourceString ].
	^ sourceString! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577398!
priorSourceOrNil
	"If the currently-selected method has a previous version, return its source, else return nil"
	| aClass aSelector  changeRecords |
	(aClass := self selectedClassOrMetaClass) ifNil: [^ nil].
	(aSelector := self selectedMessageName) ifNil: [^ nil].
	changeRecords := aClass changeRecordsAt: aSelector.
	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].
	^ (changeRecords at: 2) string 
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577415!
typeCheckMethod
		
	| typeChecker |
	typeChecker := self currentCompiledMethod typeCheck.
	typeChecker showResultsWith:  typeChecker method classAndSelector 
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577424!
addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream
	"add an annotation detailing the prior versions count"
	| versionsCount |

	versionsCount := VersionsBrowser versionCountForSelector: aSelector class: aClass.
	aStream nextPutAll: 
				((versionsCount > 1
					ifTrue:
						[versionsCount = 2 ifTrue:
							['1 prior version']
							ifFalse:
								[versionsCount printString, ' prior versions']]
					ifFalse:
						['no prior versions']))! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577442!
toggleDecompile
	"Toggle the setting of the showingDecompile flag, unless there are unsubmitted edits that the user declines to discard"

	self showDecompile: self showingDecompile not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577451!
toggleLineDiffing
	"Toggle whether regular-diffing should be shown in the code pane"

	self showLineDiffs: self showingLineDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577459!
toggleDiffing
	"Toggle whether diffs should be shown in the code pane.  If any kind of diffs were being shown, stop showing diffs.  If no kind of diffs were being shown, start showing whatever kind of diffs are called for by default."

	self showDiffs: self showingAnyKindOfDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577472!
hierarchyBrowser
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |
	(selectedClassOrMetaClass := self selectedClassOrMetaClass)
		ifNil: [^ nil].
	newBrowser := HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.
	((aSymbol := self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])
		ifTrue: [
			aBehavior := selectedClassOrMetaClass.
			messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.
			messageCatIndex = 0 ifFalse: [
				newBrowser messageCategoryListIndex: messageCatIndex + 1.
				newBrowser messageListIndex:
					((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol) ]].
	^newBrowser! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577501!
showingPlainSourceString
	"Answer a string telling whether the receiver is showing plain source"

	^ self showingPlainSource asMenuItemTextPrefix,
		'source'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577510!
showingDecompileString
	"Answer a string characerizing whether decompilation is showing"

	^ self showingDecompile asMenuItemTextPrefix,
		'decompile'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577518!
defaultDiffsSymbol
	"Answer the code symbol to use when generically switching to diffing"

	^ (Preferences at: #diffsWithPrettyPrint)
		ifTrue: [
			#prettyLineDiffs]
		ifFalse: [
			#lineDiffs]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577528!
togglePrettyLineDiffing
	"Toggle whether pretty-diffing should be shown in the code pane"

	self showPrettyLineDiffs: self showingPrettyLineDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577536!
selectedBytecodes
	"Answer text to show in a code pane when in showing-byte-codes mode"

	^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName ifAbsent: [^ '' asText]) symbolic asText! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577546!
showDiffs: aBoolean
	"Set whether I'm showing diffs as indicated; use the global preference to determine which kind of diffs to institute."

	self showingAnyKindOfDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: self defaultDiffsSymbol]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577560!
contentsSymbol: aSymbol
	"Set the contentsSymbol as indicated.  #source means to show source code, #comment means to show the first comment found in the source code"

	contentsSymbol := aSymbol.
	self acceptedContentsChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577571 overrides: 50586905!
autoCompleterClassFor: textGetter
	currentCompiledMethod ifNotNil: [ :cm |
		^cm compilerClass autoCompleterClass ].
	^SmalltalkCompleter! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577579!
selectedClassOrMetaClass

	^ self selectedClass	"I don't know any better"! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577585!
shouldDiffWords
	"Answer whether the receiver is currently set to use the word based differ"

	^ #(wordDiffs prettyWordDiffs) includes: self contentsSymbol! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577594!
currentMethodRefactored

	self acceptedContentsChanged
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577599!
inspectCompiledMethod
	"Open an Inspector on the CompiledMethod itself"

	self selectedMessageName ifNotNil: [
		(self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)
			inspect ]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577609!
annotationForClassCommentFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the clas comment of the given class."

	| aStamp nonMeta |
	aStamp :=  (nonMeta := aClass theNonMetaClass) organization commentStamp.
	^ aStamp
		ifNil:
			[nonMeta name, ' has no class comment']
		ifNotNil:
			['class comment for ', nonMeta name,
				(aStamp = '<historical>'
					ifFalse:
						[' - ', aStamp]
					ifTrue:
						[''])]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577627!
showingSource
	"Answer whether the receiver is currently showing source code"

	^ self contentsSymbol == #source
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577634!
showDecompile: aBoolean
	"Set the decompile toggle as indicated"

	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#decompile])! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577642!
revertToPreviousVersion
	"Revert to the previous version of the current method"
	| aClass aSelector  changeRecords |
	aClass := self selectedClassOrMetaClass.
	aClass ifNil: [^ self changed: #flash].
	aSelector := self selectedMessageName.
	changeRecords := aClass changeRecordsAt: aSelector.
	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Smalltalk beep].
	changeRecords second fileIn.
	self acceptedContentsChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577660!
showingLineDiffsString
	"Answer a string representing whether I'm showing regular diffs"

	^ self showingLineDiffs asMenuItemTextPrefix,
		'lineDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577668!
updateIfNeeded
	self didCodeChangeElsewhere
		ifTrue: [
			self acceptedContentsChanged]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577674!
resetMethodTypes
	
	self currentCompiledMethod initializeTypeInformation.
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577680!
contentsSymbol
	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"

	^ contentsSymbol ifNil: [
		contentsSymbol := (Preferences at: #browseWithPrettyPrint)
					ifTrue:
						[#prettyPrint]
					ifFalse:
						[#source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577696!
okayToAccept
	"Answer whether it is okay to accept the receiver's input"

	self showingByteCodes ifTrue: [
		self inform: 
'Sorry, you can only submit changes here 
when you are showing source.'.
		^ false].

	self showingDocumentation ifTrue: [
		self inform: 
'Sorry, you can only submit changes here 
when you are showing source.'.
		^ false].

	self showingAnyKindOfDiffs ifTrue: [
		^ SelectionMenu confirm: 
'Caution!!  You are "showing diffs" here, so 
there is a danger that some of the text in the
code pane is contaminated by the "diff" display'
		trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider' icons: #(acceptIcon cancelIcon)
	].

	^ true! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577721!
currentCompiledMethod
	^currentCompiledMethod! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577726!
removeClass
	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."

	| message  className classToRemove result |
	classToRemove := self selectedClassOrMetaClass ifNil: [Smalltalk beep. ^ false].
	classToRemove := classToRemove theNonMetaClass.
	className := classToRemove name.
	message := 'Are you certain that you
want to REMOVE the class ', className, '
from the system?'.
	(result := self confirm: message)
		ifTrue: [
			classToRemove subclasses notEmpty
				ifTrue: [(self confirm: 'class has subclasses: ' , message)
					ifFalse: [^ false]].
			classToRemove removeFromSystem.
			self changed: #classList.
			true].
	^ result! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577754!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer false if showing difs, to veto the styling."
	
	^self showingAnyKindOfDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577764!
showDocumentation: aBoolean
	"Set the showDocumentation toggle as indicated"

	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#documentation])! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577773!
categoryFromUserWithPrompt: aPrompt for: aClass
	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"

	^(MethodCategoriesPrompter 
		staringFrom: aClass 
		rejectingFirst: false) prompt: aPrompt ifNone: [ nil ]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577784 overrides: 50586864!
editorClassFor: textGetter
	(#(acceptedContents classCommentText) statePointsTo: textGetter) ifFalse: [
		^super editorClassFor: textGetter ].
	currentCompiledMethod ifNotNil: [ :cm |
		^cm compilerClass editorClass ].
	^SmalltalkEditor! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577795!
commentContents
	"documentation for the selected method"

	| poss aClass aSelector |
	^ (poss := (aClass := self selectedClassOrMetaClass)
						ifNil:
							['----']
						ifNotNil:
							[(aSelector := self selectedMessageName)
								ifNil:
									['---']
								ifNotNil:
									[(aClass precodeCommentOrInheritedCommentFor: aSelector)", String crString, String crString, self timeStamp"
"which however misses comments that are between the temps  declaration and the body of the method; those are picked up by [aClass commentOrInheritedCommentFor: aSelector] but that method will get false positives from comments *anywhere* in the method source"]])
		isEmptyOrNil
			ifTrue:
				[aSelector
					ifNotNil:
						[((aClass methodHeaderFor: aSelector), '

Has no comment') ]
					ifNil:
						['Hamna']]
			ifFalse:	[aSelector
				ifNotNil: [((aClass methodHeaderFor: aSelector), '

', poss) ]
				ifNil: [poss]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577828!
showLineDiffs: aBoolean
	"Set whether I'm showing regular diffs as indicated"

	self showingLineDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #lineDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577839!
isThereAnOverride
	"Answer whether any subclass of my selected class implements my 
	selected selector"
	| aName aClass |
	aName := self selectedMessageName
				ifNil: [^ false].
	aClass := self selectedClassOrMetaClass ifNil: [ ^ false ].
	aClass allSubclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].
	^ false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577853!
annotationSeparator
	"Answer the separator to be used between annotations"

	^ ' ° '! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577859!
unusedMethods
	| classes unsent messageList cls |

	(cls := self selectedClass) ifNil: [^ nil].
	classes := Array with: cls with: cls class.
	unsent := Set new.
	classes do: [:c | unsent addAll: c selectors].
	unsent := Smalltalk allUnSentMessagesIn: unsent.
	messageList := OrderedCollection new.
	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asArray sort
					do: [:sel | messageList add: 
						(MethodReference class: c selector: sel) ]].
	^messageList! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577878!
canShowMultipleMessageCategories
	"Answer whether the receiver is capable of showing multiple message categories"

	^ false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577886!
togglePrettyPrint
	"Toggle whether pretty-print is in effectin the code pane"

	self showingPrettyPrint
		ifTrue: [
			self contentsSymbol: #source]
		ifFalse: [
			self contentsSymbol: #prettyPrint]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577897 overrides: 50586846!
textStylerClassFor: textGetter
	textGetter = #acceptedContents ifFalse: [
		^super textStylerClassFor: textGetter ].
	currentCompiledMethod ifNotNil: [ :cm |
		^cm compilerClass textStylerClass ].
	^SHTextStylerST80! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577907!
prettyPrintString
	"Answer whether the receiver is showing pretty-print"

	^ self showingPrettyPrint asMenuItemTextPrefix,
		'prettyPrint'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577915!
methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577921 overrides: 50586887!
methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ self selectedClassOrMetaClass methodNodeFor: aSourceCode ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577931!
showByteCodes: aBoolean
	"Get into or out of bytecode-showoing mode"

	aBoolean
		ifTrue: [
			self contentsSymbol: #byteCodes]
		ifFalse: [
			self contentsSymbol == #byteCodes ifTrue: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577942!
isModeStyleable
	"determine if Shout can style in the current mode"
	^ self showingSource or: [self showingPrettyPrint or: [self showingDecompile]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577950!
letUserReclassify: anElement in: aClass
	"Put up a list of categories and solicit one from the user.  
	Answer true if user indeed made a change, else false"
	

	| currentCat newCat |
	currentCat := aClass organization categoryOfElement: anElement.
	newCat := self 
				categoryFromUserWithPrompt: 'choose category (currently "', currentCat, '")' 
				for: aClass.
	(newCat notNil and: [newCat ~= currentCat])
		ifTrue: [
			aClass organization classify: anElement under: newCat suppressIfDefault: false.
			^ true]
		ifFalse: [
			^ false]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577971!
showWordDiffs: aBoolean
	"Set whether I'm showing regular diffs as indicated"

	self showingWordDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #wordDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50577982!
annotationForMessageCategory: aCategory ofClass: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."
	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Message Category: ';
			nextPutAll: aCategory.
		(Preferences at: #messageCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#messagesCount] -> [
					strm
						print: (aClass messagesCountInCategory: aCategory);
						nextPutAll: ' total messages' ].
				[#messageSendsCount] -> [
					strm
						print: (aClass messageSendsCountInCategory: aCategory);
						nextPutAll: ' total message sends' ].
			}]].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578009 overrides: 16914636!
releaseCachedState
	"Can always be found again.  Don't write on a file."
	currentCompiledMethod := nil.! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578017 overrides: 16915189!
is: aSymbol
	^ aSymbol == #CodeProvider or: [ super is: aSymbol ]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578023!
annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name.
		(Preferences at: #classAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#instanceMethodsCount] -> [
					strm
						print: (aClass theNonMetaClass selectors size);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (aClass theMetaClass selectors size);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (aClass theNonMetaClass linesOfCode);
						nextPutAll: ' total lines of code' ].
				[#messageSendsCount] -> [
					strm
						print: (aClass theNonMetaClass messageSendsCount);
						nextPutAll: ' total message sends' ].
			}]].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578056!
showingByteCodesString
	"Answer whether the receiver is showing bytecodes"

	^ self showingByteCodes asMenuItemTextPrefix,
		'byteCodes'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578064!
categoryOfCurrentMethod
	"Answer the category that owns the current method.  If unable to determine a category, answer nil."

	^ self selectedClassOrMetaClass ifNotNil: [ :cls | 
		self selectedMessageName ifNotNil: [ :sel |
			cls whichCategoryIncludesSelector: sel]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578076!
copySelector
	"Copy the selected selector to the clipboard"

	| selector |
	(selector := self selectedMessageName) ifNotNil: [
		Clipboard storeObject: selector asPlainString]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578085!
toggleShowingByteCodes
	"Toggle whether the receiver is showing bytecodes"

	self showByteCodes: self showingByteCodes not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578093!
annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578237!
showingWordDiffsString
	"Answer a string representing whether I'm showing regular diffs"

	^ self showingWordDiffs asMenuItemTextPrefix,
		'wordDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578245!
showPrettyWordDiffs: aBoolean
	"Set whether I'm showing pretty diffs as indicated"

	self showingPrettyWordDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #prettyWordDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578257!
selectedMessageName

	^ nil! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578262!
isThisAnOverride
	"Answer whether any superclass of my selected class implements my selected selector"
	| aName aClass |
	aName := self selectedMessageName ifNil: [^ false].
	aClass := self selectedClassOrMetaClass ifNil: [^false ].
	aClass allSuperclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].
	^ false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578276!
showingDecompile
	"Answer whether the receiver should show decompile rather than, say, source code"

	^ self contentsSymbol == #decompile
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578284!
showingDocumentationString
	"Answer a string characerizing whether documentation is showing"

	^ self showingDocumentation asMenuItemTextPrefix,
		'documentation'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578293!
showingPrettyLineDiffsString
	"Answer a string representing whether I'm showing pretty diffs"

	^ self showingPrettyLineDiffs asMenuItemTextPrefix,
		'linePrettyDiffs'! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578302!
fileOutMessage
	"Put a description of the selected message on a file"

	self selectedMessageName ifNotNil: [
		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578311!
annotation
	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."

	|  aSelector aClass |

	((aSelector := self selectedMessageName) == nil or: [(aClass := self selectedClassOrMetaClass) == nil])
		ifTrue: [^ ''].
	^ self annotationForSelector: aSelector ofClass: aClass! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578326!
showingByteCodes
	"Answer whether the receiver is showing bytecodes"

	^ self contentsSymbol == #byteCodes! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578333!
showingPrettyLineDiffs
	"Answer whether the receiver is showing pretty diffs of source code"

	^ self contentsSymbol == #prettyLineDiffs! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578341!
contentsSymbolQuints
	"Answer a list of quintuplets representing information on the alternative views available in the code pane
		first element:	the contentsSymbol used
		second element:	the selector to call when this item is chosen.
		third element:	the selector to call to obtain the wording of the menu item.
		fourth element:	the wording to represent this view
		fifth element:	balloon help
	A hypen indicates a need for a seperator line in a menu of such choices"

	^ #(
(source				togglePlainSource 			showingPlainSourceString
														'source'			'the textual source code as writen')
(documentation		toggleShowDocumentation showingDocumentationString
														'documentation'	'the first comment in the method')
-
(prettyPrint			togglePrettyPrint 			prettyPrintString
														'prettyPrint'			'the method source presented in a standard text format')
-
(lineDiffs				toggleLineDiffing			showingLineDiffsString
														'lineDiffs'			'the textual source lines diffed from its prior version')
(wordDiffs			toggleWordDiffing			showingWordDiffsString
														'wordDiffs'			'the textual source words diffed from its prior version')
(prettyLineDiffs		togglePrettyLineDiffing	showingPrettyLineDiffsString
														'prettyLineDiffs'		'formatted source lines diffed from formatted prior version')
(prettyWordDiffs	togglePrettyWordDiffing	showingPrettyWordDiffsString
														'prettyWordDiffs'	'formatted source words diffed from prior version')
-
(decompile			toggleDecompile			showingDecompileString
														'decompile'			'source code decompiled from byteCodes')
(byteCodes			toggleShowingByteCodes	showingByteCodesString
														'byteCodes'		'the bytecodes that comprise the compiled method')
	)! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578399!
showingPlainSource
	"Answer whether the receiver is showing plain source"

	^ self contentsSymbol == #source! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578406!
diffFromPriorSourceFor: sourceCode 
	"If there is a prior version of source for the selected method, return a diff, else just return the source code"

	^ self priorSourceOrNil
		ifNil: [ sourceCode ]
		ifNotNil: [ :prior |
			DifferenceFinder
				displayPatchFrom: prior to: sourceCode
				tryWords: self shouldDiffWords
				prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [self selectedClass])]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578422!
selectedMessage
	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."

	| class selector method |

	self showingDecompile ifTrue: [
		^ self decompiledSource ].

	class := self selectedClassOrMetaClass.
	(class isNil or: [(selector := self selectedMessageName) isNil]) ifTrue: [^ ''].
	method := class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"
	currentCompiledMethod := method.

	^ (self showComment
		ifFalse: [self sourceStringPrettifiedAndDiffed]
		ifTrue:	[ self commentContents])
			copy! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578451!
toggleWordDiffing
	"Toggle whether regular-diffing should be shown in the code pane"

	self showWordDiffs: self showingWordDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578459!
showComment
	"Answer whether the receiver should show documentation rather than, say, source code"

	^ self contentsSymbol == #documentation
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578467!
togglePrettyWordDiffing
	"Toggle whether pretty-diffing should be shown in the code pane"

	self showPrettyWordDiffs: self showingPrettyWordDiffs not! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578475!
showingPrettyWordDiffs
	"Answer whether the receiver is showing pretty diffs of source code"

	^ self contentsSymbol == #prettyWordDiffs
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578483!
selectedMessageCategoryName
	"Answer the name of the message category of the message of the currently selected context."

	^ self selectedClass organization categoryOfElement: self selectedMessageName! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578493!
showingDocumentation
	"Answer whether the receiver should show documentation rather than, say, source code"

	^ self contentsSymbol == #documentation
! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578501!
showingPrettyPrint
	"Answer whether the receiver is showing pretty-print"

	^ self contentsSymbol == #prettyPrint! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578508!
showingAnyKindOfPrettyDiffs
	"Answer whether the receiver is currently set to show any kind of pretty diffs"

	^ #(prettyLineDiffs prettyWordDiffs) includes: self contentsSymbol! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578517!
isEditingMethod

	^false! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578522 overrides: 50586877!
acceptedStringOrText
	"Answer the source code or documentation for the selected method"

	self showingByteCodes ifTrue: [
		^ self selectedBytecodes].

	self showingDocumentation ifTrue: [
		^ self commentContents].

	^ self selectedMessage! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578533!
showPrettyLineDiffs: aBoolean
	"Set whether I'm showing pretty diffs as indicated"

	self showingPrettyLineDiffs
		ifFalse: [
			aBoolean ifTrue: [
				self contentsSymbol: #prettyLineDiffs]]
		ifTrue: [
			aBoolean ifFalse: [
				self contentsSymbol: #source]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578545!
decompiledSource
	"Obtain a source string by decompiling the method's code.
	Also return the string."
	| class selector method answer |
	class := self selectedClassOrMetaClass.
	selector := self selectedMessageName.
	"Was method deleted while in another project?"
	method := class
		compiledMethodAt: selector
		ifAbsent: [ ^ '' ].
	currentCompiledMethod := method.
	"decompile without temp names "
	answer := (class decompilerClass new
		decompile: selector
		in: class
		method: method) decompileString.
	^ answer copy! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578565!
doItContext
	"Answer the context in which a text selection can be evaluated."

	^nil! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578571!
changeCategory
	"Present a menu of the categories of messages for the current class, 
	and let the user choose a new category for the current message"

	self selectedClassOrMetaClass ifNotNil: [ :cls |
		self selectedMessageName ifNotNil: [ :sel |
			(self letUserReclassify: sel in: cls) ifTrue: [
				self methodCategoryChanged]]]! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578585!
toggleShowDocumentation
	"Toggle the setting of the showingDocumentation flag, unless there are unsubmitted edits that the user declines to discard"

	self showDocumentation: self showingDocumentation not! !
!CodeProvider class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578595!
normalizeCodeForCodeFiles: aTextOrString
	"Adapt edited code to be suitable or logging.
	Answer is a plain text.
	Additionally, if code was modified for better look and edition experience, normalize it.
	This may include reverting to ':=' for assignment, '^' for return, and any replacements of
	ASCII by Unicode symbols done by Shout.
	See also SHTextStylerST80 >> #privateConvert
	See also Clipboard >> #storeObject:"

	| answer |
	answer := aTextOrString asPlainString.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString, UnicodeCodePoint zeroWidthSpace asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkUpArrow asString` with: '^'.
	^answer! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578623!
help
	^self class help! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578627!
selectWord
	"Select exactly one word.
	See also #selectWordOrDelimitedText"

	| wordRange |
	wordRange := self wordRangeIncluding: self pointIndex.
	self selectFrom: wordRange first to: wordRange last! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578637!
morph
	^ morph! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578641!
moveCursor: directionBlock forward: forward event: aKeyboardEvent
	"Private - Move cursor.
	directionBlock is a one argument Block that computes the new Position from a given one."
	| shift indices newPosition |
	shift := aKeyboardEvent notNil and: [aKeyboardEvent shiftPressed].
	indices := self
		setIndices: shift
		forward: forward.
	newPosition := directionBlock value: (indices at: #moving).
	shift
		ifTrue: [
			self
				selectMark: (indices at: #fixed)
				point: newPosition - 1 ]
		ifFalse: [ self deselectAndPlaceCursorAt: newPosition ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578662!
offerMenuFromEsc: aKeyboardEvent
	"The escape key was hit while the receiver has the keyboard focus; take action"

	^ aKeyboardEvent shiftPressed ifFalse: [
		morph mouseButton2Activity ]; not! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578672!
pointIndex

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578677!
pasteString
	"Paste the text's string from the shared buffer over the current selection and 
	redisplay if necessary.
	Pasting a string means using destination current attributes if appropriate."

	self replaceSelectionWith: self clipboardStringOrText asPlainString! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578689!
selectMark: mark point: point
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse: [
		self selectInvisiblyMark: mark point: point ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578700!
enter: aKeyboardEvent
	"Enter / return key was pressed"
	"Process the various Enter / Return keystrokes"
	"Not sure if this is ever called"
	
	^self returnKey: aKeyboardEvent! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578709!
beginningOfNextParagraph: position
	| s |
	s := self privateCurrentString.
	^ (s
		indexOf: Character newLineCharacter
		startingAt: position
		ifAbsent: [ s size ])
			+ 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578718!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this.
	
	Do not push down this method. It is used in SimpleEditor of package Widgets-Extras
	"

	"if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [
		self selectLine ].
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^ returnBlock value ].! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578741!
cursorTopHome: aKeyboardEvent
	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."

	self deselectAndPlaceCursorAt: 1.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578750!
normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |
	"Convert strings like '\+161 ' (š) to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		string at: index :: = $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			key size > 2 and: [ key at: 1 :: = $+ ] ::
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := UnicodeCodePoint codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsability to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) = $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `UnicodeCodePoint codePoint: 16r300` ] -> [ '`' ].
				[ `UnicodeCodePoint codePoint: 16r301` ] -> [ '''' ].
				[ `UnicodeCodePoint codePoint: 16r302` ] -> [ '^' ].
				[ `UnicodeCodePoint codePoint: 16r303` ] -> [ '~' ].
				[ `UnicodeCodePoint codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578808!
selectInterval: anInterval
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	self selectFrom: anInterval first to: anInterval last! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578817!
beginningOfParagraph: position
	| s |
	s := self privateCurrentString.
	^ (s
		lastIndexOf: Character newLineCharacter
		startingAt: (position-1 min: s size)
		ifAbsent: [ 0 ])
			+ 1.! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578826!
cursorPageUp: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo - self pageHeight]
				forward: false]
		forward: false
		event: aKeyboardEvent.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578836!
paste: aKeyboardEvent 
	"Replace the current text selection by the text in the shared buffer."

	self paste.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578843!
cursorUp: aKeyboardEvent 
	"Private - Move cursor from position in current line to same position in
	prior line. If prior line too short, put at end"

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line - 1] forward: false.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [
						newPos := self beginningOfParagraph: newPos-1 ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self beginningOfText ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578868!
markIndex

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578873!
userHasEdited
	"Note that my text is not free of user edits."

	morph hasUnacceptedEdits: true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578879!
endOfParagraph: position
	| s |
	s := self privateCurrentString.
	^ s
		indexOf: Character newLineCharacter
		startingAt: position
		ifAbsent: [ s size + 1 ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578887!
selectionIsEmptyOrSeparators
	"Answer true if no selection or selection is just separators (whitespace)"

	self subclassResponsibility! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578895!
beginningOfText
	^1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578899!
selectAll: aKeyboardEvent 
	"select everything, invoked by cmd-a.  1/17/96 sw"

	self selectAll.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578906!
paste
	"Paste the text from the shared buffer over the current selection and 
	redisplay if necessary."

	self replaceSelectionWith: self clipboardStringOrText! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578914!
sameColumn: start newLine: lineBlock forward: isForward
	"See comment in other implementors."
	self subclassResponsibility! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578921!
selectionInterval
	"Answer the interval that is currently selected."

	^self startIndex to: self stopIndex - 1 ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578928!
endOfText
	^self privateCurrentString size + 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578933!
nextWordStartFrom: aPosition goingForwards: goingForwardsBoolean
	
	"Answer the position of the start of the next word on the current line going
	forwards (or backwards).
	If the given position is the end (or beginning) of the line then answer the
	beginning (or end) of the next (or previous) line."
	
	| string beginningOfLine endOfLine step offset index newPosition |
	
	string := self privateCurrentString.
	beginningOfLine := self beginningOfLine: aPosition.
	endOfLine := self endOfLine: aPosition.
	step := goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	offset := goingForwardsBoolean ifTrue: [0] ifFalse: [-1].
	
	index := aPosition.
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers]]
			whileTrue: [index := index + step].
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers not]]
			whileTrue: [index := index + step].
	
	newPosition := index = aPosition ifTrue: [index + step] ifFalse: [index].
	^newPosition min: string size + 1 max: 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578970!
cut: aKeyboardEvent 
	"Cut out the current text selection."

	self cut.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578976!
cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^self class cmdShortcuts! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578984!
beginningOfLine: position
	"Redefined in subclasses using TextComposition"
	^ self beginningOfParagraph: position! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50578991!
cursorLeft: aKeyboardEvent
	"Private - Move cursor left one character if nothing selected, otherwise move cursor to beginning of selection. If the shift key is down, start selecting or extending current selection.
	Don't allow cursor past beginning of text"

	self
		moveCursor: [ :position | | newPos |
			newPos := position - 1.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ newPos := self previousWordStart: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self beginningOfLine: position ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579017!
delimitedRangeAt: index hitOnRightHalf: hitOnRightHalfOfDelimiter leftDelimiters: leftDelimiters rightDelimiters: rightDelimiters simpleDelimiters: simpleDelimiters
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter finalDelimiter direction leftMatch rightMatch simpleMatch includeDelimiters level string hitOnRightHalf here hereChar start stop sSize |
	string := self privateCurrentString.
	sSize := string size.
	sSize < 2 ifTrue: [^1 to: 1].
	hitOnRightHalf := hitOnRightHalfOfDelimiter.
	here := index min: sSize max: 2.
	((string at: here) isLineSeparator and: [ here > 2 ]) ifTrue: [
		here := here - 1.
		hitOnRightHalf := true ].
	initialDelimiter := string at: here.
	leftMatch := leftDelimiters indexOf: initialDelimiter.
	rightMatch := rightDelimiters indexOf: initialDelimiter.
	simpleMatch := simpleDelimiters  indexOf: initialDelimiter.
	leftMatch + rightMatch + simpleMatch = 0 ifTrue: [
		"no delimiters, then just select word."
		^self wordRangeIncluding: index ].

	(simpleMatch > 0 & hitOnRightHalf or: [leftMatch > 0])
		ifTrue: [	"Hit on right half of simple delimiter or is a left delimiter -- match to the right"
			start := here.
			direction := 1 ]
		ifFalse: [ 	"Hit on left half of simple delimiter or is a right delimiter-- match to the left"
			stop := here.
			direction :=  -1 ].
	
	simpleMatch > 0
		ifTrue: [
			finalDelimiter := initialDelimiter.
			includeDelimiters := false ]
		ifFalse: [
			leftMatch > 0
				ifTrue: [
					finalDelimiter := rightDelimiters at: leftMatch.
					includeDelimiters := hitOnRightHalf not ]
				ifFalse: [
					finalDelimiter := leftDelimiters at: rightMatch.
					includeDelimiters := hitOnRightHalf ]].

	level := 1.
	[ level > 0 and: [ direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			here := here + direction.
			hereChar := string at: here.
			"delimiter match just counts nesting level"
			hereChar = finalDelimiter
				ifTrue: [level := level - 1"leaving nest"]
				ifFalse: [
					hereChar = initialDelimiter 
						ifTrue: [level := level + 1"entering deeper nest" ]]].
	level > 0 ifTrue: [
		"If we failed to find final delimiter, then just select word."
		^self wordRangeIncluding: index ].
	direction > 0
		ifTrue: [ stop := here ]
		ifFalse: [ start := here ].
	^includeDelimiters
		ifTrue: [ start to: stop ]
		ifFalse: [ start+1 to: stop-1 ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579095!
selectInvisiblyMark: mark point: point
	"Select the designated characters, inclusive.  Make no visual changes."

	self markIndex: mark pointIndex: point + 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579103!
clipboardTextPut: textOrString

	^ Clipboard storeObject: textOrString! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579109!
wordRangeIncluding: aPositionInText
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter direction level string here hereChar start sSize |
	string := self privateCurrentString.
	sSize := string size.
	sSize < 2 ifTrue: [^1 to: 1].
	here := aPositionInText min: sSize max: 2.
	initialDelimiter := string at: here.
	"no delimiters -- select a token"
	direction := -1.
	level := 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar := string at: (here := here + direction).
			"token scan goes left, then right"
			hereChar isValidInIdentifiers 	"Consider $: as a word separator"
				ifTrue: [
					here = 1
						ifTrue: [
							start := 1.
							"go right if hit string start"
							direction := 1]]
				ifFalse: [
					direction < 0
						ifTrue: [
							start := here + 1.
							"go right if hit non-token"
							direction := 1]
						ifFalse: [level := 0]]].
	level > 0 ifTrue: [
		here := here + direction ].
	"If a word ends with $: (a keyword), consider it part of the word"
	hereChar = $: ifTrue: [here := here + 1].
	^start to: here - 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579148!
codeCoverageInfoAt: mousePositionInText 
	
	^ [
		(morph owningWindow model isKindOf: CodeCoverageAnalyzerBrowser)
			ifTrue: [ morph owningWindow model codeCoverageInfoAt: mousePositionInText ]
			ifFalse: [ '' ] ]
		on: Error do: [ '' ] ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579159!
selectWord: aKeyboardEvent

	self selectWord.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579164!
copySelection: aKeyboardEvent
	"Copy the current text selection."

	self copySelection.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579170!
cursorPageDown: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo + self pageHeight]
				forward: true]
		forward: true
		event: aKeyboardEvent.
	^true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579180!
newLine: aKeyboardEvent

	self addString: (UnicodeString with: Character newLineCharacter).
	^false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579187!
setIndices: shiftPressed forward: forward
	"Little helper method that sets the moving and fixed indices according to some flags."
	| indices |
	indices := Dictionary new.
	(shiftPressed and:[Preferences at: #selectionsMayShrink])
		ifTrue: [
			indices at: #moving put: self pointIndex.
			indices at: #fixed put: self markIndex
		] ifFalse: [
			forward
				ifTrue:[
					indices at: #moving put: self stopIndex.
					indices at: #fixed put: self startIndex.
				] ifFalse: [
					indices at: #moving put: self startIndex.
					indices at: #fixed put: self stopIndex.
				]
		].
	^indices! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579209!
wordSelectAndEmptyCheck: returnBlock
	"Ensure selecting the entire current word; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectWord.  "Select exactly a whole word"
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^ returnBlock value ].! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579225!
selectAll

	self selectFrom: 1 to: self privateCurrentString size! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579231!
deselectAndPlaceCursorAt: characterIndex 
	"Deselect, then place the text cursor before the character at characterIndex.
	 Be sure it is in view."

	self selectFrom: characterIndex to: characterIndex - 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579241!
selectLine

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579246!
selectInvisiblyFrom: start to: stop
	"Select the designated characters, inclusive.  Make no visual changes."

	self markIndex: start pointIndex: stop + 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579254!
previousWordStart: aPosition
	
	^self nextWordEndFrom: aPosition goingForwards: false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579260!
nextWordEnd: aPosition
	
	^self nextWordEndFrom: aPosition goingForwards: true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579266!
privateCurrentString

	self subclassResponsibility! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579271!
cursorDown: aKeyboardEvent
	"Private - Move cursor from position in current line to same position in
	next line. If next line too short, put at end. If shift key down,
	select."

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line + 1 ] forward: true.
			"Mac standard keystroke"
			aKeyboardEvent rawMacOptionKeyPressed ifTrue: [
				newPos := self endOfParagraph: position+1 ].
			"Windows / Linux standard keystroke"
			aKeyboardEvent controlKeyPressed ifTrue: [
				newPos := self beginningOfNextParagraph: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self endOfText ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579298!
backspace: aKeyboardEvent
	"Backspace over the last character."
	"This is a user command, and generates undo"

	| startIndex |
	(aKeyboardEvent rawMacOptionKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [ ^ self backWord: aKeyboardEvent ].
	startIndex := self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).
	startIndex := 1 max: startIndex - 1.
	self backTo: startIndex.
	^ false! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579314!
cursorRight: aKeyboardEvent 
	"Private - Move cursor right one character if nothing selected, otherwise move cursor to end of selection. If the shift key is down, start selecting characters or extending already selected characters. 
	Don't allow cursor past end of text"

	self
		moveCursor: [ :position | | newPos |
			newPos := position + 1.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ newPos := self nextWordEnd: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self endOfLine: position ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579340!
hasSelection

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579345!
clipboardStringOrText

	| clipContents |
	clipContents := Clipboard retrieveStringOrText.
	^ ((clipContents is: #Text) and: [ clipContents respondsTo: #asNonStyledText ])
		ifTrue: [ clipContents asNonStyledText ]
		ifFalse: [ clipContents ]! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579356!
nextWordStart: aPosition
	
	^self nextWordStartFrom: aPosition goingForwards: true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579362!
noop: aKeyboardEvent 
	"Unimplemented keyboard command; just ignore it."

	^ true! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579368!
nextWordEndFrom: aPosition goingForwards: goingForwardsBoolean
	
	"Answer the position of the end of the next word on the current line going
	forwards (or backwards).
	If the given position is the end (or beginning) of the line then answer the
	beginning (or end) of the next (or previous) line."
	
	| string beginningOfLine endOfLine step offset index newPosition |
	
	string := self privateCurrentString.
	beginningOfLine := self beginningOfLine: aPosition.
	endOfLine := self endOfLine: aPosition.
	step := goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	offset := goingForwardsBoolean ifTrue: [0] ifFalse: [-1].
	
	index := aPosition.
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers not]]
			whileTrue: [index := index + step].
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers]]
			whileTrue: [index := index + step].
	
	newPosition := index = aPosition ifTrue: [index + step] ifFalse: [index].
	^newPosition min: string size + 1 max: 1! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579405!
currentAttributes
	"Redefined by subclasses that handle TextAttributes"
	^nil! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579411!
shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	^self class shortcuts! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579419!
endOfLine: position
	"Redefined in subclasses using TextComposition"
	^self endOfParagraph: position! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579426!
returnKey: aKeyboardEvent
	"Return / Enter / key was pressed"
	"Process the various Return / Enter keystrokes"
	
	morph acceptOnCR ifTrue: [
		^ true].
	aKeyboardEvent commandAltKeyPressed ifTrue: [
		(aKeyboardEvent controlKeyPressed | aKeyboardEvent rawMacOptionKeyPressed) ifTrue: [
			self addString: UnicodeString crString.
			^false ].
		self addString: UnicodeString crlfString.
		^false ].
	^ self newLine: aKeyboardEvent! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579443!
startIndex

	self subclassResponsibility ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579448!
morph: aMorph
	"Install a link back to the morph being edited (esp for text links)"
	morph := aMorph ! !
!Editor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579455!
stopIndex

	self subclassResponsibility ! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579460!
initializeShortcuts
	"Initialize the table for regular (i.e. non-command) keystroke dispatch"
	"
	self initializeShortcuts
	"
	| actions |
	actions := Array new: 256 withAll: #normalCharacter:.
	0 to: 31 do: [ :i | actions at: i+1 put: #noop: ].
	actions at: 1 + 1 put: #cursorHome:.				"home key"
	actions at: 3 + 1 put: #enter:.						"enter / return key"
	actions at: 4 + 1 put: #cursorEnd:.				"end key"
	actions at: 5 + 1 put: #noop:.						"insert key"
	actions at: 8 + 1 put: #backspace:.				"macDelete winBackspace key"
	actions at: 9 + 1 put: #normalCharacter:.		"tab"
	actions at: 11 + 1 put: #cursorPageUp:.			"page up key"
	actions at: 12 + 1 put: #cursorPageDown:.		"page down key"
	actions
		at:  InputSensor returnKey + 1
		put: #returnKey:.									"return (sometimes labelled enter) key"
	actions at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"
	actions at: 28 + 1 put: #cursorLeft:.				"left arrow key"
	actions at: 29 + 1 put: #cursorRight:.				"right arrow key"
	actions at: 30 + 1 put: #cursorUp:.				"up arrow key"
	actions at: 31 + 1 put: #cursorDown:.			"down arrow key"
	actions at: 127 + 1 put: #forwardDelete:.		"winDelete key"
	shortcuts := actions! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579500!
help
	"
	TextEditor help edit
	SmalltalkEditor help edit
	"
	^ (self formatShortcutsUsingModifierKey: 'Shift' andSpecs: self allShiftShortcutsSpec) ,
		(self formatShortcutsUsingModifierKey: 'Cmd' andSpecs: self allCmdShortcutsSpec).
! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579512 overrides: 16916096!
initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c basicInitialize ]! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579518!
collectCmdShortcutsSpecUsing: anInitializationMessage

	| shortcutsSpec dynamicInitializationMessage |
	
	shortcutsSpec := self perform: anInitializationMessage.

	dynamicInitializationMessage := (self name asPlainString uncapitalized, anInitializationMessage asPlainString capitalized) asSymbol.
	(Smalltalk allClassesImplementing: dynamicInitializationMessage) do: [ :aClass | 
		shortcutsSpec := shortcutsSpec, (aClass soleInstance perform: dynamicInitializationMessage) ].

	^shortcutsSpec

! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579537!
allShiftShortcutsSpec

	^ self shiftShortcutsSpec! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579543 overrides: 16789356!
releaseClassCachedState

	shortcuts := nil.
	cmdShortcuts := nil.! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579549!
allCmdShortcutsSpec

	^ (self collectCmdShortcutsSpecUsing: #basicCmdShortcutsSpec), (self collectCmdShortcutsSpecUsing: #cmdShortcutsSpec)! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579557!
basicCmdShortcutsSpec

	^#()! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579562!
shiftShortcutsSpec
	"Only for help. See senders."

	^#(
		#(		'Enter' 	#globalFindClass: 'Global Find class name or fragment')
	)! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579570!
cmdShortcutsSpec

	^#()! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579574!
putIntoCmdShortcuts: shortcutsSpec

	shortcutsSpec do: [ :ary | | i previous |
		i := ary first numericValue + 1.
		previous := cmdShortcuts at: i.
		previous = #noop:
			ifTrue: [
				cmdShortcuts at: i put: ary second ]
			ifFalse: [ 
				('Editor shortcut: ', ary first printString, ' already taken for: ', previous, 
				'. Override request for: ', ary second, '  ignored') print ]].! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579590!
basicInitialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c initializeShortcuts; initializeCmdShortcuts ]! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579598!
initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table.
	If you want to add a new shortcut for an specific editor, for example SmalltalkEditor, you should
	define the message #smalltalkEditorCmdShortcutsSpec in a class of your category and it will
	be dynamically send"

	"NOTE: if you don't know what your keyboard generates, use Sensor test"

	"
	Editor initialize
	"

	cmdShortcuts := Array new: 256 withAll: #noop:.

	self putIntoCmdShortcuts: self allCmdShortcutsSpec
! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579618!
formatShortcutsUsingModifierKey: aModifierKey andSpecs: aSpecs
	"Format shortcuts specs with a modifier key"
	^ String streamContents: [ :strm |
		aSpecs do: [ :triplet | | c |
			c := triplet first = Character space
				ifFalse: [ triplet first asString, '   	' ]
				ifTrue: [ 'Space'].
			strm nextPutAll: (aModifierKey, '-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579634!
shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	
	shortcuts ifNil: [ self initializeShortcuts ].
	
	^shortcuts! !
!Editor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579643!
cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	
	cmdShortcuts ifNil: [self initializeCmdShortcuts ].
	
	^cmdShortcuts! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579653!
createCategories

	| classCategories |
	
	categories := OrderedCollection with: 'new ...'.
	lines := OrderedCollection with: 1. 
	classCategories := startClass methodCategoriesAsSortedCollection.
	
	reject := classCategories asSet.
	reject
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	
	startClass isMeta ifTrue: [ self initializeCategoriesWhenMeta: classCategories].
	rejectingFirst ifFalse: [ categories addAll: classCategories ]! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579671!
initializeCategoriesWhenMeta: classCategories

	categories add: Categorizer instanceCreation.
	classCategories remove: Categorizer instanceCreation ifAbsent: [].
	reject add: Categorizer instanceCreation! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579681!
requestNewCategory
	
	^self request: 'New category name?' initialAnswer: 'category-name'! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579688!
initializeCategories
	
	self 
		createCategories;
		addCategories! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579694!
lines

	^lines ! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579699!
addCategories

	startClass allSuperclasses do: [ :superclass | self addCategoriesOf: superclass ]! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579706!
initializeStaringFrom: aClass rejectingFirst: aRejectingFirst

	startClass := aClass.
	rejectingFirst := aRejectingFirst.
	
	self initializeCategories ! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579715!
prompt: aPrompt ifNone: aNoneBlock

	| selectedCategoryIndex categoryName |
	
	selectedCategoryIndex := self promptCategory: aPrompt.
	selectedCategoryIndex = 0 ifTrue: [^ aNoneBlock value].
	
	categoryName := selectedCategoryIndex = 1 ifTrue: [ self requestNewCategory ] ifFalse: [ categories at: selectedCategoryIndex ].
	categoryName isEmpty ifTrue: [ ^aNoneBlock value ].
	
	^categoryName
	! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579731!
categories

	^categories! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579736!
promptCategory: aPrompt
	
	| selectedLabelIndex |
	
	selectedLabelIndex := categories size = 1 
		ifTrue: [ 1 ]
	 	ifFalse: [ (PopUpMenu labelArray: categories lines: lines) startUpWithCaption: aPrompt ].
	
	^selectedLabelIndex! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579747!
addCategoriesOf: aSuperclass

	| superclassCategories |
	
	superclassCategories := aSuperclass methodCategoriesAsSortedCollection reject: [ :category | reject includes: category].
	
	superclassCategories isEmpty ifFalse: [
		lines add: categories size.
		categories addAll: superclassCategories.
		reject addAll: superclassCategories]! !
!MethodCategoriesPrompter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579762!
staringFrom: aClass rejectingFirst: rejectingFirst 
	
	^self new initializeStaringFrom: aClass rejectingFirst: rejectingFirst 
! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579770 overrides: 16913521!
bindingOf: aString

	^textProvider bindingOf: aString! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579776!
textProvider
	^textProvider! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579781 overrides: 50586419!
acceptContentsFrom: aTextModelMorph
	textSetter ifNil: [ ^ true ].
	^ textSetter numArgs = 2
		ifTrue: [
			textProvider
				perform: textSetter
				with: actualContents
				with: aTextModelMorph ]
		ifFalse: [
			textProvider
				perform: textSetter
				with: actualContents ].! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579794 overrides: 50586431!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579803 overrides: 50586438!
getSelection
	"Answer the model's selection interval."

	^selectionGetter ifNotNil: [
		textProvider perform: selectionGetter ]! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579811 overrides: 50586444!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579820 overrides: 50586691!
autoCompleterClass
	^textProvider autoCompleterClassFor: textGetter! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579827 overrides: 50586462!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	This is useful in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^textProvider styleByParagraphs! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579842 overrides: 16915792!
update: aSymbol
	"We are being notified of a change in our provider.
	Notify our dependents"
	"
	self changed: aSymbol
	"
	aSymbol == textGetter ifTrue: [ ^self changed: #acceptedContents ].
	aSymbol == selectionGetter ifTrue: [ ^self changed: #initialSelection ].
	self changed: aSymbol! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579855!
initWith: aTextProvider
	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."

	textProvider := aTextProvider.
	undoRedoCommands := ReadWriteStream on: #().
	lastEditTimeStamp := nil! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579867 overrides: 50586488!
textStylerClass
	^textProvider textStylerClassFor: textGetter! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579873 overrides: 50586508!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579882 overrides: 50586535!
editorClass
	^textProvider editorClassFor: textGetter! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579888 overrides: 16914636!
releaseCachedState
	textProvider releaseCachedState! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579894 overrides: 50586540!
is: aSymbol
	^ aSymbol == #hasTextProvider or: [ super is: aSymbol ]! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579901 overrides: 50586718!
refetch
	"Answer true if actualContents was actually fetched."
	textGetter
		ifNil: [
			actualContents ifNil: [
				self actualContents: Text new ].
			^false ]
		ifNotNil: [
			self actualContents: (Text
				initialFont: (Preferences at: #standardCodeFont)
				stringOrText: (textProvider perform: textGetter)).
			self changed: #refetched.
			^true ]! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579916!
textGetter: symbol1 textSetter: symbol2 selectionGetter: symbol3
	textGetter := symbol1.
	textSetter := symbol2.
	selectionGetter := symbol3! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579925 overrides: 50586733!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	^textProvider shouldStyle: text with: anSHTextStyler! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579940 overrides: 50586750!
classOfThisContext

	^ textProvider classOfThisContext ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579946 overrides: 50586755!
wantsFrameAdornments

	^textSetter notNil! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579952 overrides: 50586759!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^textProvider shouldAutoHighlight! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579961 overrides: 50586604!
classOfWorkspaceVarNamed: aName

	^ textProvider classOfWorkspaceVarNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579968 overrides: 50586776!
actualContents
	actualContents ifNil: [ self refetch ].
	^actualContents! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579975 overrides: 50586781!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	textProvider computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName ! !
!PluggableTextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579983!
refusesToAccept
	^textProvider is: #refusingToAccept! !
!PluggableTextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579989!
on: aTextProvider
	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."
	^self basicNew initWith: aTextProvider! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50579999!
extractToTemporary

	self performCodeExtractionRefactoringWith: ExtractToTemporaryApplier! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580006!
actualLocalImplementorsOfIt: aKeyboardEvent

	self actualLocalImplementorsOfIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580012!
showSelectionTypeInfo

	self isEditingClassDefinition 
		ifTrue: [ self showTypeInfoOfInstanceVariable ]
		ifFalse: [ self showSelectionTypeInfoInMethod ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580021!
showTypeInfoOfInstanceVariable

	| instVarName typeInfo |
	
	instVarName := self wordUnderCursor asString.
	typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^morph flash].

	^(InstanceVariableTypesDisplay typeInfo: typeInfo) showTypes 
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580034!
changeSelectorOf: aMessageNode in: aSelectedClass at: aSelectedSelector using: aChangeSelectorApplier

	aChangeSelectorApplier
		on: aMessageNode
		createAndValueHandlingExceptionsOn: model textProvider
		in: aSelectedClass
		at: aSelectedSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580046!
moveInstanceVariable: aNodeUnderCursor in: aSelectedClass at: aMethodNode

	aNodeUnderCursor isTempOrArg ifTrue: [ ^morph flash ].

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		aNodeUnderCursor isInstanceVariableNode 
			ifTrue: [^self moveInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aSelectedClass ]
			ifFalse: [^morph flash]. ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580061!
argNext: aKeyboardEvent
	"Invoked by cmd-A.
	 Search forward from the end of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the end of the text.."

	| start t |
	t := model actualContents.
	start := t findString: ': ' startingAt: self startIndex.
	start = 0 ifTrue: [ start := t size + 1].
	self deselectAndPlaceCursorAt: start + 2.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580078!
selectForInspection: aNodeUnderCursor in: aMethodNode 
	
	(aNodeUnderCursor isLiteralNode or: [ aNodeUnderCursor isVariableNode ]) ifTrue: [ ^self selectNodeRange: aNodeUnderCursor in: aMethodNode ].
	aNodeUnderCursor isMessageNode ifTrue: [ ^self selectMessageNode: aNodeUnderCursor in: aMethodNode ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580091!
contextualChangeSelectorInMethodUsing: aChangeSelectorApplier
	
	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualChangeSelectorOf: methodNode in: selectedClass using: aChangeSelectorApplier ]
		ifErrorsParsing: [ :anError | morph flash ]		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580103!
balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) 
		calculateTypes; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580117!
hoverHelpToShowEvaluating: aNodeUnderCursor

	^ [[ self hoverHelpStringOfEvaluating: aNodeUnderCursor]
		on: MessageNotUnderstood 
		do: [ :mnu | | receiverPrintString | 
			"just guessing if the real receiver is the one in the message node to show a nicer error message.
			This will not be correct in cases such as: v1 xx: (v2 xx: 1). In this case will show that v1 does not understand xx: 
			when it is v2 the one that does not understand it, but this is so rare that I leave it anyway - Hernan"
			receiverPrintString := mnu message selector = aNodeUnderCursor selectorSymbol 
				ifTrue: [ aNodeUnderCursor originalReceiver printSourceCode ]
				ifFalse: [ mnu receiver printString ].
			mnu return: receiverPrintString, ' does not understand ', mnu message selector]]
		on: Error 
		do: [ :anError | anError return: anError messageText ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580147!
implementorsOfItWhenErrorsParsing

	"Open an implementors browser on the selected selector"

	| aSelector |

	self lineSelectAndEmptyCheck: [^ self].
	(aSelector := self selectedSelector) ifNil: [^ morph flash].
	Smalltalk browseAllImplementorsOf: aSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580159!
extractMethod

	self performCodeExtractionRefactoringWith: ExtractMethodApplier! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580165!
acceptAndTestAll: aKeyboardEvent

	^self acceptAndTestAll! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580171!
changeSelectorTo: aSelector in: aClassToRefactor using: aChangeSelectorApplier
	
	aChangeSelectorApplier 
		createAndValueHandlingExceptionsOn: model textProvider 
		for: aSelector 
		in: aClassToRefactor ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580181!
lineOrNodeSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, either
		- expand it to be the entire current line
		- or expand it to a meaningful chunk of code.
	If after that's done the selection is still empty, then evaluate the returnBlock."

	self hasSelection ifFalse: [
		(model actualContents isLineEndAt: self pointIndex)
			ifTrue: [ self selectLine ]
			ifFalse: [
				self
					withMethodNodeAndClassDo: [ :methodNode :selectedClass |
						self selectNodeUnderCursorForInspectionIn: methodNode ]
					ifErrorsParsing: [ :anError | ]]].
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^returnBlock value ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580205!
actualImplementorsOfIt: aKeyboardEvent

	self actualImplementorsOfIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580212 overrides: 50589554!
normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string := self privateCurrentString.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	self pointIndex - 1 to: (self pointIndex - 20 max: 1) by: -1 do: [:i|
		(string at: i) = $\ ifTrue: 
			[key := string copyFrom: i + 1 to: self pointIndex - 1.
			UnicodeCodePoint namedCharactersMap at: key ifPresent: [:value| self selectFrom: i to: self pointIndex - 1; replaceSelectionWith: (UnicodeString with: value)].
			^ super normalCharacter: aKeyboardEvent]].
	^ super normalCharacter: aKeyboardEvent! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580243!
argPrev: aKeyboardEvent
	"Invoked by cmd-Q.
	 Search backwards from the start of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the start of the text.."

	| t i |
	t := model actualContents.
	i := self stopIndex.
	i > 1 ifTrue: [
		i := i -2.
		[i > 0 and: [ (t at: i) ~= $  or: [(t at: i-1) ~= $: ]]] whileTrue: [
			i := i -1 ].
		self deselectAndPlaceCursorAt: i + 1.
	].
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580261!
typeCheckMethod
	
	self hasUnacceptedEdits ifTrue: [ ^self inform: 'The method can not be typed check because source code is not saved' ].
	
	self codeProvider typeCheckMethod.
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580270!
exploreIt

	self lineOrNodeSelectAndEmptyCheck: [^ self ].
	self
		evaluateSelectionAndDo: [ :result | result explore ]
		ifFail: [ ^morph flash ]
		profiled: false.
	morph convertAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580282!
doItSourceCodeFor: aSourceCode in: anEvaluationContext

	^UnicodeString streamContents: [ :stream |
		Scanner doItSourceCodeHeaderWithContext: anEvaluationContext notNil into: stream.
		stream nextPutAll: aSourceCode		]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580293!
moveInstanceVariableOn: aBrowser at: aClassToRefactor
	self moveInstanceVariableOn: aBrowser for: nil at: aClassToRefactor.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580301!
explainCtxt: symbol 
	"Is symbol a context variable?"

	| reply classes text cls provider |
	symbol = #nil ifTrue: [reply := ' is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables.'].
	symbol = #true ifTrue: [reply := ' is a constant.  It is the only instance of class True and is the receiver of many control messages.'].
	symbol = #false ifTrue: [reply := ' is a constant.  It is the only instance of class False and is the receiver of many control messages.'].
	symbol = #thisContext ifTrue: [reply := ' is a context variable.  Its value is always the MethodContext which is executing this method.'].
	provider := self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [
		cls := provider selectedClassOrMetaClass].
	cls ifNil: [^ reply].	  "no class known"
	symbol = #self ifTrue: 
			[classes := cls withAllSubclasses.
			classes size > 12
				ifTrue: [text := cls printString , ' or a subclass']
				ifFalse: 
					[classes := classes printString.
					text := 'one of these classes' , (classes copyFrom: 4 to: classes size)].
			reply := ' is the receiver of this message; an instance of ' , text ].
	symbol = #super ifTrue: [reply := 'is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')'].
	^reply ifNotNil: [symbol, reply]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580347!
sendersOfItWhenErrorsParsing

	"Open a senders browser on the selected selector"

	| aSelector |

	self lineSelectAndEmptyCheck: [^ self].
	(aSelector := self selectedSelector) ifNil: [^ morph flash].
	Smalltalk browseAllCallsOn: aSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580358!
selectPrecedingIdentifier
	"Invisibly select the identifier that ends at the end of the selection, if any."

	| string sep stop tok |
	tok := false.
	string := self privateCurrentString.
	stop := self stopIndex - 1.
	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop := stop - 1].
	sep := stop.
	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok := true. sep := sep - 1].
	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580376!
explainChar: string
	"Does string start with a special character?"

	| char |
	char := string at: 1.
	char = $. ifTrue: [^'Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float).'].
	char = $' ifTrue: [^'The characters between two single quotes are made into an instance of class String'].
	char = $" ifTrue: [^'Double quotes enclose a comment.  Smalltalk ignores everything between double quotes.'].
	char = $# ifTrue: [^'The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants.'].
	(char = $( or: [char = $)]) ifTrue: [^'Expressions enclosed in parenthesis are evaluated first'].
	(char = $[ or: [char = $]]) ifTrue: [^'The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockClosure and is usually passed as an argument.'].
	(char = ${ or: [char = $}]) ifTrue: [^ 'A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array'].
	(char = $< or: [char = $>]) ifTrue: [^'<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails.'].
	char = $^ ifTrue: [^'Up arrow means return from this method.  The value returned is the expression following the ^'].
	char = $| ifTrue: [^'Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code.'].
	char = $_ ifTrue: [^'Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it.'].
	char = $; ifTrue: [^'Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon.'].
	char = $: ifTrue: [^'A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withNewLines, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon).'].
	char = $$ ifTrue: [^'The single character following a dollar sign is made into an instance of class Character'].
	char = $- ifTrue: [^'A minus sign in front of a number means a negative number.'].
	char = $e ifTrue: [^'An e in the middle of a number means that the exponent follows.'].
	char = $r ifTrue: [^'An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base.'].
	char = Character space ifTrue: [^'the space Character'].
	char = Character tab ifTrue: [^'the tab Character'].
	char = Character cr ifTrue: [^'the carriage return Character'].
	char = Character lf ifTrue: [^'newline. The line feed Character'].
	^nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580481!
temporaryToInstanceVariable: aKeyboardEvent

	self temporaryToInstanceVariable.

	^true.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580488!
moveInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor
	"self halt."
	(RefactoringApplier moveInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580498!
explainInst: string 
	"Is string an instance variable of this class?"
	| classes cls provider |
	provider := self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [
		cls := provider selectedClassOrMetaClass].
	cls ifNil: [^ nil].	  "no class known"
	classes := (Array with: cls)
				, cls allSuperclasses.
	classes := classes detect: [:each | (each instVarNames
			detect: [:name | name = string] ifNone: nil)
			notNil] ifNone: [^nil].
	classes := classes printString.
	^ String streamContents: [:str |
		str
			nextPutAll: string;
			nextPutAll: ' is an instance variable of the receiver; defined in class ';
			nextPutAll: classes, '\' withNewLines;
			nextPutAll: 'Smalltalk browseAllAccessesTo: ''';
			nextPutAll: string;
			nextPutAll: ''' from: ';
			nextPutAll: classes;
			nextPut: $.]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580527!
selectedClassOrMetaClassOrUndefinedObject

	"I have to do this because some codeProviders do not answer selectedClassOrMetaClass like the Workspace - Hernan"
	
	^ [ self codeProvider selectedClassOrMetaClass ] 
		on: Error 
		do: [ :anError | anError return: UndefinedObject ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580539!
renameGlobalOn: aBrowser for: anOldName

	(RenameGlobalApplier on: aBrowser for: anOldName) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580546!
implementorsOfNodeUnder: aMousePosition

	| mousePositionInText |
	
	mousePositionInText := morph positionInTextOf: aMousePosition.
	self browseImplementorsAt: mousePositionInText ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580555!
afterCompiling: aSourceCode do: aBlock for: aReceiver in: anEvaluationContext ifFail: aFailBlock
	
	| methodNode method sourceCode compiler |

	sourceCode := self doItSourceCodeFor: aSourceCode in: anEvaluationContext.
	
	methodNode := [
		compiler := Compiler new.
		compiler		
			compileDoIt: sourceCode
			in: aReceiver class
			context: anEvaluationContext
			notifying: self
			ifFail: [ ^ aFailBlock value ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method := methodNode generate.
	method methodNode: methodNode.

	^aBlock value: compiler value: method value: aReceiver value: anEvaluationContext 
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580579!
inlineTemporaryVariable: aKeyboardEvent

	self inlineTemporaryVariable.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580585!
selectedSymbol
	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"

	| aString |
	self hasSelection ifFalse: [^ nil].
	aString := self selectedString withoutSeparators.
	aString isEmpty ifTrue: [^ nil].
	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].

	^ nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580599 overrides: 50589710!
paste
	| objectName |
	
	model canBindVariables ifTrue: [
		"Not a copy!!!!!!"
		Clipboard contentsOriginalObject ifNotNil: [ :object |
			objectName := model nameForObject: object.
			(model bindingOf: objectName) value: object.
			self replaceSelectionWith: objectName.
			^ self ]].
	^ super paste! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580612!
temporaryToInstanceVariable

	self
		withNodeUnderCursorDo: [ :nodeUnderCursor |
			(nodeUnderCursor isTemp and: [nodeUnderCursor isArg not])
				ifTrue: [ TemporaryToInstanceVariableApplier on: self for: nodeUnderCursor name :: value ]
				ifFalse: [ morph flash ]]
		ifAbsent: [ morph flash ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580625!
contextualMoveInstanceVariable
	"self halt."
	self isEditingClassDefinition 
		ifTrue: [ self contextualMoveInstanceVariableInClassDefinition ]
		ifFalse: [ self contextualMoveInstanceVariableInMethod ].
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580635!
balloonTypeInfoOf: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class) 
		calculateTypesWithContext; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580651!
testSuiteForCategoryOf: aClass

	| selectedSystemCategory |
	
	"If we are in a senders or implementors window, a MessageSet, the selectedSystemCategory is nil.
	In that case most of those cases the user wants to run the tests of the category of the selected method class - Hernan"
	selectedSystemCategory := self codeProvider selectedSystemCategory ifNil: [ aClass category ].
	^TestSuite forSystemCategoryNamed: selectedSystemCategory using: SystemOrganization 
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580669!
implementorsOfIt
	"Open an implementors browser.
	If text selection defines a selector, take it. Otherwise, try finding selector under cursor. If this fails, consider the whole line."

	^self selectedSelector 
		ifNil: [ self browseImplementorsAt: self startIndex ]
		ifNotNil: [ :selector | Smalltalk browseAllImplementorsOf: selector ].
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580683!
contextualInlineMethod

	self isEditingClassDefinition ifTrue: [ ^morph flash ].
	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualInlineMethodOf: methodNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]	]	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580696!
withSelectorUnderCursorDo: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock

	self withSelectorAt: self startIndex do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580705!
explainGlobal: symbol 
	"Is symbol a global variable?"
	| reply classes |
	reply := Smalltalk at: symbol ifAbsent: [^nil].
	(reply class == Dictionary or:[reply isKindOf: SharedPool class])
		ifTrue: 
			[classes := Set new.
			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]
					ifNone: nil)
					ifNotNil: [classes add: each]].
			classes := classes printString.
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a global variable.  It is a pool which is used by the following classes ';
					nextPutAll: (classes allButFirst: 5) ]].
	(reply isKindOf: Behavior)
		ifTrue: [^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a global variable.  ';
				nextPutAll: symbol;
				nextPutAll: ' is a class in category ';
				nextPutAll: reply category, '.', '\' withNewLines;
				nextPutAll: 'BrowserWindow fullOnClass: ';
				nextPutAll: symbol;
				nextPutAll: ' selector: nil';
				nextPut: $.]].
	symbol == #Smalltalk 
		ifTrue: [^ symbol, ' is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables.'].
	^ String streamContents: [:str |
		str
			nextPutAll: symbol;
			nextPutAll: ' is a global variable.  ';
			nextPutAll: symbol;
			nextPutAll: ' is ';
			nextPutAll: reply printString ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580751!
browseImplementorsAt: aPosition

	self 
		withSelectorAt: aPosition 
		do: [ :selector | Smalltalk browseAllImplementorsOf: selector ]
		ifBehavior: [ :behavior | BrowserWindow fullOnClass: behavior selector: nil ]
		otherwise: [ self implementorsOfItWhenErrorsParsing ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580763!
renameTemporary: aTemporaryNode at: aMethodNode

	self codeProvider isEditingMethod ifTrue: [ | applier |
		[ applier := RenameTemporaryApplier on: self for: aTemporaryNode at: aMethodNode ]
			on: SyntaxErrorNotification
			do: [:anError | ^self inform: (RenameTemporaryApplier errorMessageForCanNotParseMethod: anError) ].
		applier value ].
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580778!
codeProvider
	^ (model is: #hasTextProvider)
		ifTrue: [ model textProvider ]
		ifFalse: [ model ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580785!
performCodeExtractionRefactoringWith: aRefactoringApplierClass

	"To prevent the refactoring to be evaluated on editors w/o methods like the workspace - Nahuel"
	self hasValidCurrentCompiledMethod ifFalse: [ ^ nil ].

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		
	aRefactoringApplierClass createAndValueHandlingExceptions: [
		aRefactoringApplierClass
			on: self codeProvider
			for: self selectionInterval asSourceCodeInterval
			of: self codeProvider currentCompiledMethod ] ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580804!
acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ 
			aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580817!
selectNodeRange: aNodeUnderCursor in: aMethodNode 
	
	| range ranges |
	
	ranges := aMethodNode rangeForNode: aNodeUnderCursor ifAbsent: [ ^ self ].
	range := (aMethodNode isMultipleRanges: ranges) 
		ifTrue: [ ranges detect: [ :aRange | aRange includes: self startIndex ] ifNone: [ ^self ]]
		ifFalse: [ ranges ].
		
	self selectFrom: range first to: range last
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580832!
contextualPushDownInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushDownInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass ) value ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580843!
classCommentsContainingIt
	"Open a browser class comments which contain the current selection somewhere in them."

	self lineSelectAndEmptyCheck: [^ self].
	Smalltalk browseClassCommentsWithString: self selectedString! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580854!
contextualRenameInMethod

	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualRenameOf: methodNode in: selectedClass]
		ifErrorsParsing: [ :anError | morph flash ]		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580864!
contextualMoveInstanceVariable: aKeyboardEvent
	self contextualMoveInstanceVariable.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580871!
printIt: aKeyboardEvent
	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw
	 2/29/96 sw: don't call selectLine now, since it's called by doIt"

	self printIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580883!
actualSendersOfIt
	
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			BrowseActualSenders browseOf: methodNode definedIn: class withCursorAt: self startIndex in: morph ]
		ifErrorsParsing: [ :anError | morph flash ].


	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580894!
explainDelimitor: string
	"Is string enclosed in delimitors?"

	| str |
	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"
	(string first = string last) ifTrue:
			[^ self explainChar: (String with: string first)]
		ifFalse:
			[(string first = $( and: [string last = $)]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = $[ and: [string last = $]]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = ${ and: [string last = $}]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = $< and: [string last = $>]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first = $# and: [string last = $)]) ifTrue:
				[^'An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array.'].
			string first = $# ifTrue:
				[^'An instance of class Symbol.'].
			(string first = $$ and: [string size = 2]) ifTrue:
				[^'An instance of class Character.  This one is the character ', (String with: string last), '.'].
			(string first = $:) ifTrue:
				[str := string allButFirst.
				(self explainTemp: str) ifNotNil: [
					^'An argument to this block will be bound to the temporary variable ',
						str, '.']]].
	^ nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580938!
typeCheckMethod: aKeyboardEvent 
	
	self typeCheckMethod.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580944!
sendersOfIt: aKeyboardEvent
	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"

	self sendersOfIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580953!
withClassDefinitionNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self codeProvider selectedClassOrMetaClass.
	methodNode := [ selectedClass methodNodeFor: model actualContents string noPattern: true ]
		on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580968!
methodStringsContainingIt: aKeyboardEvent
	"Triggered by Cmd-E"

	self methodStringsContainingIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580975!
acceptAndTestAll
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ].
	^true
	
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580983!
contextualRenameInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self contextualRenameInClassDefinitionOf: classDefinitionNode in: selectedClass]
			ifErrorsParsing: [ :anError | morph flash ] ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50580996!
evaluateSelectionAndDo: aBlock ifFail: failBlock profiled: doProfile
	"Treat the current selection as an expression; evaluate it and evaluate aBlock with the result
	3 + 4
	"	

	self evaluate: self selection string andDo: aBlock ifFail: failBlock profiled: doProfile! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581008!
inspectIt: aKeyboardEvent
	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw
	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"

	self inspectIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581019!
contextualRename: aKeyboardEvent

	self contextualRename.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581025!
renameSelectorFor: aSelector in: aClassToRefactor

	RefactoringApplier renameSelectorApplier createAndValueHandlingExceptionsOn: model textProvider for: aSelector in: aClassToRefactor ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581035!
selectNodeUnderCursorForInspectionIn: aMethodNode 
	
	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self selectForInspection: nodeUnderCursor in: aMethodNode ]
		ifAbsent: []


! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581045!
referencesToIt: aKeyboardEvent
	"Triggered by Cmd-N; browse references to the current selection"

	self referencesToIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581053!
debug: aCompiledMethod receiver: anObject in: evalContext

	Debugger
		openDebugging: [
			aCompiledMethod
				valueWithReceiver: anObject
				arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ])]
		to: aCompiledMethod
		label: 'Debug it'.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581065!
quickPrintOfNodeUnder: aMousePosition

	| mousePositionInText |
	
	mousePositionInText := morph positionInTextOf: aMousePosition.

	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | morph showBalloon: (self hoverHelpToShowEvaluating: aNodeUnderCursor)]
				ifAbsent: [  morph flash  ]]
		ifErrorsParsing: [ :anError | morph showBalloon: anError messageText ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581083!
contextualInlineMethod: aKeyboardEvent

	self contextualInlineMethod.
	^true.

	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581089!
notify: aString at: anInteger in: aStream 
	"The compilation of text failed. The syntax error is noted as the argument, 
	aString. Insert it in the text at starting character position anInteger."
	"This is a user command, and generates undo"
	model startNewUndoRedoCommand.
	self insertAndSelect: aString at: (anInteger max: 1).! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581103!
contextualMoveInstanceVariableOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self moveInstanceVariable: nodeUnderCursor in: aSelectedClass at: aMethodNode ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifFalse: [ morph flash ]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581117!
selectMessageNode: aMessageNodeUnderCursor in: aMethodNode
	
	| messageRange |
	
	self 
		withReceiverRangeOf: aMessageNodeUnderCursor 
		in: aMethodNode 
		selectorPosition: self startIndex 
		do: [ :receiverRange |
			messageRange := aMethodNode rangeForNode: aMessageNodeUnderCursor ifAbsent: [ ^ self ].
			self selectFrom: receiverRange first to: messageRange last ]
		
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581133!
contextualMoveInstanceVariableInMethod
	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualMoveInstanceVariableOf: methodNode in: selectedClass ]
		ifErrorsParsing: [ :anError | morph flash ]		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581144!
explainTemp: string 
	"Is string the name of a temporary variable (method or block argument or temporary)?"

	| provider selectedClass methodNode tempNode |
	provider := self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	provider selectedMessageName ifNil: [^nil].	"not in a method"
	selectedClass := provider selectedClassOrMetaClass.
	methodNode := selectedClass parserClass new parse: provider selectedMessage class: selectedClass.
	tempNode := methodNode encoder tempNodes detect: [ :n | n name = string ] ifNone: [^nil].
	^(tempNode isArg
		ifTrue: [string, ' is an argument to this ']
		ifFalse: [string, ' is a temporary variable in this ']),
	   (tempNode isDeclaredAtMethodLevel
		ifTrue: ['method ']
		ifFalse: ['block '])! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581172!
pasteInitials: aKeyboardEvent 
	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor."
	"This is a user command, and generates undo"

	| i |
	i := self stopIndex.
	self replaceSelectionWith: (Text fromString: Utilities changeStamp).
	self deselectAndPlaceCursorAt: i.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581188!
withNodeUnderCursorDo: aDoBlock ifAbsent: anAbsentBlock

	self 
		withMethodNodeAndClassDo: [ :currentMethodNode :currentClass |
			currentMethodNode 
				withParseNodeIncluding: self startIndex
				do: aDoBlock
				ifAbsent: anAbsentBlock ] 
		ifErrorsParsing: [ :arg1 | anAbsentBlock value ].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581201!
contextualExtractAsParameter

	self isEditingClassDefinition 
		ifTrue: [ morph flash ]
		ifFalse: [ self ifSourceCodeRefactoringCanBeAppliedDo: [ self extractAsParameter ]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581210!
actualSendersOfIt: aKeyboardEvent

	self actualSendersOfIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581216!
acceptAndWithMethodDo: aBlock
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod := self codeProvider currentCompiledMethod.
	^potencialTestMethod 
		ifNil: [ false ]
		ifNotNil: [
			aBlock value: potencialTestMethod.
			true]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581228!
browseIt: aKeyboardEvent
	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"

	self browseIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581237!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor

	(RenameInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581247!
referencesToSelectedLiteral
	"Evaluate the selected text and browse methods that reference the same literal"
	[
		self
			evaluateSelectionAndDo: [ :result |
				Smalltalk
					browseMessageList: (Smalltalk allReferencesToLiteral: result)
					name: 'Users of literal: ' , result asString
					autoHighlight: self selection
					allOccurrences: true ]
			ifFail: nil
			profiled: false ]
	on: UndeclaredVariableReference , UnknownSelector
	do: [ :ex |
		morph flash ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581265!
withSelectorAt: aPosition do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock
	| methodNode nodeAtRange nodeUnderCursor  |

	methodNode := self codeProvider
		methodNodeOf: model actualContents string
		ifErrorsParsing: [ :anError | ^ failBlock value ].

	aPosition < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: aPosition ifAbsent: [ ^ failBlock value ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ])
		ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].
	(nodeUnderCursor isLiteralVariableNode and: [ nodeUnderCursor isReferencingBehavior ])
		ifTrue: [ ^aBehaviorBlock value: nodeUnderCursor key value ].

	^ failBlock value.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581296!
withReceiverRangeOf: aMessageNode in: aMethodNode selectorPosition: aSelectorPosition do: aBlock   
	
	| receiverRange receiverRangeOrRanges messageNodeReceiver |
	
	"If aMessageNode receiver isNil it means that it is a cascade receiver so this imposes the question on how to inspect
	a cascade message send. We could inspect the result of sending all the messages up to the cursor but the problem is
	that when looking for the cascade receiver range it does not find it because it is a different node that the used in the source
	ranges... we could do the trick of looking for printString in the sourceRanges keys, but that is too much - Hernan"
	aMessageNode isCascade ifFalse: [ 
		messageNodeReceiver := aMessageNode receiver.
		messageNodeReceiver isMessageNode ifTrue: [ 
			^self withReceiverRangeOf: messageNodeReceiver in: aMethodNode selectorPosition: (messageNodeReceiver keywordPositionAt: 1) first do: aBlock ].
		
		receiverRangeOrRanges := aMethodNode rangeForNode: messageNodeReceiver ifAbsent: [ ^ self ].
		
		receiverRange := (aMethodNode isMultipleRanges: receiverRangeOrRanges)
			ifTrue: [ | closestRange |
				closestRange := receiverRangeOrRanges first.
				receiverRangeOrRanges do: [ :aRange |  (aRange last < aSelectorPosition and: [ aRange last > closestRange last ]) ifTrue: [ closestRange := aRange ]].
				closestRange ]
			ifFalse: [ receiverRangeOrRanges ].

		aBlock value: receiverRange ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581344!
showSelectionTypeInfo: aKeyboardEvent

	self showSelectionTypeInfo.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581350!
debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selection string
		do: [ :compiler :method :receiver :context |
			(method notNil and: [method isQuick not]) ifTrue: [
				self debug: method receiver: receiver in: context ]]
		ifFail: [].! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581362!
referencesToIt
	"Open a references browser on the selected symbol: a variable name or class name"

	| selectedSymbol provider environment selectedString |
	self hasSelection ifFalse: [ self selectWord ].
	selectedSymbol := self selectedSymbol.

	"convenient access to class variables, including those in SharedPools"
	provider := self codeProvider.
	environment := (provider respondsTo: #selectedClassOrMetaClass) ifTrue: [ provider selectedClassOrMetaClass ].
	environment := environment ifNil: [ Smalltalk ].

	(selectedSymbol ifNotNil: [environment bindingOf: selectedSymbol]) ifNotNil: [ :reference |
		Smalltalk browseAllCallsOn: reference.
		^ self ].

	selectedString := self selectedString withoutSeparators.
	(environment ~= Smalltalk and: [ environment definesInstanceVariableNamedInHierarchy: selectedString ]) ifTrue: [
		Smalltalk browseAllAccessesTo: selectedString from: environment.
		^ self ].

	self referencesToSelectedLiteral! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581395!
browseClassFromIt
	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."

	| aClass |
	self wordSelectAndEmptyCheck: [^ self].

	aClass := Utilities
		classFromPattern: self selectedString withBlanksCondensed
		withCaption: 'choose a class to browse...'.
	aClass ifNil: [^ morph flash].

	HierarchyBrowserWindow
		onClass: aClass
		selector: nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581413!
openMenu: aMenu
	
	aMenu popUpInWorld: morph world! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581418!
browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry |
	(Preferences at: #alternativeBrowseIt) ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol := self selectedSymbol ifNil: [
		self
			evaluate: self selection string
			andDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false ].

	aSymbol first isUppercase
		ifTrue: [
			anEntry := (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry := anEntry class].
			BrowserWindow fullOnClass: anEntry selector: nil]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:03' prior: 50581446!
renameSelectorOf: aMessageNode in: aSelectedClass at: aSelectedSelector

	RefactoringApplier renameSelectorApplier
		on: aMessageNode
		createAndValueHandlingExceptionsOn: model textProvider
		in: aSelectedClass
		at: aSelectedSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581457!
contextualRename

	self isEditingClassDefinition 
		ifTrue: [ self contextualRenameInClassDefinition ]
		ifFalse: [ self contextualRenameInMethod ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581465!
contextualMoveInstanceVariableInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self contextualMoveInstanceVariableInClassDefinitionOf: classDefinitionNode in: selectedClass]
			ifErrorsParsing: [ :anError | morph flash ] ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587845!
balloonTypeInfoOfInstanceVariableAt: mousePositionInText

	| instVarName typeInfo types |
	
	instVarName := (self wordUnder: mousePositionInText) asString.
	"typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^'']."
	types := self codeProvider selectedClass 
				liveTypesOfInstanceVariableNamed: instVarName 
				storingGenericsInfoIn: (LiveTyping getGenericsStorage) 
				ifAbsent: [`EmptyType new`].
	typeInfo := InstanceVariableTypeInfo of: instVarName in: self codeProvider selectedClass are: types asArray.
	^typeInfo printTypesUpTo: 5! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581502 overrides: 50585528!
getMenu
	
	^self createMenuCollectingOptionsWith: #smalltalkEditorMenuOptions! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581508!
inlineMethodInUsage: aMessageNodeReference

	RefactoringApplier inlineMethodApplier
		createAndValueHandlingExceptionsOn: model textProvider
		forMessageSend: aMessageNodeReference.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581517!
explainMySel: symbol 
	"Is symbol the selector of this method?  Is it sent by this method?  If 
	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 
	selector sent here.  If not, explain will call (explainAnySel:) to catch any 
	selector. "

	| provider lits classes msg |
	provider := self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg := provider selectedMessageName) ifNil: [^nil].	"not in a message"
	classes := Smalltalk allClassesImplementing: symbol.
	classes size > 12
		ifTrue: [classes := 'many classes']
		ifFalse: [classes := 'these classes ' , classes printString].
	msg = symbol
		ifTrue: [
			^ String streamContents: [:str |
				str
					nextPut: $#;
					nextPutAll: symbol;
					nextPutAll: ' is the selector of this very method!!  It is defined in ';
					nextPutAll: classes;
					nextPutAll: self class plateA]]
		ifFalse: [
			lits := (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(lits detect: [:each | each == symbol]
				ifNone: nil)
					ifNil: [^nil].
			^ String streamContents: [:str |
				str
					nextPut: $#;
					nextPutAll: symbol;
					nextPutAll: ' is a message selector which is defined in ';
					nextPutAll: classes;
					nextPutAll: self class plateA]]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581561!
withMethodNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self selectedClassOrMetaClassOrUndefinedObject.
	[ 
		[ methodNode := selectedClass methodNodeFor: model actualContents string ]
			on: UndeclaredVariableWarning do: [ :ex | ex resume ]
	] on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581578!
exploreIt: aKeyboardEvent
	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."

	self exploreIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581587!
testSuiteOf: aClass

	^TestSuite forClass: aClass
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581592!
methodSourceContainingIt: aKeyboardEvent
	"Triggered by Cmd-e"

	self methodSourceContainingIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581599!
extractToTemporary: aKeyboardEvent

	self extractToTemporary.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581605!
explainClass: symbol 
	"Is symbol a class variable or a pool variable?"
	| provider class reply classes |
	provider := self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass)
		ifFalse: [^ nil].
	(class := provider selectedClassOrMetaClass) ifNil: [^ nil].
	"no class is selected"
	(class isKindOf: Metaclass)
		ifTrue: [class := class soleInstance].
	classes := (Array with: class)
				, class allSuperclasses.
	"class variables"
	reply := classes detect: [:each | (each classVarNames detect: [:name | symbol = name]
					ifNone: nil)
					notNil]
				ifNone: nil.
	reply ifNotNil: [
		^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a class variable, defined in class ';
				nextPutAll: reply printString, '\' withNewLines;
				nextPutAll: 'Smalltalk browseAllCallsOn: (';
				nextPutAll: reply printString;
				nextPutAll: ' classPool associationAt: #';
				nextPutAll: symbol;
				nextPutAll: ').']].
	"pool variables"
	classes do: [:each | (each sharedPools
			detect: [:pool | (pool includesKey: symbol)
					and: 
						[reply := pool.
						true]]
			ifNone: nil)
			notNil].
	reply
		ifNil: [(Undeclared includesKey: symbol)
				ifTrue: [
					^ String streamContents: [:str |
						str
							nextPutAll: symbol;
							nextPutAll: ' is an undeclared variable.';
							nextPutAll: 'Smalltalk browseAllCallsOn: (Undeclared associationAt: #';
							nextPutAll: symbol;
							nextPutAll: ').']]]
		ifNotNil: 
			[classes := Array streamContents: [ :strm |
				Smalltalk
					allBehaviorsDo: [:each | (each sharedPools
							detect: 
								[:pool | 
								pool == reply]
							ifNone: nil)
							notNil ifTrue: [strm nextPut: each]]].
			"Perhaps not print whole list of classes if too long. (unlikely)"
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a pool variable from the pool ';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ', which is used by the following classes ';
					nextPutAll: classes printString , '\' withNewLines;
					nextPutAll: 'Smalltalk browseAllCallsOn: (';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ' bindingOf: #';
					nextPutAll: symbol;
					nextPutAll: ').']].
	^ nil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581680!
contextualRemoveParameter: aKeyboardEvent 
	
	self contextualRemoveParameter.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581686!
debugIt: aKeyboardEvent

	self debugIt.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581691!
implementorsOfIt: aKeyboardEvent
	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"

	self implementorsOfIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581701!
methodStringsContainingIt
	"Open a browser on methods which contain the current selection as part of a string constant."

	self lineSelectAndEmptyCheck: [^ self].
	Smalltalk browseMethodsWithString: self selectedString! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581712!
acceptAndTest: aKeyboardEvent

	^self acceptAndTest! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581717!
doIt: aKeyboardEvent
	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.
	2/29/96 sw: don't call selectLine; it's done by doIt now"

	self doIt.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581727!
acceptAndTest
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ].
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581734!
showSelectionTypeInfoInMethod
		
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | | cursorPosition |
			cursorPosition := self startIndex.
			methodNode 
				withParseNodeIncluding: cursorPosition 
				do: [ :aNodeUnderCursor | self showTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class ]
				ifAbsent: [ 
					cursorPosition <= methodNode selectorLastPosition 
						ifTrue: [ self showTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ morph flash ]]]
		ifErrorsParsing: [ :anError | morph flash ]

! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581755!
displayIfFalse: aKeyboardEvent
	"Replace the current text selection with the text 'ifFalse:'--initiated by 
	cmd-F."

	self addString: 'ifFalse:'.
	^false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581764!
sendersOfIt
	"Open a senders browser.
	If text selection defines a selector, take it. Otherwise, try finding selector under cursor. If this fails, consider the whole line."

	self selectedSelector ifNotNil: [ :selector |
		^ Smalltalk browseAllCallsOn: selector ].
	self
		withSelectorUnderCursorDo: [ :selector | Smalltalk browseAllCallsOn: selector ]
		ifBehavior: [:behavior | Smalltalk browseAllCallsOn: (Smalltalk bindingOf: behavior name)] 
		otherwise: [ self sendersOfItWhenErrorsParsing ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581783!
contextualExtractAsParameter: aKeyboardEvent 
	
	self contextualExtractAsParameter.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581790!
explainAnySel: symbol 
	"Is this any message selector?"

	| list reply |
	list := Smalltalk allClassesImplementing: symbol.
	list isEmpty ifTrue: [^nil].
	list size < 12
		ifTrue: [reply := ' is a message selector which is defined in these classes ' , list printString]
		ifFalse: [reply := ' is a message selector which is defined in many classes'].
	^'#' , symbol , reply , '.\' withNewLines, 'Smalltalk browseAllImplementorsOf: #' , symbol! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581808!
nextTokenFrom: start direction: dir
	"simple token-finder for compiler automated corrections"
	| loc str |
	loc := start + dir.
	str := self privateCurrentString.
	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]
		whileTrue: [loc := loc + dir].
	^ loc! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581820!
selectedSelector
	"Try to make a selector out of the current text selection"

	^ self selectedString findSelector! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581827!
doIt

	self doItProfiling: false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581832!
contextualRemoveParameter

	self contextualChangeSelectorUsing: RefactoringApplier removeParameterApplier ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581839!
apply: aBlock inClassDefinitionOf: aClassDefinitionNode in: aSelectedClass 
	
	| analyzer cursorPosition |
	
	analyzer := ClassDefinitionNodeAnalyzer for: aClassDefinitionNode.
	cursorPosition := self startIndex.
	
	(analyzer isAtInstanceVariables: cursorPosition) 
		ifTrue: [ aBlock value: aSelectedClass ]
		ifFalse: [ morph flash ]
	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581854 overrides: 50585916!
clickAndHalfAt: localEventPosition

	| here |
	here := self pointIndex.
	(here between: 2 and: model textSize)
		ifTrue: [
			super clickAndHalfAt: localEventPosition ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581866!
actualLocalImplementorsOfIt

	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			BrowseActualLocalImplementors browseOf: methodNode definedIn: class withCursorAt: self startIndex in: morph ]
		ifErrorsParsing: [ :anError | morph flash ].

		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581878!
balloonTypeInfoInMethodAt: mousePositionInText

	^self withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| 
					self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class 
				]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 	mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]
				]]
		ifErrorsParsing: [ :anError | '' ]


! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581904!
showTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class 

	[ (ParseNodeTypesDisplay of: aNodeUnderCursor in: methodNode definedAt: class) show ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | self inform: anError messageText ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581915!
actualImplementorsOfIt
	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			BrowseActualImplementors browseOf: methodNode definedIn: class withCursorAt: self startIndex in: morph ]
		ifErrorsParsing: [ :anError | morph flash ].

		! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581926!
renameClassOn: aBrowser for: aClassToRefactor

	(RenameClassApplier for: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581933!
runTestSuite: aTestSuite

	(ProgressiveTestRunner for: aTestSuite) value
	
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581939!
contextualRenameOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self rename: nodeUnderCursor in: aSelectedClass at: aMethodNode ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifTrue: [ self ifSourceCodeRefactoringCanBeAppliedDo: [ self renameSelectorFor: aMethodNode selector in: aSelectedClass ]]
				ifFalse: [ morph flash ]]


! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581956!
acceptAndDebugTest: aKeyboardEvent 
	
	^self acceptAndDebugTest ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581962!
contextualChangeSelectorOf: aMethodNode in: aSelectedClass using: aChangeSelectorApplier

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self changeSelector: nodeUnderCursor in: aSelectedClass at: aMethodNode selector using: aChangeSelectorApplier ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifTrue: [ self changeSelectorTo: aMethodNode selector in: aSelectedClass using: aChangeSelectorApplier ]
				ifFalse: [ morph flash ]]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581981!
profileIt

	self doItProfiling: true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50581986!
explainNumber: string 
	"Is string a Number?"

	| strm c |
	(c := string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])
			ifFalse: [^nil]].
	strm := string readStream.
	c := Number readFrom: strm.
	strm atEnd ifFalse: [ ^nil ].
	c printString = string
		ifTrue: [ ^ string , ' is a ' , c class name ]
		ifFalse: [ ^ string , ' (= ' , c printString , ') is a ' , c class name ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582003!
isEditingClassDefinition

	^(self codeProvider is: #Browser) and: [ self codeProvider isEditingExistingClass ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582010!
acceptThenTestMethodAndSuite: aSuiteBuilder
	
	self acceptAndWithMethodDo: [ :aPotencialTestMethod |
		self runAndDebuggIfNecessary: aPotencialTestMethod.
		self runTestSuite: (aSuiteBuilder value: aPotencialTestMethod) ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582021!
ifEditingClassDefinitionDoOrWarn: aBlock

	self isEditingClassDefinition 
		ifTrue: aBlock
		ifFalse: [ self informRefactoringCanOnlyBeAppliedInClassDefinition ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582030!
doItProfiling: aBoolean
	"Set the context to include pool vars of the model.  Then evaluate.
	Print the result on the Transcript"

	self lineOrNodeSelectAndEmptyCheck: [^ self ].
	self evaluateSelectionAndDo: nil ifFail: nil profiled: aBoolean.
	morph convertAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582045!
contextualInlineMethodOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor |
			nodeUnderCursor isMessageNode ifFalse: [^morph flash].

			((aMethodNode completeSourceRangesOf: nodeUnderCursor ifAbsent: [self shouldNotHappen])
				detect: [ :aSourceRange | aSourceRange includes: self startIndex]
					ifFound: [ :aSourceRange | | messageNodeReference |
						messageNodeReference := MessageNodeReference
							messageNode: nodeUnderCursor
							selector: aMethodNode selector
							class: aSelectedClass
							completeSourceRange: aSourceRange.
						self inlineMethodInUsage: messageNodeReference.	]
					ifNone: [self shouldNotHappen ])]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition ifFalse: [ ^ morph flash ].

			RefactoringApplier inlineMethodApplier
				createAndValueHandlingExceptionsOn: model textProvider
				forMethod: (MethodReference class: aSelectedClass selector: aMethodNode selector)]

! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582080!
displayIfTrue: aKeyboardEvent
	"Replace the current text selection with the text 'ifTrue:'--initiated by 
	cmd-T."

	self addString: 'ifTrue:'.
	^false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582089!
contextualAddParameter
	
	self contextualChangeSelectorUsing: RefactoringApplier addParameterApplier ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582096!
methodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"

	self lineSelectAndEmptyCheck: [^ self].
	Smalltalk browseMethodsWithSourceString: self selectedString! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582109 overrides: 50589984!
newLine: aKeyboardEvent
	"Replace the current text selection with a newLine (i.e. LF) followed by as many tabs
	as there are leading tabs on the current line (+/- bracket count)."

	| char s i tabCount stopIndex newLineString |
	s := self privateCurrentString.
	stopIndex := self stopIndex.
	i := stopIndex.
	tabCount := 0.
	[ (i := i-1) > 0 and: [ (char := s at: i) isLineSeparator not ] ] whileTrue: [
		"Count brackets"
		char = $[ ifTrue: [tabCount := tabCount + 1].
		char = $] ifTrue: [tabCount := tabCount - 1]].
	[ (i := i + 1) < stopIndex and: [ (char := s at: i) isSeparator ] ] whileTrue: [
		"Count leading tabs"
		char = Character tab ifTrue: [ tabCount := tabCount + 1 ]].
	"Now inject newline with tabCount tabs, generating a new undoable command"
	newLineString := UnicodeString streamContents: [ :strm | strm newLineTab: tabCount ].
	model startNewUndoRedoCommand.
	self replaceSelectionWith: newLineString.
	^ false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582142!
printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."

	self lineSelectAndEmptyCheck: [^ self ].
	self
		evaluateSelectionAndDo: [ :result |
			| text |
			text := model fullPrintIt
				ifTrue: [result printText]
				ifFalse: [result printTextLimitedTo: 10000].
			text := text copyReplaceAll: String lfString with: String lfString, ' '.
			text := ' ', text asText shoutDisableEmphasis, ' .'.
			self afterSelectionInsertAndSelect: (text initialFontFrom: emphasisHere)]
		ifFail: [ morph flash ]
		profiled: false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582167!
hoverHelpStringOfEvaluating: aNodeUnderCursor

	^ self
		evaluate: aNodeUnderCursor printSourceCode
		andDo: [ :result | result printString ]
		ifFail: [ 
			morph flash.
			'Nothing to show' ]
		profiled: false! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582177!
rename: aNodeUnderCursor in: aSelectedClass at: aMethodNode

	aNodeUnderCursor isTempOrArg ifTrue: [ ^self renameTemporary: aNodeUnderCursor at: aMethodNode ].

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		aNodeUnderCursor isMessageNode ifTrue: [
			^ self renameSelectorOf: aNodeUnderCursor in: aSelectedClass at: aMethodNode selector ].
		aNodeUnderCursor isInstanceVariableNode ifTrue: [
			^ self renameInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aSelectedClass ].
		aNodeUnderCursor isLiteralVariableNode ifTrue: [ | variableName |
			variableName := aNodeUnderCursor key key.
			(Smalltalk classNamed: variableName) ifNotNil: [ :classToRename |
				^self renameClassOn: self codeProvider for: classToRename ].
			(Smalltalk bindingOf: variableName) ifNotNil: [
				^self renameGlobalOn: self codeProvider for: variableName ] ].

		^morph flash ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582208!
replaceUnicodeArrowsWithSmalltalkArrows
	"Useful, for instance, to paste code from TheCuisBook.pdf.
	Some day we may change our minds, or maybe add a preference."

	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582217!
inlineTemporaryVariable

	"To prevent the refactoring to be evaluated on editors w/o methods like the workspace - Fernando"
	self hasValidCurrentCompiledMethod ifFalse: [ ^ nil ].

	InlineTemporaryVariableApplier createAndValueHandlingExceptions: [
		InlineTemporaryVariableApplier
			on: self
			for: self selectionInterval asSourceCodeInterval
			of: self codeProvider currentCompiledMethod ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582233!
contextualAddParameter: aKeyboardEvent 
	
	self contextualAddParameter.
	^true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582240 overrides: 50586147!
balloonTypeInfoAt: mousePositionInText

	^self isEditingClassDefinition 
		ifTrue: [ self balloonTypeInfoOfInstanceVariableAt: mousePositionInText ]
		ifFalse: [ self balloonTypeInfoInMethodAt: mousePositionInText ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582251!
informRefactoringCanOnlyBeAppliedInClassDefinition

	self inform: 'This refactoring can only be applied from the class definition'! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582259!
contextualMoveInstanceVariableInClassDefinitionOf: aClassDefinitionNode in: aSelectedClass 
	
	| analyzer cursorPosition |
	
	analyzer := ClassDefinitionNodeAnalyzer for: aClassDefinitionNode.
	cursorPosition := self startIndex.
	
	(analyzer isAtInstanceVariables: cursorPosition) 
		ifTrue: [ |selection variableToMove|
			selection := self selectedString.
			variableToMove := selection isEmpty ifTrue: [ self wordUnderCursor ] ifFalse: [ selection ].
			^self moveInstanceVariableOn: self codeProvider for: variableToMove at: aSelectedClass ].
		
	(analyzer isAtClassName: cursorPosition)
		ifTrue: [ ^self moveInstanceVariableOn: self codeProvider at: aSelectedClass ].
	
	morph flash
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582284!
explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg provider |
	provider := self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg := provider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last = $: ifFalse: [^ nil].
	"Name of this method"
	lits := Array with: msg.
	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply := ', which is the selector of this very method!!'.
			s := self class plateA]
		ifNil: [ 
			"Selectors called from this method"
			lits := (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole := lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply := '.'.
			s := self class plateB].
		classes := Smalltalk allClassesImplementing: whole.
		classes size > 12
			ifTrue: [classes := 'many classes']
			ifFalse: [classes := 'these classes ' , classes printString].
		^ String streamContents: [:str |
			str
				nextPutAll: string;
				nextPutAll: ' is one part of the message selector ';
				nextPutAll: whole;
				nextPutAll: reply;
				nextPutAll: '  It is defined in ';
				nextPutAll: classes;
				nextPutAll: s]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582334!
runAndDebuggIfNecessary: aPotencialTestMethod

	aPotencialTestMethod isTestMethod ifTrue: [
		aPotencialTestMethod methodClass debug: aPotencialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582343!
contextualChangeSelectorUsing: aChangeSelectorApplier
	
	self isEditingClassDefinition 
		ifTrue: [ morph flash ]
		ifFalse: [ self ifSourceCodeRefactoringCanBeAppliedDo: [ self contextualChangeSelectorInMethodUsing: aChangeSelectorApplier ]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582354!
ifSourceCodeRefactoringCanBeAppliedDo: aBlock

	^(self hasUnacceptedEdits or: [morph hasEditingConflicts ])
		ifTrue: [ self inform: 'This refactoring can not be applied when there are unsaved changes' ]
		ifFalse: aBlock! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582365!
contextualRenameInClassDefinitionOf: aClassDefinitionNode in: aSelectedClass 
	
	| analyzer cursorPosition |
	
	analyzer := ClassDefinitionNodeAnalyzer for: aClassDefinitionNode.
	cursorPosition := self startIndex.
	
	(analyzer isAtSuperclass: cursorPosition) 
		ifTrue: [ ^self renameClassOn: self codeProvider for: analyzer superclass ].
	
	(analyzer isAtClassName: cursorPosition)
		ifTrue: [ ^self renameClassOn: self codeProvider for: aSelectedClass ].
		
	(analyzer isAtInstanceVariables: cursorPosition) 
		ifTrue: [ |selection variableToRename|
			selection := self selectedString.
			variableToRename := selection isEmpty ifTrue: [ self wordUnderCursor ] ifFalse: [ selection ].
			^self renameInstanceVariableOn: self codeProvider for: variableToRename at: aSelectedClass ].
		
	(analyzer isAtCategory: cursorPosition)
		ifTrue: [ 
			"I'm sure codeProvider is a Browser - Hernan"
			^self codeProvider renameSystemCategory ].
		
	morph flash
	
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582399!
afterCompiling: aSourceCode do: aBlock ifFail: failBlock

	| context provider receiver |
	
	provider := self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver := provider doItReceiver.
			context := provider doItContext]
		ifFalse: [
			receiver := context := nil].

	^self afterCompiling: aSourceCode do: aBlock for: receiver in: context ifFail: failBlock.
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582415!
fileItIn
	"Make a Stream on the text selection and fileIn it."

	self selection fileIn! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582421!
hasValidCurrentCompiledMethod

	^ (self codeProvider respondsTo: #currentCompiledMethod)
		and: [ self codeProvider currentCompiledMethod notNil ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582430 overrides: 50590149!
clipboardStringOrText
	| clipContents |
	clipContents := super clipboardStringOrText.
	self replaceUnicodeArrowsWithSmalltalkArrows ifTrue: [
		clipContents := clipContents copyReplaceAll: `(UnicodeCodePoint codePoint: 16r2190) asString` with: `(Character smalltalkLeftArrow ) asString`.
		clipContents := clipContents copyReplaceAll: `(UnicodeCodePoint codePoint: 16r2191) asString` with: `(Character smalltalkUpArrow ) asString`.
		].
	^clipContents.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582448!
extractAsParameter

	^ RefactoringApplier extractAsParameterApplier createAndValueHandlingExceptions: [
		RefactoringApplier extractAsParameterApplier
			from: self selectionInterval 
			on: model textProvider 
			for: self codeProvider selectedMessageName 
			in: self selectedClassOrMetaClassOrUndefinedObject  ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582462!
inspectIt

	self lineOrNodeSelectAndEmptyCheck: [^ self ].
	self
		evaluateSelectionAndDo: [ :result | result inspect ]
		ifFail: [ ^morph flash ]
		profiled: false.
	morph convertAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582474!
createMenuCollectingOptionsWith: aMenuOptionsSelector
	
	^(DynamicMenuBuilder buildTitled: self class name targeting: self collectingMenuOptionsWith: aMenuOptionsSelector)
		addStayUpIcons;
		yourself
		
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582484!
inClassDefinitionContextuallyApply: aBlock

	self ifEditingClassDefinitionDoOrWarn: [
		self ifSourceCodeRefactoringCanBeAppliedDo: [
			self
				withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
					self apply: aBlock inClassDefinitionOf: classDefinitionNode in: selectedClass ]
				ifErrorsParsing: [ :anError | morph flash ]]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582499!
cancel: aKeyboardEvent
	"Cancel all edits done. Revert to saved version."

	model refetch.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582506!
fileItIn: aKeyboardEvent
	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."

	self fileItIn.
	^ true! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582514!
changeSelector: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector using: aChangeSelectorApplier

	aNodeUnderCursor isMessageNode 
		ifTrue: [ self changeSelectorOf: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector using: aChangeSelectorApplier ]
		ifFalse: [ morph flash ]
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582527!
contextualPushUpInClassDefinition 

	self inClassDefinitionContextuallyApply: [ :aSelectedClass | 
		(PushUpInstanceVariableApplier 
			on: self codeProvider 
			for: self wordUnderCursor 
			at: aSelectedClass) value ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582538!
evaluate: aSourceCode andDo: aBlock ifFail: failBlock profiled: doProfile
	
	| result | 
	
	^ self 
		afterCompiling: aSourceCode 
		do: [ :compiler :method :receiver :context | method ifNotNil: [
			result := compiler evaluateMethod: method to: receiver logged: true profiled: doProfile.
			aBlock notNil ifTrue: [
				aBlock value: result ]]]
		ifFail: failBlock.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582553!
explain
	"Try to shed some light on what kind of entity the current selection is. 
	The selection must be a single token or construct. Insert the answer after 
	the selection. Send private messages whose names begin with 'explain' 
	that return a string if they recognize the selection, else nil."

	| string tiVars cgVars selectors delimitors numbers sorry reply symbol provider |
	sorry := 'Sorry, I can''t explain that.  Please select a single
token, construct, or special character.'.
	(string := self selectedString) isEmpty
		ifTrue: [reply := '']
		ifFalse: [
			string := string withBlanksTrimmed.
			"Remove space, tab, cr"
			"Temps and Instance vars need only test strings that are all letters"
			(string detect: [:char | char isValidInIdentifiers not]
				ifNone: nil) ifNil: [
					tiVars := (self explainTemp: string)
						ifNil: [self explainInst: string]].
					
			provider := self codeProvider.
			(tiVars == nil and: [provider respondsTo: #explainSpecial:])
				ifTrue: [tiVars := provider explainSpecial: string].
			tiVars := tiVars
				ifNil: [ '']
				ifNotNil: [ tiVars , '\' withNewLines].
			"Context, Class, Pool, and Global vars, and Selectors need 
			only test symbols"
			(Symbol hasInterned: string ifTrue: [:s | symbol := s])
				ifTrue: [
					cgVars := (self explainCtxt: symbol) 
						ifNil: [ (self explainClass: symbol)
							ifNil: [ self explainGlobal: symbol]].
					"See if it is a Selector (sent here or not)"
					selectors := (self explainMySel: symbol)
						ifNil: [(self explainPartSel: string)
							ifNil: [ self explainAnySel: symbol]]]
				ifFalse: [selectors := self explainPartSel: string].
			cgVars := cgVars
				ifNil: [ '']
				ifNotNil: [cgVars , '\' withNewLines].
			selectors := selectors
				ifNil: [ '']
				ifNotNil: [ selectors , '\' withNewLines].
			delimitors := string size = 1
				ifTrue: ["single special characters"
					self explainChar: string]
				ifFalse: ["matched delimitors"
					self explainDelimitor: string].
			numbers := self explainNumber: string.
			numbers ifNil: [numbers := ''].
			delimitors ifNil: [delimitors := ''].
			reply := tiVars , cgVars , selectors , delimitors , numbers].
	reply isEmpty ifTrue: [reply := sorry].

	morph showBalloon: reply.
	self runningWorld ifNotNil: [ :w | w findATranscript ].
	reply print! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582629!
extractMethod: aKeyboardEvent

	self extractMethod.
	^true! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582635!
plateX
	"As in boiler plate. Answer a string which appears in several explanations"
	
	^ ' go to the message list pane, get the menu, and select ''implementors of...''.'! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582645 overrides: 50586266!
releaseClassCachedState

	"We are not calling super to avoid cleansing class vars many times.
	So, repeat inherited class instVars!!"
	shortcuts := nil.
	cmdShortcuts := nil! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582654!
plateB
	"As in boiler plate. Answer a string which appears in several explanations"
	
	^ '.  To see the definitions,', self plateX! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582662!
smalltalkEditorEditingMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 			-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 			-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 			-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 			-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 			-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 			-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 			-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 			-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 			-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 			-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'Paste...'.
				#selector 			-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 			-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 			-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 			-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Set Font Size'.
				#selector 			-> 		#offerFontSizeMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
		}`.! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582777 overrides: 50586328!
cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	self flag: #definesKeyboardShortcuts.
	^#(
		#(		$0 	changeEmphasis:							'Normal')
		#(		$1 	changeEmphasis:							'Bold')
		#(		$2 	changeEmphasis:							'Italic')
		#(		$3 	changeEmphasis:							'Underline')
		#(		$4 	changeEmphasis:							'Strikeout')
		#(		$5 	changeEmphasis:							'Superscript')
		#(		$6 	changeEmphasis:							'Subscript')
		#(		$8	#offerColorMenu:							'Change color')
	
		#(		$e	#methodSourceContainingIt:							'Method source containing it')
		#(		$r	#acceptAndDebugTest:							'Saves method and debugs it')
		#(		$t	#acceptAndTest:							'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:							'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$u	#align:							'Toggle alignment')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:							'Print it (selection is a valid expression)')

		#(		$d	#doIt:							'Do it (selection is a valid expression)')
		#(		$k	#offerFontMenu:							'Set font')
		#(		$l	#cancel:							'Cancel all edits')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:							'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:							'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$Q	#argPrev:							'Previous argument')
		#(		$W	#argNext:							'Next argument')
		#(		$E	#methodStringsContainingIt:							'Method strings containing it')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$D	#debugIt:							'Debug it')

		#(		$N	#referencesToIt:							'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582844!
smalltalkEditorMenuOptions
	
	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Help...'.
				#selector 			-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 			-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 			-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 			-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 			-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		50.
				#label 			-> 		'Debug it (D)'.
				#selector 			-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		60.
				#label 			-> 		'Profile it'.
				#selector 			-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		5.
				#label 			-> 	SmalltalkEditor editMenuLabel.
				#selector 			-> 		#yourself.
				#icon 			-> 		#textEditorIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Explain'.
				#selector 			-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 			-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 			-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 			-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 			-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 			-> 		#methodStringsContainingIt.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Method Source with it (e)'.
				#selector 			-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 			-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 			-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 			-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 			-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 			-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}, SmalltalkEditor smalltalkEditorEditingMenuOptions `. ! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582970!
editMenuLabel

	^'Edit'! !
!SmalltalkEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582975!
plateA
	"As in boiler plate. Answer a string which appears in several explanations"
	
	^ '.  To see the other definitions,', self plateX! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50582983 overrides: 16947497!
reversed
	"Answer a copy of the receiver with element order reversed."
	
	| answer |
	answer := self class string: string reversed runs: runs reversed.
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected.
	The way it is done could be considered to be wrong. In this case, instead of making the text to take
	the ParagraphAttributes from the cr characters, it could be done the other way, making the cr's take 
	the ParagraphAttributes of the preceeding char. This way, the attributes would be mostrly preserved.
	I don't know if this is of much use anyway"
	answer fixParagraphAttributesFrom: 1 to: answer size.
	^answer

  "  It is assumed that  self size = runs size  holds. "! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583009!
green
	"Stuff like
	'Hello world' green edit
	"
	self color: Color green! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583015!
black
	"Stuff like
	'Hello world' black edit
	"
	self color: Color black! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583021 overrides: 16829096!
printOn: aStream
	aStream isText
		ifTrue: [aStream nextPutAll: self. ^ self].
	self printNameOn: aStream.
	aStream nextPutAll: ' for '; print: string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583029!
privateSetParagraphAttributes: paragraphAttributes from: start to: stop

	self privateSetRuns: (runs
		copyReplaceFrom: start
		to: stop
		with: ((runs copyFrom: start to: stop) mapValues: [ :attributes |
			Text setParagraphAttributes: paragraphAttributes toArray: attributes]))! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583042 overrides: 16828266!
size
	^runs size! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583046!
attributesAt: characterIndex
	"Answer the code for characters in the run beginning at characterIndex."

	self isEmpty
		ifTrue: [^ #()].  "null text tolerates access"
	^runs at: characterIndex! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583055!
paragraphStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self
		withAttributeValues: textAttributes
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^paragraphStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583068!
justified
	"Stuff like
	('Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. Hello world. ' justified ) edit
	"
	self addAttribute: TextAlignment justified! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583083 overrides: 16947665!
grownTo: newSize
	"Accommodate for the fact that string could hold a String or an ArrayOfCharactersAndCodePoints
	when being streamed to."

	| grownText |
	grownText := Text fromString: (string class new: newSize).
	grownText replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownText! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583096!
asUnicodeStringOrText
	"Answer is either an UnicodeString or a Text including an UnicodeString"

	string isUnicodeString ifTrue: [ ^self ].
	^Text string: string asUnicodeString runs: runs! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583105!
paragraphStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ paragraphStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583116!
alignmentAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ alignment ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583126!
yellow
	"Stuff like
	'Hello world' yellow edit
	"
	self color: Color yellow! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583132!
replaceFrom: start to: stop withString: replacementString attributes: attributesArray startingAt: repStart 
	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. 
	Do it to both the string and the runs.
	The size does not change"

	| newRepRuns |
	string := string replaceFrom: start to: stop with: replacementString startingAt: repStart.
	newRepRuns := RunArray new: stop-start+1 withAll: attributesArray.
	self privateSetRuns: (runs copyReplaceFrom: start to: stop with: newRepRuns).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	self fixParagraphAttributesFrom: start to: start + replacementString size - 1! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583158!
editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583164!
canJoin: attributes1 and: attributes2
	| s |
	s := attributes1 size.
	^s = attributes2 size and: [
		(1 to: s) allSatisfy: [ :i |
			(attributes1 at: i) canBeJoinedWith: (attributes2 at: i) ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583173!
findString: aString startingAt: start 
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583184!
append: stringOrText

	^ stringOrText appendToText: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583189!
gray
	"Stuff like
	'Hello world' gray edit
	"
	self color: Color gray! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583195 overrides: 16913802!
postCopy

	string := string copy.
	runs := runs copy.
	runs mapValues: [ :attributes | attributes collect: [ :attr | attr copy ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583202!
embeddedMorphsFrom: start to: stop 
	"return the list of morphs embedded in me"

	| morphs |
	morphs := IdentitySet new.
	self attributesFrom: start to: stop do: [:attr |
		attr anchoredFormOrMorph ifNotNil: [ :m |
			(m is: #Morph) ifTrue: [
				morphs add: m]]].
	^morphs! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583215 overrides: 16947586!
copyReplaceFrom: start to: stop with: aText

	^self copy replaceFrom: start to: stop with: aText! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583221!
thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult	"
	string := string thatCanHoldCodePoints! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583228!
font: aFont
	"Apply aFont to the entire contents.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	self addAttribute: (TextFontFamily
			familyName: aFont familyName).
	self addAttribute: (TextFontSize
			pointSize: aFont pointSize).! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583239!
struck
	"Stuff like
	('Hello world' struck ) edit
	"
	self addAttribute: TextEmphasis struckThrough! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583246!
red
	"Stuff like
	'Hello world' red edit
	"
	self color: Color red! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583252 overrides: 16947300!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. 
	Do it to both the string and the runs.
	The size does not change"

	| rep newRepRuns |
	rep := replacement asText.	"might be a string"
	string replaceFrom: start to: stop with: rep string startingAt: repStart.
	newRepRuns := rep runs copyFrom: repStart to: repStart + stop - start.
	self privateSetRuns: (runs copyReplaceFrom: start to: stop with: newRepRuns).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	self fixParagraphAttributesFrom: start to: start + replacement size - 1! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583278!
leftFlush
	"Stuff like
	('Hello world' leftFlush ) edit
	"
	self addAttribute: TextAlignment leftFlush! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583285!
appendToText: aText

	| textSize start stop textResult |
	textSize := aText size.
	start := textSize + 1.
	stop := textSize.
	textResult := Text fromString: aText string , self string.
	textResult privateSetRuns: (aText runs copyReplaceFrom: start to: stop with: self runs).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	textResult fixParagraphAttributesFrom: start to: start + self size - 1.
	^ textResult
	! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583303 overrides: 16948381!
customizeExplorerContents

	^ false! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583308!
findStringCaseInsensitive: aString startingAt: start
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findStringCaseInsensitive: aString asPlainString startingAt: start! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583320!
pointSize: pointSize
	"Stuff like
	('Hello World' pointSize: 22) edit
	"
	self addAttribute: (TextFontSize pointSize: pointSize)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583327!
asUtf8Bytes
	"Answer UTF-8 bytes for the string representation of the receiver."
	^string asUtf8Bytes! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583334!
allBold
	"prefer shorter selector"
	self bold! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583339!
embeddedMorphs
	"return the list of morphs embedded in me"
	^self embeddedMorphsFrom: 1 to: self size! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583346 overrides: 16947363!
= other
	"Am I equal to the other Text or String?  
	***** Warning ***** Two Texts are considered equal if they have the same characters in them.  They might have completely different emphasis, fonts, sizes, text actions, or embedded morphs.  If you need to find out if one is a true copy of the other, you must do (text1 = text2 and: [text1 runs = text2 runs])."

	self == other ifTrue: [ ^ true ].
	(other is: #Text) ifTrue: [ "This is designed to run fast even for megabytes"
		^ string == other string or: [string = other string]].
	other isString ifTrue: [^ string == other or: [string = other]].
	^ false! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583369!
lineCount

	^ string lineCount! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583374 overrides: 16829232!
canHoldCodePoints
	"Ask our string"
	^string canHoldCodePoints! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583379!
italic
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis italic! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583388 overrides: 16947284!
replaceFrom: start to: stop with: replacement
	"newSize = oldSize - (stop-start-1) + aText size"
	
	| rep |
	rep := replacement asText.	"might be a string"
	string := string copyReplaceFrom: start to: stop with: rep string.
	self privateSetRuns: (runs copyReplaceFrom: start to: stop with: rep runs).
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	self fixParagraphAttributesFrom: start to: start + replacement size - 1! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583406!
initialFontFrom: someAttributes
	"Apply aFont to those parts that are not already specifying one.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	| fontAttr |
	fontAttr := someAttributes detect: [ :any | any isFont ] ifNone: [ ^ self ].
	runs mapValues: [ :attributes |
		(attributes anySatisfy: [ :attr | attr isFont ])
			ifTrue: [ attributes ]
			ifFalse: [ attributes copyWith: fontAttr ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583422!
isLineEndAt: anIndex
	"Answer true if a line ends at position anIndex.
	Tolerates one position behind last character: 	"
	^string isLineEndAt: anIndex! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583431 overrides: 16947560!
copyFrom: start to: stop 
	"Answer with a copied subrange of this text"

	| realStart realStop |
	stop > self size
		ifTrue: [realStop := self size]		"handle selection at end of string"
		ifFalse: [realStop := stop].
	start < 1
		ifTrue: [realStart := 1]			"handle selection before start of string"
		ifFalse: [realStart := start].
	^Text 
		string: (string copyFrom: realStart to: realStop)
		runs: (runs copyFrom: realStart to: realStop)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583449 overrides: 16829104!
storeOn: aStream 
	aStream nextPutAll: '(Text string: ';
		store: string;
		nextPutAll: ' runs: ';
		store: runs;
		nextPut: $)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583456!
string
	"Answer the string representation of the receiver."
	^string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583462!
blue
	"Stuff like
	'Hello world' blue edit
	"
	self color: Color blue! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583468!
removeAttributesThat: aBlock
	runs mapValues: [ :attributes |
		attributes reject: aBlock ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583474!
shoutDisableEmphasis

	self addAttribute: ShoutDisable new! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583479!
setString: aString setRuns: anArray
	"Warning. No attempt is done to ensure the invariant that TextAttributes that answer true to
	 #isParagraphAttribute are only applied to whole paragraphs.
	Use with care. "

	string := aString.
	self privateSetRuns: anArray! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583491!
magenta
	"Stuff like
	'Hello world' magenta edit
	"
	self color: Color magenta! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583497!
rangeOf: attribute startingAt: index
	"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index."
	^ self isEmpty
		ifTrue: [ index to: index - 1 ]
		ifFalse: [
			runs
				rangeOf: attribute
				startingAt: index ].! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583511!
cyan
	"Stuff like
	'Hello world' cyan edit
	"
	self color: Color cyan! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583517!
characterStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ characterStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583528!
prepend: stringOrText

	self replaceFrom: 1 to: 0 with: stringOrText! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583534!
under
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis underlined! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583543!
sub
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis subscript! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583552 overrides: 16947448!
asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	self setString: string asStreamResult setRuns: runs.
	^self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583560 overrides: 16947518!
, aStringOrText

	^ aStringOrText appendToText: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583565!
isLastSeparator
	^string isLastSeparator! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583570!
removeAttributes: attributesToRemove from: requestedStart to: requestedStop
	"Remove the attribute over the interval start to stop.
	Turned into a command to enable reuse by undo / redo"
	
	(self
		commandForRemoveAttributes: attributesToRemove
		from: requestedStart
		to: requestedStop) doOn: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583583!
fontAt: characterIndex default: defaultFont
	"Answer the font for characters in the run beginning at characterIndex."

	^self fontIfApplying: (self attributesAt: characterIndex) default: defaultFont! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583593 overrides: 16913367!
at: index put: character

	| answer prevChar |
	prevChar := string at: index.
	answer := string at: index put: character.

	"Only fix ParagraphAttributes if there is real danger of breaking the invariant"
	(prevChar isLineSeparator and: [
			(self attributesAt: index) anySatisfy: [ :attr | attr isParagraphAttribute]]) ifTrue: [
		self fixParagraphAttributesFrom: index to: index ].
	
	^answer! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583609!
attributesFrom: start to: stop do: aBlock
	"evaluate aBlock for each attribute in the specified range.
	Warning: aBlock might be evaluated several times for each attribute, but not as many as the characters that it applies to!!."
	runs runsFrom: start to: stop do: [ :attributes |
		attributes do: [ :attribute |
			aBlock value: attribute ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583623!
commandForAddAttribute: aTextAttribute from: requestedStart to: requestedStop

	"Set the attribute for characters in the interval start to stop."
	| intervalToFix start stop new old |
	start := requestedStart.
	stop := requestedStop.
	
	"If aTextAttribute must be applied to whole paragraphs, do so."
	aTextAttribute isParagraphAttribute ifTrue: [
		intervalToFix := self encompassParagraph: (start to: stop).
		start := intervalToFix first.
		stop := intervalToFix last ].

	old := runs copyFrom: start to: stop.
	new := old copy mapValues: [ :attributes | 
			Text addAttribute: aTextAttribute toArray: attributes ].
	^AttributesReplaceCommand
		old: old
		new: new
		start: start
		stop: stop! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583648!
encompassParagraph: anInterval
	^string encompassParagraph: anInterval! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583654!
bold
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis bold! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583663!
rightFlush
	"Stuff like
	('Hello world' rightFlush ) edit
	"
	self addAttribute: TextAlignment rightFlush! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583670!
asText	
	"Answer the receiver itself."
	^self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583675!
hasAnyAttribute
	"Return false if there are no emphasis (i.e., a String would not make a difference)"

	^runs values anySatisfy: [ :emphArray | emphArray notEmpty ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583684!
paragraphStyleChunksDo: aBlock
	"Evaluate aBlock over each chunk (sequence of paragraphs) that have the same paragraphStyle"
	| start nextStart style |
	start := 1.
	nextStart := 1.
	[ start <= self size ] whileTrue: [
		style := self paragraphStyleOrNilAt: start.
		[ nextStart <= self size and: [ (self paragraphStyleOrNilAt: nextStart) = style ]] whileTrue: [
			nextStart := nextStart + 1 ].
		aBlock value: (start to: nextStart-1) value: style.
		start := nextStart ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583702!
commandForReplaceFrom: start to: stop with: replacement

	^TextReplaceCommand
		old: (self copyFrom: start to: stop)
		new: replacement
		at: start! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583711 overrides: 16829410!
is: aSymbol
	^ aSymbol == #Text or: [ super is: aSymbol ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583716!
optimizedForMutationSpeed
	"Do not use RunArray. Optimized for extensive attribute modification."
	
	(runs is: #RunArray) ifTrue: [
		^Text string: string runs: (RunNotArray withAll: runs) ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583725!
runLengthFor: characterIndex 
	"Answer the count of characters remaining in run beginning with 
	characterIndex."

	^runs runLengthAt: characterIndex! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583733!
colorAt: characterIndex
	"Answer the color for characters in the run beginning at characterIndex."

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ color ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583745!
find: attribute
	"Return the first interval over which this attribute applies"
	^ runs find: attribute! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583752!
color: aColor
	"Stuff like
	'Hello world' blue edit
	"
	self addAttribute: (TextColor color: aColor)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583759!
asPlainString
	"Answer a plain String, not a Text."
	^string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583764!
asNumber
	"Answer the number created by interpreting the receiver as the textual
	representation of a number."

	^string asNumber! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583771!
findString: aString startingAt: start caseSensitive: caseSensitive
	"Answer the index of subString within the receiver, starting at index 
	start. If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start caseSensitive: caseSensitive! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583784!
initialFont: aFont
	"Apply aFont to those parts that are not already specifying one.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	| fontAttributes |
	fontAttributes := {TextFontFamily			familyName: aFont familyName.
			TextFontSize pointSize: aFont pointSize}.
	runs mapValues: [ :attributes |
		(attributes anySatisfy: [ :attr | attr isFont ])
			ifTrue: [ attributes ]
			ifFalse: [ attributes, fontAttributes ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583801!
emphasisAt: characterIndex
	"Answer the emphasis for characters in the run beginning at characterIndex."

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ emphasis ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583814!
isSeparators
	"Answer true if the receiver contains only separators (i.e. whitespace)."
	^string isSeparators! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583821!
characterStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		^characterStyle ]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583834!
centered
	"Stuff like
	('Hello world' centered ) edit
	"
	self addAttribute: TextAlignment centered! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583841!
fixParagraphAttributesFrom: start to: end
	"Helper method to ensure the invariant that TextAttributes that answer true to
	 #isParagraphAttribute are only applied to whole paragraphs.
	See senders"
	
	| paragraphEnd paragraphInterval paragraphStart paragraphAttributes|
	self hasAnyParagraphAttribute ifFalse: [ ^self ].
	paragraphEnd := end max: start.	"end could be start-1 when new text is empty, for example, when backspacing"
	[
		paragraphInterval := self encompassParagraph: (paragraphEnd to: paragraphEnd).
		paragraphStart := paragraphInterval first.
		paragraphEnd := paragraphInterval last.
	
		"We must honor the paragraph attributes as defined in the newline (Lf) Character that ends the paragraph"
		paragraphAttributes := (self attributesAt: paragraphEnd) select: [ :attr | attr isParagraphAttribute ].

		"if paragraphEnd is inside the interval just modified, and it doesn't bring any paragraph attributes (i.e., it doesn't end in CR),
		then try to keep the paragraph attributes previously in use in this paragraph..
		This is needed, for example, when pasting an image  or a plain text at the end of the document"
		(paragraphEnd = end and: [ paragraphStart < start and: [ end > 0 and: [ (string at: end) isLineSeparator not ]]]) ifTrue: [
			paragraphAttributes := (self attributesAt: paragraphStart) select: [ :attr | attr isParagraphAttribute ]].

		self privateSetParagraphAttributes: paragraphAttributes from: paragraphStart to: paragraphEnd.
		paragraphEnd := paragraphStart - 1.
		paragraphStart > start ] whileTrue.
	runs coalesce! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583893!
runs
	^runs! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583897 overrides: 16947400!
hash
	"#hash is implemented, because #= is implemented.  We are now equal to a string with the same characters.  Hash must reflect that."

	^ string hash! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583905!
commandForRemoveAttributes: attributesToRemove from: requestedStart to: requestedStop
	"Remove the attribute over the interval start to stop."

	| intervalToFix start stop new old |
	start := requestedStart.
	stop := requestedStop.
	
	"If att must be applied to whole paragraphs, do so."
	(attributesToRemove anySatisfy: [ :att | att isParagraphAttribute ]) ifTrue: [
		intervalToFix := self encompassParagraph: (start to: stop).
		start := intervalToFix first.
		stop := intervalToFix last ].

	old := runs copyFrom: start to: stop.
	new := old copy mapValues: [ :attributes | 
			attributes copyWithoutAll: attributesToRemove].
	^AttributesReplaceCommand
		old: old
		new: new
		start: start
		stop: stop! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583931!
isRemote
	^false! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583936 overrides: 16913349!
at: index 
	^string at: index! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583940!
fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	| font fn ps |
	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		font := defaultFont ifNil: [FontFamily defaultFamilyAndPointSize].
		familyName notNil | pointSize notNil ifTrue: [
			fn := familyName ifNil: [ defaultFont familyName ].
			ps := pointSize ifNil: [ defaultFont pointSize ].
			(FontFamily familyName: fn pointSize: ps) ifNotNil: [ :f |
				font := f emphasized: defaultFont emphasis]].
		^font 	emphasized: (defaultFont emphasis bitOr: emphasis) ].! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583965!
addAttribute: att 
	self isEmpty ifTrue: [ ^self ].
	^ self addAttribute: att from: 1 to: self size! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583972!
edit

	self editLabel: 'Text Editor'! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583977!
hasAnyParagraphAttribute
	"Return false if there are no paragraph attributes"

	^runs values anySatisfy: [ :emphArray | emphArray anySatisfy: [ :attr | attr isParagraphAttribute ]]! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583987 overrides: 16828310!
add: newObject 
	"Adding to an Interval is not allowed."

	self shouldNotImplement! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50583994 overrides: 16913675!
asString
	"Answer a String representation of the textual receiver."
	^string! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584000!
isLastLineSeparator
	^string isLastLineSeparator! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584005!
privateSetRuns: anArray
	"Warning. No attempt is done to ensure the invariant that TextAttributes that answer true to
	 #isParagraphAttribute are only applied to whole paragraphs.
	Use with care. Currently only used for Shout, that seems to know what it does.
	Also used for private use, replacing asignment to the ivar, to ensure that the RunArray is set to properly compare TextAttributes"

	runs := anArray.
	runs canJoinMessage: (MessageSend receiver: self selector: #canJoin:and:)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584024!
super
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z ^ ℵ' sub, '(1 / z)' ) edit
	"
	self addAttribute: TextEmphasis superscript! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584033!
encompassLine: anInterval
	^string encompassLine: anInterval! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584038!
addAttribute: aTextAttribute from: requestedStart to: requestedStop
	"Set the attribute for characters in the interval start to stop.
	Turned into a command to enable reuse by undo / redo"
	(self
		commandForAddAttribute: aTextAttribute
		from: requestedStart
		to: requestedStop) doOn: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584051 overrides: 16829426!
isEmpty
	^self size = 0! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584055!
appendToString: aString

	| stringSize |
	stringSize := aString size.
	^ (aString asText) 
			replaceFrom: stringSize + 1
			to: stringSize 
			with: self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584064 overrides: 16914685!
displayStringOrText
	"To be used in the UI"
	"Answer the receiver itself."

	^self! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584070!
basicReplaceAttributesFrom: start to: stop with: replacement
	"Private. Does not enforce invariants.
	replacement size = (stop-start-1) "
	
	self privateSetRuns: (runs basicReplaceAttributesFrom: start to: stop with: replacement)! !
!Text methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584081!
withAttributeValues: attributes do: aBlock
	"Evaluate aBlock with the values of various attributes that affect text formatting, applied in the correct order
	The order is (each overwriting the previous one)
	1) basic defaults
	2) ParagraphStyleReferene
	3) CharacterStyleReference
	4) TextFontReference
	5) TextEmphasis"

	| paragraphStyle characterStyle familyName pointSize emphasis alignment color backgroundColor |
	paragraphStyle := nil.
	characterStyle := nil.
	familyName := nil.
	pointSize := nil.
	emphasis := 0.
	alignment := nil.
	color := nil.
	backgroundColor := nil.
	
	"ParagraphStyle is the first to set several values"
	attributes do: [ :attribute |
		attribute forParagraphStyleReferenceDo: [ :s |
			paragraphStyle := s.
			familyName := s familyName.
			pointSize := s pointSize.
			emphasis := s emphasis.
			alignment := s alignment.
			s color ifNotNil: [ :c | color := c ]]].

	"CharacterStyle, if present, can override font and color"
	attributes do: [ :attribute |
		attribute forCharacterStyleReferenceDo: [ :s |
			characterStyle := s.
			familyName := s familyName.
			pointSize := s pointSize.
			emphasis := s emphasis.
			s color ifNotNil: [ :c | color := c ]]].

	"These will not interfere with each other, and all of them take precedence over previous values"
	attributes do: [ :attribute |
		attribute forFontFamilyDo: [ :fn | familyName := fn ].
		attribute forFontSizeDo: [ :ps | pointSize := ps ].
		attribute forTextEmphasisDo: [ :e | emphasis := emphasis bitOr: e ].
		attribute forTextColorDo: [ :c | color := c ].
		attribute forTextBackgroundColorDo: [ :c | backgroundColor := c ].
		attribute forTextAlignmentDo: [ :a | alignment := a ].
	].
	
	"Done. Now evaluate the block."
	^aBlock valueWithArguments: { familyName. pointSize. emphasis. color. alignment. characterStyle. paragraphStyle. backgroundColor }! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584143 overrides: 16787780!
new: stringSize 
	^self fromString: (String new: stringSize)! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584149!
setParagraphAttributes: paragraphAttributes toArray: others
	"Make paragraphAttributes the only paragraph attributes,
	but keep characterAttributes to an existing set"
	
	^ Array streamContents: [:strm |
		paragraphAttributes do: [ :att |
			strm nextPut: att ].
		others do: [ :other | 
			other isParagraphAttribute ifFalse: [ strm nextPut: other ]]]! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584164!
withForm: aForm
	"
	('Hello', (Text withForm: ImageMorph defaultForm), 'world') edit
	"
	^' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aForm)), ' '! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584173!
initialFont: aFont stringOrText: aStringOrText
	"Answer an instance of me whose characters are aString.
	Note: use #baseFont. If emphasis is desired, add it separatedly."

	(aStringOrText is: #Text) ifTrue: [
		^aStringOrText initialFont: aFont ].
	
	^self string: aStringOrText attributes: {
			TextFontFamily familyName: aFont familyName.
			TextFontSize pointSize: aFont pointSize }! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584189!
fromString: aString 
	"Answer an instance of me whose characters are those of the argument, aString."

	^ self string: aString attributes: #()! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584197!
string: aString runs: anArray  
	^self basicNew setString: aString setRuns: anArray! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584203!
addAttribute: newTextAttribute toArray: existingAttributes
	"Add a new text attribute to an existing set"

	| includeNew |
	includeNew := true.
	^ Array streamContents: [ :strm |
		existingAttributes do: [ :existing |
			(newTextAttribute dominates: existing) ifFalse: [
				"Keep existing unless new dominates it."
				strm nextPut: existing.
				"If new doesn't dominate existing, perhaps existing dominates new."
				(existing dominates: newTextAttribute) ifTrue: [
					"Don't add new if an existing attribute dominates it."
					includeNew := false ]
				]].
		includeNew ifTrue: [ strm nextPut: newTextAttribute ]].! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584227 overrides: 16787772!
new

	^self fromString: ''! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584231!
string: aString 
	"Answer an instance of me whose characters are those of the argument, aString."

	^ self string: aString attributes: #()! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584239!
string: aString attributes: atts
	"Answer an instance of me whose characters are those of aString.
	atts is an array of TextAttributes."

	^self string: aString runs: (RunArray new: aString size withAll: atts)! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584249!
string: aString attribute: att
	"Answer an instance of me whose characters are aString.
	att is a TextAttribute."

	^self string: aString attributes: (Array with: att)! !
!Text class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584258!
initialFont: aFont string: aString attribute: aTextAttribute
	"Answer an instance of me whose characters are aString.
	Note: use #baseFont. If emphasis is desired, add it separatedly."

	^self
		string: aString
		attributes: {
			TextFontFamily familyName: aFont familyName.
			TextFontSize pointSize: aFont pointSize.
			aTextAttribute}! !
!TextCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584272!
undoOn: aTextModel
	"Undo the command, bringing the text model to the state it had prior to doing it"
	^nil! !
!TextCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584279!
doOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing"
	^nil! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584286 overrides: 16913521!
bindingOf: aString
	^model bindingOf: aString! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584291!
addCutAndPasteMenuSectionTo: aMenu
	"Adds  typical cut and paste operations section to a menu"

	self flag: #assumesKeyboardShortcuts.
	self hasUnacceptedEdits ifTrue: [
		aMenu
			add: 'Accept (s)'
			action: #acceptContents
			icon: #acceptIcon
	].
	
	aMenu
		add: 'Copy (c)'
		action: #copySelection
		icon: #copyIcon.
	
	aMenu
		add: 'Cut (x)'
		action: #cut
		icon: #cutIcon.

	aMenu
		add: 'Paste (v)'
		action: #paste
		icon: #pasteIcon.
		
	aMenu
		add: 'Paste without Format'
		action: #pasteString
		icon: #pasteIcon.
	
	aMenu
		add: 'Paste...'
		action: #pasteRecent
		icon: #worldIcon.
	
	^aMenu! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584314!
offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel := self selection.
	colors := #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index := (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute := TextColor color: (Color perform: (colors at: index)) ]
		ifFalse: [
			index := index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute := self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	morph updateFromTextComposition.
	^ true.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584343 overrides: 50589476!
pointIndex
	pointBlock ifNil: [^1].
	^ pointBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584349!
doubleClickAndHalf

	| here interval |
	here := self pointIndex.
	interval := self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection := false.
	doParagraphSelection := true.
	initialSelectionStart := self startBlock.
	initialSelectionStop := self stopBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584363!
addAttributesForPasting: replacement
	^ (replacement is: #Text)
		ifTrue: [ replacement ]
		ifFalse: [
			Text
				string: replacement
				attributes: emphasisHere ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584372 overrides: 50589445!
moveCursor: directionBlock forward: forward event: aKeyboardEvent

	super moveCursor: directionBlock forward: forward event: aKeyboardEvent.
	self setEmphasisHereFromTextForward: forward! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584381!
copyHiddenInfo
	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden
info.  Copy that to the clipboard.  You can paste it and see what it is.
Usually enclosed in <>."

	^ self clipboardTextPut: self hiddenInfo! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584392!
unapplyAttributes: textAttributes
	"The user selected textAttributes to be removed.
	If there is a selection, unapply the attributes to the selection.
	In any case do not use the attribute for the user input (emphasisHere)"
	"This generates undo"

	| interval |
	emphasisHere := emphasisHere copyWithoutAll: textAttributes.
	interval := self selectionInterval.
	(interval isEmpty and: [ textAttributes noneSatisfy: [ :each | each isParagraphAttribute ]])
		ifTrue: [ ^self ].
	model logUndoAndRemoveAttributes: textAttributes from: interval first to: interval last.
	textComposition recomposeFrom: interval first to: interval last delta: 0.
	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
	morph possiblyChanged! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584420!
align: aKeyboardEvent
	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"

	self align.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584427!
lastFont
	"Answer the Font for to be used if positioned at the end of the text"

	^self startIndex > model textSize
		ifTrue: [ model actualContents fontIfApplying: emphasisHere default: defaultFont ]
		ifFalse: [ model actualContents fontAt: model textSize +1 default: defaultFont ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584439!
makeUppercase: aKeyboardEvent
	"Force the current selection to uppercase.  Triggered by Cmd-Y."
	"This is a user command, and generates undo"

	self replaceSelectionWith: self selectedString asUppercase.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584449!
blinkParen
	"Used if Shout"
	lastParenLocation ifNotNil: [
		model textSize >= lastParenLocation ifTrue: [
			model privateAddBoldAt: lastParenLocation ]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584457!
removeMorph: aMorph
	"This is a user command, and generates undo"

	| range |

	"Warning: As undo will only be done for text in the model, undoing this will neither
	recreate the morph nor add it to the TextMorph!! (See senders of #insertMorph:at:
	A specific undo for inserting / removing morphs might be in order. But I doubt the
	TextModel should be responsible for that."
	self flag: #jmv.

	range := model actualContents find: (TextAnchor new anchoredFormOrMorph: aMorph).
	range ifNotNil: [
		model logUndoAndReplaceFrom: range first to: range last with: Text new.
		textComposition recomposeFrom: range first to: range first  -1 delta: range size negated ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584481!
indent: aKeyboardEvent
	"Add a tab at the front of every line occupied by the selection. Invoked from keyboard via cmd-shift-R.  2/29/96 sw"

	^ self inOutdent: aKeyboardEvent delta: 1! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584490!
makeLowercase: aKeyboardEvent
	"Force the current selection to lowercase.  Triggered by Cmd-X."
	"This is a user command, and generates undo"

	self replaceSelectionWith: self selectedString asLowercase.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584500!
blinkPrevParen: aCharacter
	"Used if not Shout"
	| closingDelimiter openingDelimiter level string here hereChar |
	string := self privateCurrentString.
	here := pointBlock stringIndex.
	closingDelimiter := aCharacter.
	openingDelimiter := '([{' at: (')]}' indexOf: closingDelimiter).
	level := 1.
	[ level > 0 and: [ here > 1 ]]
		whileTrue: [
			hereChar := string at: (here := here - 1).
			hereChar = openingDelimiter
				ifTrue: [
					level := level - 1.
					level = 0
						ifTrue: [^ self blinkParenAt: here]]
				ifFalse: [
					hereChar = closingDelimiter
						ifTrue: [ level := level + 1]]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584522!
wrapOnOff
	"Toggle WordWrap"

	morph wrapOnOff! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584527!
recomputeSelection
	"The same characters are selected but their coordinates may have changed."

	self markIndex: self markIndex pointIndex: self pointIndex.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584536!
backTo: startIndex
	"During typing, backspace to startIndex."
	"This is a user command, and generates undo"

	self markIndex: startIndex.
	self replaceSelectionWith: self nullText.
	markBlock := pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584546!
dispatchOn: aKeyboardEvent
	"Carry out the action associated with this character, if any."

	| codePoint asciiValue c |
	self clearParens.
  	codePoint := aKeyboardEvent keyValue.
	
	codePoint > 255 ifTrue: [
		^self normalCharacter: aKeyboardEvent ].

	asciiValue := codePoint.
	"Control keys are handled by #shortcuts even if they have any modifiers"
	(self shouldHandleUsingCmdShortcuts: aKeyboardEvent) ifTrue: [
		^self perform: (self cmdShortcuts at: asciiValue + 1) with: aKeyboardEvent ].

	c := aKeyboardEvent keyCharacter.
	(')]}' includes: c)
		ifTrue: [ self blinkPrevParen: c ].

	^ self perform: (self shortcuts at: asciiValue + 1) with: aKeyboardEvent.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584570!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	aMouseButtonEvent shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(textComposition characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock := textComposition characterBlockAtPoint: localEventPosition.
			cursorIndex := cursorBlock stringIndex.
			startBlock := self startBlock min: cursorBlock.
			startIndex := startBlock stringIndex.
			stopBlock := self stopBlock max: cursorBlock.
			stopIndex := stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock := startBlock.
					pointBlock := cursorBlock ]
				ifFalse: [
					markBlock := stopBlock.
					pointBlock := cursorBlock ]].
	self storeSelectionInComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584602 overrides: 16932297!
initialize
	initialSelectionStart := nil.
	initialSelectionStop := nil.
	doWordSelection := false.
	doParagraphSelection := false.
	defaultFont := FontFamily defaultFamilyAndPointSize! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584611!
offerFontStyleMenu
	"This is a user command, and generates undo"

	| emphases menuStrings entries reply code startIndex attribute |
	startIndex := self startIndex.
	code := model actualContents emphasisAt: startIndex.
	emphases := #(bold italic underlined struckThrough superscript subscript).
	menuStrings := Array streamContents: [ :strm |
		strm nextPut:(code isZero ifTrue: ['<on>'] ifFalse: ['<off>']), 'normal'.
		emphases do: [ :emph |
			strm nextPut:
				((code anyMask: (TextEmphasis perform: emph) emphasisCode)
					ifTrue: ['<on>'] ifFalse: ['<off>']),
				emph asPlainString ]].
	entries := `#(normal)`, emphases.
	reply := (SelectionMenu labelList: menuStrings lines: #(1) selections: entries) startUpMenu.
	reply ifNotNil: [
		attribute := TextEmphasis perform: reply.
		((menuStrings at: (entries indexOf: reply)) beginsWith: '<on>')
			ifTrue: [ self unapplyAttributes: {attribute} ]
			ifFalse: [ self applyAttribute:  attribute ]].
	morph updateFromTextComposition.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584646 overrides: 50589672!
markIndex
	markBlock ifNil: [^1].
	^ markBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584651!
outdent: aKeyboardEvent
	"Remove a tab from the front of every line occupied by the selection.
	Invoked from keyboard via cmd-shift-L.  2/29/96 sw"

	^ self inOutdent: aKeyboardEvent delta: -1! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584661 overrides: 50589677!
userHasEdited

	morph hasUnacceptedEdits: model isDirty! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584666!
cursorEnd: aKeyboardEvent 

	"Private - Move cursor end of current line."

	self
		moveCursor: [ :position |
			"Mac standard keystrole"		
			(aKeyboardEvent commandAltKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ self endOfText ]
					ifFalse: [ self endOfLine: position ]]
		forward: true
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584682 overrides: 50589691!
selectionIsEmptyOrSeparators
	"Answer true if no selection or selection is just separators (whitespace)"

	self hasSelection ifFalse: [ ^true ].
	^self selection isSeparators! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584691!
findAgain: aKeyboardEvent 
	"Find the desired text again.  1/24/96 sw"

	self findAgain.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584698!
addString: aString
	"Think of a better name"
	"This is a user command, and generates undo"

	self replaceSelectionWith: aString! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584706!
find
	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"

	self
		request: 'Find what?'
		initialAnswer: self class findText
		do: [:aString|
			aString isEmpty ifFalse:
				["Set focus on our text morph, so that cmd-g does the search again"
				morph world activeHand newKeyboardFocus: morph.
				self setSearch: aString.
				ChangeText := self class findText.  "Implies no replacement to againOnce: method"
				(self findAndReplaceMany: false)
					ifFalse: [ self flash ].
				morph scrollSelectionIntoView ]].

"	morph installEditorToReplace: self"! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584729!
redo: aKeyboardEvent 
	"Redo the last edit."

	self redo.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584735!
selection
	"Answer the text that is currently selected."

	| t firstIndex lastIndex |
	t := model actualContents.
	firstIndex := self startIndex.
	lastIndex := self stopIndex - 1.
	(firstIndex = 1 and: [ lastIndex = t size ])
		ifTrue: [ ^t copy ].
	^t copyFrom: firstIndex to: lastIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584748!
cut
	"Cut out the current selection and redisplay if necessary."
	"This is a user command, and generates undo"

	| selection |
	self lineSelectAndEmptyCheck: [^ self].
	selection := self selection.
	self replaceSelectionWith: self nullText.
	self clipboardTextPut: selection.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584761 overrides: 50589788!
beginningOfLine: position
	"Redefined in subclasses using TextComposition"
	^ (textComposition lines at: (textComposition lineIndexFor: position)) first! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584769!
insertAndSelect: aString at: anInteger
	"This is a user command, and generates undo"

	| newText |
	newText := (aString is: #Text) ifTrue: [aString] ifFalse: [Text string: aString attributes: emphasisHere].
	self deselectAndPlaceCursorAt: anInteger.
	self replaceSelectionWith: newText.
	self selectFrom: anInteger to: anInteger + newText size - 1! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584783!
processKeystrokeEvent: aKeyboardEvent
	"Key struck on the keyboard. Find out which one and, if special, carry 
	out the associated special action. Otherwise, add the character to the 
	stream of characters."

	(self dispatchOn: aKeyboardEvent) ifTrue: [
		self storeSelectionInComposition.
		^self].

	markBlock := pointBlock.
	self storeSelectionInComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584798!
insertMorph: aMorph at: relPt
	"This is a user command, and generates undo"
	| index newText |

	"Warning: As undo will only be done for text in the model, undoing this will neither
	kill the morph nor send it to another owner!! See implementors of #removeMorph: in TextMorphs.
	A specific undo for inserting / removing morphs might be in order. But I doubt the
	TextModel should be responsible for that."
	self flag: #jmv.

	index := (textComposition characterBlockAtPoint: relPt) stringIndex.
	newText := ' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aMorph)), ' '.
	model logUndoAndReplaceFrom: index to: index-1 with: newText.
	textComposition recomposeFrom: index to: index + newText size -1 delta: newText size.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584825!
makeCapitalized: aKeyboardEvent
	"Force the current selection to uppercase.  Triggered by Cmd-X."
	"This is a user command, and generates undo"

	| prev |
	prev := $-.  "not a letter"
	self replaceSelectionWith: 
		(self selectedString collect:
			[:c | prev := prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]]).
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584839!
flushUndoRedoCommands
	model flushUndoRedoCommands! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584844!
offerFontSizeMenu
	| startIndex currentFont fontFamily attr |
	startIndex := self startIndex.
	currentFont := model actualContents fontAt: startIndex default: defaultFont.
	fontFamily := currentFont family.
	(FontFamily
		promptUserForSize: currentFont pointSize
		fontFamily: fontFamily) ifNotNil: [ :ptSize |
			attr := TextFontSize pointSize: ptSize.
			self applyAttribute: attr.
			morph updateFromTextComposition ].! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584861!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Change the selection in response to mouse-down drag"

	| newPointBlock goingBackwards newStartBlock newStopBlock interval i1 i2 |
	newPointBlock := textComposition characterBlockAtPoint: localEventPosition.
	goingBackwards := newPointBlock stringIndex < markBlock stringIndex.

	doWordSelection ifTrue: [
		pointBlock := newPointBlock.
		self selectWord.
		newStartBlock := self startBlock min: initialSelectionStart.
		newStopBlock := self stopBlock max: initialSelectionStop.
		markBlock := goingBackwards ifTrue: [newStopBlock] ifFalse: [newStartBlock].
		pointBlock := goingBackwards ifTrue: [newStartBlock] ifFalse: [newStopBlock].
		self storeSelectionInComposition.
		^self ].

	doParagraphSelection ifTrue: [
		i1 := newPointBlock stringIndex min: initialSelectionStart stringIndex.
		i2 := newPointBlock stringIndex max: initialSelectionStop stringIndex-1.
		interval := self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		newStartBlock := self startBlock min: initialSelectionStart.
		newStopBlock := self stopBlock max: initialSelectionStop.
		markBlock := goingBackwards ifTrue: [newStopBlock] ifFalse: [newStartBlock].
		pointBlock := goingBackwards ifTrue: [newStartBlock] ifFalse: [newStopBlock].
		self storeSelectionInComposition.
		^self ].

	pointBlock := newPointBlock.
	self storeSelectionInComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584910!
acceptContents
	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"
	^morph acceptContents! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584920!
inOutdent: aKeyboardEvent delta: delta
	"Add/remove a tab at the front of every line occupied by the selection.
	This is a user command, and generates undo"

	| realStart realStop lines startLine stopLine start stop adjustStart size inStream outStream |

	"Operate on entire lines, but remember the real selection for re-highlighting later"
	realStart := self startIndex.
	realStop := self stopIndex - 1.

	"Special case: the text cursor on a line of its own, including weird case at end of paragraph"
	(realStart > realStop and: [
				realStart < 2 or: [(self privateCurrentString at: realStart - 1) isLineSeparator ]])
		ifTrue: [
			delta < 0
				ifTrue: [
					morph flash]
				ifFalse: [
					self replaceSelectionWith: Character tab asSymbol.
					self deselectAndPlaceCursorAt: realStart + 1].
			^true].

	lines := textComposition lines.
	startLine := textComposition lineIndexFor: realStart.
	stopLine := textComposition lineIndexFor: (realStart max: realStop).
	start := (lines at: startLine) first.
	stop := (lines at: stopLine) last.
	
	"Pin the start of highlighting unless the selection starts a line"
	adjustStart := realStart > start.

	size :=  stop + 1 - start.
	inStream := self privateCurrentString readStreamFrom: start to: stop.
	outStream := UnicodeString writeStream.

	"This subroutine does the actual work"
	self indent: delta fromStream: inStream toStream: outStream.

	"Adjust the range that will be highlighted later"
	adjustStart ifTrue: [realStart := (realStart + delta) max: start].
	realStop := realStop + outStream position - size.

	"Prepare for another iteration"
	self selectInvisiblyFrom: start to: stop.
	self replaceSelectionWith: outStream contents.
	self selectFrom: realStart to: realStop. 	"highlight only the original range"
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584979!
compareToClipboard: aKeyboardEvent
	"Compare the receiver to the text on the clipboard."

	self compareToClipboard.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584986!
wordUnderCursor
	
	^self wordAt: self pointIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50584991!
firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine := textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine := currentLine first.
	endOfIndentation := self privateCurrentString
		skipDelimiters: (UnicodeString with: Character tab)
		startingAt: beginningOfLine.
		
	stops := OrderedCollection with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585020!
pointIndex: anIndex
	"Called, for example, when selecting text with shift+arrow keys"
	pointBlock := textComposition characterBlockForIndex: anIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585028!
currentParagraphStyle
	"Answer the ParagraphStyle for the current selection or cursor location if any"
	
	| i |
	i := self startIndex.
	^i > model textSize
		ifTrue: [ model actualContents paragraphStyleOrNilIfApplying: emphasisHere ]
		ifFalse: [ model actualContents paragraphStyleOrNilAt: i ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585041!
markIndex: anIndex
	"Called, for example, when selecting text with shift+arrow keys"
	markBlock := (textComposition characterBlockForIndex: anIndex)
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585049!
enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex := self startIndex.
	stopIndex := self stopIndex.
	oldSelection := self selection.
	which := '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left := '([<{"''`' at: which.
	right := ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left
				and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (UnicodeString with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (UnicodeString with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^ true.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585086!
model: aModel
	model := aModel! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585091!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	| b |

	initialSelectionStart := nil.
	initialSelectionStop := nil.
	doWordSelection := false.
	doParagraphSelection := false.

	b := textComposition characterBlockAtPoint: localEventPosition.
	(textComposition clickAt: localEventPosition) ifTrue: [
		markBlock := b.
		pointBlock := b.
		aMouseButtonEvent hand releaseKeyboardFocus: self.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			markBlock := b.
			pointBlock := b.	
			self setEmphasisHereFromText ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585112!
setSearch: aStringOrText
	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."

	self class findText = aStringOrText
		ifFalse: [FindText := ChangeText := aStringOrText]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585124!
startBlock
	^ pointBlock min: markBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585129!
lastParagraphStyleOrNil
	"Answer the ParagraphStyle for to be used if positioned at the end of the text"

	^self startIndex > model textSize
		ifTrue: [ model actualContents paragraphStyleOrNilIfApplying: emphasisHere ]
		ifFalse: [ model actualContents paragraphStyleOrNilAt: model textSize +1 ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585142!
characterBlockForIndex: anIndex

	^ textComposition characterBlockForIndex: anIndex ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585148!
markIndex: anIndex pointIndex: anotherIndex
	"Called, for example, when selecting text with shift+arrow keys"
	self
		markIndex: anIndex;
		pointIndex: anotherIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585157!
nullText

	^Text string: '' attributes: emphasisHere! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585162!
tabKey: aKeyboardEvent
	"Add/remove a tab at the front of every line occupied by the selection if there is one; treat as a normal character otherwise."
	
	aKeyboardEvent shiftPressed 
		ifTrue: [ ^ self outdent: aKeyboardEvent ].
	
	^ self hasSelection 
		ifTrue: [ self indent: aKeyboardEvent ]
		ifFalse: [ self normalCharacter: aKeyboardEvent ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585176!
changeEmphasis: aKeyboardEvent
	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis."
	"control 0..9 -> 0..9"
	"This is a user command, and generates undo"

	| keyCode attributeToAdd attributesToRemove oldAttributes |
	keyCode := ('0123456'
		indexOf: aKeyboardEvent keyCharacter
		ifAbsent: [ 1 ]) - 1.
	oldAttributes := emphasisHere.

	keyCode = 0
		ifTrue: [
			"Remove all TextEmphasis"
			attributeToAdd := nil.
			attributesToRemove := oldAttributes ]
		ifFalse: [
			"Toggle the indicated TextEmphasis"
			(keyCode between: 1 and: 6) ifTrue: [
				attributeToAdd := TextEmphasis perform: (
					#(#bold #italic #underlined #struckThrough #superscript #subscript)
						at: keyCode).
				oldAttributes do: [ :oldAtt |
					oldAtt = attributeToAdd ifTrue: [
						attributeToAdd := nil.
						attributesToRemove := {oldAtt} ]]]].

	attributeToAdd ifNotNil: [ self applyAttribute: attributeToAdd ].
	attributesToRemove ifNotNil: [ self unapplyAttributes: attributesToRemove ].
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585212!
setSearchString
	"Make the current selection, if any, be the current search string."
	self hasSelection ifFalse: [morph flash. ^ self].
	self setSearch: self selectedString! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585221!
hiddenInfo
	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."

	| attrList |
	attrList := model actualContents attributesAt: (self pointIndex + self markIndex)//2.
	attrList do: [:attr |
		attr forTextActionInfoDo: [ :info |
			^ self selectedString, '<', info, '>']].
	"If none of the above"
	attrList do: [:attr |
		attr forTextColorDo: [ :color |
			^ self selectedString, '<', color printString, '>']].
	^ self selectedString, '[No hidden info]'! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585243!
indent: delta fromStream: inStream toStream: outStream
	"Append the contents of inStream to outStream, adding or deleting delta or -delta
	 tabs at the beginning, and after every NewLine except a final NewLine.  Do not add tabs
	 to totally empty lines, and be sure nothing but tabs are removed from lines."

	| ch skip tab prev atEnd |
	tab := Character tab.
	delta > 0
		ifTrue: [
			"shift right"
			prev := Character newLineCharacter.
			[
			ch := (atEnd := inStream atEnd)
				ifTrue: [ Character newLineCharacter ]
				ifFalse: [ inStream next ].
			(prev isLineSeparator and: [ ch isLineSeparator not ]) ifTrue: [ delta timesRepeat: [ outStream nextPut: tab ]].
			atEnd ] whileFalse: [
				outStream nextPut: ch.
				prev := ch ]]
		ifFalse: [
			"shift left"
			skip := delta.
			"a negative number"
			[ inStream atEnd ] whileFalse: [
				((ch := inStream next) = tab and: [ skip < 0 ]) ifFalse: [ outStream nextPut: ch ].
				skip := ch isLineSeparator
					ifTrue: [ delta ]
					ifFalse: [ skip + 1 ]]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585278!
clearParens
	lastParenLocation ifNotNil: [
		model textSize >= lastParenLocation ifTrue: [
			model privateRemoveBoldAt: lastParenLocation ]].
	lastParenLocation := nil! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585287!
findAndReplaceMany: doMany
	"Subroutine of search: and again.  Use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."
	"jmvnote: We currently have no command for search&replace, but it is really easy to add, and this method supports it. See ChangeText"
	"This is a user command, and generates undo"

	|  indexStream |

	"Find and Change, recording start indices in the array"
	indexStream := WriteStream on: (Array new: 20). "an array to store change locs"
	[(self findAndReplaceOnce: indexStream) & doMany] whileTrue. "<-- this does the work"
	"Answer whether something was found"
	^indexStream notEmpty! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585312!
compareToClipboard
	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."
	| s1 s2 |
	s1 := self clipboardStringOrText string.
	s2 := self selection ifEmpty: [self privateCurrentString].
	s1 = s2 ifTrue: [^ self inform: 'Exact match'].

	(TextModel new contents:
		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))
			openLabel: 'Comparison to Clipboard Text'! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585329!
selectFrom: start to: stop
	"Select the specified characters inclusive.
	I.e. if contents is 'hello' and we want to select the $e, do 'self selectFrom: 2 to: 2'
	If we want to put cursor after e, but with no selection, do 'self selectFrom: 3 to: 2', or better yet, call #selectAt:"
	self selectInvisiblyFrom: start to: stop.
	self storeSelectionInComposition.
	"Preserve current emphasis if selection is empty"
	start > stop ifTrue: [
		self setEmphasisHereFromText ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585347!
undo

	morph disablesEditing ifTrue: [
		^ self ].

	model undoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.				"this could be made more specific..."
			morph possiblyChanged ]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585363 overrides: 50590209!
currentAttributes
	| i |
	i := self startIndex.
	^i > model textSize
		ifTrue: [
			emphasisHere ]
		ifFalse: [
			"paragraph attributes at the current paragraph will later be applied.
			include them in the answer"
			(emphasisHere reject: [ :attr | attr isParagraphAttribute ]),
				((model actualContents attributesAt: i) select: [ :attr | attr isParagraphAttribute ]) ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585378!
clearFont
	"Remove any Font attribute"
	"This is a user command, and generates undo"

	| attributesToRemove firstIndex lastIndex |
	attributesToRemove := Set new.
	firstIndex := self startIndex.
	lastIndex := self stopIndex - 1.
	model actualContents attributesFrom: firstIndex to: lastIndex do: [ :attribute |
		attribute isFont ifTrue: [ attributesToRemove add: attribute ]].

	self unapplyAttributes: attributesToRemove.
	morph resetTextComposition.
	self recomputeSelection.
	morph updateFromTextComposition.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585398!
actualContents

	^model actualContents ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585403 overrides: 50590247!
startIndex
	pointBlock ifNil: [^1].
	^ self startBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585409 overrides: 50590223!
endOfLine: position
	"Redefined in subclasses using TextComposition"
	| targetLine |
	targetLine := textComposition lines at: (textComposition lineIndexFor: position).
	^ targetLine = textComposition lastLine
		ifFalse: [ targetLine last ]
		ifTrue: [ targetLine last + 1 ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585421!
addFinderMenuSectionTo: aMenu
	"Build a submenu with finding related operations"

	self flag: #assumesKeyboardShortcuts.
	aMenu addItemsFromDictionaries:
	 `{
			{
				#label 			-> 		'Find...(f)'.
				#selector 			-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 			-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 			-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
		}`.
		^aMenu! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585443 overrides: 16914387!
flash
	^ morph flash! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585448 overrides: 50590259!
stopIndex
	pointBlock ifNil: [^1].
	^ self stopBlock stringIndex! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585454!
chooseAlignment
	"This is a user command, and generates undo"

	| aList reply  |
	aList := #(leftFlush centered justified rightFlush).
	reply := (SelectionMenu labelList: aList selections: aList) startUpMenu.
	reply ifNil: [ ^self ].
	self applyAttribute: (TextAlignment perform: reply).
	morph updateFromTextComposition.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585468!
findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where := model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [Preferences at: #caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585499!
cursorHome: aKeyboardEvent

	"Private - Move cursor from position in current line to beginning of current line or end of indentation (see #firstOfBeginningOfLineOrEndOfIndentationLeftOf:).
	If control key is pressed put cursor at beginning of text"

	self
		moveCursor: [ :position |
			"Mac standard keystrole"		
			(aKeyboardEvent commandAltKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ self beginningOfText ]
					ifFalse: [ self firstOfBeginningOfLineOrEndOfIndentationLeftOf: position ]]
		forward: false
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585522!
help: aKeyboardEvent
	"Show a help screen"

	self openHelp.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585528!
getMenu
	| aMenu | 
	aMenu := MenuMorph new defaultTarget: self.
	aMenu
		addTitle: self class name;
		addStayUpIcons.
		
	aMenu
		add: 'Help...'
		action: #openHelp
		icon: #helpIcon.
	aMenu addLine.
	
	self addFinderMenuSectionTo: aMenu.
	self addUndoMenuSectionTo: aMenu.
	aMenu addLine.
	
	self addCutAndPasteMenuSectionTo: aMenu.
	aMenu addLine.
	
	self addStyleMenuSectionTo: aMenu.
	
	^aMenu ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585544!
totalTextHeight

	^textComposition lines last bottom! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585549!
shouldHandleUsingCmdShortcuts: aKeyboardEvent 
	^ (aKeyboardEvent keyValue between: 32 and: 126) and: [ aKeyboardEvent commandAltKeyPressed ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585557!
redo

	morph disablesEditing ifTrue: [
		^ self ].

	model redoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.			"this could be made more specific..."
			morph possiblyChanged ]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585572!
align
	"Align text according to the next greater alignment value,
	cycling among leftFlush, rightFlush, center, and justified."
	self chooseAlignment! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585580!
pasteRecent
	"Paste an item chose from RecentClippings."

	| clipping |
	(clipping := Clipboard chooseRecentClipping) ifNil: [^ self].
	self clipboardTextPut: clipping.
	^ self paste! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585589!
actualContents: aString

	model actualContents: aString ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585594!
setEmphasisHereFromTextForward: f

	| i forward delta prevIsLineSeparator nextIsLineSeparator prevIsSeparator nextIsSeparator nextChar prevChar |
	i := self pointIndex.
	"Try to set emphasisHere correctly after whitespace.
	Most important after a cr, i.e. at the start of a new line"
	prevIsLineSeparator :=  i > 1 and: [ (prevChar := model actualContents at: i-1) isLineSeparator ].
	nextIsLineSeparator := i <= model textSize and: [ (nextChar := model actualContents at: i) isLineSeparator ].
	prevIsSeparator :=  i > 1 and: [ prevChar isSeparator ].
	nextIsSeparator := i <= model textSize and: [ nextChar isSeparator ].
	prevIsLineSeparator & nextIsLineSeparator
		ifTrue: [
			"Empty paragraph: take emphasis from the newLine character"
			forward := false ]
		ifFalse: [
			prevIsSeparator == nextIsSeparator
				ifTrue: [
					"Space at both sides, or non-space at both sides, take emphasis used where the cursor comes from"
					forward := f ]
				ifFalse: [
					"Space at one side and non-space at the other, take emphasis from the non-space character"
					forward := nextIsSeparator ]].
	delta := forward ifTrue: [ 1 ] ifFalse: [ 0 ].
	emphasisHere := (model actualContents attributesAt: (i - delta max: 1))
					select: [:att | att mayBeExtended].
	morph possiblyChanged! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585638!
backWord: aKeyboardEvent
	"If the selection is not empty, delete it and leave it in the backspace buffer.
	 Else, delete the word before the text cursor."
	"This is a user command, and generates undo"

	| startIndex |
	self hasSelection ifFalse: [ "No selection, delete at least one character"
		startIndex := 1 max: self markIndex - 1.
		[startIndex > 1 and:
			[(self privateCurrentString at: startIndex - 1) tokenish]]
				whileTrue: [
					startIndex := startIndex - 1]]
	ifTrue: [ "some selection, just delete it"
		startIndex := self markIndex].
	self backTo: startIndex.
	^false! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585660!
changeLineEndsToLf: aKeyboardEvent
	"Replace all CRs and CrLfs by LFs.
	Triggered by Cmd-U -- useful when getting code from FTP sites"
	"This is a user command, and generates undo"
	
	self replaceSelectionWith: self selectedString withCuisLineEndings.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585672!
applyAttribute: aTextAttribute
	"The user selected aTextAttribute via shortcut, menu or other means.
	If there is a selection, apply the attribute to the selection.
	In any case use the attribute for the user input (emphasisHere)"
	"This generates undo"
	| anythingDone interval |

	morph disablesEditing ifTrue: [
		^ self ].

	anythingDone := false.
	emphasisHere := Text addAttribute: aTextAttribute toArray: emphasisHere.

	interval := self selectionInterval.
	(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])
		ifTrue: [
			anythingDone := true.
			model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.
			textComposition recomposeFrom: interval first to: interval last delta: 0 ].

	anythingDone ifTrue: [
		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
		self userHasEdited ].

	"Even if nothing done, emphasisHere might have changed"
	morph possiblyChanged.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585706!
findAgain
	"Find the text-to-find again.  1/24/96 sw"

	(self findAndReplaceMany: false)
		ifFalse: [ self flash ].! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585713!
addStyleMenuSectionTo: aMenu
	"Adds to the given menu text styiling related operations"

	self flag: #assumesKeyboardShortcuts.
	aMenu
		addItemsFromDictionaries: 
	`{
		{
				#label 			-> 		'Toggle WordWrap'.
				#selector 			-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 			-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 			-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font Size'.
				#selector 			-> 		#offerFontSizeMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Set Style'.
				#selector 			-> 		#offerFontStyleMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Set Text Color'.
				#selector 			-> 		#offerColorMenu.
				#icon 			-> 		#graphicsIcon
			} asDictionary.
			{
				#label 			-> 		'Set Alignment...'.
				#selector 			-> 		#chooseAlignment.
				#icon 			-> 		#formatJustifyLeftIcon
			} asDictionary.
		}`.
		^aMenu! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585752!
forwardDelete: aKeyboardEvent
	"Delete forward over the next character."
	"This is a user command, and generates undo"

	| startIndex stopIndex |

	"If there was a selection"
	self hasSelection ifTrue: [
		self replaceSelectionWith: self nullText.
		^ false].

	"Exit if at end"
	startIndex := self markIndex.
	startIndex > model textSize ifTrue: [
		^ false].

	"Null selection - do the delete forward"
	stopIndex := startIndex.
	(self shouldDeleteAWordForward: aKeyboardEvent)
		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].
	self selectFrom: startIndex to: stopIndex.
	self replaceSelectionWith: self nullText.
	self deselectAndPlaceCursorAt: startIndex.
	^false! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585777!
hasUnacceptedEdits: aBoolean

	^morph hasUnacceptedEdits: aBoolean ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585783!
addUndoMenuSectionTo: aMenu
	"Adds undo operations to the given menu"

	self flag: #assumesKeyboardShortcuts.
	aMenu
		addItemsFromDictionaries: 
		`{	
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 			-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 			-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 			-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
		}`.
		
	^aMenu.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585804!
visibleHeight

	^morph owner morphHeight! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585809!
hasUnacceptedEdits

	^morph hasUnacceptedEdits ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585814!
find: aKeyboardEvent
	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"

	self find.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585822!
copySelection
	"Copy the current selection and store it in the Clipboard, unless empty."

	| multiSelection |
	self lineSelectAndEmptyCheck: [^ self].

	multiSelection := self selection.
	self clipboardTextPut: multiSelection! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585833!
currentCharacterStyleOrNil
	"Answer the CharacterStyle for the current selection or cursor location if any"

	^self hasSelection
		ifTrue: [ model actualContents characterStyleOrNilAt: self startIndex ]
		ifFalse: [ model actualContents characterStyleOrNilIfApplying: emphasisHere ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585845!
offerFontMenu: aKeyboardEvent 
	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw"

	self offerFontMenu.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585854!
textComposition: aTextComposition 
	"Install aTextComposition as the one to be edited by the receiver."

	textComposition := aTextComposition! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585863 overrides: 50589718!
sameColumn: start newLine: lineBlock forward: isForward
	"Private - Compute the index in my text
	with the line number derived from lineBlock,"
	" a one argument block accepting the old line number.
	The position inside the line will be preserved as good as possible"
	"The boolean isForward is used in the border case to determine if
	we should move to the beginning or the end of the line."
	| column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |
	lines := textComposition lines.
	numberOfLines := textComposition numberOfLines.
	currentLineNumber  := textComposition lineIndexFor: start.
	currentLine := lines at: currentLineNumber.
	column := start - currentLine first.
	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.
	offsetAtTargetLine := (lines at: targetLineNumber) first.
	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).
	targetLineNumber = currentLineNumber
	"No movement or movement failed. Move to beginning or end of line."
		ifTrue:[
			^isForward
				ifTrue:[targetEOL]
				ifFalse:[offsetAtTargetLine]].
	^offsetAtTargetLine + column min: targetEOL.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585905!
wordAt: aPositionInText
	
	| wordUnderCursorRange |
	wordUnderCursorRange := self wordRangeIncluding: aPositionInText.
	^(model actualContents copyFrom: wordUnderCursorRange first to: wordUnderCursorRange last) asPlainString.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585916!
clickAndHalfAt: localEventPosition

	self selectWordOrDelimitedTextAt: localEventPosition.

	doWordSelection := true.
	doParagraphSelection := false.
	initialSelectionStart := self startBlock.
	initialSelectionStop := self stopBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585927!
defaultFont
	^defaultFont! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585931!
replaceSelectionWith: aTextOrString
	"Deselect, and replace the selection text by aText."
	"This is a user command, and generates undo"

	| start stop replacement |

	morph disablesEditing ifTrue: [
		^ self ].

	start := self startIndex.
	stop := self stopIndex.
	(aTextOrString isEmpty and: [stop > start]) ifTrue: [
		"If deleting, then set emphasisHere from 1st character of the deletion"
		emphasisHere := (model actualContents attributesAt: start) select: [:att |
			att mayBeExtended]].

	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [
		replacement := self addAttributesForPasting: aTextOrString.
		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.
		textComposition
			recomposeFrom: start
			to:  start + replacement size - 1
			delta: replacement size - (stop-start).
		self deselectAndPlaceCursorAt: start + replacement size.
		self userHasEdited  " -- note text now dirty" ].

	morph possiblyChanged! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585964!
blinkParenAt: parenLocation

	model privateAddBoldAt: parenLocation.
	lastParenLocation := parenLocation! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585971!
storeSelectionInComposition
	"for proper display of selected text"

	pointBlock ifNil: [ ^self ].
	textComposition
		selectionStartBlock: self startBlock
		selectionStopBlock: self stopBlock.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585981!
stopBlock
	^ pointBlock max: markBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50585986!
chooseColor
	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"

	| |
	"(ColorPickerMorph new)
		choseModalityFromPreference;
		sourceHand: morph activeHand;
		target: (attribute := TextColor color: Color black);
		selector: #color:;
		originalColor: Color black;
		putUpFor: morph near: morph morphFullBoundsInWorld.
	^attribute"! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586001!
correctFrom: start to: stop with: aString
	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."
	"This is a user command, and generates undo"
	| userSelection delta loc str |
	aString = '#insert period' ifTrue: [
		loc := start.
		str := self privateCurrentString.
		[(loc := loc-1)>0 and: [(str at: loc) isSeparator]]
			whileTrue: [loc := loc-1].
		^ self correctFrom: loc+1 to: loc with: '.'].
	userSelection := self selectionInterval.

	self selectInvisiblyFrom: start to: stop.
	self replaceSelectionWith: aString.

	delta := aString size - (stop - start + 1).
	self
		selectInvisiblyFrom: userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])
		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ])
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586033!
shouldDeleteAWordForward: aKeyboardEvent

	^ aKeyboardEvent isDelete and: [
		aKeyboardEvent rawMacOptionKeyPressed or: [
			aKeyboardEvent controlKeyPressed ] ]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586042!
save: aKeyboardEvent
	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw"

	self acceptContents.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586049!
offerColorMenu: aKeyboardEvent 
	"The user typed the command key that requests a font change; Offer the color menu."

	self offerColorMenu.
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586057!
offerUndoHistory
	| index labels current |
	current := model undoRedoCommandsPosition.
	labels := model undoRedoCommands withIndexCollect: [ :each :i | 
		(i = current ifTrue: [ '<on>' ] ifFalse: [ '<off>' ]), each printString ].
	labels isEmpty ifFalse: [
		index := (PopUpMenu
			labelArray: labels
			lines: #()) startUpMenu.
		index = current ifTrue: [ ^self ].
		index = 0 ifTrue: [ ^self ].
		index < current
			ifTrue: [ current - index timesRepeat: [ self undo ]]
			ifFalse: [ index - current timesRepeat: [ self redo ]]]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586077!
pointBlock
	^pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586081!
setSearchString: aKeyboardEvent
	"Establish the current selection as the current search string."

	| aString |
	self lineSelectAndEmptyCheck: [^ true].
	aString :=  self selectedString.
	aString isEmpty
		ifTrue: [ self flash ]
		ifFalse: [ self setSearch: aString ].
	^ true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586094 overrides: 50590045!
selectLine
	"Make the receiver's selection, encompass the current line."

	self selectInterval: (model actualContents encompassLine: self selectionInterval)! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586103!
openHelp
	"Show help screen"
	TextModel new contents: self help; openLabel: self name, ' Help'.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586110!
defaultFont: aFont
	defaultFont := aFont! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586115!
offerFontMenu
	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.
	Note: use #baseFont. If emphasis is desired, add it separatedly."
	"This is a user command, and generates undo"

	| currentFont attr startIndex |
	startIndex := self startIndex.
	currentFont := model actualContents fontAt: startIndex default: defaultFont.
	(FontFamily promptUser: currentFont familyName) ifNotNil: [ :fontFamily |
		attr := TextFontFamily familyName: fontFamily familyName.
		self applyAttribute: attr.
		morph updateFromTextComposition ].! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586136!
resetState
	"Establish the initial conditions for editing the paragraph: place text cursor 
	before first character and set the emphasis to that of the first character"

	markBlock := textComposition defaultCharacterBlock.
	pointBlock := markBlock.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586147!
balloonTypeInfoAt: mouseInTextPosition

	^''! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586152!
selectionRectangle
	"Answer a rectangle that encompasses selection.
	If no selection, answer a rectangle that includes cursor."
	^ markBlock quickMerge: pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586161 overrides: 50590070!
privateCurrentString
	"Answer the string I'm editing. Private. Just for internal Editor use."

	^model actualContents string! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586169 overrides: 50590144!
hasSelection
	^ markBlock ~= pointBlock! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586174!
afterSelectionInsertAndSelect: aString
	"This is a user command, and generates undo"

	self insertAndSelect: aString at: self stopIndex ! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586182!
setEmphasisHereFromText

	self setEmphasisHereFromTextForward: true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586188!
selectedString

	^self selection string! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586193!
isDisjointFrom: anInterval
	"Answer true if anInterval is empty and not touching or within the current
	 interval, or if anInterval is a not empty but it does not overlap the current
	 selection."

	| fudge |
	fudge := anInterval size = 0 ifTrue: [1] ifFalse: [0].
	^(anInterval last + fudge < self startIndex or:
			[anInterval first - fudge >= self stopIndex])
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586208!
selectWordOrDelimitedTextAt: localEventPosition
	"Select delimited text or word--the result of double-clicking."

	| hitCharacterBlock range |
	hitCharacterBlock := textComposition characterBlockIncludingPoint: localEventPosition.
	range := self
		delimitedRangeAt: hitCharacterBlock stringIndex
		hitOnRightHalf: localEventPosition x  > hitCharacterBlock center x
		leftDelimiters: '([{<'
		rightDelimiters: ')]}>'
		simpleDelimiters: '|''"`'.
	self selectFrom: range first to: range last.! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586227!
undo: aKeyboardEvent 
	"Undo the last edit."

	self undo.
	^true! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586233!
text
	"The returned object should be treated as read-only, and never modified"
	^ model actualContents! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586240!
pageHeight
	| howManyLines visibleHeight totalHeight ratio |
	howManyLines := textComposition numberOfLines.
	visibleHeight := self visibleHeight.
	totalHeight := self totalTextHeight.
	ratio := visibleHeight / totalHeight.
	^(ratio * howManyLines) rounded - 2! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586253 overrides: 50590264!
initializeShortcuts
	
	super initializeShortcuts.
	shortcuts at: 9 + 1 put: #tabKey:.! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586259!
openTextEditor

	^ SystemWindow editText: TextModel new label: 'Text Editor' wrap: true! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586266 overrides: 50590347!
releaseClassCachedState

	FindText := nil.
	ChangeText := nil.
	"We are not calling super to avoid cleansing class vars many times.
	So, repeat inherited class instVars!!"
	shortcuts := nil.
	cmdShortcuts := nil! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586277 overrides: 50590361!
basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	self flag: #definesKeyboardShortcuts.
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$s 	#save:					'Save')
		#(		$f 	#find:					'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:					'Open this help')
		#(		$j 	#setSearchString:					'Set selection as search string for find again')

		#(		$z 	#undo:					'Undo (multiple levels)')
		#(		$x 	#cut:					'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:					'Copy selection to the Clipboard')
		#(		$v 	#paste:					'Paste Clipboard contents')

		#(		$U	#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:					'Move cursor to start of text')

		#(		$Z	#redo:					'Redo (multiple levels)')
		#(		$C	#compareToClipboard:		'Compare argument to clipboard')
	)! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586328 overrides: 50590374!
cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	self flag: #definesKeyboardShortcuts.
	^#(
		#(		$0 	changeEmphasis:			'Normal')
		#(		$1 	changeEmphasis:			'Bold')
		#(		$2 	changeEmphasis:			'Italic')
		#(		$3 	changeEmphasis:			'Underline')
		#(		$4 	changeEmphasis:			'Strikeout')
		#(		$5 	changeEmphasis:			'Superscript')
		#(		$6 	changeEmphasis:			'Subscript')
		#(		$8	#offerColorMenu:		'Change color')

		#(		$u	#align:				'Toggle alignment')

		#(		$k	#offerFontMenu:			'Set font')
	)! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586348!
findText
	FindText ifNil: [
		FindText := Text new ].
	^FindText! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586354!
changeText
	ChangeText ifNil: [
		ChangeText := Text new ].
	^ChangeText! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586360!
worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		10.
			#label 			->			'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586374!
openHelp

	self new openHelp! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586378!
isTextEmpty
	^actualContents isEmpty! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586383!
contents: aTextOrString
	"Does not update any view...
	The kind of stuff that needs to be cleaned some day..."
	self basicActualContents: aTextOrString! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586391!
convertAndStyleIfNeededWith: anSHTextStyler

	anSHTextStyler ifNotNil: [
		(self shouldStyle: self actualContents with: anSHTextStyler) ifTrue: [
			self styleByParagraphs
				ifTrue: [ self convertAndStyleIByParagraphsWith: anSHTextStyler ]
				ifFalse: [ 	self convertAndStyleAllWith: anSHTextStyler ]	]]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586404!
logUndoAndAddAttribute: aTextAttribute from: requestedStart to: requestedStop
	"As requested."

	| command |
	command := actualContents commandForAddAttribute: aTextAttribute from: requestedStart to: requestedStop.
	undoRedoCommands
		nextPut: command;
		truncateAtPosition.	"To disable redo of previous commands, now invalidated."
	command doOn: self.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586419!
acceptContentsFrom: aTextModelMorph
	"Tell the owning window to save the contents if it supports that action.
	
	Also clear the user edits."
	
	aTextModelMorph owningWindow ifNotNil: [ :ow |
		ow hasSaveAs ifTrue: [ 
			ow forceSaveContents.
			self changed: #clearUserEdits ] ]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586431!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586438!
getSelection
	"Answer the model's selection interval."

	^ nil	"null selection"! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586444!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586451!
allowStylingWithEmphasis
	"Default for Smalltalk methods"

	^true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586457!
undoRedoCommands
	^undoRedoCommands contents! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586462!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	This is useful in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586475!
isDirty

	^undoRedoCommands position isZero not.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586480!
privateAddBoldAt: idx
	"Just for shout. No undo."

	actualContents 
		addAttribute: ShoutTextEmphasis bold
		from: idx
		to: idx! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586488!
textStylerClass
	^nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586492!
openLabel: aString 
	"Create a standard system view of the model, me, and open it."
	^SystemWindow editText: self label: aString wrap: true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586500!
commandForReplaceFrom: start to: stop with: replacement

	^ actualContents commandForReplaceFrom: start to: stop with: replacement! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586508!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586515!
fullPrintIt
	^true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586520 overrides: 16932297!
initialize
	"Initialize the state of the receiver with its default contents."

	undoRedoCommands := ReadWriteStream on: #().
	self basicActualContents: ''.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586528!
actualContents: aTextOrString
	self basicActualContents: aTextOrString.
	self changed: #actualContents! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586535!
editorClass
	^TextEditor! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586540 overrides: 16915189!
is: aSymbol
	^ aSymbol == #canSaveContents or: [ super is: aSymbol ]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586546!
convertAndStyleIByParagraphsWith: anSHTextStyler
	"Convert and style. Treat each paragraph (separated by an empty line) as a separate script.
	Useful for Workspaces, Inspectors, etc."
	| separator fragmentStart fragmentEnd done|

	actualContents := actualContents optimizedForMutationSpeed.	
	anSHTextStyler getReady.
	anSHTextStyler workspaceContents: actualContents.
	separator := String newLineString, String newLineString.
	fragmentStart := 1.
	done := false.
	[done] whileFalse: [
		fragmentEnd := actualContents
			indexOfSubCollection: separator
			startingAt: fragmentStart
			ifAbsent: [done := true. actualContents size].
		anSHTextStyler parseWorkspaceFrom: fragmentStart to: fragmentEnd.
		anSHTextStyler privateConvertAssignmentsOffset: fragmentStart-1.
		anSHTextStyler styleWorkspaceOffset: fragmentStart-1 allowEmphasis: self allowStylingWithEmphasis.
		fragmentStart := fragmentEnd+separator size ].
	self changed: #shoutStyled! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586580 overrides: 16779298!
postCopy
	super postCopy.
	actualContents := actualContents copy.
	undoRedoCommands := ReadWriteStream on: #().
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586588!
logUndoAndRemoveAttributes: textAttributes from: requestedStart to: requestedStop
	"As requested."

	| command |
	command := actualContents commandForRemoveAttributes: textAttributes from: requestedStart to: requestedStop.
	undoRedoCommands
		nextPut: command;
		truncateAtPosition.	"To disable redo of previous commands, now invalidated."
	command doOn: self.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586604!
classOfWorkspaceVarNamed: aName

	^ nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586609!
canBindVariables
	^ false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586613!
flushUndoRedoCommands

	undoRedoCommands := ReadWriteStream on: #().
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586620!
basicActualContents: aTextOrString
	"Do not throw events."
	| prevContents |
	prevContents := actualContents.
	actualContents := aTextOrString asText asUnicodeStringOrText.
	actualContents = prevContents ifFalse: [	"Compares only characters, not attributes"
		undoRedoCommands resetToStart.
		lastEditTimeStamp := nil ]! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586634!
undoAndEvaluate: aTwoArgBlock
	| modelUpdated newCursorPos |
	modelUpdated := false.
	undoRedoCommands position > 0 ifTrue: [
		undoRedoCommands skipBack.
		newCursorPos := undoRedoCommands peek undoOn: self.
		modelUpdated := true ].
	aTwoArgBlock value: modelUpdated value: newCursorPos.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586647!
textSize
	actualContents ifNil: [ ^0 ].
	^actualContents size! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586653!
privateRemoveBoldAt: idx
	"Just for shout. No undo."

	actualContents 
		removeAttributes: { ShoutTextEmphasis bold }
		from: idx
		to: idx! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586661!
logUndoAndReplaceFrom: start to: stop with: replacement
	"As requested."

	| command now |
	"Time millisecondClockValue rolls over and is generally not adviced.
	But here, we don't care. A user edit doing during rollover would be split  in two, as if the user did a pause.
	Not a problem."
	
	now := Time millisecondClockValue.
	command := self commandForReplaceFrom: start to: stop with: replacement.
	(stop+1 = start and: [ lastEditTimeStamp notNil and: [ now - lastEditTimeStamp < 1000 and: [start = undoRedoCommands peekLast stopPosition] ]])
		ifTrue: [
			"Don't use the command we just built"
			undoRedoCommands peekLast appendToNew: replacement
			]
		ifFalse: [
			undoRedoCommands
				nextPut: command;
				truncateAtPosition.	"To disable redo of previous commands, now invalidated."
			].
	command doOn: self.
	lastEditTimeStamp := now! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586691!
autoCompleterClass
	^nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586695!
startNewUndoRedoCommand

	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586700!
convertAndStyleAllWith: anSHTextStyler
	"Convert and style all contents as a single method or script.
	Do it in a background process if too big."

	anSHTextStyler convertAndStyle: self actualContents allowBackgroundStyleProcess: true.
	self basicActualContents: anSHTextStyler convertedAndStyledText.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586713!
undoRedoCommandsPosition
	^undoRedoCommands position! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586718!
refetch
	"Nothing here. Answer true if actualContents was actually fetched."
	self basicActualContents: self actualContents.
	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586726!
saveOn: stream
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asPlainString.! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586733!
shouldStyle: aText with: aSHTextStylerST80 
	
	^true! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586738!
redoAndEvaluate: aTwoArgBlock
	| modelUpdated newCursorPos |
	modelUpdated := false.
	undoRedoCommands atEnd ifFalse: [
		newCursorPos := undoRedoCommands next doOn: self.
		modelUpdated := true ].
	aTwoArgBlock value: modelUpdated value: newCursorPos.
	lastEditTimeStamp := nil! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586750!
classOfThisContext

	^ MethodContext ! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586755!
wantsFrameAdornments
	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586759!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^false! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586766!
basicReplaceFrom: start to: stop with: replacement
	"As requested. Basic service used by Undo / Redo. Does not genertate undo."

	actualContents replaceFrom: start to: stop with: replacement! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586776!
actualContents
	^actualContents! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586781!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586788!
basicReplaceAttributesFrom: start to: stop with: replacement
	"As requested. Basic service used by Undo / Redo. Does not genertate undo."

	actualContents basicReplaceAttributesFrom: start to: stop with: replacement! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586799 overrides: 16914586!
convertToCurrentVersion: varDict refStream: smartRefStrm

	"Maybe old instances won't have this variable set."
	undoRedoCommands ifNil: [
		undoRedoCommands := ReadWriteStream on: #() ]! !
!TextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586809 overrides: 16916100!
windowColor
	^ Theme current textEditor! !
!TextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586814!
withText: aTextOrString
	^self new basicActualContents: aTextOrString! !
!TextModel class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586820!
openLabel: aString

	^self new openLabel: aString! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586825!
contentsSelection
	"Return the interval of text in the code pane to select when I set the pane's contents"

	^ nil  "null selection"! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586833!
acceptedContents
	^ Text
		initialFont: (Preferences at: #standardCodeFont)
		stringOrText: self acceptedStringOrText! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586840!
acceptedContentsChanged

	self changed: #acceptedContents! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586846 overrides: 16915686!
textStylerClassFor: textGetter
	^nil! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586851!
classOfThisContext

	^ MethodContext ! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586856!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586864 overrides: 16915680!
editorClassFor: textGetter
	^TextEditor! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586869!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586877!
acceptedStringOrText
	^self subclassResponsibility! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586882!
classOfWorkspaceVarNamed: aName

	^ nil! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586887!
methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586897!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586905 overrides: 16915674!
autoCompleterClassFor: textGetter
	^nil! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586910!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^false! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586917!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	False, for instance, in all code Browsers.
	True in Workspaces and Inspectors, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^true! !
!TextProvider methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586931!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586939!
appendToNew: aStringOrText
	new := new, aStringOrText! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586945 overrides: 50595076!
undoOn: aTextModel
	"Undo the command, bringing the text model to the state it had prior to doing it.
	Answer a new position for the text cursor"

	aTextModel basicReplaceFrom: position to: position + new size-1 with: old.
	^position + old size! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586957!
old: oldStringOrText new: newStringOrText at: anInteger
	old := oldStringOrText.
	new := newStringOrText.
	position := anInteger! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586966 overrides: 16914834!
printOn: aStream
	old isEmpty ifTrue: [
		^aStream nextPutAll: 'typed: '; nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes].
	new isEmpty ifTrue: [
		^aStream nextPutAll: 'deleted: '; nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ].
	aStream
		nextPutAll: 'replaced: ';
		nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes;
		nextPutAll: ' with: ';
		nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586987!
stopPosition
	^position + new size.! !
!TextReplaceCommand methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50586993 overrides: 50595083!
doOn: aTextModel
	"Perform the command, used for initial execution or for redo after undoing.
	Answer a new position for the text cursor"

	aTextModel basicReplaceFrom: position to: position + old size-1 with: new.
	^position + new size! !
!TextReplaceCommand class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587004!
old: oldStringOrText new: newStringOrText at: anInteger
	^self basicNew old: oldStringOrText new: newStringOrText at: anInteger! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587012 overrides: 16829104!
storeOn: aStream
	"Refer to the comment in Object|storeOn:."
	| noneYet |
	aStream nextPutAll: '(('.
	aStream nextPutAll: self class name.
	aStream nextPutAll: ' new)'.
	noneYet := true.
	self keysAndValuesDo: 
			[:each :val | 
			noneYet
				ifTrue: [noneYet := false]
				ifFalse: [aStream nextPut: $;].
			aStream 
				nextPutAll: ' at: ';
				store: each;
				nextPutAll: ' put: ';
				store: val].
	noneYet ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587031 overrides: 16828310!
add: aString

	self at: aString put: aString! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587036 overrides: 16913367!
at: aString put: aValue

	rootNode ifNil: [
		rootNode := TrieNode someKey: aString segmentStart: 1].
	^rootNode at: aString put: aValue characterIndex: 1! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587044!
at: aString ifAbsent: aBlock

	rootNode ifNil: [ ^aBlock value ].
	^ rootNode at: aString ifAbsent: aBlock characterIndex: 1! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587051!
keysDo: aBlock

	self keysAndValuesDo: [ :k :v | aBlock value: k ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587057!
valuesDo: aBlock

	self keysAndValuesDo: [ :k :v | aBlock value: v ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587063!
at: key ifPresent: aBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := self at: key ifAbsent: [^ nil].
	^ aBlock value: v! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587075 overrides: 16829183!
remove: aString ifAbsent: exceptionBlock
	"Consistent with Set"
	self at: aString ifPresent: [ :v |
		v = aString ifTrue: [
			self removeKey: aString ifAbsent: exceptionBlock ]]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587085 overrides: 16829426!
isEmpty
	^rootNode isNil! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587089!
removeKey: aString ifAbsent: aBlock
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| answer |
	rootNode ifNil: [ ^aBlock value ].
	answer := rootNode removeKey: aString ifAbsent: aBlock characterIndex: 1.
	rootNode isEmpty ifTrue: [
		rootNode := nil ].
	^answer! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587105!
removeKey: aString 
	"Remove key from the receiver.
	If key is not in the receiver, notify an error."

	^ self removeKey: aString ifAbsent: [ self errorKeyNotFound: aString ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587115 overrides: 16829369!
includes: aString
	"Consistent with Set, but not with Dictionary,  as in Dictionary, #includes:
	finds a value regardless of the key. To get this behavior, use #includesValue:"

	aString isString ifFalse: [ ^ false ].
	self at: aString ifPresent: [ :v | ^v = aString ].
	^false! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587127!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock value]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587138 overrides: 16828787!
do: aBlock
	"Consistent both with Set (#add:) and Dictionary (#at:put:) protocols."
	self valuesDo: aBlock! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587145!
forPrefix: aString keysAndValuesDo: twoArgBlock

	rootNode ifNotNil: [
		rootNode forPrefix: aString keysAndValuesDo: twoArgBlock characterIndex: 1]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587153!
includesValue: anObject
	"Similar to Dictionary>>#includes:"
	self do: [:each | anObject = each ifTrue: [^true]].
	^false! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587160!
errorKeyNotFound: key

	self error: (
		String streamContents: [ :strm |
			strm nextPutAll: 	'key: '.
			key printOn: strm.
			strm nextPutAll: ' not found' ])! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587169 overrides: 16913349!
at: key 
	"Answer the value associated with the key."

	^ self at: key ifAbsent: [ self errorKeyNotFound: key ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587176!
keysAndValuesDo: twoArgBlock

	rootNode ifNotNil: [
		rootNode keysAndValuesDo: twoArgBlock ]! !
!Trie methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587182!
includesKey: key
	
	self at: key ifAbsent: [^false].
	^true! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587187!
at: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys isArray ifTrue: [
		keyIndex := keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock value ]
			ifFalse: [ values at: keyIndex ]].
	keys = aString ifTrue: [ ^ values ].
	^ aBlock value! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587201!
at: aString put: aValue characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys ifNil: [
		keys := aString.
		values := aValue.
		^aValue ].
	keys isArray ifFalse: [
		keys = aString
			ifFalse: [
				keys := {keys. aString }.
				values := {values. aValue}]
			ifTrue: [ values := aValue ].
		^ aValue ].
	keyIndex := keys indexOf: aString.
	keyIndex = 0
		ifTrue: [
			keys := keys copyWith: aString.
			values := values copyWith: aValue ]
		ifFalse: [ values at: keyIndex put: aValue ].
	^ aValue! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587221!
removeKey: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex answer |
	keys isArray ifTrue: [
		keyIndex := keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock value ]
			ifFalse: [
				answer := values at: keyIndex.
				keys size = 2
					ifTrue: [
						keys := keys at: 3-keyIndex.
						values := values at: 3-keyIndex ]
					ifFalse: [
						keys := (keys copyFrom: 1 to: keyIndex-1), (keys copyFrom: keyIndex+1 to: keys size).
						values := (values copyFrom: 1 to: keyIndex-1), (values copyFrom: keyIndex+1 to: values size) ].
				answer]].
	keys = aString ifTrue: [
		answer := values.
		keys := nil.
		values := nil.
		^ answer ].
	^ aBlock value! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587247!
isEmpty
	^keys isNil! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587251!
keysAndValuesDo: twoArgBlock

	keys isArray
		ifTrue: [ keys with: values do: twoArgBlock ]
		ifFalse: [ twoArgBlock value: keys value: values ]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587259!
at: aString put: aValue characterIndex: i

	| child |
	childrenFirstChars ifNotNil: [
		self splitIfNeededFor: aString characterIndex: i ].
	child := self childFor: aString characterIndex: i orAdd: true.
	^child at: aString put: aValue characterIndex: i + segmentSize! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587271!
childFor1: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil.
	This method for the case where we currently have exactly one child."
	| nextSegmentStart nextSegmentFirst answer |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	childrenFirstChars = nextSegmentFirst ifTrue: [ ^ children].

	doAdd ifFalse: [ ^ nil ].
	
	answer := nextSegmentStart > aString size
		ifTrue: [ TrieLeaf new ]
		ifFalse: [ TrieNode someKey: aString segmentStart: nextSegmentStart ].

	"Just one child, if adding, convert references to a collection"
	nextSegmentFirst < childrenFirstChars
		ifTrue: [
			children := {answer . children }.
			childrenFirstChars := Array with: nextSegmentFirst with: childrenFirstChars ]
		ifFalse: [
			children := {children . answer}.
			childrenFirstChars := Array with: childrenFirstChars with: nextSegmentFirst ].
	^answer! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587310!
setChildrenFirstChars: aString children: anArray
	"Private. To be called only from parent node"
	childrenFirstChars := aString.
	children := anArray.! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587318!
splitIfNeededFor: aString characterIndex: segmentStart
	"This method splits the self (the current node) into two nodes, such that the concatenation of their string segment equals our current string segment,
	and such that the string segment of the first node (i.e. us) equals or is a prefix of aString.
	If this latter condition is already met, do nothing."
	| oldSegmentStop newSegmentStop newNode |

	"Compute last index where both strings are equal"
	oldSegmentStop := segmentStart + segmentSize - 1.
	newSegmentStop := someKey commonPartWith: aString startAt: segmentStart stopAt: oldSegmentStop
		applying: [ :c | c asLowercase asUnaccented ].
			
	newSegmentStop = oldSegmentStop ifTrue: [
		"No need to split: our segment is already a prefix of aString"
		^self ].

	"Split node"
	newNode := TrieNode someKey: someKey setSegmentSize: oldSegmentStop - newSegmentStop.
	newNode setChildrenFirstChars: childrenFirstChars children: children.

	"As this is a split point, these will be turned into arrays soon, when the new node addition (that called us) is done."
	childrenFirstChars := (someKey at: newSegmentStop+1) asLowercase asUnaccented.
	children := newNode.
	"Update our segment"
	segmentSize := newSegmentStop - segmentStart + 1! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50587360!
at: aString ifAbsent: aBlock characterIndex: i

	| child |
	child := self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock value ].
	^child at: aString ifAbsent: aBlock characterIndex: i + segmentSize! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587371!
forPrefix: aString keysAndValuesDo: twoArgBlock characterIndex: i

	i + segmentSize > aString size
		ifTrue: [
			self keysAndValuesDo: twoArgBlock ]
		ifFalse: [
			(self childFor: aString characterIndex: i orAdd: false)
				ifNotNil: [ :node |
					node
						forPrefix: aString
						keysAndValuesDo: twoArgBlock
						characterIndex: i + segmentSize ]]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587386!
childForN: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil.
	This method for the case where we currently have more than one child."
	| answer newChildren newFirstChars nextSegmentFirst nextSegmentStart s |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found | ^ children at: found ]
		ifNone: [ :a :b |
			"Already more than one child. If adding, convert to a bigger collection."
			doAdd
				ifFalse: [ ^nil]
				ifTrue: [
					 answer := nextSegmentStart > aString size
						ifTrue: [ TrieLeaf new ]
						ifFalse: [  TrieNode someKey: aString segmentStart: nextSegmentStart ].
					s := children size + 1.
					newChildren := Array new: s.
					newChildren
						replaceFrom: 1 to: a with: children startingAt: 1;
						at: a+1 put: answer;
						replaceFrom: a+2 to: s with: children startingAt: a+1.
					newFirstChars := Array new: s.
					newFirstChars
						replaceFrom: 1 to: a with: childrenFirstChars startingAt: 1;
						at: a+1 put: nextSegmentFirst;
						replaceFrom: a+2 to: s with: childrenFirstChars startingAt: a+1.
					children := newChildren.
					childrenFirstChars := newFirstChars.
					^answer ]]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587439!
getChildrenFirstChars
	"Private. To be called only from parent node"
	^childrenFirstChars! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587445!
isEmpty
	^childrenFirstChars isNil! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587450!
childFor: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."

	"No children yet"
	childrenFirstChars ifNil: [
		doAdd ifTrue: [
			children := TrieLeaf new.
			childrenFirstChars := TrieNode characterForLeaf ].
		^children ].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		^ self childFor1: aString characterIndex: i orAdd: doAdd ].

	"Already more than one child. If adding, convert to a bigger collection."
	^self childForN: aString characterIndex: i orAdd: doAdd! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587475!
getSegmentSize
	"Private. To be called only from parent node"
	^segmentSize! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587481!
getSomeKey
	"Private. To be called only from parent node"
	^someKey! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587487!
removeChildFor: aString characterIndex: i
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."
	| nextSegmentStart nextSegmentFirst |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		childrenFirstChars = nextSegmentFirst
			ifTrue: [ childrenFirstChars := nil. children := nil ].
		^self ].
	
	"Already more than one child."
	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found |
			childrenFirstChars size = 2
				ifTrue: [		"Two children: remove the arrays"
					childrenFirstChars := childrenFirstChars at: 3-found.
					children := children at: 3-found ]
				ifFalse: [	"More than two children. condense the arrays"
					childrenFirstChars := (childrenFirstChars copyFrom: 1 to: found-1), 
						(childrenFirstChars copyFrom: found+1 to: childrenFirstChars size).
					children := (children copyFrom: 1 to: found-1), (children copyFrom: found+1 to: children size) ]]
		ifNone: [].! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587533!
getChildren
	"Private. To be called only from parent node"
	^children! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587539!
setSegmentSize: anInteger someKey: aString
	"Private. To be called only from parent node"
	segmentSize := anInteger.
	someKey := aString! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587547!
keysAndValuesDo: twoArgBlock

	children isArray ifFalse: [
		^children keysAndValuesDo: twoArgBlock ].

	children do: [ :child |
		child ifNotNil: [ child keysAndValuesDo: twoArgBlock ]]! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587556!
removeKey: aString ifAbsent: aBlock characterIndex: i

	| child answer |
	child := self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock value ].
	answer := child removeKey: aString ifAbsent: aBlock characterIndex: i + segmentSize.
	child isEmpty ifTrue: [
		self removeChildFor: aString characterIndex: i.
		"If child is not needed anymore, compress the path"	
		children class == TrieNode ifTrue: [
			someKey := children getSomeKey.
			segmentSize := segmentSize + children getSegmentSize.
			childrenFirstChars := children getChildrenFirstChars.
			children := children getChildren ]].
	^answer! !
!TrieNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587579!
someKey: aString segmentStart: i
	^self new setSegmentSize: aString size - i + 1 someKey: aString! !
!TrieNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587586!
characterForLeaf
	"A special character to mean leaf node. Must have lower code than alphabetic chars,
	so in the trie 'car' comes before 'cars'"
	^Character numericValue: 0! !
!TrieNode class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587595!
someKey: aString setSegmentSize: s
	^self new setSegmentSize: s someKey: aString! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587602 overrides: 16913521!
bindingOf: aString
	mustDeclareVariables ifTrue: [^ nil].
	(bindings includesKey: aString) ifFalse: [
		aString first isUppercase
			ifTrue: [^nil]
			ifFalse: [bindings at: aString put: nil]].
	^bindings associationAt: aString! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587613!
classOfBindingOf: aName
												
	^ (self bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587620!
bindingNamesDo: aBlock

	bindings keysDo: aBlock! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587625!
hasBindingThatBeginsWith: aString 

	bindings keysDo: [ :each |
		(each beginsWith: aString) ifTrue: [ ^true ] ].
	^false! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587632!
mustDeclareVariableWording
	
	^ mustDeclareVariables not
		ifTrue: ['<yes> automatically create variable declaration']
		ifFalse: ['<no> automatically create variable declaration']! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587641!
nameForObject: object
	"Answer a name suitable for a Workspace variable"
	^ (object class name, object identityHash printString) asIdentifier: false! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587649!
initializeBindings
	
	bindings := Dictionary new.
	self changed: #actualContents.
! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587655!
shouldStyle

	^shouldStyle ifNil: [ Preferences at: #shoutInWorkspaces]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587661 overrides: 50597266!
styleByParagraphs
	"Answer true if each paragraph should be styled independent of the others.
	This is useful in Workspaces, where the whole contents might not be valid Smalltalk.
	Note that this precludes multi paragraph comments. Multiple comments are required in such cases."

	^true! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587674 overrides: 50597495!
autoCompleterClass
	^SmalltalkCompleter! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587679!
methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587689!
toggleVariableDeclarationMode

	mustDeclareVariables := mustDeclareVariables not! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587696 overrides: 50597255!
allowStylingWithEmphasis
	"Disabled by default for faster styling of large contents, as text metrics are not affected by styling."

	^ Preferences at: #stylingWithEmphasisInWorkspaces! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587706 overrides: 50597292!
textStylerClass
	^SHTextStylerST80! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587711 overrides: 50597319!
fullPrintIt

	^fullPrintIt ifNil: [ Preferences at: #fullPrintItInWorkspaces]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587718 overrides: 50597296!
openLabel: aString 
	"Create a standard system view of the model, me, and open it."
	| window |
	window := WorkspaceWindow editText: self label: aString wrap: true.
	self changed: #actualContents.
	^window! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587729 overrides: 50597312!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	anAutocompleter computeMessageEntriesForClassOrNil: (self classOfBindingOf: aName) ! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587738 overrides: 50597324!
initialize
	
	super initialize.
	self initializeBindings.
	mustDeclareVariables := false.
	fullPrintIt := false.! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587746 overrides: 50597339!
editorClass
	^SmalltalkEditor! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587751!
hasBindingOf: aString
	^bindings includesKey: aString! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587757 overrides: 50597344!
is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587763!
toggleStylingLabel

	^self shouldStyle 
		ifTrue: [ '<on> syntax highlighting' ]
		ifFalse: [ '<off> syntax highlighting' ]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587771 overrides: 50597537!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text."

	self shouldStyle ifFalse: [ ^false ].
	anSHTextStyler 
		classOrMetaClass: nil;
		workspace: self.
	^true! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587782!
toggleFullPrintIt

	fullPrintIt := self fullPrintIt not.! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587788 overrides: 50597408!
classOfWorkspaceVarNamed: aName
												
	^ self classOfBindingOf: aName ! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587794!
toggleStyling

	shouldStyle := self shouldStyle not.
	actualContents := actualContents asPlainString asText.
	self changed: #actualContents! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587803 overrides: 50597413!
canBindVariables
	^ true! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587807!
toggleFullPrintItLabel

	^self fullPrintIt 
		ifTrue: [ '<on> full printIt' ]
		ifFalse: [ '<off> full printIt' ]! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587814!
selectedClassOrMetaClass
	
	^UndefinedObject ! !
!Workspace class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587819!
openWorkspace
	^self new
		contents: '';
		openLabel: 'Workspace'.
! !
!Workspace class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587826 overrides: 50597613!
windowColor
	^ Theme current workspace! !
!Workspace class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 19:18:05' prior: 50587831!
worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		20.
			#label 			->			'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!SmalltalkEditor methodsFor: '*LiveTypingGenerics' stamp: 'AC 8/6/2023 20:53:55' prior: 50592283!
balloonTypeInfoOfInstanceVariableAt: mousePositionInText

	| instVarName typeInfo types |
	
	instVarName := (self wordUnder: mousePositionInText) asString.
	"typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^'']."
	types := self codeProvider selectedClass 
				liveTypesOfInstanceVariableNamed: instVarName 
				storingGenericsInfoIn: (LiveTyping getGenericsStorage) 
				ifAbsent: [`EmptyType new`].
	typeInfo := InstanceVariableTypeInfo of: instVarName in: self codeProvider selectedClass are: types asArray.
	^typeInfo printTypesUpTo: 5! !
!SmalltalkEditor methodsFor: '*LiveTypingGenerics' stamp: 'JFGO 10/11/2024 19:25:43' prior: 50598649!
balloonTypeInfoOfInstanceVariableAt: mousePositionInText

	| instVarName typeInfo types |
	
	instVarName := (self wordAt: mousePositionInText) asString.
	"typeInfo := self codeProvider selectedClass typeInfoOfInstanceVariableNamed: instVarName ifAbsent: [^'']."
	types := self codeProvider selectedClass 
				liveTypesOfInstanceVariableNamed: instVarName 
				storingGenericsInfoIn: (LiveTyping getGenericsStorage) 
				ifAbsent: [`EmptyType new`].
	typeInfo := InstanceVariableTypeInfo of: instVarName in: self codeProvider selectedClass are: types asArray.
	^typeInfo printTypesUpTo: 5! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'HAW 7/11/2019 17:20:47' prior: 50592682!
balloonTypeInfoInMethodAt: mousePositionInText

	^self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class ]
				ifAbsent: [ 
					mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]]]
		ifErrorsParsing: [ :anError | '' ]


! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 10/11/2024 19:40:01' prior: 16853845!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |

	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.
self halt.
	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: 'source mapping' stamp: 'JFGO 10/11/2024 19:40:50' prior: 50598714!
parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |

	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !

sourceRanges!

self associations !

self associations !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50598695!
balloonTypeInfoInMethodAt: mousePositionInText

	^self withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| 
					self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class 
				]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 	mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]
				]]
		ifErrorsParsing: [ :anError | '' ]


! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'HAW 7/11/2019 17:20:47' prior: 50598762!
balloonTypeInfoInMethodAt: mousePositionInText

	^self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class ]
				ifAbsent: [ 
					mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]]]
		ifErrorsParsing: [ :anError | '' ]


! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/11/2024 19:18:04' prior: 50598788!
balloonTypeInfoInMethodAt: mousePositionInText

	^self withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode withParseNodeAndBlockNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor :aBlockNodeUnderCursor| 
					self balloonTypeInfoOf: aNodeUnderCursor within: aBlockNodeUnderCursor in: methodNode definedAt: class 
				]
				ifBlockNodeAbsent:[:aNodeUnderCursor | self balloonTypeInfoOf: aNodeUnderCursor in: methodNode definedAt: class]
				ifParseNodeAbsent: [ 	mousePositionInText <= methodNode selectorLastPosition 
						ifTrue: [ self balloonTypeInfoOf: methodNode in: methodNode definedAt: class ]
						ifFalse: [ '' ]
				]]
		ifErrorsParsing: [ :anError | '' ]


! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/11/2024 20:01:14' prior: 50591439!
balloonTypeInfoOf: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class) 		calculateTypesWithContext; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!SmalltalkEditor methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/11/2024 20:02:26' prior: 50598834!
balloonTypeInfoOf: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class

	^[ ((ParseNodeTypesDisplay of: aNodeUnderCursor within: aBlockNode in: methodNode definedAt: class) 		
		calculateTypesWithContext; 
		initializeTypeInfo;
		typeInfo) printTypesUpTo: 5 ]
		on: MethodNotAnnotatingTypes 
		do: [ :anError | 'Could not get type because: ', anError messageText ]
! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499036!
totalSize
	
	^self implementorsSize + self notImplementedSize! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499056!
notImplementedSize
	
	^notImplemented size! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499078!
finderTypeString
	
	self subclassResponsibility ! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499051!
notImplementedIsEmpty
	
	^notImplemented isEmpty ! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499069!
selector
	
	^selector ! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499041!
initializeOf: aSelector forAll: aTypes

	selector := aSelector.
	types := aTypes! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499074 overrides: 16914075!
value

	self subclassResponsibility ! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499047!
notImplemented
	
	^notImplemented! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499031!
implementorsSorted
	
	^implementors asArray sort! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499022!
implementorsIsEmpty
	
	^implementors isEmpty ! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499065!
types
	
	^types! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499027!
implementorsSize
	
	^implementors size! !
!ActualImplementorsFinder methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499061!
notImplementedSorted
	
	^notImplemented sort ! !
!ActualImplementorsFinder class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499083!
of: aSelector forAll: aTypes

	^self new initializeOf: aSelector forAll: aTypes! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490944!
hasPossibleMessageSends

	^ possibleMessageSends notEmpty! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490938!
hasOnlySureMessageSends

	^sureMessageSends notEmpty and: [ possibleMessageSends isEmpty ]! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490981!
isSureMessageSendFor: receiverTypes
	
	^receiverTypes anySatisfy: [ :aReceiverType | 
		(aReceiverType includesBehavior: sentMethodClass) or: [ isToAnalizeInSuperclass and: [ aReceiverType = toAnalizeMethodClass ]]]! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490903 overrides: 16919345!
visitMessageNode: aMessageNode
	
	(aMessageNode selector isNamed: sentSelector) ifTrue: [ self analizeMessageSend: aMessageNode ].
		
	^super visitMessageNode: aMessageNode 
	! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490921!
initializeIn: toAnalizeCompiledMethod of: aSentCompiledMethod 

	toAnalize := toAnalizeCompiledMethod.
	toAnalizeMethodClass := toAnalizeCompiledMethod methodClass.
	sent := aSentCompiledMethod.
	sentSelector := sent selector.
	sentMethodClass := sent methodClass.
	isToAnalizeInSuperclass := sentMethodClass includesBehavior: toAnalizeMethodClass.
	
	sureMessageSends := OrderedCollection new.
	possibleMessageSends := OrderedCollection new.! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490893!
possibleMessageSends
	
	^possibleMessageSends ! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490898!
sureMessageSends
	
	^sureMessageSends! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535185!
analizeMessageSend: aMessageNode
	
	 | receiverTypes incompleteTypeInfoReasons |

	incompleteTypeInfoReasons := Set new.
	receiverTypes := [ aMessageNode receiverOrCascadeReceiver 
		basicTypesIn: toAnalize 
		addingIncompleteTypeInfoTo: incompleteTypeInfoReasons ]
			on: MethodNotAnnotatingTypes 
			do: [ :anError | #() ].			
	
	receiverTypes isEmpty
		ifTrue: [ possibleMessageSends add: aMessageNode->(Array with: 'Could not get receiver''s type info') ]
		ifFalse: [ 
			"A method can have sure message sends and possible message sends!! - Hernan"
			(self isSureMessageSendFor: receiverTypes) ifTrue: [ sureMessageSends add: aMessageNode ].
			incompleteTypeInfoReasons notEmpty ifTrue: [ possibleMessageSends add: aMessageNode->incompleteTypeInfoReasons ]]! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490912 overrides: 16919354!
visitMessageNodeInCascade: aMessageNode
	
	(aMessageNode selector isNamed: sentSelector) ifTrue: [ self analizeMessageSend: aMessageNode ].
		
	^super visitMessageNodeInCascade: aMessageNode 
	! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490949!
hasSureMessageSends

	^sureMessageSends notEmpty! !
!ActualMessageSendsCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490991!
in: toAnalizeCompiledMethod of: aSentCompiledMethod 
	
	^self new initializeIn: toAnalizeCompiledMethod of: aSentCompiledMethod 
! !
!ActualSendersMessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490718 overrides: 16898594!
messageSendsRangesOf: aSelector
	
	^ selectedMessage 
		ifNil: [ #() ]
		ifNotNil: [selectedMessage rangesOf: aSelector whenSendTo: types ]
! !
!ActualSendersMessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490726!
initializeTypes: aReceiverTypes 

	types := aReceiverTypes.
! !
!ActualSendersMessageSet class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50490731!
messageList: messageList types: aReceiverTypes 

	| newInstance |
	
	newInstance := self messageList: messageList.
	^newInstance initializeTypes: aReceiverTypes ! !
!AllActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499104 overrides: 50598877!
finderTypeString
	
	^'Actual'! !
!AllActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499089 overrides: 50598901!
value 

	| typeImplementors |
	
	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType | 
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty 
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!AllActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499126 overrides: 50598877!
finderTypeString
	
	^'Actual Local'! !
!AllActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499109 overrides: 50598901!
value
	
	notImplemented := OrderedCollection new.
	implementors := types 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selector ) 
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!AllActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541654!
liveTypeValue
	
	notImplemented := OrderedCollection new.
	implementors := IdentitySet new.
	types liveTypesDo: [ :aLiveType | 
		(aLiveType liveClass lookupSelector: selector ) 
			ifNil: [ notImplemented add: (NotImplementedMethod class: aLiveType liveClass selector: selector ) ]
			ifNotNil: [ :method | implementors add: method ].
		 ].

	implementors := implementors collect: [ :method | method asMethodReference ].
	
	^self 
! !
!BrowseActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499311 overrides: 50499248!
browseForCommonSupertype: aCommonSupertype

	Smalltalk browseAllActualImplementorsOf: sentSelector for: aCommonSupertype ! !
!BrowseActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499319 overrides: 50499254!
browseWhenAtMethodSelector

	Smalltalk browseAllActualmplementorsOf: methodToLookUp ! !
!BrowseActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499298 overrides: 50499238!
browseAll

	Smalltalk browseAllImplementorsOf: sentSelector 	! !
!BrowseActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499304 overrides: 50499243!
browseForAllTypes

	Smalltalk browseAllActualImplementorsOf: sentSelector forAll: types ! !
!BrowseActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499331 overrides: 50499275!
showBrowseActualAnywayLabel
	
	^'Show actual implementors anyway' ! !
!BrowseActualImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499326 overrides: 50499259!
browseActualLabel

	^'implementors'! !
!BrowseActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499344 overrides: 50599151!
browseForCommonSupertype: aCommonSupertype

	self browseForAllTypes ! !
!BrowseActualLocalImplementors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499337 overrides: 50599173!
browseForAllTypes

	Smalltalk browseAllActualLocalImplementorsOf: sentSelector forAll: types 
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499264!
incompleteTypeInfoQuestionTitle
	
	^'Incomplete type info. What do you want to do?'! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499194!
browseActualWithTypeInfoAndIncompleteTypeInfo
	
	| menu labels icons selectionIndex |
	
	labels := OrderedCollection with: self showBrowseActualAnywayLabel with: self seeAllLabel.
	icons := OrderedCollection with: Theme current acceptIcon with: Theme current acceptIcon.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray.
	incompleteTypeInfoReasons do: [ :anIncompleteTypeInfo | 
		labels add: anIncompleteTypeInfo reasonDescription.
		icons add: Theme current closeIcon ].
	
	menu := PopUpMenu labelArray: labels lines: #(2) icons: icons.
	selectionIndex := menu startUpWithCaption: self incompleteTypeInfoQuestionTitle.
	selectionIndex = 1 ifTrue: [ ^self browseActualWithTypeInfoNoMatterIncompleteTypeInfo ].
	selectionIndex = 2 ifTrue: [ ^self browseAll ].
	selectionIndex > 2 ifTrue: [ ^(incompleteTypeInfoReasons at: selectionIndex - 2) browse ]
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499224!
browseActualWithTypeInfoNoMatterIncompleteTypeInfo

	| receiverTypeInfo |

	receiverTypeInfo := VariableTypeInfo new initializeRawTypes: types asArray.
	receiverTypeInfo 
		withCommonSupertypeDo: [ :aCommonSupertype | self browseForCommonSupertype: aCommonSupertype ]	
		 ifGeneric: [ :aGenericType | self browseForAllTypes ].
		
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499184!
browseActualWithTypeInfo
	
	incompleteTypeInfoReasons isEmpty 
		ifTrue: [ self browseActualWithTypeInfoNoMatterIncompleteTypeInfo ]
		ifFalse: [ self browseActualWithTypeInfoAndIncompleteTypeInfo ]
		
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499248!
browseForCommonSupertype: aCommonSupertype
	
	self subclassResponsibility ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499254!
browseWhenAtMethodSelector
	
	self subclassResponsibility ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499238!
browseAll
	
	self subclassResponsibility ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499138!
browse
	
	| methodSelector | 

	methodSelector := methodNode selector.
	methodToLookUp := class 
		compiledMethodAt: methodSelector 
		ifAbsent: [ NotImplementedMethod class: class selector: methodSelector ].
 	cursorPosition < methodNode selectorLastPosition ifTrue: [ ^self browseWhenAtMethodSelector ].
	
	methodNode 
		withParseNodeIncluding: cursorPosition 
		do: [ :aNodeUnderCursor | aNodeUnderCursor isMessageNode 
			ifTrue: [ ^self browseActualMessageNode: aNodeUnderCursor ] ]
		ifAbsent: [].
		
	 morph flash 
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499130!
initializeOf: aMethodNode definedIn: aClass withCursorAt: aPosition in: aMorph

	methodNode := aMethodNode.
	class := aClass.
	cursorPosition := aPosition.
	morph := aMorph ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499243!
browseForAllTypes
	
	self subclassResponsibility ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499275!
showBrowseActualAnywayLabel
	
	self subclassResponsibility ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535510!
browseActualMessageNode: messageNode 
self halt.
	sentSelector := messageNode selector key.
	incompleteTypeInfoReasons := Set new.
	types := messageNode receiverOrCascadeReceiver typesIn: methodToLookUp addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.

	types isEmptyType
		ifTrue: [ self browseActualWithNoTypeInfoSendTo: messageNode receiverOrCascadeReceiver ]
		ifFalse: [ self browseActualWithTypeInfo ].
		
		
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499174!
browseActualWithNoTypeInfoSendTo: receiver

	(self confirm: 'There is no type info for ', receiver nodeTypeAndIdentifierPrintString, '
Do you want to see all ', self browseActualLabel, '?') ifTrue: [ self browseAll ]
		
! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499259!
browseActualLabel

	self subclassResponsibility ! !
!BrowseActualSelectors methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499270!
seeAllLabel
	
	^'See all ', self browseActualLabel! !
!BrowseActualSelectors class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499280!
browseOf: aMethodNode definedIn: aClass withCursorAt: aPosition in: aMorph

	^(self of: aMethodNode definedIn: aClass withCursorAt: aPosition in: aMorph) browse! !
!BrowseActualSelectors class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499289!
of: aMethodNode definedIn: aClass withCursorAt: aPosition in: aMorph

	^self new initializeOf: aMethodNode definedIn: aClass withCursorAt: aPosition in: aMorph
! !
!BrowseActualSenders methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499363 overrides: 50599269!
browseForCommonSupertype: aCommonSupertype

	| implementor |
	
	implementor := aCommonSupertype lookupSelector: sentSelector .
	implementor isNil
		ifTrue: [ self browseForAllTypes ]
		ifFalse: [ Smalltalk browseAllActualSendersOn: implementor ]
! !
!BrowseActualSenders methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499375 overrides: 50599275!
browseWhenAtMethodSelector

	Smalltalk browseAllActualSendersOn: methodToLookUp ! !
!BrowseActualSenders methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499350 overrides: 50599281!
browseAll

	Smalltalk browseAllCallsOn: sentSelector ! !
!BrowseActualSenders methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499356 overrides: 50599315!
browseForAllTypes

	 Smalltalk browseAllActualSendersOn: sentSelector forAll: types ! !
!BrowseActualSenders methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499387 overrides: 50599321!
showBrowseActualAnywayLabel
	
	^'Show actual senders anyway' ! !
!BrowseActualSenders methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499382 overrides: 50599355!
browseActualLabel

	^'senders'! !
!ClassType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499412 overrides: 50499396!
asTypeFor: aReceiverType

	^((`Set with: Behavior with: ClassDescription with: Class with: Metaclass`) includes: aReceiverType) 
		ifTrue: [ Metaclass ]
		ifFalse: [ aReceiverType class ]
	! !
!ClassType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499421 overrides: 50499392!
typeName

	^'class'! !
!DynamicType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499396!
asTypeFor: aReceiverType

	self subclassResponsibility ! !
!DynamicType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499401 overrides: 16914834!
printOn: aStream

	aStream nextPutAll: self typeName ! !
!DynamicType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499405!
TO_DO

"
should it be used only as message return type? it looks like...
Should I call it MetaReturnType?

"! !
!DynamicType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499392!
typeName

	self subclassResponsibility ! !
!HierarchyInstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501503 overrides: 50501165!
typesSize
	
	^self types size! !
!HierarchyInstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501481 overrides: 50501118!
isTypesEmpty
	
	^self types isEmpty! !
!HierarchyInstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501466!
allSubclassesTypesPlus: thisClassTypes

	| typesWithAllSubclasses |
			
	typesWithAllSubclasses := Set withAll: thisClassTypes.
	
	class allSubclassesDo: [ :aSubclass | | subclassTypes |
		subclassTypes := (aSubclass instanceVariablesTypes localTypeInfoOf: variableName) types.
		typesWithAllSubclasses addAll: subclassTypes ].
	
	^typesWithAllSubclasses! !
!HierarchyInstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501493 overrides: 50501137!
types
	
	| thisClassTypes |
	
	thisClassTypes := super types.
	
	^ class isSubclassesEmpty 
		ifTrue: [ thisClassTypes ]
		ifFalse: [ self allSubclassesTypesPlus: thisClassTypes ]! !
!HierarchyInstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501485!
maxRawTypesSize
	
	^(class withAllSubclasses collect: [ :aSubclass | aSubclass instanceVariableRawTypesSizeFor: variableName ]) max! !
!HierarchyInstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501461 overrides: 50501365!
isMegamorphic
	
	^ self types size >= self maxRawTypesSize! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499471!
reasonDescription
	
	^reasonDescription ! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499467!
methodReference
	
	^methodReference! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541672!
initializeOf: aMethodReference describedAs: aReasonDescription node: aMessageNode
	
	methodReference := aMethodReference.
	reasonDescription := aReasonDescription .
	messageNode := aMessageNode.! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499482 overrides: 16913610!
= anObject

	^ self class = anObject class and: [ reasonDescription = anObject reasonDescription]! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499489 overrides: 16913626!
hash

	^reasonDescription hash! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499475!
browse
	
	BrowserWindow fullOnClass: methodReference actualClass selector: methodReference methodSymbol ! !
!IncompleteTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499459!
initializeOf: aMethodReference describedAs: aReasonDescription
	
	methodReference := aMethodReference.
	reasonDescription := aReasonDescription ! !
!IncompleteTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541682!
of: aMethodReference describedAs: aReasonDescription node: aMessageNode
	
	^self new initializeOf: aMethodReference describedAs: aReasonDescription node: aMessageNode.! !
!IncompleteTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499493!
of: aMethodReference describedAs: aReasonDescription
	
	^self new initializeOf: aMethodReference describedAs: aReasonDescription! !
!IncompleteTypeInfoError methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499500!
addTo: aMethodTypeCheckerVisitor node: aMessageNode 
	
	aMethodTypeCheckerVisitor addWarning: self node: aMessageNode ! !
!IncompleteTypeInfoError class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499515!
missingImplementationDescriptionOf: aMethodReference 
	
	^'#', aMethodReference selector, ' not implemented in ', aMethodReference actualClass name! !
!IncompleteTypeInfoError class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499507!
dueToMissingImplementationOf: aMethodReference 
	
	^self of: aMethodReference describedAs: (self missingImplementationDescriptionOf: aMethodReference)! !
!IncompleteTypeInfoWarning methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541691!
addTo: aMethodTypeCheckerVisitor node: aMessageNode 
	
	aMethodTypeCheckerVisitor addWarning: self node: aMessageNode ! !
!IncompleteTypeInfoWarning class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499538!
noReturnTypesDescriptionOf: aMethodReference 
	
	^'There is no return type info for ', aMethodReference classAndSelector! !
!IncompleteTypeInfoWarning class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541718!
missingImplementationDescriptionOf: aMethodReference 
	
	^'#', aMethodReference selector, ' not implemented in ', aMethodReference actualClass name! !
!IncompleteTypeInfoWarning class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541699!
dueToMissingImplementationOf: aMethodReference 
	
	^self of: aMethodReference describedAs: (self missingImplementationDescriptionOf: aMethodReference)! !
!IncompleteTypeInfoWarning class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499530!
dueToNoReturnTypeOf: aMethodReference 
	
	^self of: aMethodReference describedAs: (self noReturnTypesDescriptionOf: aMethodReference)! !
!IncompleteTypeInfoWarning class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50541708!
dueToNoReturnTypeOf: aMethodReference node: aMessageNode
	
	^self of: aMethodReference describedAs: (self noReturnTypesDescriptionOf: aMethodReference) node: aMessageNode.! !
!InstanceType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499425 overrides: 50599442!
asTypeFor: aReceiverType

	^aReceiverType isMeta 
		ifTrue: [ aReceiverType soleInstance ]
		ifFalse: [ 
			(aReceiverType = Behavior or: [ aReceiverType = ClassDescription or: [ aReceiverType = Class or: [ aReceiverType = Metaclass ]]])
				ifTrue: [ aReceiverType ]
				ifFalse: [ self error: self class onlyBehaviorsCanBeConvertedToInstanceTypeErrorDescription ]]
			
			! !
!InstanceType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499440 overrides: 50599460!
typeName

	^'instance'! !
!InstanceType class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499444!
onlyBehaviorsCanBeConvertedToInstanceTypeErrorDescription
	
	^'Only behaviors can be converted by instance type'! !
!InstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501446!
initializeOf: anInstVarName in: aClass are: aRawTypes

	variableName := anInstVarName.
	class := aClass.
	self initializeRawTypes: aRawTypes ! !
!InstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501429 overrides: 50501386!
identifier

	^class->self variableName ! !
!InstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501438!
addTypeFrom: anInstance

	| instVarType |
	
	instVarType := (anInstance instVarNamed: variableName) class.
	self addType: instVarType ifFull: []! !
!InstanceVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501434 overrides: 50501390!
variableName

	^variableName ! !
!InstanceVariableTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501454!
of: anInstVarName in: aClass are: rawTypes

	^self new initializeOf: anInstVarName in: aClass are: rawTypes
! !
!InstanceVariableTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500920 overrides: 50500664!
addCrudOptions

	self addCrudOptionsFor: instVarTypeInfo ! !
!InstanceVariableTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500926 overrides: 50535635!
showTypes
	
	types isEmpty 
		ifTrue: [ self inform: 'There is no type info for ', instVarTypeInfo variableName ]
		ifFalse: [ self showTypesWhenNotEmpty ].
! !
!InstanceVariableTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500911!
initializeTypeInfo: anInstanceVariableTypeInfo 
	
	instVarTypeInfo := anInstanceVariableTypeInfo.
	types := instVarTypeInfo types.
	incompleteTypeInfoReasons := #()! !
!InstanceVariableTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500935 overrides: 50500827!
showTypesPopUp

	| menu |

	menu := PopUpMenu labelArray: labels lines: lines icons: icons.
	selectedIndex := menu startUpWithCaption: 'Type info of inst var ', instVarTypeInfo variableName ! !
!InstanceVariableTypesDisplay class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500945!
typeInfo: anInstanceVariableTypeInfo 
	
	^self new initializeTypeInfo: anInstanceVariableTypeInfo! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501866!
addNumberOfRawTypesTo: aBagCollector

	rawTypes ifNotNil: [ class allInstVarNames do: [ :anInstVarName | aBagCollector add: (self localTypeInfoOf: anInstVarName) typesSize ]]! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501922 overrides: 50501654!
typeInfoOf: anInstVarName ifAbsent: anAbsentBlock

	(class definesInstanceVariableNamedInHierarchy: anInstVarName) ifFalse:[ ^anAbsentBlock value ].
	
	^ self typeInfoInHierarchyOf: anInstVarName! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501875!
addTypeInformationOf: anInstance using: instVarTypes

	instVarTypes do: [ :anInstVarTypeInfo | anInstVarTypeInfo addTypeFrom: anInstance ]
	! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501899!
rawTypesOf: anInstVarName

	| instVarIndex |
	
	instVarIndex := class indexOfInstanceVariable: anInstVarName ifAbsent: [ ^self error: anInstVarName, ' is not defined in ', class name, ' or its hierarchy' ].
	
	^(rawTypes isNil or: [ instVarIndex > rawTypes size ]) 
		ifTrue: [ nil ]
		ifFalse: [ rawTypes at: instVarIndex ].
	! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501939 overrides: 50501671!
typesInfoSize
	
	^self variablesNames size! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501882!
localTypeInfoOf: anInstVarName

	| instVarRawTypes |
	
	instVarRawTypes := self rawTypesOf: anInstVarName.
		
	^ class createLocalInstanceVariableTypeInfoOf: anInstVarName with: instVarRawTypes ! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501854!
storeAllInstancesCurrentTypes

	| instVarTypes |
	
	rawTypes isNil ifTrue: [ ^self ].
	
	instVarTypes := class allInstVarNames collect: [ :anInstVarName | self localTypeInfoOf: anInstVarName ].
	class allInstancesDo: [ :anInstance | self addTypeInformationOf: anInstance using: instVarTypes ] 
	! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501892 overrides: 50501643!
localTypesInfoDo: aBlock
	
	self variablesNames do: [ :variableName | aBlock value: (self localTypeInfoOf: variableName) ]! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501948!
doesStoreTypes
	
	^rawTypes notNil ! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501838!
initializeEachInstanceVariableRawTypes

	rawTypes ifNotNil: [ 
		class allInstVarNames withIndexDo: [ :instVarName :instVarIndex | 
			rawTypes at: instVarIndex put: (class createInstanceVariableRawTypesFor: instVarName) ]]! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501944 overrides: 50501726!
variablesNames

	^class instVarNames ! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501932 overrides: 50501659!
typesInfoDo: aBlock
	
	self variablesNames do: [ :variableName | aBlock value: (self typeInfoOf: variableName) ]! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501952!
megamorphicInstanceVariables

	^ class allInstVarNames select: [ :anInstVarName | (self typeInfoOf: anInstVarName) isMegamorphic]! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501848!
initializeOf: aClass rawTypes: aRawTypes
	
	class := aClass.
	rawTypes := aRawTypes.
	! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501912!
typeInfoInHierarchyOf: anInstVarName

	| instVarRawTypes |
	
	instVarRawTypes := self rawTypesOf: anInstVarName.
		
	^ class createHierarchyInstanceVariableTypeInfoOf: anInstVarName with: instVarRawTypes ! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501966!
of: aClass rawTypes: rawTypes

	^self new initializeOf: aClass rawTypes: rawTypes! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50502003 overrides: 50501822!
printTypesInfoHeaderOn: aStream

	aStream 
		newLine;
		nextPut: $";
		newLine.	
		! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501987!
initializeForAllClassesWithAllInstances

	"
	self initializeForAllClassesWithAllInstances.
	"

	ProtoObject withAllSubclassesDo: [ :aClass | aClass initializeInstanceVariablesRawTypesWithAllInstances]! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501972 overrides: 50501808!
unload: aClassToUnload from: aRawTypes 

	InstanceVariableTypeInfo unload: aClassToUnload from: aRawTypes ! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501979!
initializeForAllClasses

	"
	self initializeForAllClasses.
	"

	ProtoObject withAllSubclassesDo: [ :aClass | aClass initializeInstanceVariablesRawTypes]! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501997 overrides: 50501833!
of: aClass do: aBlock

	aBlock value: aClass instanceVariablesTypes ! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50502010 overrides: 50501762!
numberOfRawTypesForAll

	"
	self numberOfRawTypesForAll
	"
	
	| numberOfTypes |
	
	numberOfTypes := Bag new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addNumberOfRawTypesTo: numberOfTypes ]].
	
	^numberOfTypes contents! !
!InstanceVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50501960!
of: aClass

	^self of: aClass rawTypes: aClass instanceVariablesRawTypes! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500021!
addAndClassifySelectorStep1SourceCode

	^'addAndClassifySelector: nodeOrSelector withMethod: compiledMethod inProtocol: category notifying: requestor

	| priorMethodOrNil priorProtocolOrNil selector |

	selector := nodeOrSelector isSymbol ifTrue: [nodeOrSelector ] ifFalse: [ nodeOrSelector selector ].
	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: nil.
	priorProtocolOrNil _ self whichCategoryIncludesSelector: selector.
	self addSelectorSilently: selector withMethod: compiledMethod.
	compiledMethod initializeTypeInformation.
	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].

	priorMethodOrNil
		ifNil: [
			SystemChangeNotifier uniqueInstance 
				methodAdded: compiledMethod 
				selector: selector 
				inProtocol: category 
				class: self 
				requestor: requestor ]
		ifNotNil: [
			
			SystemChangeNotifier uniqueInstance 
				methodChangedFrom: priorMethodOrNil 
				to: compiledMethod 
				selector: selector 
				inClass: self 
				requestor: requestor.
			category = priorProtocolOrNil ifFalse: [
				SystemChangeNotifier uniqueInstance
					selectorRecategorized: selector
					from: priorProtocolOrNil
					to: category
					inClass: self ]]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535545!
addGetterFor: aClass on: aSelector forParameter: aParameterIndex

	genericsStorage addGetterFor: aClass on: aSelector forParameter: aParameterIndex! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535574!
trace: aSelector for: aGenericClass onArg: anArgumentIndex

	genericsStorage trace: aSelector for: aGenericClass onArg: anArgumentIndex.! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499751!
classListMenuOptions

	^ `{
			{
				#itemGroup 		-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 	LiveTyping aMenuLabel. 
				#selector 		-> 		#yourself.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'type check (T)'.
				#selector 		-> 		#typeCheckClass.
				#object 			-> 		#model.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'reset types'.
				#selector 		-> 		#resetClassType.
				#object 			-> 		#model.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500123!
blockReturnTopSourceCode

	^'blockReturnTop
	
	"I do not want block returns to affect method return types that is why
	I send return:from: to super - Hernan"
	
	self assert: closureOrNil isClosure.
	^super return: self pop from: self'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535558!
initializeGenerics

	genericsStorage := GAConfigurableStorage new.
	! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499581!
compile: aNewSourceCode in: aClass ifOriginalSourceCodeIs: anOriginalSourceCode
	
	| newSourceCodeMethodNode originalSourceMethodNode |
	
	newSourceCodeMethodNode := aClass methodNodeFor: aNewSourceCode.
	originalSourceMethodNode := aClass methodNodeFor: anOriginalSourceCode.
	
	newSourceCodeMethodNode selector = originalSourceMethodNode selector ifFalse: [ self error: 'New source code selector is not equal to original source code selector' ].
	(aClass sourceCodeAt: originalSourceMethodNode selector) = anOriginalSourceCode ifFalse: [ self error: 'Current source code of ', aClass name, '>>', originalSourceMethodNode selector, ' is not equal to the expected one' ].
	
	aClass compile: aNewSourceCode ! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535539!
addGetterFor: aClass on: aSelector

	genericsStorage addGetterFor: aClass on: aSelector.! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499848!
smalltalkEditorCmdShortcutsSpec

	^#(
			#(		$P	#showSelectionTypeInfo:		'Prints type info of selection')
			#(		$B	#actualSendersOfIt:				'Actual senders of message under cursor')
			#(		$M	#actualImplementorsOfIt:			'Actual implementors of message under cursor')
			#(		$L  #actualLocalImplementorsOfIt:  'Actual Local implementros of message under cursor')
			#(		$T  #typeCheckMethod:  'Type check the selected method')
		)
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499700!
modifyClassDescriptionShape

	[[ SystemChangeNotifier uniqueInstance doSilently: [ self defineInstVarNamed: 'instanceVariablesRawTypes' in: ClassDescription ]]
		on: Warning do: [ :aWarning | aWarning resume ]]
		on: Error do: [ :anError | anError return: nil ]
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499983!
addAndClassifySelectorSourceCode

	^'addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor

	| priorMethodOrNil priorProtocolOrNil |

	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: nil.
	priorProtocolOrNil _ self whichCategoryIncludesSelector: selector.
	self addSelectorSilently: selector withMethod: compiledMethod.
	compiledMethod initializeTypeInformation.
	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].

	priorMethodOrNil
		ifNil: [
			SystemChangeNotifier uniqueInstance 
				methodAdded: compiledMethod 
				selector: selector 
				inProtocol: category 
				class: self 
				requestor: requestor ]
		ifNotNil: [
			
			SystemChangeNotifier uniqueInstance 
				methodChangedFrom: priorMethodOrNil 
				to: compiledMethod 
				selector: selector 
				inClass: self 
				requestor: requestor.
			category = priorProtocolOrNil ifFalse: [
				SystemChangeNotifier uniqueInstance
					selectorRecategorized: selector
					from: priorProtocolOrNil
					to: category
					inClass: self ]]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500299!
messageListKeyFromSourceCode

	^'messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	self flag: #definesKeyboardShortcuts.
	aChar = $D ifTrue: [^ model toggleDiffing].

	sel := model selectedMessageName.
	aChar = $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar = $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	aChar = $M ifTrue: [ ^ self browseActualImplementorsOfSelectedMethod ].
	aChar = $B ifTrue: [ ^ self browseActualSendersOfSelectedMethod ].
	aChar = $X ifTrue: [ ^ self model removeMessageCheckingActualSenders ].

	"The following require a class selection"
	(class := model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar = $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar = $N ifTrue: [^ self browseClassRefs].
	aChar = $i ifTrue: [^ self methodInheritance].
	aChar = $h ifTrue: [^ self browseHierarchy].
	aChar = $p ifTrue: [^ self browseFullProtocol].

	sel
		ifNotNil: [
			"The following require a method selection"
			aChar = $o ifTrue: [^ model fileOutMessage].
			aChar = $c ifTrue: [^ model copySelector].
			aChar = $v ifTrue: [^ self browseVersions].
			aChar = $C ifTrue: [^ model showHomeCategory].
			aChar = $O ifTrue: [^ self openSingleMessageBrowser].
			aChar = $x ifTrue: [^ model removeMessage].
			aChar = $t ifTrue: [^ model runMethodTest].
			aChar = $r ifTrue: [^ model debugMethodTest].
			aChar = $T ifTrue: [^ self model typeCheckMethod ]]
		ifNil: [
			aChar = $R ifTrue: [^ model renameClass].
			aChar = $T ifTrue: [ ^ self model typeCheckClass ]]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535532!
addGeneric: aClass withParameters: aParametersQuantity

	genericsStorage addGeneric: aClass withParameters: aParametersQuantity! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499661 overrides: 50504893!
initializeTypeInformation

	ProtoObject withAllSubclassesDo: [ :aClass | 
		aClass shouldLiveTypingBeDisabled
			ifTrue: [ aClass disableLiveTypingForAll ]
			ifFalse: [ 
				aClass initializeInstanceVariablesRawTypesWithAllInstances.
				aClass initializeMethodsTypeInformation]].
	
	self initializeWellKnownReturnTypes.
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535590!
trace: aSelector for: aGenericClass onArgs: paramToArgIndexAssociations 
	
	genericsStorage trace: aSelector for: aGenericClass onArgs: paramToArgIndexAssociations ! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500247!
messageListKeyFromOriginalSourceCode

	^'messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	self flag: #definesKeyboardShortcuts.
	aChar = $D ifTrue: [^ model toggleDiffing].

	sel := model selectedMessageName.
	aChar = $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar = $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class := model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar = $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar = $N ifTrue: [^ self browseClassRefs].
	aChar = $i ifTrue: [^ self methodInheritance].
	aChar = $h ifTrue: [^ self browseHierarchy].
	aChar = $p ifTrue: [^ self browseFullProtocol].

	sel
		ifNotNil: [
			"The following require a method selection"
			aChar = $o ifTrue: [^ model fileOutMessage].
			aChar = $c ifTrue: [^ model copySelector].
			aChar = $v ifTrue: [^ self browseVersions].
			aChar = $C ifTrue: [^ model showHomeCategory].
			aChar = $O ifTrue: [^ self openSingleMessageBrowser].
			aChar = $x ifTrue: [^ model removeMessage].
			aChar = $t ifTrue: [^ model runMethodTest].
			aChar = $r ifTrue: [^ model debugMethodTest]]
		ifNil: [
			aChar = $R ifTrue: [^ model renameClass]]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499727 overrides: 16916096!
initialize

	Utilities informUser: 'Initializing live typing' during: [ self initializeLiveTyping ].
	! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499743!
aMenuLabel

	"I had to call it aMenuLabel and not just menuLabel because it has to be loaded before classListMenuOptions for
	it compile - Hernan"
	^'LiveTyping'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499606!
compileAfterInstallMethods.

	self 
		compile: self addAndClassifySelectorStep1SourceCode in: ClassDescription ifOriginalSourceCodeIs: self addAndClassifySelectorOriginalSourceCode;
		compile: self compileClassifiedWithStampNotifyingLogSourceSourceCode in: ClassDescription ifOriginalSourceCodeIs: self compileClassifiedWithStampNotifyingLogSourceOriginalSourceCode;
		compile: self addAndClassifySelectorStep2SourceCode in: ClassDescription ifOriginalSourceCodeIs: self addAndClassifySelectorStep1SourceCode;
		compile: self doneCompilingSourceCode in: ClassDescription ifOriginalSourceCodeIs: self doneCompilingOriginalSourceCode;
		compile: self unloadSourceCode in: Class ifOriginalSourceCodeIs: self unloadOriginalSourceCode;
		compile: self recompileFromSourceCode in: Behavior ifOriginalSourceCodeIs: self recompileFromOriginalSourceCode;
		compile: self messageListKeyFromSourceCode in: CodeWindow ifOriginalSourceCodeIs: self messageListKeyFromOriginalSourceCode;
		compile: self mouseMoveLocalPositionSourceCode in: InnerTextMorph ifOriginalSourceCodeIs: self mouseMoveLocalPositionOriginalSourceCode;
		compile: self setSenderReceiverMethodArgumentsSourceCode in: MethodContext 
			ifOriginalSourceCodeIs: self setSenderReceiverMethodArgumentsOriginalSourceCode;
		compile: self blockReturnTopSourceCode in: MethodContext ifOriginalSourceCodeIs: self blockReturnTopOriginalSourceCode 
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500110!
blockReturnTopOriginalSourceCode

	^'blockReturnTop
	"Simulate the interpreter''s action when a ReturnTopOfStackToCaller bytecode is 
	 encountered in the receiver.  This should only happen in a closure activation."
	self assert: closureOrNil isClosure.
	^self return: self pop from: self'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500423!
recompileFromSourceCode

	^'recompile: selector from: oldClass
	"Compile the method associated with selector in the receiver''s method dictionary."
	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"
	| method trailer methodNode newMethod |
	method _ oldClass compiledMethodAt: selector.
	trailer _ method trailer.
	methodNode _ self compilerClass new
				compile: (oldClass sourceCodeAt: selector)
				in: self
				notifying: nil
				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"
	selector == methodNode selector ifFalse: [self error: ''selector changed!!''].
	newMethod _ methodNode generate: trailer.
	self addSelectorSilently: selector withMethod: newMethod.
	newMethod copyTypeInformationFrom: method using: methodNode'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50500490!
unloadSourceCode

	^'unload
	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."

	self unloadFromAllRawTypes'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499653!
defineInstVarNamed: anInstVarName in: aClass

	(aClass definesInstanceVariableNamed: anInstVarName ) ifFalse: [ aClass addInstVarName: anInstVarName ]! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50499712!
registerRefactoringAppliers

	RefactoringApplier 
		registerRenameSelectorApplier: RenameSelectorWithActualScopeApplier;
		registerAddParameterApplier: AddParameterWithActualScopeApplier;
		registerRemoveParameterApplier: RemoveParameterWithActualScopeApplier;
		registerExtractAsParameterApplier: ExtractAsParameterApplierWithActualScopeApplier 
		! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:47' prior: 50535563!
stopTracing: aClass 
	
	genericsStorage stopTracing: aClass.! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499573!
checkTimeStampOf: aMethod is: expectedTimeStamp

	aMethod timeStamp = expectedTimeStamp ifFalse: [ self error: aMethod classAndSelector, ' has changed' ].! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500233!
doneCompilingSourceCode

	^'doneCompiling
	"A ClassBuilder has finished the compilation of the receiver.
	This message is a notification for a class that needs to do some
	cleanup / reinitialization after it has been recompiled."
	
	self withAllSubclassesDo: [ :aClass | aClass initializeInstanceVariablesRawTypes ]'
	
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499674!
initializeWellKnownReturnTypes

	Number allSubclassesDo: [ :aClass |
		#(< <= = ~= >= >) do: [ :aSelector | self addReturnTypes: { True. False } to: aSelector in: aClass ].
		self addReturnTypes: { Float } to: #asFloat in: aClass ].
	
	#(bitOr: bitAnd: bitXor: bitShift:) do: [ :aSelector | 
		self addReturnTypes: { SmallInteger } to: aSelector in: SmallInteger ].
	
	! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499920!
systemCategoryMenuOptions

	^`{
			{
				#itemGroup 		-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 	LiveTyping aMenuLabel. 
				#selector 		-> 		#yourself.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Type Check'.
				#selector 		-> 		#typeCheckCategory.
				#object 			-> 		#model.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'reset types'.
				#selector 		-> 		#resetCategoryTypes.
				#object 			-> 		#model.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499946!
addAndClassifySelectorOriginalSourceCode

	^'addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor
	| priorMethodOrNil priorProtocolOrNil |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: nil.
	priorProtocolOrNil := self whichCategoryIncludesSelector: selector.
	self addSelectorSilently: selector withMethod: compiledMethod.
	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].
	priorMethodOrNil
		ifNil: [
			SystemChangeNotifier uniqueInstance 
				methodAdded: compiledMethod 
				selector: selector 
				inProtocol: category 
				class: self 
				requestor: requestor ]
		ifNotNil: [
			SystemChangeNotifier uniqueInstance 
				methodChangedFrom: priorMethodOrNil 
				to: compiledMethod 
				selector: selector 
				inClass: self 
				requestor: requestor.
			category = priorProtocolOrNil ifFalse: [
				SystemChangeNotifier uniqueInstance
					selectorRecategorized: selector
					from: priorProtocolOrNil
					to: category
					inClass: self ]]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500398!
recompileFromOriginalSourceCode

	^'recompile: selector from: oldClass
	"Compile the method associated with selector in the receiver''s method dictionary."
	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"
	| method trailer methodNode |
	method := oldClass compiledMethodAt: selector.
	trailer := method trailer.
	methodNode := self compilerClass new
				compile: (oldClass sourceCodeAt: selector)
				in: self
				notifying: nil
				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"
	selector == methodNode selector ifFalse: [self error: ''selector changed!!''].
	self addSelectorSilently: selector withMethod: (methodNode generate: trailer).
'
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500482!
unloadOriginalSourceCode

	^'unload
	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."
	""
'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499864!
smalltalkEditorMenuOptions

	^`{
			{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		10.
				#label 			-> 	LiveTyping aMenuLabel. 
				#selector 		-> 		#yourself.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#submenuOf ->				LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Show type info (P)'.
				#selector 		-> 		#showSelectionTypeInfo.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#submenuOf ->				LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Actual Senders of it (B)'.
				#selector 		-> 		#actualSendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#submenuOf ->				LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'Actual Implementors of it (M)'.
				#selector 		-> 		#actualImplementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#submenuOf ->				LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'Actual Local Implementors of it (L)'.
				#selector 		-> 		#actualLocalImplementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#submenuOf ->				LiveTyping aMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Type Check (T)'.
				#selector 		-> 		#typeCheckMethod.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#submenuOf ->				LiveTyping aMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Reset types'.
				#selector 		-> 		#resetMethodTypes.
				#object 			-> 		#codeProvider.
				#icon 			-> 		#deleteIcon
			} asDictionary.

		}`
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535607!
traceConstructor: aMethodReference for: aType onParametersFromArgs: anArgumentIndexCollection

	genericsStorage traceConstructor: aMethodReference for: aType onParametersFromArgs: anArgumentIndexCollection! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500134!
compileClassifiedWithStampNotifyingLogSourceOriginalSourceCode

	^'compile: code classified: category withStamp: changeStamp notifying: requestor logSource: logSource
	
	| methodAndNode selector isExistingMethod updatedCode |	
	methodAndNode := self basicCompile: code notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector := methodAndNode selector.
	isExistingMethod := self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: ''Method modification not allowed'']]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: ''Method addition not allowed'']].
	logSource ifTrue: [
		"Re-fetching source code may be needed if, for example, some variable declaration was corrected during compilation."
		updatedCode := CodeProvider normalizeCodeForCodeFiles: (requestor ifNil: [code] ifNotNil: [requestor text]).
		self logMethodSource: updatedCode forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp notifying: requestor.
	].
	self addAndClassifySelector: selector withMethod: methodAndNode 
		method inProtocol: category notifying: requestor.
	^ methodAndNode selector'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499560!
checkRedefinedMethodsDidNotChange

	self 
		checkTimeStampOf: ContextPart>>#popIntoTemporaryVariable: is: 'eem 6/15/2008 11:34';
		checkTimeStampOf: ContextPart>>#return:from: is: 'jar 1/18/2024 17:52:20' ;
		checkTimeStampOf: ContextPart>>#storeIntoRemoteTemp:inVectorAt: is: 'eem 5/12/2009 13:05'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500450!
setSenderReceiverMethodArgumentsOriginalSourceCode

	^'setSender: s receiver: r method: m arguments: args 
	"Create the receiver''s initial state."

	sender := s.
	receiver := r.
	method := m.
	closureOrNil := nil.
	pc := method initialPC.
	self stackp: method numTemps.
	1 to: args size do: [:i | self at: i put: (args at: i)]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500377!
mouseMoveLocalPositionSourceCode

	^'mouseMove: aMouseMoveEvent localPosition: localEventPosition

	self shouldShowBalloonHelp ifTrue: [
		aMouseMoveEvent hand 
			removePendingBalloonFor: self;
			triggerBalloonFor: self after: self balloonHelpDelayTime ].
	
	aMouseMoveEvent mouseButton1Pressed ifFalse: [
		^ self enterClickableRegion: aMouseMoveEvent localPosition: localEventPosition ].
	self handleInteraction: [
		editor mouseMove: aMouseMoveEvent localPosition: localEventPosition].
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500464!
setSenderReceiverMethodArgumentsSourceCode

	^'setSender: s receiver: r method: m arguments: args 
	"Create the receiver''s initial state."

	| parameterIndex |
	
	sender := s.
	receiver := r.
	method := m.
	closureOrNil := nil.
	pc := method initialPC.
	self stackp: method numTemps.
	parameterIndex := args size.
	1 to: args size do: [:i | 
		method annotateTemporaryTypeOf: (self at: i put: (args at: i)) at: parameterIndex.
		parameterIndex := parameterIndex - 1. ]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535553!
getGenericsStorage

	^genericsStorage asNonConfigurableStorage ! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535568!
stopTracing: aSelector for: aClass 
	
	genericsStorage stopTracing: aSelector for: aClass .! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499545!
addReturnTypes: types to: aSelector in: aClass

	| methodReturnTypeInfo |
	
	methodReturnTypeInfo := (aClass compiledMethodAt: aSelector ifAbsent: [ ^self ]) returnTypeInfo.
	"Abstract methods, quick return methods do not have a types array, that is the reason of the ifFull: .. - Hernan"
	types do: [ :type | methodReturnTypeInfo addType: type ifFull: [] ]! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499776!
messageListMenuOptions

	^`{{
				#itemGroup 		-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 	LiveTyping aMenuLabel. 
				#selector 		-> 		#yourself.
				#icon 			-> 		#acceptIcon
		} asDictionary.
		{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'actual senders of it (B)'.
				#selector 		-> 		#browseActualSendersOfSelectedMethod.
				#icon 			-> 		#mailForwardIcon
		} asDictionary.
		{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'actual implementors of it (M)'.
				#selector 		-> 		#browseActualImplementorsOfSelectedMethod.
				#icon 			-> 		#developmentIcon
		} asDictionary.
		{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove method checking actual senders (X)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessageCheckingActualSenders.
				#icon 			-> 		#deleteIcon
		} asDictionary.	
		{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Type Check (T)'.
				#selector 		-> 		#typeCheckMethod.
				#object 			-> 		#model.
				#icon 			-> 		#acceptIcon
		} asDictionary.
		{
				#submenuOf -> LiveTyping aMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Reset types'.
				#selector 		-> 		#resetMethodTypes.
				#object 			-> 		#model.
				#icon 			-> 		#deleteIcon
		} asDictionary.		


		{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		15.
				#label 			-> 		'actual senders of it (B)'.
				#selector 		-> 		#browseActualSendersOfSelectedMethod.
				#icon 			-> 		#mailForwardIcon
		} asDictionary.
		{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		25.
				#label 			-> 		'actual implementors of it (M)'.
				#selector 		-> 		#browseActualImplementorsOfSelectedMethod.
				#icon 			-> 		#developmentIcon
		} asDictionary.
		{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		15.
				#label 			-> 		'remove method checking actual senders (X)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessageCheckingActualSenders.
				#icon 			-> 		#deleteIcon
		} asDictionary.			
		}`
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500063!
addAndClassifySelectorStep2SourceCode

	^'addAndClassifySelector: node withMethod: compiledMethod inProtocol: category notifying: requestor

	| priorMethodOrNil priorProtocolOrNil selector |

	selector := node selector.
	priorMethodOrNil _ self compiledMethodAt: selector ifAbsent: nil.
	priorProtocolOrNil _ self whichCategoryIncludesSelector: selector.
	self addSelectorSilently: selector withMethod: compiledMethod.

	"I pass the methodNode becuase the compiledMethod needs the temps mapping to initialize its var raw types.
	So to avoid parsing and generating the code again to get the temps mapping I pass the alredy created method node - Hernan" 
	compiledMethod initializeTypeInformationUsing: node.

	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].

	priorMethodOrNil
		ifNil: [
			SystemChangeNotifier uniqueInstance 
				methodAdded: compiledMethod 
				selector: selector 
				inProtocol: category 
				class: self 
				requestor: requestor ]
		ifNotNil: [
			
			SystemChangeNotifier uniqueInstance 
				methodChangedFrom: priorMethodOrNil 
				to: compiledMethod 
				selector: selector 
				inClass: self 
				requestor: requestor.
			category = priorProtocolOrNil ifFalse: [
				SystemChangeNotifier uniqueInstance
					selectorRecategorized: selector
					from: priorProtocolOrNil
					to: category
					inClass: self ]]'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500361!
mouseMoveLocalPositionOriginalSourceCode

	^'mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [
		^ self enterClickableRegion: aMouseMoveEvent localPosition: localEventPosition ].
	self handleInteraction: [
		editor mouseMove: aMouseMoveEvent localPosition: localEventPosition].
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499733!
initializeLiveTyping

	self 
		modifyClassDescriptionShape;
		modifyAdditionalMethodStateShape;
		checkRedefinedMethodsDidNotChange;
		compileAfterInstallMethods;
		initializeTypeInformation;
		registerRefactoringAppliers! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500178!
compileClassifiedWithStampNotifyingLogSourceSourceCode

	^'compile: code classified: category withStamp: changeStamp notifying: requestor logSource: logSource
	
	| methodAndNode selector isExistingMethod updatedCode |	
	methodAndNode _ self basicCompile: code notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector _ methodAndNode selector.
	isExistingMethod _ self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: ''Method modification not allowed'']]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: ''Method addition not allowed'']].
	logSource ifTrue: [
		"Re-fetching source code may be needed if, for example, some variable declaration was corrected during compilation."
		updatedCode _ CodeProvider normalizeCodeForCodeFiles: (requestor ifNil: [code] ifNotNil: [requestor text]).
		self logMethodSource: updatedCode forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp notifying: requestor.
	].
	self addAndClassifySelector: methodAndNode node withMethod: methodAndNode 
		method inProtocol: category notifying: requestor.
	^ methodAndNode selector'! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535598!
traceConstructor: aMethodReference for: aType onArgs: anArgumentIndexCollection

	genericsStorage traceConstructor: aMethodReference for: aType onArgs: anArgumentIndexCollection.! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499689!
modifyAdditionalMethodStateShape

	#('variablesRawTypes' 'returnRawTypes' 'remoteVectorRawTypes' 'variableNameToTypeIndex' 'variableNameToRemoteVectorTypeIndex') 
		do: [ :aVariableName | self defineInstVarNamed: aVariableName  in: AdditionalMethodState ]! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535527!
addGeneric: aClass 
	
	genericsStorage addGeneric: aClass.! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500222!
doneCompilingOriginalSourceCode

	^'doneCompiling
	"A ClassBuilder has finished the compilation of the receiver.
	This message is a notification for a class that needs to do some
	cleanup / reinitialization after it has been recompiled."'
	
! !
!LiveTyping class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535582!
trace: aSelector for: aGenericClass onArgParameter: anArgumentIndex 
	
	genericsStorage trace: aSelector for: aGenericClass onArgParameter: anArgumentIndex ! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497379!
addCommonMessagesStartingWith: prefixedSelectors

	| selectorsCollector |
	
	selectorsCollector := AutoCompleterSelectorsCollector for: prefix.
	
	entries := selectorsCollector 
		addedSelectors: prefixedSelectors;
		addSelectorsOfAll: selectorsClasses upTo: Object;
		addSelectorsOf: Object;		
		entriesToShow.
		
	self addCommonMessagesToEntries: prefixedSelectors.
		
	possibleInvalidSelectors := selectorsCollector possibleInvalidSelectors! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497651!
tryToRecoverFromSyntaxErrorWithMethodNodeDo: doBlock ifError: anErrorBlock
	
	^ self withMethodNodeOf: self allSource do: doBlock ifError: anErrorBlock 
	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497684!
withMethodNodeOf: aSourceCode do: doBlock ifError: anErrorBlock

	^ [[ | methodNode noPattern |

		noPattern := (model is: #providesBindings) 
			or: [(model is: #hasTextProvider) 
				and: [ (model textProvider is: #providesBindings)
					and: [ (model textProvider is: #CodeProvider) not]]].
				
		methodNode := (parser classOrMetaClass ifNil: [ UndefinedObject ]) 
			methodNodeFor: aSourceCode
			noPattern: noPattern .
		doBlock value: methodNode ] 
		on: UndeclaredVariableReference 
		do: [  :anUndeclareVariableReference | anUndeclareVariableReference declareTempAndResume ]]
		on: Error - MessageNotUnderstood 
		do: anErrorBlock
		
	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497875!
computeMessageEntriesWithBinaryMessageForTypeInfo: aVariableTypeInfo 
 
	aVariableTypeInfo 
		withCommonSupertypeDo: [ :commonSupertype | 
			self 
				computeMessageEntriesWithBinaryMessageForCommonSupertype: commonSupertype 
				of: aVariableTypeInfo ]
		ifGeneric: [ :genericType | 
			self computeMessageEntriesWithBinaryMessageForGenericSupertypeOf: aVariableTypeInfo ].
	
! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497660!
withMethodNodeDo: doBlock ifError: anErrorBlock

	^ self 
		withMethodNodeOf: parser source 
		do: doBlock 
		handlingSyntaxErrorOrIfError: anErrorBlock! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497777!
typeOfCascadeReceiverIn: methodNode at: aPosition 

	^methodNode 
		withTopParseNodeIncluding: aPosition 
		do: [ :aNodeUnderCursor | self commonSupertypeOrSelectorsOf: aNodeUnderCursor receiverOrCascadeReceiver in: methodNode ]
		ifAbsent: [ nil ].
		! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497521 overrides: 16952126!
computeMessageEntriesOfEnclosedExpressionReturn   

	 | typeInfo |

	typeInfo := self 
		withMethodNodeDo: [ :methodNode |
			self 
				returnTypeOfEnclosedExpresionIn: methodNode 
				at: (allRanges at: self indexOfNoRightParenthesis) end ]
		ifError: [ :anError | nil ].

	self computeMessageEntriesForTypeInfoOrNil: typeInfo ! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497499 overrides: 16952120!
computeMessageEntriesOfCascadeReceiver

	 | positionBeforeSemiColon typeInfo |

	positionBeforeSemiColon := currentRange end - 1.

	"I have to parse excluding the last semi-colon because if not a syntax error will be signaled 
	because the cascade message is not finished - Hernan"
	typeInfo := self
		withMethodNodeOf: (parser source first: positionBeforeSemiColon) 
		do: [ :methodNode | self typeOfCascadeReceiverIn: methodNode at: positionBeforeSemiColon ]
		ifError: [ :anError | nil ].

	self computeMessageEntriesForTypeInfoOrNil: typeInfo ! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497668!
withMethodNodeOf: aSourceCode do: doBlock handlingSyntaxErrorOrIfError: anErrorBlock

	^self 
		withMethodNodeOf: aSourceCode
		do: doBlock 
		ifError: [ :anError |
			(anError isKindOf: SyntaxErrorNotification) 
				ifTrue: [ self tryToRecoverFromSyntaxError: anError withMethodNodeOf: aSourceCode do: doBlock ifError: anErrorBlock ]
				ifFalse: [ anErrorBlock value: anError ]]
	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497476!
computeMessageEntriesForTypeInfo: aVariableTypeInfo   

	self isPreviousMessageSendBinary
		ifTrue: [ self computeMessageEntriesWithBinaryMessageForTypeInfo: aVariableTypeInfo ]
		ifFalse: [ self computeMessageEntriesWithoutBinaryMessageForTypeInfo: aVariableTypeInfo ]
		! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497617!
indexOfNoRightParenthesis
	
	| currentIndex |
	
	currentIndex := allRanges size - 1.
	[ currentIndex > 1 and: [
	(allRanges at: currentIndex) rangeType beginsWith: #'rightParenthesis']] whileTrue: [ currentIndex := currentIndex - 1 ].

	^currentIndex
			! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497830!
computeMessageEntriesWithBinaryMessageForClass: aClass 
	collectingWith: selectorsCollector 
	asRoot: hierarchyRoot 
 
	| classes |
	
	classes := Set new.
	"In the case of sending a message to super in ProtoObject, aClass will be nil because 
	ProtoObject has no superclass - Hernan"
	aClass ifNotNil: [ classes add: aClass ].
	selectorsCollector addUnaryAndBinarySelectorsOf: aClass.	
	
	self 
		computeMessageEntriesWithBinaryMessageForClasses: classes 
		collectingWith: selectorsCollector 
		asRoot: hierarchyRoot 

	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497767!
returnTypeOfNodeUnderCursorIn: methodNode at: aPosition

	^methodNode
		withParseNodeIncluding: aPosition 
		do: [ :aNodeUnderCursor | self commonSupertypeOrSelectorsOf: aNodeUnderCursor in: methodNode ]
		ifAbsent: [ nil ]! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497397!
addCommonMessagesToEntries: prefixedSelectors

	^ prefixedSelectors notEmpty ifTrue: [
		entries addAllFirst: prefixedSelectors asSortedCollection.
		entries size > 1 ifTrue: [ entries addFirst: '-- common selectors excluding Object' ].
	 ]! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497535!
computeMessageEntriesWithBinaryMessageForCommonSupertype: commonSupertype of: aVariableTypeInfo 
	
	| selectorsCollector classes |
	
	classes := Set withAll: aVariableTypeInfo types.
	selectorsCollector := AutoCompleterSelectorsCollector for: prefix.
	selectorsCollector 
		addUnaryAndBinarySelectorsOf: commonSupertype upTo: Object;
		addUnaryAndBinarySelectorsOfAll: classes upTo: commonSupertype;
		addUnaryAndBinarySelectorsOf: Object.
		
	self 
		computeMessageEntriesWithBinaryMessageForClasses: classes 
		collectingWith: selectorsCollector 
		asRoot: Object.
	
	self ifEmptyEntriesShowAllPrefixedSelectors
! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497635!
tryToRecoverFromSyntaxError: aSyntaxErrorNotification withMethodNodeOf: aSourceCode do: doBlock ifError: anErrorBlock
	
	^ aSyntaxErrorNotification errorMessage = 'right parenthesis expected' 
		ifTrue: [ self withMethodNodeOf: aSourceCode, ')' do: doBlock handlingSyntaxErrorOrIfError: anErrorBlock ]
		ifFalse: [ self withMethodNodeOf: self allSource do: doBlock ifError: anErrorBlock ]
	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497442!
computeMessageEntriesForGenericSupertypeOf: aVariableTypeInfo
			
	 | prefixedSelectors protoObjectReached | 

	selectorsClasses := aVariableTypeInfo types.
	selectorsClasses isEmpty ifTrue: [ ^self computeMessageEntriesForUnknowClass ].
	
	"If Object is not in the superclasses chain, then it means we are working with ProtoObject or any of its
	subclasses outside the Object hierarchy, so the common selectors are ProtoObject ones - Hernan"
	protoObjectReached := false.
	prefixedSelectors := aVariableTypeInfo 
		commonSelectorsPreviousTo: Object 
		ifInvalidSupertype: [ :aType | 
			protoObjectReached := true.
			ProtoObject selectors ].
	prefix notEmpty ifTrue: [ prefixedSelectors := prefixedSelectors select: [ :aSelector | aSelector beginsWith: prefix ]].

	protoObjectReached 
		ifTrue: [ entries := prefixedSelectors sorted ]
		ifFalse: [ self addCommonMessagesStartingWith: prefixedSelectors.].
	
	self ifEmptyEntriesShowAllPrefixedSelectors
		
	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497629 overrides: 16952447!
documentationOf: aMethod

	^aMethod liveTypingAutoCompleterDocumentation! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497707!
argumentOf: nodeToAnalyze ifPreviousIsBinaryMessageIn: methodNode
		
	^(self isPreviousMessageSendBinary and: [ nodeToAnalyze isMessageNode and: [ nodeToAnalyze isInfix ]]) 
		ifTrue: [ self handleArgumentOf: nodeToAnalyze whenPreviousIsBinaryMessage: methodNode ]
		ifFalse: [ nodeToAnalyze ]

			
! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497558!
computeMessageEntriesWithBinaryMessageForGenericSupertypeOf: aVariableTypeInfo 
			
	 | prefixedSelectors classes protoObjectReached selectorsCollector | 

	classes := Set withAll: aVariableTypeInfo types.
	classes isEmpty ifTrue: [ ^self computeMessageEntriesForUnknowClass ].
	protoObjectReached := false.
	
	"If Object is not in the superclasses chain, then it means we are working with ProtoObject or any of its
	subclasses outside the Object hierarchy, so the common selectors are ProtoObject ones - Hernan"
	prefixedSelectors := aVariableTypeInfo 
		commonSelectorsPreviousTo: Object 
		ifInvalidSupertype: [ :aType | 
			protoObjectReached := true.
			ProtoObject selectors ].
	prefixedSelectors := prefixedSelectors select: [ :aSelector | (aSelector beginsWith: prefix) and: [ aSelector isKeyword not ]].

	selectorsCollector := AutoCompleterSelectorsCollector for: prefix.
	selectorsCollector addedSelectors: prefixedSelectors.
	
	protoObjectReached ifFalse: [
		selectorsCollector
			addUnaryAndBinarySelectorsOfAll: classes upTo: Object;
			addUnaryAndBinarySelectorsOf: Object ].
	
	self
		computeMessageEntriesWithBinaryMessageForClasses: classes 
		collectingWith: selectorsCollector 
		asRoot: Object. 
 
	self addCommonMessagesToEntries: prefixedSelectors.
		
	self ifEmptyEntriesShowAllPrefixedSelectors
		
	! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497750!
returnTypeOfEnclosedExpresionIn: methodNode at: aPosition

	^ methodNode  
		withTopParseNodeIncluding: aPosition
		do: [ :aNodeUnderCursor | | nodeToAnalyze |
			nodeToAnalyze := aNodeUnderCursor isReturn ifTrue: [ aNodeUnderCursor expr ] ifFalse: [ aNodeUnderCursor ].
			nodeToAnalyze := self argumentOf: nodeToAnalyze ifPreviousIsBinaryMessageIn: methodNode.
			self commonSupertypeOrSelectorsOf: nodeToAnalyze in: methodNode ]
		ifAbsent: [ nil ]! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497819 overrides: 16952149!
computeMessageEntriesWithBinaryMessageForClass: aClass 
 
	self 
		computeMessageEntriesWithBinaryMessageForClass: aClass 
		collectingWith: (AutoCompleterSelectorsCollector for: prefix) 
		asRoot: Object! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535464!
commonSupertypeOrSelectorsOf: aNodeUnderCursor in: aMethodNode  
	
	| methodToAnalyze types liveTypes methodClass |
	
	methodClass := aMethodNode encoder classEncoding.
	methodToAnalyze := methodClass compiledMethodAt: aMethodNode selector ifAbsent: [ NotImplementedMethod class: methodClass selector: aMethodNode selector ].
	
	liveTypes := (aNodeUnderCursor typesIn: methodToAnalyze addingIncompleteTypeInfoTo: Set new).
	types := OrderedCollection new. 
	liveTypes classTypesDo: [:aClass | types add: aClass].
	
	^ VariableTypeInfo new initializeRawTypes: types asArray.
	
! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497789!
addBinarySelectorsTo: selectorsCollector classes: classes for: typeInfo with: hierarchyRoot 

	| types prefixedSelectors classLimit |
	
	types := typeInfo types.
	classes addAll: types.
	
	typeInfo 
		withCommonSupertypeDo: [ :commonSupertype | 
			classes add: commonSupertype. 
			selectorsCollector addKeywordSelectorsOf: commonSupertype upTo: hierarchyRoot.
			classLimit := commonSupertype ]
		ifGeneric: [ :genericType | 
			prefixedSelectors := typeInfo commonSelectorsPreviousToObject 
				select: [ :aSelector | (aSelector beginsWith: prefix) and: [ aSelector isKeyword ]].
			selectorsCollector addedSelectors: prefixedSelectors.
			classLimit := hierarchyRoot ].
		
	selectorsCollector
		addKeywordSelectorsOfAll: types upTo: classLimit;
		addKeywordSelectorsOf: hierarchyRoot ! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497851!
computeMessageEntriesWithBinaryMessageForClasses: classes 
	collectingWith: selectorsCollector 
	asRoot: hierarchyRoot 
 
	| binaryMessageReturnTypeInfo |
	
	self
		withMethodNodeDo: [ :methodNode | 
			binaryMessageReturnTypeInfo := self returnTypeOfNodeUnderCursorIn: methodNode at: possibleBinarySendRange end.
			self addBinarySelectorsTo: selectorsCollector classes: classes for: binaryMessageReturnTypeInfo with: hierarchyRoot ]
		ifError: [ :anError | ].
		
	selectorsClasses := classes asArray.
	entries := selectorsCollector entriesToShow.
	possibleInvalidSelectors := selectorsCollector possibleInvalidSelectors.! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497422!
computeMessageEntriesForCommonSupertype: commonSupertype of: aVariableTypeInfo
	
	| selectorsCollector |
	
	selectorsClasses := aVariableTypeInfo types.
	selectorsCollector := AutoCompleterSelectorsCollector for: prefix.
	entries := selectorsCollector
		addSelectorsOf: commonSupertype upTo: Object;
		addSelectorsOfAll: selectorsClasses upTo: commonSupertype;
		addSelectorsOf: Object;
		entriesToShow.
		
	possibleInvalidSelectors := selectorsCollector possibleInvalidSelectors.
	
	self ifEmptyEntriesShowAllPrefixedSelectors
! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497738!
handleArgumentOf: nodeToAnalyze whenPreviousIsBinaryMessage: methodNode

	| argument |

	argument := nodeToAnalyze arguments first.
	argument isMessageNode ifTrue: [ 
		methodNode 
			rangeForNode: argument selector 
			ifAbsent: [  argument := argument receiver  ]].

	^argument! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497603!
computeMessageEntriesWithoutBinaryMessageForTypeInfo: aVariableTypeInfo

	aVariableTypeInfo 
		withCommonSupertypeDo: [ :commonSupertype | 
			self computeMessageEntriesForCommonSupertype: commonSupertype of: aVariableTypeInfo ]
		ifGeneric: [ :genericType | 
			self computeMessageEntriesForGenericSupertypeOf: aVariableTypeInfo ]! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497488!
computeMessageEntriesForTypeInfoOrNil: aVariableTypeInfoOrNil  

	aVariableTypeInfoOrNil 
		ifNil: [ self computeMessageEntriesForUnknowClass ]
		ifNotNil: [ self computeMessageEntriesForTypeInfo: aVariableTypeInfoOrNil ]
	 ! !
!LiveTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497409 overrides: 16951994!
computeEntriesOfUnaryMessageReturnNamed: aSelector 
	
	| typeInfo |
	
	typeInfo := self
		withMethodNodeDo: [ :methodNode | self returnTypeOfNodeUnderCursorIn: methodNode at: currentRange end]
		ifError: [ :anError | nil ].
		
	self computeMessageEntriesForTypeInfoOrNil: typeInfo ! !
!LiveTypingSmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50497891 overrides: 16952739!
isForCurrentTypeSystem

	^ Smalltalk isLiveTypingInstalled ! !
!MethodNotAnnotatingTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490879!
method
	
	^method! !
!MethodNotAnnotatingTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490872 overrides: 16856627!
messageText

	messageText ifNil: [ messageText := method classAndSelector, ' is not anottating types' ].
	^messageText! !
!MethodNotAnnotatingTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490863 overrides: 16855782!
isResumable
	
	^ true! !
!MethodNotAnnotatingTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490867!
initializeFor: aMethod

	method := aMethod! !
!MethodNotAnnotatingTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490883!
signalFor: aMethod

	^(self for: aMethod) signal! !
!MethodNotAnnotatingTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490888!
for: aMethod

	^self new initializeFor: aMethod! !
!MethodVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501517!
initializeOf: aVarName in: aCompiledMethod are: aRawTypes

	variableName := aVarName.
	method := aCompiledMethod.
	self initializeRawTypes: aRawTypes ! !
!MethodVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501508 overrides: 50501386!
identifier

	^method -> self variableName ! !
!MethodVariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501513 overrides: 50501390!
variableName

	^variableName ! !
!MethodVariableTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501525!
of: aVarName in: aCompiledMethod are: rawTypes

	^self new initializeOf: aVarName in: aCompiledMethod are: rawTypes
! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502063!
addNumberOfRawTypesTo: aBagCollector

	self typesInfoDo: [ :aTypeInfo |  aBagCollector add: aTypeInfo typesSize ]
	! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502022 overrides: 50501654!
typeInfoOf: aVarName ifAbsent: anAbsentBlock

	| rawTypes |
	
	rawTypes := methodProperties rawTypesOf: aVarName ifAbsent: [ ^anAbsentBlock value ].
	
	^method methodClass createMethodVariableTypeInfoOf: aVarName in: method are: rawTypes ! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535667!
typeInfoOf: aVarName cachingPartialDataIn: aStorage ifAbsent: anAbsentBlock

	| rawTypes |
	
	rawTypes := methodProperties rawTypesOf: aVarName ifAbsent: [ ^anAbsentBlock value ].
	
	^method methodClass createMethodVariableTypeInfoOf: aVarName in: method are: rawTypes ! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502051!
variablesNamesDo: aBlock

	^ methodProperties variablesNamesDo: aBlock! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502041 overrides: 50501671!
typesInfoSize
	
	methodProperties numberOfVariables! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502056!
initializeOf: aCompiledMethod with: aMethodProperties

	method := aCompiledMethod.
	methodProperties := aMethodProperties 
! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502046 overrides: 50501726!
variablesNames

	^methodProperties variablesNames! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502033 overrides: 50501659!
typesInfoDo: aBlock
	
	self variablesNamesDo: [ :aVarName | aBlock value: (self typeInfoOf: aVarName ifAbsent: [ self error: 'should not happen' ])]! !
!MethodVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502121 overrides: 50501822!
printTypesInfoHeaderOn: aStream

	aStream 
		newLine;
		nextPutAll: '"Type info:';
		newLine.	
		! !
!MethodVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502077 overrides: 50501808!
unload: aClassToUnload from: aRawTypes 

	MethodVariableTypeInfo unload: aClassToUnload from: aRawTypes ! !
!MethodVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502084!
initializeForAllClasses

	"
	self initializeForAllClasses.
	"
	ProtoObject withAllSubclassesDo: [ :aClass | aClass initializeMethodsTypeInformation ]! !
!MethodVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502093 overrides: 50501833!
of: aClass do: aBlock

	aClass methodsDo: [ :aCompiledMethod | 
		[ aBlock value: aCompiledMethod methodVariablesTypes ]
			on: MethodNotAnnotatingTypes 
			do: [ :error | ]]! !
!MethodVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502102 overrides: 50501762!
numberOfRawTypesForAll

	"
	self numberOfRawTypesForAll
	"
	
	| numberOfTypes |
	
	numberOfTypes := Bag new.
	[ ProtoObject withAllSubclassesDo: [ :aClass | 
		self of: aClass do: [ :aVariablesTypesOrNil | aVariablesTypesOrNil ifNotNil: [ aVariablesTypesOrNil addNumberOfRawTypesTo: numberOfTypes ]]]]
		on: MethodNotAnnotatingTypes
		do: [ :anError | anError resume: (AdditionalMethodState forMethod: anError method selector: anError method selector) ].
	
	^numberOfTypes contents! !
!MethodVariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50502070!
of: aCompiledMethod

	^self new initializeOf: aCompiledMethod with: aCompiledMethod typeAnnotationsHolder! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491181 overrides: 16914075!
value

	self 
		calculateSendersInfo;
		groupSendersByType;
		createMessageList ! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491193!
messageList
	
	^messageList! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491079!
calculatePossibleSendersOf: aSentImplementor from: aPossibleSenders

	| senderInfo |
	
	aPossibleSenders do: [ :aPossibleSender | 
		senderInfo := sendersInfo at: aPossibleSender ifAbsentPut: [ SenderInfo of: aPossibleSender for: sentImplementors ].
		senderInfo addPossibleSender: aPossibleSender of: aSentImplementor ]! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491198!
messageListSize
	
	^messageList size - numberOfTitles ! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491173!
methodReferenceTitleForImplementors: implementors

	^self methodReferenceForTitle: (self titleForImplementors: implementors)! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491164!
methodReferenceForTitle: aTitle

	^ (MethodReference class: Object selector: ('_', numberOfTitles printString) asSymbol) 
		stringVersion: aTitle;
		yourself! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491212!
allImplementorsTitleOn: aStream

	| sentImplementorsByIsValid |
	
	aStream nextPutAll: sentImplementors anyOne selector.
	sentImplementorsByIsValid := sentImplementors groupBy: [ :anImplementor | anImplementor isValid ].
	
	self 
		allValidImplementorsTitleOn: aStream from: sentImplementorsByIsValid;
		allInvalidImplementorsTitleOn: aStream from: sentImplementorsByIsValid.	
		! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491064!
addToPossibleSenders: aSenderInfo

	| possibleSender | 
	
	possibleSender := possibleSenders 
		at: aSenderInfo sender 
		ifAbsentPut: [ PossibleSender in: aSenderInfo sender withPossibleMessageSends: #() ].
	
	aSenderInfo withPossibleMessageSendsDo: [:aPossibleMessageSend | 
		possibleSender addPossibleMessageSends: aPossibleMessageSend ]! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491203!
allImplementorsTitle
	
	^String streamContents: [ :aStream |
		aStream nextPutAll: '-- Senders of '.	
		self allImplementorsTitleOn: aStream.
		aStream nextPutAll: ' --'].! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491031!
addPossibleSendersToMessageList

	possibleSenders notEmpty ifTrue: [
		numberOfTitles := numberOfTitles + 1.
		messageList add: (self methodReferenceForTitle: '-- Possible senders --').
		messageList addAll: (possibleSenders values asSortedCollection: [ :left :right | left stringVersion < right stringVersion ]) ].

		
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50490999!
addCompleteSureSendersToMessageList

	completeSureSenders ifNotEmpty: [
		
		sentImplementors ifNotEmpty: [
			numberOfTitles := 1.
			messageList add: (self methodReferenceForTitle: self allImplementorsTitle) ].
		
		messageList addAll: (completeSureSenders asSortedCollection: [ :left :right | left stringVersion < right stringVersion ]) ].
	! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491045!
addToCompleteSureSenders: aSenderInfo

	completeSureSenders add: aSenderInfo sender ! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491014!
addPartialSureSendersToMessageList

	(partialSureSenders keys asSortedCollection: [ :left :right | left size > right size ]) do: [ :implementors |
		numberOfTitles := numberOfTitles + 1.
		messageList add: (self methodReferenceTitleForImplementors: implementors).
		messageList addAll: ((partialSureSenders at: implementors) 
			asSortedCollection: [ :left :right | left stringVersion < right stringVersion ]) ].
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491052!
addToPartialSureSenders: aSenderInfo

	| sureSendersOfPartialImplementors | 

	sureSendersOfPartialImplementors := partialSureSenders at: aSenderInfo sureSenders ifAbsentPut: [ Set new ]. 
	sureSendersOfPartialImplementors add: aSenderInfo sender ! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491228!
allInvalidImplementorsTitleOn: aStream from: sentImplementorsByIsValid
		
	sentImplementorsByIsValid 
		at: false 
		ifPresent: [ :notImplemented | 
			aStream 
				nextPutAll: ' and' when: (sentImplementorsByIsValid includesKey: true);
				nextPutAll: ' not implemented in ';
				nextPutAll: notImplemented asCommaSeparated: [ :aNotImplementor | 
					aStream print: aNotImplementor methodClass ]]
		ifAbsent: [].! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491093!
calculateSendersInfo
	
	sendersInfo := Dictionary new.	
	sentImplementors do: [ :aSentImplementor | self calculateSendersInfoOf: aSentImplementor ].
	
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491153!
groupSendersByType

	completeSureSenders := Set new.
	partialSureSenders := Dictionary new. 
	possibleSenders := Dictionary new. 
	
	sendersInfo valuesDo: [ :aSenderInfo | self groupSenderByTypeFor: aSenderInfo ].
	! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491128!
createMessageList

	messageList := OrderedCollection new.
	numberOfTitles := 0.
	
	self 
		addCompleteSureSendersToMessageList;
		addPartialSureSendersToMessageList;
		addPossibleSendersToMessageList
		
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491187!
initializeFor: aSentImplementors 

	sentImplementors := aSentImplementors ! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491102!
calculateSendersInfoOf: aSentImplementor

	| actualSenders | 
	
	actualSenders := Smalltalk allActualSendersOn: aSentImplementor.
	
	self 
		calculateSureSendersOf: aSentImplementor from: actualSenders first;
		calculatePossibleSendersOf: aSentImplementor from: actualSenders second.! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491115!
calculateSureSendersOf: aSentImplementor from: aSureSenders

	| senderInfo |
	
	aSureSenders do: [ :aMethodReference | 
		senderInfo := sendersInfo at: aMethodReference ifAbsentPut: [ SenderInfo of: aMethodReference for: sentImplementors ].
		senderInfo addSureSenderOf: aSentImplementor. ].
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535213!
actualSenders
	
	^completeSureSenders.! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491270!
titleForImplementors: implementors

	^String streamContents: [ :stream |
		stream 
			nextPutAll: '-- Senders of ';
			nextPutAll: implementors asCommaSeparated: [ :aMethod | aMethod printClassAndSelectorOn: stream ];
			nextPutAll: ' --' ]! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491139!
groupSenderByTypeFor: aSenderInfo
	
	aSenderInfo hasCompleteSureSenders ifTrue: [ self addToCompleteSureSenders: aSenderInfo ].
	aSenderInfo hasPartialSureSenders ifTrue: [ self addToPartialSureSenders: aSenderInfo ].
	aSenderInfo hasPossibleSenders ifTrue: [ self addToPossibleSenders: aSenderInfo ].


! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491259!
sentImplementorsAsString
	
	| sentImplementorsClassNames |
	
	sentImplementorsClassNames := sentImplementors collect: [:aSentImplementor | aSentImplementor methodClass name ].
	
	^sentImplementorsClassNames asCommaStringAnd
! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491245!
allValidImplementorsTitleOn: aStream from: sentImplementorsByIsValid

	sentImplementorsByIsValid 
		at: true 
		ifPresent: [ :implemented | 
			aStream 
				nextPutAll: ' implemented in ';
				nextPutAll: implemented asCommaSeparated: [ :anImplementor | 
					aStream print: anImplementor methodClass ]]
		ifAbsent: [].
! !
!MultiImplementorsActualMessageSendsCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491288!
on: sentSelector forAll: types whenSomeAreNotImplemented: notImplementedBlock whenNoImplementors: noImplementorsBlock

	| notImplemented sentImplementors |
	
	notImplemented := Set new.
	sentImplementors := types 
		inject: Set new 
		into: [ :sentCompiledMethods :type | 
			(type lookupSelector: sentSelector) 
				ifNil: [ 
					notImplemented add: type name.
					sentCompiledMethods add: (NotImplementedMethod class: type selector: sentSelector) ] 
				ifNotNil: [ :implementor | sentCompiledMethods add: implementor ].
			sentCompiledMethods ].
	
	notImplemented notEmpty ifTrue: [ notImplementedBlock value: notImplemented ].
	sentImplementors ifEmpty: noImplementorsBlock.
	
	^self for: sentImplementors ! !
!MultiImplementorsActualMessageSendsCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491282!
for: sentImplementors 

	^self new initializeFor: sentImplementors ! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491900 overrides: 50507153!
actualSendersOf: aCompiledMethod 

	^#()! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535262!
analyzeGenericsOn: aTfgNode storingGenericsInfoIn: aStorage

	"not implemented method, do nothing"! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535268!
liveTypesOfInstanceVariableNamed: anInstVarName storingGenericsInfoIn: aStorage ifAbsent: anAbsentBlock 
	
	^self actualClass liveTypesOfInstanceVariableNamed: anInstVarName storingGenericsInfoIn: aStorage ifAbsent: anAbsentBlock! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491891 overrides: 16902322!
setStandardClass: aClass methodSymbol: aSelector

	super setStandardClass: aClass methodSymbol: aSelector.
	self prefixStringVersionWith: self class notImplementedStringVersionHeader ! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491905 overrides: 16902413!
dynamicTypingAutoCompleterDocumentation

	^'' asText! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491910 overrides: 50507184!
liveTypingAutoCompleterDocumentation

	^'' asText! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535291!
returnLiveTypesForReceiver: aReceiverType usingStorage: aStorage

	^`EmptyType new`! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491920 overrides: 16902431!
hasVariableBindingTo: aClass 
	
	^false! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491924!
isTestMethod
	
	^false! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491928 overrides: 16902443!
referencesParameterAt: parameterIndex

	^false! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491870!
returnTypes
	
	^#()! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491874!
typesOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^self actualClass typesOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491915 overrides: 50507165!
doesOnlySurelySend: aCompiledMethod 
	
	^false! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535279!
liveTypesOfVariableNamed: aVarName storingGenericsInfoIn: aStorage ifAbsent: anAbsentBlock
	
	^anAbsentBlock value! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491882!
typesOfVariableNamed: aVarName ifAbsent: aBlockClosure 
	
	"I have not been compiled yet, so there is no info about parameters or temps - Hernan"
	^aBlockClosure value! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491933 overrides: 16902397!
printClassAndSelectorOn: aStream

	aStream nextPutAll: 'Not Implemented '.
	super printClassAndSelectorOn: aStream ! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535286!
returnLiveTypes: aStorage

	^`EmptyType new`! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50541537!
typesOfVariableNamed: aVariableName withNode: aMethodNode withinBlockNode: blockToTest addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	^(ContextAppliersMethodVisitor for: self with: aMethodNode on: aVariableName within: blockToTest addingIncompleteTypeInfoTo: incompleteTypeInfoReasons) types.! !
!NotImplementedMethod class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491940!
notImplementedStringVersionHeader
	
	^'Not implemented'! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500527!
visitLiteralVariableNode: aLiteralVariableNode! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500578!
visitTempVariableNode: aTempVariableNode

	typeInfo := method typeInfoOfVariableNamed: aTempVariableNode name ifAbsent: [ self resetTypeInfo ]! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500593!
resetTypeInfo

	typeInfo := nil! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500585!
visitUndeclaredVariableNode: aVariableNode! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500597!
withTypeInfoDo: aBlock ifNone: aNoneBlock

	self resetTypeInfo.
	parseNodeToAnalize accept: self.
	
	^typeInfo ifNotNil: aBlock ifNil: aNoneBlock.
	
	! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500514!
visitInstanceVariableNode: anInstanceVariableNode

	typeInfo := method methodClass typeInfoOfInstanceVariableNamed: anInstanceVariableNode name ifAbsent: [ self resetTypeInfo ]
	! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500561!
visitNewArrayNode: aNewArrayNode! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500523!
visitLiteralNode: aLiteralNode! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500510!
visitCascadeNode: aCascadeNode
	! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535617!
visitMessageNode: aMessageNode
	
	| implementors receiverTypes |
	
	receiverTypes := aMessageNode receiverOrCascadeReceiver typesIn: method addingIncompleteTypeInfoTo: Set new.
	implementors := IdentitySet new.
	receiverTypes classTypesDo: [ :aType | (aType lookupSelector: aMessageNode selectorSymbol) ifNotNil: [ :implementor | implementors add: implementor ]].
	
	implementors size = 1 ifTrue: [ typeInfo := implementors anyOne returnTypeInfo ]! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500574!
visitSelectorNode: aSelectorNode! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500605!
initializeOf: aParseNode in: aCompiledMethod 

	parseNodeToAnalize := aParseNode.
	method := aCompiledMethod ! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500589!
visitVariableNode: aVariableNode

! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500565!
visitRemoteTempVectorNode: aRemoteTempVectorNode! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500502!
visitBlockNode: aBlockNode
	
		! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500554!
visitMethodNode: aMethodNode
	
	"Used when cursor is in method selector - Hernan"
	
	typeInfo := method returnTypeInfo ! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500506!
visitBraceNode: aBraceNode
	! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500498!
visitAssignmentNode: anAssignmentNode
	! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500548!
visitMessageNodeInCascade: aMessageNode
	
	"does it with visitMessageNode - Hernan"! !
!ParseNodeTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500569!
visitReturnNode: aReturnNode
	
	typeInfo := method returnTypeInfo ! !
!ParseNodeTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500612!
of: aParseNode in: aCompiledMethod 

	^self new initializeOf: aParseNode in: aCompiledMethod 
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50541726!
calculateTypesWithContext

	incompleteTypeInfoReasons := Set new.
		
	types := methodToAnalyze typesOfVariableNamed: parseNodeToAnalize withNode: methodNodeOwner withinBlockNode: contextBlockNode addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray .
	
	! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500637!
addCommonSupertypeLabel

	typeInfo typesSize = 1
		ifTrue: [ | typeName |
			typeName := typeInfo types anyOne typeName.
			labels add: typeName.
			actions add: [ self browseClassNamed: typeName ].
			icons add: Theme current editFindReplaceIcon]
		ifFalse: [
			(typeInfo typesSize = 2 and: [ typeInfo includesNil ]) ifFalse: [
				typeInfo 
					withCommonSupertypeDo: [ :commonSupertype |
						labels add: commonSupertype typeName.
						actions add: [ self browseClassNamed: commonSupertype typeName ].
						icons add: Theme current goTopIcon ]
					ifGeneric: [ :genericType |
						labels add: self commonSelectorsOption.
						actions add: [ self showCommonSelectors ]. 
						icons add: Theme current spreadsheetIcon ].
				lines add: 1 ]]
		! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500702!
addTypesLabels

 	| typeIcon canBeNil |
	
	typeInfo typesSize > 1 ifTrue: [
		typeIcon := self typeIcon.
		canBeNil := false.
		typeInfo typesNames do: [ :aTypeName |
			aTypeName = UndefinedObject name 
				ifTrue: [ canBeNil := true ]
				ifFalse: [
					labels add: aTypeName.
					actions add: [ self browseClassNamed: aTypeName ].
					icons add: typeIcon ]].
		
		canBeNil ifTrue: [
			labels add: 'Can be nil'.
			icons add: Theme current warningIcon.
			actions add: [ self browseClassNamed: UndefinedObject name ]]].
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500857!
typeInfo
	
	^typeInfo! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535635!
showTypes

	types isEmptyType 
		ifTrue: [ self inform: 'There is no type info for ', parseNodeToAnalize nodeTypeAndIdentifierPrintString ]
		ifFalse: [ self showTypesWhenNotEmpty ].
	! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500744!
browseSelectedTypeOrCommonSelectors

	| selected |
		
	selected := labels at: selectedIndex.
	selected = self commonSelectorsOption 
		ifTrue: [ self showCommonSelectors ]
		ifFalse: [ self browseClassNamed: selected ]! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500781!
initializeTypeInfo

	typeInfo := VariableTypeInfo new initializeRawTypes: types asArray.
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500754!
calculateLabelsAndLines

	labels := OrderedCollection new.
	lines := OrderedCollection new.
	icons := OrderedCollection new.
	actions := OrderedCollection new.

	self 
		addCommonSupertypeLabel;
		addTypesLabels;
		addCrudOptions;
		addIncompleteTypesReasons
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500793!
isTypeSelection
	
	^selectedIndex between: 1 and: typesIndexLimit! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500798!
showCommonSelectors

	 | commonSelectors menu selectedSelectorIndex |
			
	commonSelectors := typeInfo commonSelectorsPreviousToObject.
	commonSelectors isEmpty ifTrue: [ ^self inform: 'There are no common selectors' ].
	commonSelectors := commonSelectors sorted.
	
	menu := PopUpMenu labelArray: commonSelectors.
	selectedSelectorIndex := menu startUpWithCaption: 'Common selectors'.
	selectedSelectorIndex = 0 ifFalse: [ Smalltalk browseAllActualImplementorsOf: (commonSelectors at: selectedSelectorIndex) forAll: typeInfo types ]! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500853!
parseNodeToAnalize
	
	^parseNodeToAnalize! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500737!
browseSelected
	
	| action |
	
	action := actions at: selectedIndex ifAbsent: [ ^self ].
	action value! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500880!
removeTypeFrom: aVariableTypeInfo
	
	| typeNamesToRemove typeNamesToRemoveIcons selectedTypeToRemoveIndex typeNameToRemove options |
	
	typeNamesToRemove := aVariableTypeInfo typesNames.
	typeNamesToRemoveIcons := typeNamesToRemove collect: [ :aType | self typeIcon ].
	
	options := PopUpMenu labelArray: typeNamesToRemove lines: #() icons: typeNamesToRemoveIcons.
	selectedTypeToRemoveIndex := options startUpWithCaption: 'Select type to remove'.
	
	typeNameToRemove := typeNamesToRemove at: selectedTypeToRemoveIndex ifAbsent: [ ^self ].
	aVariableTypeInfo removeType: (Smalltalk classNamed: typeNameToRemove)! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50541740!
initliazeOf: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass

	parseNodeToAnalize := aParseNodeToAnalize.
	contextBlockNode:=aBlockNode.
	methodNodeOwner := aMethodNodeOwner.
	definingClass := aClass.
	methodToAnalyze := definingClass 
		compiledMethodAt: methodNodeOwner selector 
		ifAbsent: [ NotImplementedMethod class: definingClass selector: methodNodeOwner selector ].
	
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500632!
show

	self 
		calculateTypes;
		showTypes
		! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500664!
addCrudOptions

	(ParseNodeTypeInfo of: parseNodeToAnalize in: methodToAnalyze) 
		withTypeInfoDo: [ :parseNoteTypeInfo | self addCrudOptionsFor: parseNoteTypeInfo ]
		ifNone: []! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500722!
browseClassNamed: aName

	(Smalltalk classNamed: aName)
		ifNil: [ self inform: 'Can not browse ', aName ]
		ifNotNil: [ :aClass | BrowserWindow fullOnClass: aClass selector: nil ]! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500875!
removeAllTypesFrom: aVariableTypeInfo
	
	aVariableTypeInfo removeAllTypes! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500673!
addCrudOptionsFor: aTypeInfo

	lines add: labels size.
	
	labels add: 'Add type ...'.
	icons add: Theme current listAddIcon.
	actions add: [ self addTypeTo: aTypeInfo ].
	
	labels add: 'Remove type ...'.
	icons add: Theme current listRemoveIcon.
	actions add: [ self removeTypeFrom: aTypeInfo ].
	
	labels add: 'Remove all types'.
	icons add: Theme current deleteIcon.
	actions add: [ self removeAllTypesFrom: aTypeInfo ].! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500844!
typeIcon

	^Theme current editFindReplaceIcon! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500618!
initliazeOf: aParseNodeToAnalize in: aMethodNodeOwner definedAt: aClass

	parseNodeToAnalize := aParseNodeToAnalize.
	methodNodeOwner := aMethodNodeOwner.
	definingClass := aClass.
	methodToAnalyze := definingClass 
		compiledMethodAt: methodNodeOwner selector 
		ifAbsent: [ NotImplementedMethod class: definingClass selector: methodNodeOwner selector ].
	
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500731!
browseIncompleteTypeInfo

	^(incompleteTypeInfoReasons at: selectedIndex - typesIndexLimit) browse ! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500776!
commonSelectorsOption

	^'Common selectors previous to Object'! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500765!
calculateTypes

	incompleteTypeInfoReasons := Set new.
	types := parseNodeToAnalize typesIn: methodToAnalyze addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray 
	! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500849!
definingClass
	
	^definingClass! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500861!
addTypeTo: aVariableTypeInfo

	| className trimmedNamed |
	
	className := ClassNameRequestMorph request: 'Enter type to add' orCancel: [ ^self ].
	trimmedNamed := className withBlanksTrimmed.
	
	(Smalltalk classNamed: trimmedNamed) ifNotNil: [ :aType | 
		aVariableTypeInfo addType: aType ifFull: [ self inform: 'There is no more space to add type' ]]! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500837!
showTypesWhenNotEmpty

	self 
		initializeTypeInfo;
		calculateLabelsAndLines;
		showTypesPopUp;
		browseSelected	! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500827!
showTypesPopUp

	| menu |

	menu := PopUpMenu labelArray: labels lines: lines icons: icons.
	selectedIndex := menu startUpWithCaption: 'Type info of ', parseNodeToAnalize nodeTypeAndIdentifierPrintString .
! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500690!
addIncompleteTypesReasons
	
	incompleteTypeInfoReasons notEmpty ifTrue: [
		lines add: labels size.
		incompleteTypeInfoReasons do: [ :aTypeInfoError | 
			labels add: aTypeInfoError reasonDescription.
			actions add: [ aTypeInfoError browse ].
			icons add: Theme current closeIcon ]]
	
	
	! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500787!
isIncompleteTypeInfoSelection
	
	^selectedIndex between: typesIndexLimit + 1 and: labels size! !
!ParseNodeTypesDisplay class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50541757!
of: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass

	^self new initliazeOf: aParseNodeToAnalize within: aBlockNode in: aMethodNodeOwner definedAt: aClass
! !
!ParseNodeTypesDisplay class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500903!
of: aParseNodeToAnalize in: aMethodNodeOwner definedAt: aClass

	^self new initliazeOf: aParseNodeToAnalize in: aMethodNodeOwner definedAt: aClass
! !
!PossibleSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491960!
withPossibleMessageSendsDo: aBlock
	
	possibleMessageSends do: aBlock! !
!PossibleSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50492002 overrides: 50507176!
isPossibleSender

	^true! !
!PossibleSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491945!
initializeWithPossibleMessageSends: aPossibleMessageSends 
	
	possibleMessageSends := Set newFrom: aPossibleMessageSends.
	self prefixStringVersionWith: self class possibleSenderStringVersionHeader ! !
!PossibleSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491954!
addPossibleMessageSends: aPossibleMessageSend

	possibleMessageSends add: aPossibleMessageSend ! !
!PossibleSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50491965 overrides: 50507198!
rangesOf: aSentSelector whenSendTo: aReceiverTypes

	| compiledMethod possibleMessageSendsAsStrings ranges |

	ranges := Set new.
	compiledMethod := self compiledMethodIfAbsent: [ ^#() ].
	
	"This is good enoght but not nice... parse node equality is identity and the possible message send nodes where generated
	using other method node that the one we use here, so I look for printString in the sourceRanges, a hack that works but could
	generate invalid ranges if the printString of really different message sends are equal... but is good enought for now.
	I do not use methodNode rawSourceRanges becuase it regenerates the code and it is necessary here... I beleive :-).
	If the compiledMethod would keep the methodNode all this would not be necesary... - Hernan"
	possibleMessageSendsAsStrings := possibleMessageSends collect: [ :possibleMessageSend | 
		possibleMessageSend key printString ].
	compiledMethod notOptimizedMethodNode encoder rawSourceRanges keysAndValuesDo: [ :parseNode :range |
		(possibleMessageSendsAsStrings includes: parseNode printString) ifTrue: [ ranges add: range ]].
	
	^ranges! !
!PossibleSender class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50492006!
in: aSender withPossibleMessageSends: aPossibleMessageSends

	| newInstance |
	
	newInstance := self method: aSender.
	^newInstance initializeWithPossibleMessageSends: aPossibleMessageSends ! !
!PossibleSender class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50492015!
possibleSenderStringVersionHeader
	
	^'Possible'! !
!ReturnTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501532 overrides: 50501386!
identifier

	^method -> self variableName ! !
!ReturnTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501537 overrides: 50501390!
variableName

	^'^'! !
!ReturnTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501541!
initializeOf: aCompiledMethod are: aRawTypes  
	
	method := aCompiledMethod.
	self initializeRawTypes: aRawTypes ! !
!ReturnTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501577!
of: aCompiledMethod are: aRawTypes
	
	^self new initializeOf: aCompiledMethod are: aRawTypes ! !
!ReturnTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501565!
percentangeOfUsedRawTypes

	^VariablesTypes percentangeOfUsedRawTypesOf: self ! !
!ReturnTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501548!
numberOfRawTypesForAll

	"
	self numberOfRawTypesForAll
	"
	
	| numberOfTypes |
	
	numberOfTypes := Bag new.
	[ ProtoObject withAllSubclassesDo: [ :aClass | 
		aClass methodsDo: [ :aMethod | numberOfTypes add: (ReturnTypeInfo of: aMethod) typesSize ]]]
		on: MethodNotAnnotatingTypes
		do: [ :anError | anError resume: (AdditionalMethodState forMethod: anError method selector: anError method selector) ].
	
	^numberOfTypes contents! !
!ReturnTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501571!
of: aCompiledMethod 
	
	^self of: aCompiledMethod are: aCompiledMethod returnRawTypes! !
!SelfType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499451 overrides: 50599442!
asTypeFor: aReceiverType

	^aReceiverType ! !
!SelfType methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50499455 overrides: 50599460!
typeName

	^'self'! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500973!
withPossibleMessageSendsDo: aBlock
	
	possibleSenders do: [ :aPossibleSender | aPossibleSender withPossibleMessageSendsDo: aBlock ]! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500980!
addSureSenderOf: aSentImplementor

	sureSenders add: aSentImplementor! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500985!
hasCompleteSureSenders
	
	^sureSenders size = sentImplementors size! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500951!
initializeOf: aSender for: aSentImplementors
	
	sender := aSender.
	sentImplementors := aSentImplementors.
	sureSenders := Set new.
	possibleSenders := OrderedCollection new.
! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500990!
hasPartialSureSenders
	
	^sureSenders size between: 1 and: sentImplementors size - 1
	
	! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500996!
sureSenders
	
	^sureSenders! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500963!
addPossibleSender: aPossibleSender of: aSentImplementor

	possibleSenders add: aPossibleSender ! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500959!
sender
	
	^sender! !
!SenderInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50500969!
hasPossibleSenders
	
	^possibleSenders notEmpty ! !
!SenderInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501000!
of: aSender for: aSentImplementors
	
	^self new initializeOf: aSender for: aSentImplementors! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501365!
isMegamorphic
	
	^rawTypes isMegamorphic ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501141!
typesDo: aBlock
	
	^self types do: aBlock ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501295!
commonSupertypeIfNoTypes: aBlock

	| types commonSupertypes commonSupertype |
	
	types := self types.
	types := types reject: [ :aType | aType = UndefinedObject ].
	types isEmpty ifTrue: [ ^aBlock value ].
	types size = 1 ifTrue: [ ^types anyOne ].
	
	"I have to convert types to Array becuase inst var types can be a Set - Hernan"
	commonSupertypes := self allSupertypesOf: types.
	commonSupertype := self commonLowestTypeIn: commonSupertypes.
	
	^commonSupertype ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501313!
commonSupertypeOrCommonSelectorsPreviousToObjectIfGeneric
	
	^self commonSupertypeIfGeneric: [ :genericSuperclass | self commonSelectorsPreviousToObject ]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501126!
removeType: aType

	^self removeType: aType ifAbsent: [ self signalTypeNotFound]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501155!
typesIncludesAllOf: aTypesCollection
	
	^self types includesAllOf: aTypesCollection ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501063!
printReducedTypesOn: aStream

	aStream nextPut: $<.
	
	self isTypesEmpty  
		ifTrue: [ aStream nextPut: $? ]
		ifFalse: [
			self 
				withCommonSupertypeDo: [ :aCommonSupertype | 
					aStream nextPutAll: aCommonSupertype typeName.
					self typesSize > 1 ifTrue: [ aStream nextPutAll: ' # ... ' ]]
				ifGeneric: [ :genericType | 
					aStream nextPutAll: 'any # '.
					self 
						typesDo: [:aType | aStream nextPutAll: aType typeName ]
						separatedBy: [ aStream nextPutAll: ' | ' ]]].
			
	aStream nextPut: $>.
! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501105!
addType: aType

	^self addType: aType ifFull: [ self signalRawTypesIsFull]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501087!
printTypesOn: aStream

	| types |
	
	types := self types.

	self print: types on: aStream upTo: types size.
	! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501122!
removeAllTypes
	
	rawTypes removeAllTypes ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501006!
print: originalTypes on: aStream upTo: aNumberOfTypes
	
	| types canBeNil |
	
	types := originalTypes asArray.
	aStream nextPut: $<.

	types isEmpty 
		ifTrue: [ aStream nextPut: $? ]
		ifFalse: [
			types size > 1 ifTrue: [
				self 
					withCommonSupertypeDo: [ :aCommonSupertype | aStream nextPutAll: aCommonSupertype typeName ] 
					ifGeneric: [ :aGenericType | aStream nextPutAll: 'any' ].
				aStream nextPutAll: ' # ' ].
			
			(types includes: UndefinedObject) 
				ifTrue: [
					canBeNil := true.
					types := types reject: [ :aType | aType = UndefinedObject ]]
				ifFalse: [
					canBeNil := false ].
				
			aNumberOfTypes < types size 
				ifTrue: [ 
					self printAll: (types first: aNumberOfTypes) on: aStream.
					canBeNil ifTrue: [ aStream nextPutAll: ' | can be nil !!' ].
					aStream nextPutAll: ' | ...' ] 
				ifFalse: [ 
					self printAll: types on: aStream.
					canBeNil ifTrue: [ aStream nextPutAll: ' | can be nil !!' ]]].
	
	aStream 
		nextPut: $>;
		newLine "The newLine is necessary for the ballonhelp not to be wrapped... puag!!!! - Hernan"
	
	! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501110!
addType: aType ifFull: aFullBlock

	"If rawTypes is nil, it is assumed that type can not be added and therefore it is full - Hernan"
	
	^rawTypes addType: aType ifFull: aFullBlock
! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501118!
isTypesEmpty
	
	^rawTypes isTypesEmpty! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501145!
typesDo: aBlock separatedBy: separatorBlock
	
	^self types do: aBlock separatedBy: separatorBlock! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535657!
printTypesOn: aStream upTo: aNumberOfTypes

	| liveTypes |   
	
        liveTypes := RawToLiveTypesAdapter new adapt: self types.   
        (LiveTypesPrinter on: aStream) print: liveTypes upTo: aNumberOfTypes. ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501165!
typesSize
	
	^rawTypes typesSize ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501209!
commonSelectorsPreviousToObject

	^ self commonSelectorsPreviousTo: Object ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501051 overrides: 16914834!
printOn: aStream

	aStream 
		nextPutAll: self variableName;
		nextPutAll: ' : '.
		
	self printTypesOn: aStream
	! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501215!
intersect: previousCommonSelectors withSelectorsOf: aStartingType previousTo: aSupertypeToExclude ifInvalidSupertype: anInvalidBlock

	|  commonSelectors |
	
	commonSelectors := Set new.

	self 
		withSelectorsOf: aStartingType 
		previousTo: aSupertypeToExclude 
		do:  [ :aSelector | (previousCommonSelectors includes: aSelector) ifTrue: [ commonSelectors add: aSelector ]]
		ifInvalidSuperclass: [ :aType | ^anInvalidBlock value: aType ].
			
	^commonSelectors ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501321!
withCommonSupertypeDo: doBlock ifGeneric: ifGenericBlock
 
	| commonSupertype block  |
	
	commonSupertype := self commonSupertype.
	block := (commonSupertype = Object or: [ commonSupertype = ProtoObject ])
		ifTrue: [ ifGenericBlock ]
		ifFalse: [ doBlock  ].
		
	^block value: commonSupertype ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501334!
commonLowestTypeIn: commonSupertypes
	
	| commonSupertype commonSupertypeSuperclassesSize |
	
	commonSupertypeSuperclassesSize := 0.
	
	commonSupertypes do: [ :currentType | | currentTypeSuperclassesSize |
		currentTypeSuperclassesSize := currentType withAllSuperclasses size.
		currentTypeSuperclassesSize > commonSupertypeSuperclassesSize ifTrue: [
			commonSupertypeSuperclassesSize := currentTypeSuperclassesSize.
			commonSupertype := currentType ]].
	
	^ commonSupertype! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501357!
doesStoreTypes

	^rawTypes doesStoreTypes ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501376!
signalRawTypesIsFull

	self error: self class rawTypesIfFullErrorDescription! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501381!
signalTypeNotFound
	
	self error: self class typeNotFoundErrorDescription! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501394!
ifMegamorphicAddTo: allMegamorphicVariables

	self isMegamorphic ifTrue: [ allMegamorphicVariables add: (self identifier -> self typesSize) ]
! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501352!
initializeRawTypes: aRawTypes

	rawTypes := aRawTypes ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501390!
variableName

	^'unknow variable'! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501369!
signal: aClass isNotInSuperclassesOf: anotherClass

	self error: (self class errorDescriptionFor: aClass isNotInSuperclassesOf: anotherClass)! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501057!
printReducedTypes
	
	^String streamContents: [ :stream | self printReducedTypesOn: stream ]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501082!
printTypes
	
	^String streamContents: [ :stream | self printTypesOn: stream ]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501151!
typesIncludes: aType

	^self types includes: aType ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501169!
commonSelectors

	^self commonSelectorsPreviousTo: nil! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501131!
removeType: aType ifAbsent: anAbsentBlock

	^rawTypes removeType: aType ifAbsent: anAbsentBlock
! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501184!
commonSelectorsPreviousTo: aSuperclassToExclude ifInvalidSupertype: anInvalidBlock

	| types initialType commonSelectors invalidSupertypeBlock |
	
	self isTypesEmpty ifTrue: [ ^#() ].
	
	invalidSupertypeBlock :=  [ :aStartingType | ^anInvalidBlock value: aStartingType ].
	types := self types.
	initialType := types anyOne.
	
	commonSelectors := self selectorsOf: initialType previousTo: aSuperclassToExclude ifInvalidSupertype: invalidSupertypeBlock.
	types 
		do: [ :aType | 
			commonSelectors := self 
				intersect: commonSelectors 
				withSelectorsOf: aType 
				previousTo: aSuperclassToExclude 
				ifInvalidSupertype: invalidSupertypeBlock ]
		without: initialType.
	
	^commonSelectors ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501248!
withSelectorsOf: aStartingType previousTo: aSupertypeToExclude do: aBlock ifInvalidSuperclass: anInvalidBlock

	| currentType |
	
	currentType := aStartingType.
	
	[ currentType = aSupertypeToExclude ] whileFalse: [ 
		currentType ifNil: [ ^anInvalidBlock value: aStartingType ].
		currentType selectorsDo: aBlock.
		currentType := currentType superclass ].
	
! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501288!
commonSupertypeIfGeneric: genericBlock
	
	^self withCommonSupertypeDo: [ :aCommonSupertype | aCommonSupertype ] ifGeneric: genericBlock! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501386!
identifier

	self subclassResponsibility ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501233!
selectorsOf: aStartingType previousTo: aSupertypeToExclude ifInvalidSupertype: anInvalidBlock

	| commonSelectors |
	
	commonSelectors := Set new.
	self 
		withSelectorsOf: aStartingType 
		previousTo: aSupertypeToExclude 
		do: [ :aSelector | commonSelectors add: aSelector ]
		ifInvalidSuperclass: [ :aType | ^anInvalidBlock value: aType ].
	
	^commonSelectors 
	! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501262!
addIfNoCommonSupertypeTo: allWithNoCommonSupertype 
	
	| commonSupertype |
	
	commonSupertype := self commonSupertypeIfNoTypes: [ ^self ].
	
	(commonSupertype = Object or: [ commonSupertype = ProtoObject ]) ifTrue: [  allWithNoCommonSupertype add: (self identifier->self types)]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501137!
types
	
	^rawTypes types! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501274!
allSupertypesOf: types
	
	^ types 
		inject: types anyOne withAllSuperclasses 
		into: [ :temporaryCommonSupertypes :type | temporaryCommonSupertypes intersection: type withAllSuperclasses ].
! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501361!
includesNil
	
	^ rawTypes includesNil ! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501099!
printTypesUpTo: aNumberOfTypes
	
	^String streamContents: [ :stream | self printTypesOn: stream upTo: aNumberOfTypes]! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501174!
commonSelectorsPreviousTo: aSuperclassToExclude

	^self 
		commonSelectorsPreviousTo: aSuperclassToExclude 
		ifInvalidSupertype: [ :aStartingClass | self signal: aSuperclassToExclude isNotInSuperclassesOf:  aStartingClass ].! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501160!
typesNames
	
	^(self types collect: [ :aType | aType typeName ]) sorted! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50535645!
commonSupertype
	
	"^self commonSupertypeIfNoTypes: [ ProtoObject ]"
	| liveTypes types |
	liveTypes := RawToLiveTypesAdapter new adapt: self types.
	types := Set new.
	liveTypes classTypesDo: [:aClass | types add: aClass].
	^(SupertypeDetective new: types) search.! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501043!
printAll: types on: aStream.

	types
		do: [:aType | aStream nextPutAll: aType typeName ]
		separatedBy: [ aStream nextPutAll: ' | ' ].
				
! !
!VariableTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501410!
rawTypesIfFullErrorDescription

	^'Can not add more types. Types collection is full'! !
!VariableTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501416!
typeNotFoundErrorDescription
	
	^'Type not found'! !
!VariableTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501421!
unload: aClassToUnload from: rawTypes 

	rawTypes
		removeType: aClassToUnload ifAbsent: [];
		removeType: aClassToUnload class ifAbsent: []
		! !
!VariableTypeInfo class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501402!
errorDescriptionFor: aClass isNotInSuperclassesOf: anotherClass

	^aClass name, ' in not in the superclass chain of ', anotherClass name! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501606!
printReducedTypesOf: aVarName ifAbsent: anAbsentBlock

	| typeInfo |
	
	typeInfo := self typeInfoOf: aVarName ifAbsent: [ ^anAbsentBlock value ].
	
	^typeInfo printReducedTypes ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501635!
printVariablesTypesOn: aStream

	self typesInfoNotEmpty ifTrue: [
		self printTypesInfoHeaderOn: aStream.
		self printTypesInfoOn: aStream.
		self printTypesInfoFooterOn: aStream ]! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501598!
addWithNoCommonSupertypeTo: allWithNoCommonSupertype

	self typesInfoDo: [ :aVarTypeInfo | aVarTypeInfo addIfNoCommonSupertypeTo: allWithNoCommonSupertype ]! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501654!
typeInfoOf: aVarName ifAbsent: anAbsentBlock

	self subclassResponsibility ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501614!
printTypeInfo: typeInfo on: aStream
	
	aStream 
		print: typeInfo;
		newLine! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501624!
printTypesInfoHeaderOn: aStream
	
	self class printTypesInfoHeaderOn: aStream
	! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501667!
typesInfoNotEmpty
	
	^self typesInfoIsEmpty not! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501583!
addMegamorphicVariablesTo: allMegamorphicVariables
	
	self typesInfoDo: [ :aVarTypeInfo | aVarTypeInfo ifMegamorphicAddTo: allMegamorphicVariables ]
		! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501671!
typesInfoSize
	
	self subclassResponsibility ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501629!
printTypesInfoOn: aStream
	
	self typesInfoDo: [ :typeInfo | self printTypeInfo: typeInfo on: aStream ].
	! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501675!
typesOf: aVarName

	^(self typeInfoOf: aVarName) types! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501643!
localTypesInfoDo: aBlock

	self subclassResponsibility ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501679!
typesOf: aVarName ifAbsent: aBlock

	| varTypeInfo |
	
	varTypeInfo := self typeInfoOf: aVarName ifAbsent: [ ^aBlock value ].
	
	^varTypeInfo types! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501687!
commonSelectorsOf: aVarName

	"
	SimpleMeasure instanceVariablesTypes commonSelectorsOf: 'unit'.
	SimpleMeasure instanceVariablesTypes commonSelectorsOf: 'amount'.
	"
	^ (self typeInfoOf: aVarName) commonSelectors ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501719!
commonSupertypeOf: aVarName ifNoTypes: aBlock

	^ (self typeInfoOf: aVarName) commonSupertypeIfNoTypes: aBlock! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501591!
addTypesSizesTo: aBagCollector

	self typesInfoDo: [ :aVarTypeInfo | aBagCollector add: aVarTypeInfo typesSize ]! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501697!
commonSelectorsOf: aVarName previoustTo:  aSuperclass

	"
	SimpleMeasure instanceVariablesTypes commonSelectorsOf: 'unit' previousTo: Object
	SimpleMeasure instanceVariablesTypes commonSelectorsOf: 'amount' previousTo: Number
	"
	^ (self typeInfoOf: aVarName) commonSelectorsPreviousTo: aSuperclass ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501619!
printTypesInfoFooterOn: aStream 

	aStream nextPut: $" ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501726!
variablesNames
	
	self subclassResponsibility.! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501648!
typeInfoOf: aVarName

	^self typeInfoOf: aVarName ifAbsent: [ self error: 'Invalid variable name' ].
	! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501659!
typesInfoDo: aBlock
	
	self subclassResponsibility ! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501663!
typesInfoIsEmpty
	
	^self typesInfoSize = 0! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501709!
commonSupertypeOf: aVarName

	"
	SimpleMeasure instanceVariablesTypes commonSupertypeOf: 'unit'.
	SimpleMeasure instanceVariablesTypes commonSupertypeOf: 'amount'.
	"
	^ (self typeInfoOf: aVarName) commonSupertype ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501746!
allWithNoCommonSupertype

	"
	InstanceVariablesTypes allWithNoCommonSupertype
	MethodVariablesTypes allWithNoCommonSupertype
	"
	
	| allWithNoCommonSupertype |
	
	allWithNoCommonSupertype := OrderedCollection new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addWithNoCommonSupertypeTo: allWithNoCommonSupertype ]].
			
	^allWithNoCommonSupertype 
	
! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501822!
printTypesInfoHeaderOn: aStream

	self subclassResponsibility ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501771!
numberOfTypesForAll

	"
	InstanceVariablesTypes numberOfTypesForAll
	MethodVariablesTypes numberOfTypesForAll
	"
	
	| numberOfTypes |
	
	numberOfTypes := Bag new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes |  aVariablesTypes addTypesSizesTo: numberOfTypes ]].
	
	^numberOfTypes contents! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501808!
unload: aClassToUnload from: aRawTypes 

	self subclassResponsibility ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501813!
unload: aClassToUnload fromAllRawTypesOf: aVariablesRawTypes

	aVariablesRawTypes ifNotNil: [ 
		aVariablesRawTypes do: [ :aRawTypes | self unload: aClassToUnload from: aRawTypes ]]
	! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501833!
of: aClass do: aBlock

	self subclassResponsibility ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501784!
percentangeOfUsedRawTypes

	"
	InstanceVariablesTypes percentangeOfUsedRawTypes.
	MethodVariablesTypes percentangeOfUsedRawTypes.
	ReturnTypeInfo percentangeOfUsedRawTypes
	"

	^self percentangeOfUsedRawTypesOf: self ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501794!
percentangeOfUsedRawTypesOf: aVariableTypesClass

	| usedSlots numberOfRawTypesForAll |
	
	usedSlots := 0.
	numberOfRawTypesForAll := aVariableTypesClass numberOfRawTypesForAll.
	numberOfRawTypesForAll keysAndValuesDo: [ :size :time | usedSlots := usedSlots + (size*time) ].
	
	^(usedSlots/(numberOfRawTypesForAll sum * ClassDescription defaultRawTypesSize)) asFloat.! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501731!
allMegamorphicVariables

	"
	InstanceVariablesTypes allMegamorphicVariables
	MethodVariablesTypes allMegamorphicVariables
	"
	
	| allMegamorphicVariables |
	
	allMegamorphicVariables := OrderedCollection new.
	ProtoObject withAllSubclassesDo: [ :aClass | self of: aClass do: [ :aVariablesTypes | aVariablesTypes addMegamorphicVariablesTo: allMegamorphicVariables ]].
	
	^allMegamorphicVariables ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501762!
numberOfRawTypesForAll

	"
	InstanceVariablesTypes numberOfRawTypesForAll
	MethodVariablesTypes numberOfRawTypesForAll
	ReturnTypeInfo numberOfRawTypesForAll
	"
	
	self subclassResponsibility ! !
!VariablesTypes class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/11/2024 20:04:48' prior: 50501827!
typesInfoHeader
		
	^String streamContents: [ :stream | self printTypesInfoHeaderOn: stream ]! !

!classDefinition: #ParseNodeTypesDisplay category: #LiveTyping stamp: 'JFGO 10/11/2024 20:04:54'!
Object subclass: #ParseNodeTypesDisplay
	instanceVariableNames: 'parseNodeToAnalize methodNodeOwner definingClass methodToAnalyze types incompleteTypeInfoReasons typeInfo labels lines selectedIndex icons typesIndexLimit actions contextBlockNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTyping'!
!ParseNodeTypesDisplay methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/11/2024 20:04:52' prior: 50602387!
calculateTypesWithContext

	incompleteTypeInfoReasons := Set new.
		
	types := methodToAnalyze typesOfVariableNamed: parseNodeToAnalize withNode: methodNodeOwner withinBlockNode: contextBlockNode addingIncompleteTypeInfoTo: incompleteTypeInfoReasons.
	incompleteTypeInfoReasons := incompleteTypeInfoReasons asArray .
	
	! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784565!
entryCount
	^ entries size! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784597!
selectedEntry

	^self entries at: menuMorph selected! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784524!
shouldOpenMorphWhenNoPrefixFor: currentChar 
	
	^currentChar isAlphaNumeric 
		or: [ currentChar = $]
		or: [ currentChar = $) 
		or: [ currentChar = $; ]]]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784401!
handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."

	| shouldOpenMorph |
	shouldOpenMorph := self shouldOpenMorph.

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [ ^ self openCompletionMenuFor: kbEvent if: shouldOpenMorph ].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.

	kbEvent isEsc ifTrue: [ self closeMenu. ^ true].
	kbEvent isBackspace ifTrue: [ shouldOpenMorph ifFalse: [ self closeMenu ]. ^ false].
	kbEvent isHome ifTrue: [ menuMorph goHome. ^ true ].
	kbEvent isEnd ifTrue: [ menuMorph goToEnd. ^ true].
	kbEvent isQuestionMark ifTrue: [ menuMorph help. ^true].
	kbEvent isArrowUp ifTrue: [ menuMorph goUp. ^ true].
	kbEvent isArrowDown ifTrue: [ menuMorph goDown. ^ true].
	kbEvent isPageUp ifTrue: [ menuMorph goPageUp. ^ true].
	kbEvent isPageDown ifTrue: [ menuMorph goPageDown. ^ true].

	kbEvent isArrowRight ifTrue: [ ^self handleRightArrowKeystrokeBefore: kbEvent ].
	kbEvent isArrowLeft ifTrue: [ ^self handleLeftArrowKeystrokeBefore: kbEvent ].

	(self shouldInsertSelected: kbEvent) ifTrue: [ self insertSelected ifTrue: [^ true]].
	(self shouldCloseMenu: kbEvent) ifTrue: [ self closeMenu ].

	^false! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784345!
morphClass
	^AutoCompleterMorph! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784532!
shouldOpenMorphWhenPrefixAt: currentPos and: currentChar 
	
	^ model textSize >= currentPos and: [ currentChar isAlphaNumeric or: [ currentChar isValidInBinarySelectors or: [ currentChar = $: ]]]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784615!
isPossibleInvalidEntry: anEntry

	^false! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784443!
handleLeftArrowKeystrokeBefore: kbEvent
	"Subclasses might do something"
	^true! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784606!
canSelect: anEntry

	^true! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784461!
openCompletionMenuFor: kbEvent if: shouldOpenMorph

	"Ctrl-Space or Tab for open"
	"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
	(kbEvent isCtrlSpace or: [self isTab: kbEvent and: shouldOpenMorph]) ifTrue: [ self openCompletionMenu. ^ true].
		
	"Auto-open - currently deactivated"
"	(ctrl not & cmd not & alphanum) ifTrue: [ self openCompletionMenu ]."
	
	^ false! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784478!
shouldCloseMenu: kbEvent

	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"

	^ ((kbEvent controlKeyPressed not and: [ kbEvent commandAltKeyPressed not ]) and: [ kbEvent isAlphaNumeric or: [ kbEvent isColon ]]) not
! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784541!
computeEntries
	"This default implementation might be redefined of needed."
	| prefixStart prefixStop string |
	string := model actualContents string.
	prefixStop := position.
	prefixStart := position.
	[ prefixStart > 0 and: [ (string at: prefixStart) isSeparator not ]] whileTrue: [
		prefixStart := prefixStart - 1 ].
	prefix := string copyFrom: prefixStart+1 to: prefixStop.
	entries := Array streamContents: [ :strm |
		self addEntriesTo: strm ]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784336!
closeMenu
	menuMorph ifNotNil: [
		menuMorph delete.
		menuMorph := nil ]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784490!
shouldInsertSelected: kbEvent
	
	^ kbEvent isReturnKey 
		or: [ (kbEvent isSpace and: [ kbEvent controlKeyPressed or: [ kbEvent rawMacOptionKeyPressed ]]) 
		or: [ kbEvent isTab]]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784454!
isTab: kbEvent and: shouldOpenMoprh
	
	^ self opensWithTab 
		and: [ kbEvent isTab 
		and: [ shouldOpenMoprh ]]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784448!
handleRightArrowKeystrokeBefore: kbEvent
	"Subclasses might do something"
	^true! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784331!
textMorph: aBareTextMorph
	textMorph := aBareTextMorph! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784499!
shouldOpenMorph

	| currentPos currentChar |
	
	textMorph editor hasSelection ifTrue: [ ^ false ].
	
	currentPos := textMorph editor startIndex-1.
	currentPos <= 0 ifTrue: [ ^ false ].
	currentChar := model actualContents at: currentPos.
	
	^ currentChar = Character space
		ifTrue: [ self shouldOpenMorphWhenNoPrefixAt: currentPos-1 ]
		ifFalse: [ self shouldOpenMorphWhenPrefixAt: currentPos and: currentChar ].! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784610!
canSelectEntryAt: anIndex

	^self canSelect: (self entryAt: anIndex)! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784349!
openCompletionMenu

	| theEditor |

	theEditor := textMorph editor.
	position := theEditor startIndex - 1.
	self closeMenu.
	self computeEntries.
	entries notEmpty
		ifTrue: [ | startIndex characterBlock cursorIndex |
			cursorIndex := theEditor pointIndex.
			startIndex := (theEditor text at: cursorIndex-1) = Character space
				ifTrue: [ cursorIndex ]
				ifFalse: [ theEditor previousWordStart: (cursorIndex >  theEditor text size ifTrue: [ cursorIndex-1 ] ifFalse: [ cursorIndex ])].
			characterBlock := theEditor characterBlockForIndex: startIndex.
			menuMorph :=  self morphClass
				completer: self
				position: characterBlock bottomLeft + textMorph morphPositionInWorld ].
! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784619!
opensWithTab
	
	"Returns wheter should open the auto completer when pressing Tab or not"
	
	^false! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784601!
selectedEntryFormatted

	^(self entries at: menuMorph selected), ' '! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784341!
menuClosed
	menuMorph := nil! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784569!
insertSelected
	
	| entry editor selEnd str |
	
	textMorph ifNil: [ ^false ].
	
	entry := self selectedEntryFormatted.
	(self canSelect: entry) ifFalse: [ ^true ].
	
	editor := textMorph editor.
	str := model actualContents string.
	selEnd := position.
	[selEnd < str size and: [ (str at: selEnd+1) tokenish ]] whileTrue: [ selEnd := selEnd + 1 ].
	(selEnd < str size and: [ (str at: selEnd+1) = $ ]) ifTrue: [ selEnd := selEnd + 1].
	editor selectFrom: position-prefix size+1 to: selEnd.
	editor
		replaceSelectionWith: entry;
		deselectAndPlaceCursorAt: position - prefix size + 1 + (self newCursorPosition: entry).
	textMorph redrawNeeded.
	menuMorph delete.
	menuMorph := nil.
	
	^ true! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784383!
handleKeystrokeAfter: aKeyboardEvent
	| newPos |
	menuMorph ifNil: [^self].
	newPos := textMorph editor startIndex-1.
	newPos = position ifTrue: [^self].
	newPos < position
		ifTrue: [
			prefix := prefix copyFrom: 1 to: prefix size+(newPos-position).
			position := newPos ]
		ifFalse: [
			position := position + 1.
			prefix := prefix copyWith: (model actualContents at: position) ].
	self computeEntries.
	entries notEmpty
		ifTrue: [ menuMorph resetMenu ]
		ifFalse: [ self closeMenu ]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784324!
setModel: aTextModel
	model := aTextModel! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784328!
textMorph

	^textMorph! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784515!
shouldOpenMorphWhenNoPrefixAt: currentPos 
	
	^  model textSize >= currentPos 
		and: [ currentPos > 0
		and: [ self shouldOpenMorphWhenNoPrefixFor: (model actualContents at: currentPos) ]]! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784558!
entries
	^entries! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784561!
entryAt: anIndex
	
	^self entries at: anIndex! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784373!
autoCompletionAround: aBlock keyStroke: aKeyboardEvent

	(self handleKeystrokeBefore: aKeyboardEvent)
		ifTrue: [^ self].
	aBlock value.
	"Narrow the completion with any of the keys"
	self handleKeystrokeAfter: aKeyboardEvent! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784593!
newCursorPosition: anEntry
	^anEntry size! !
!AutoCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784636!
helpText
	"
	self helpText edit
	"
^'open/close menu
	ctrl-space or tab
		open the completion menu
	ESC
		close menu
	?, ctl-h
		open this help
menu navigation
	Arrows up/down
		move the selection up and down
	Page up/down
		page up and down
	Home/End
		move to first or last page of the menu
changing menu contents
	alphanumeric character
		filter the menu to the given input
	backspace
		delete an input character, adjust menu to the new input.
inserting completion
	ctrl-space or tab
		close the menu and insert selected completion. if there only one item left in the menu this done automaticaly.'! !
!AutoCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784631!
withModel: aStringHolder
	^self new setModel: aStringHolder! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784789!
help

	TextModel new contents: AutoCompleter helpText; openLabel: 'uCompletion Keyboard Help'! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785166!
previousSelectableEntryIndexFrom: anIndex
	
	^self nextSelectableEntryIndexFrom: anIndex goingForwards: false! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784757!
goPageUp
	
	| oldEntry newEntry nextEntry |
	
	oldEntry := self selected.
	newEntry := oldEntry.
	[nextEntry := self previousSelectableEntryIndexFrom: newEntry.
	oldEntry > nextEntry and: [oldEntry - nextEntry <= self itemsPerPage]]
		whileTrue: [newEntry := nextEntry].
	
	self selected: newEntry.
	self firstVisible: newEntry.
	
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784949!
drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness
	
	| height top bottom |

	height := extent y - (2 * scrollbarThickness).
	top := (1.0 * self firstVisible-1 / self entryCount * height) ceiling + 1 + scrollbarThickness-1.
	bottom := (1.0 * self lastVisible / self entryCount * height) floor + 1 + scrollbarThickness -1.
	aCanvas
		fillRectangle: (extent x - scrollbarThickness+2@top corner:  extent x-2 @ bottom)
		color: `Color veryLightGray lighter`! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784815!
stillActive
	lastActivity := Time localMillisecondClock! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785122!
lastSelectableEntryIndex
	
	^self previousSelectableEntryIndexFrom: 1! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785072 overrides: 16796545!
defaultColor
	^ Theme current paneBackgroundFrom: self defaultBorderColor! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784771!
goToEnd
	
	self selected: self lastSelectableEntryIndex.
	self lastVisible: self selected.
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785093 overrides: 16906477!
stepTime 
	^ 100! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784829!
updateColor

	| remaining alpha |

	remaining := (self timeout - self timeOfLastActivity).
	remaining < 1000 
		ifTrue: [
			alpha := remaining / 1000.0.
			self color: (self color alpha: alpha).
			self borderColor: (borderColor alpha: alpha) ]
		ifFalse: [ self setDefaultColors ]
		
			! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784967!
drawScrollBarOn: aCanvas

	| scrollbarThickness width |

	width := extent x-2.
	self entryCount > self itemsPerPage  ifTrue: [
		scrollbarThickness := ScrollBar scrollbarThickness.
		width := width - scrollbarThickness.

		self drawScrollBarRectangleOn: aCanvas thickness: scrollbarThickness.
		self drawUpArrowOn: aCanvas thickness: scrollbarThickness.
		self drawDownArrowOn: aCanvas thickness: scrollbarThickness.
		self drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness ].

	^width
! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784995!
drawUpArrowOn: aCanvas thickness: scrollbarThickness

	upButtonForm ifNil: [
		upButtonForm := ScrollBar new instVarNamed: 'upButton' :: imageForm: 32 ].
	aCanvas
		image: upButtonForm
		at: self upButtonPosition.
! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785096 overrides: 16906498!
wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^true! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785020 overrides: 16904087!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition

	(self includesPixel: aMouseButtonEvent eventPosition)
		ifTrue: [
			((self upButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goUp ].
			((self downButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goDown ].
			self selected: (localEventPosition y // self itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784871!
calculateWidth

	| width font |

	width := 120.
	font := self class listFont.

	1
		to: self entryCount
		do: [ :index | width := width max: (font widthOfString: (completer entries at: index) asPlainString)].

	self entryCount > self itemsPerPage ifTrue: [ width := width + ScrollBar scrollbarThickness ].

	^ width ! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785107!
firstSelectableEntryIndex
	
	^self nextSelectableEntryIndexFrom: 0! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784825!
timeout
	^ 5000! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784727!
goDown
	
	self selected: (self nextSelectableEntryIndexFrom: self selected).
	(self selected between: self firstVisible and: self lastVisible)
		ifFalse: [self lastVisible: self selected].
	
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784820!
timeOfLastActivity
	^ (Time localMillisecondClock - self lastActivity)! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785160!
nextSelectableEntryIndexFromAndIncluding: anIndex
	
	^self nextSelectableEntryIndexFrom: anIndex - 1! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785041 overrides: 16904135!
mouseEnter: evt
	self activeHand newKeyboardFocus: completer textMorph.
	^ super mouseEnter: evt! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785047 overrides: 16904279!
handlesMouseDown: aMouseButtonEvent

	^ true! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785009!
setDefaultColors

	self color: self defaultColor.
	self borderColor: self defaultBorderColor ! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784861!
calculateItemsPerPage

	| itemsThatCanFit |

	itemsThatCanFit := (Display height - originalPosition y - 2) // self itemHeight.
	itemsPerPage := (itemsThatCanFit min: self maxItemsPerPage) min: self entryCount.

! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784777!
goUp

	(self selected = 0 and: [self firstVisible = 1]) ifTrue: [^ self].
	
	self selected: (self previousSelectableEntryIndexFrom: self selected).
	(self selected between: self firstVisible and: self lastVisible)
		ifFalse: [self firstVisible: self selected].
		
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784702!
itemsPerPage

	^itemsPerPage! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785116!
firstVisible: anIndex
	
	firstVisible := anIndex
		min: self entryCount - self itemsPerPage + 1
		max: 1.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785182!
isXOutOfScreen: aLocation with: anExtent
	
	^aLocation x + anExtent x > Display width! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784696!
itemHeight
	"cached to minimise recalculation"
	^ itemHeight ifNil: [itemHeight := self class itemHeight]! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784737!
goHome

	self selected: self firstSelectableEntryIndex.
	self firstVisible: 1.
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784897!
drawContainingRectangle: aCanvas
	
	aCanvas frameAndFillRectangle: self morphLocalBounds fillColor: self color borderWidth: borderWidth borderColor: borderColor.
! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785077!
setCompleter: anAutoCompleter position: aPoint 

	completer := anAutoCompleter.
	
	originalPosition := aPoint.
	
	self resetMenu.
	self openInWorld! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784892!
downButtonPosition

	^ `0@0` + (extent - ScrollBar scrollbarThickness)! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785127!
lastVisible
	
	^self firstVisible + self itemsPerPage - 1 min: self entryCount! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16784692!
entryCount
	
	^completer entryCount! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785085 overrides: 16906452!
stepAt: millisecondSinceLast

	self timeOfLastActivity > self timeout
		ifTrue: [ self delete. completer menuClosed ]
		ifFalse: [self updateColor]! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:43' prior: 16785132!
lastVisible: anIndex
	
	self firstVisible: anIndex - self itemsPerPage + 1.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784841!
adjust: aLocation ifOutOfScreenWith: anExtent xOffset: xOffset yOffset: yOffset

	| adjustedLocationX adjustedLocationY |

	adjustedLocationX := (self isXOutOfScreen: aLocation with: anExtent)
		ifTrue: [ aLocation x - anExtent x - xOffset ]
		ifFalse: [ aLocation x ].

	adjustedLocationX < 0 ifTrue: [ adjustedLocationX := aLocation x ].

	adjustedLocationY := (self isYOutOfScreen: aLocation with: anExtent)
		ifTrue: [ aLocation y - anExtent y - yOffset ]
		ifFalse: [ aLocation y ].

	^adjustedLocationX @ adjustedLocationY
	! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785172!
wrapIndex: anIndex by: aSize
	
	^anIndex - 1 \\ aSize + 1! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784713!
selected
	"Answer the value of selected"
	selected ifNil: [ self selected: self firstVisible ].
	^ selected! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784719!
selected: aNumber
	"Set the value of selected"

	((aNumber between: 1 and: self entryCount) and: [ aNumber ~= selected ])
		ifTrue: [
			selected := aNumber ]! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784743!
goPageDown
	
	| oldEntry newEntry nextEntry |
	
	oldEntry := self selected.
	newEntry := oldEntry.
	[nextEntry := self nextSelectableEntryIndexFrom: newEntry.
	nextEntry > oldEntry and: [nextEntry - oldEntry <= self itemsPerPage]]
		whileTrue: [newEntry := nextEntry].
	
	self selected: newEntry.
	self firstVisible: newEntry.
	
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784931!
drawItemsOn: aCanvas width: width

	| itemTop |

	itemTop := 1.
	self firstVisible
		to: self lastVisible
		do: [ :index |
			self drawItemOf: index on: aCanvas width: width top: itemTop.
			itemTop := itemTop + self itemHeight ].! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784884!
colorOf: entry

	^(completer isPossibleInvalidEntry: entry) 
		ifTrue: [ Theme current autoCompleterMaybeInvalid ] 
		ifFalse: [ Theme current autoCompleter ]
	! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785067 overrides: 16796540!
defaultBorderWidth
	"answer the default border width for the receiver"
	^ 1! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784795!
resetMenu
	| width newExtent |

	self calculateItemsPerPage.

	self firstVisible: 1.
	self selected: self firstSelectableEntryIndex.

	width := self calculateWidth.
	newExtent := width + 4 @ (self itemsPerPage * self itemHeight + 2).

	self morphPosition: originalPosition extent: newExtent.
	"redraw is needed even if position and extent haven't changed"
	self redrawNeeded ! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784986!
drawScrollBarRectangleOn: aCanvas thickness: scrollbarThickness
	
	aCanvas
		frameRectangle: (extent x - scrollbarThickness@0 extent: scrollbarThickness @ extent y)
		borderWidth: 1
		color: borderColor.
! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785005!
maxItemsPerPage

	^13! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785177!
canSelectEntryAt: anIndex
	
	^completer canSelectEntryAt: anIndex! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784706 overrides: 16903293!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785112!
firstVisible

	^firstVisible min: self entryCount! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785188!
isYOutOfScreen: aLocation with: anExtent
	
	^aLocation y + anExtent y > Display height! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785143!
nextSelectableEntryIndexFrom: anIndex goingForwards: goingForwardsBoolean
	
	| direction indicesFromAnIndex |
	
	direction := goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	indicesFromAnIndex := (1 to: self entryCount)
		collect: [ :offset | self wrapIndex: anIndex + (offset*direction) by: self entryCount ].
	
	^indicesFromAnIndex
		detect: [ :index | self canSelectEntryAt: index ]
		ifNone: [self error: 'there are no selectable entries']! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785015!
upButtonPosition

	^extent x - ScrollBar scrollbarThickness@0! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784905!
drawDownArrowOn: aCanvas thickness: scrollbarThickness

	downButtonForm ifNil: [
		downButtonForm := ScrollBar new instVarNamed: 'downButton' :: imageForm: 32 ].
	aCanvas
		image: downButtonForm
		at: self downButtonPosition.
! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784915!
drawItemOf: index on: aCanvas width: width top: itemTop

	| rectangle entry |
	
	rectangle := 1@itemTop extent: width@self itemHeight.
	index = self selected ifTrue: [ aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].

	entry := completer entries at: index.
	aCanvas
		drawString: entry asPlainString
		at: rectangle topLeft
		font: self class listFont
		color: (self colorOf: entry).
	! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785137!
nextSelectableEntryIndexFrom: anIndex
	
	^self nextSelectableEntryIndexFrom: anIndex goingForwards: true! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784941 overrides: 16796561!
drawOn: aCanvas
	
	| width |
	
	self drawContainingRectangle: aCanvas.
	width := self drawScrollBarOn: aCanvas.
	self drawItemsOn: aCanvas width: width 
! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16784810!
lastActivity 
	lastActivity ifNil: [self stillActive].
	^ lastActivity ! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785059 overrides: 16796534!
defaultBorderColor
	"My default border color.
	
	Note: My background color is derived from this color."
	^ Theme current autoCompleterDefaultBorderColor ! !
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785052 overrides: 16904315!
handlesMouseOver: evt
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?" 
	^true! !
!AutoCompleterMorph class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785213!
completer: anAutoCompleter position: aPoint 

	| newObject |

	newObject := self new.
	newObject setCompleter: anAutoCompleter position: aPoint.

	^ newObject! !
!AutoCompleterMorph class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785208!
listFont

	^Preferences at: #standardListFont! !
!AutoCompleterMorph class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785234 overrides: 16796934!
categoryInNewMorphMenu

	^ 'User Interface'! !
!AutoCompleterMorph class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785200!
itemHeight
	"height must be forced to be even to allow the detail arrow to be drawn correctly"	
	^ (self listFont lineSpacing + 2) roundUpTo: 2"14".! !
!AutoCompleterMorph class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785221 overrides: 16907391!
initializedInstance
	| completer m |
	completer := SmalltalkCompleter withModel: (TextModel withText: 'Small').
	completer
		instVarNamed: 'position'
		put: 5.
	completer computeEntries.
	m := completer morphClass
		completer: completer
		position: `200 @ 200`.
	completer instVarNamed: 'menuMorph' put: m.
	^m! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785414!
selectKeywordSelectorsWhile: aClosure 

	self selectSelectorsThatSatisfy: [ :aSelector | aSelector isKeyword ] while: aClosure 
! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785299!
addSelectorsOfAll: classes upTo: aSuperclass

	classes do: [ :aClass | 
		otherClasses := classes copyWithout: aClass.
		self addSelectorsMarkingPossibleInvalidOnesOf: aClass upTo: aSuperclass ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785422!
selectSelectorsThatSatisfy: aSelectorsSelectionCondition while: aClosure
	
	| currentSelectorsSelectionCondition |
	
	currentSelectorsSelectionCondition := selectorSelectionCondition.
	[ selectorSelectionCondition := aSelectorsSelectionCondition.
	aClosure value ] ensure: [ selectorSelectionCondition := currentSelectorsSelectionCondition ].! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785279!
addKeywordSelectorsOfAll: classes upTo: aSuperclass

	self selectKeywordSelectorsWhile: [ self addSelectorsOfAll: classes upTo: aSuperclass ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785465!
addLeftCategories
	
	categoriesWithSelectors keysAndValuesDo: [ :aCategory :selectors | self addCategory: aCategory with: selectors ].
	! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785508!
hasReachSelectorsLimit
	
	^addedSelectorsFastSet size >= selectorsLimit! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785490!
categoryEntryFor: aCategory
	
	^self class categoryEntryHeader, aCategory ! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785496!
prioritizedCategories 
	
	^{Categorizer instanceCreation}! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785309!
addUnaryAndBinarySelectorsOf: aClass 
	
	self selectUnaryAndBinarySelectorsWhile: [ self addSelectorsOf: aClass ].
	! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785271!
addKeywordSelectorsOf: aClass upTo: aSuperclassToExclude

	self selectKeywordSelectorsWhile: [ self addSelectorsOf: aClass upTo: aSuperclassToExclude ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785437!
selectUnaryAndBinarySelectorsWhile: aClosure
	
	self selectSelectorsThatSatisfy: [ :aSelector | aSelector isKeyword not ] while: aClosure 
! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785457!
addCategory: aCategory with: selectors 

	entriesToShow 
		add: (self categoryEntryFor: aCategory); 
		addAll: selectors
	   ! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785251!
initializeFor: aPrefix withSelectorsLimitedTo: aLimit 

	prefix := aPrefix.
	categoriesWithSelectors := OrderedDictionary new.
	addedSelectorsFastSet := IdentitySet new.
	possibleInvalidSelectors := IdentitySet new.
	selectorsLimit := aLimit.
	selectorSelectionCondition := [ :aSelector | true ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785345!
addCategoriesAndSelectorsOf: aClass

	| classOrganization |
	
	classOrganization := aClass organization.
	
	classOrganization categories do: [ :aCategory | 
		self hasReachSelectorsLimit ifTrue: [ ^ self ].
		self addCategory: aCategory of: classOrganization ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785445!
entriesToShow
	
	self hasCollectedOnlyOneSelector
		ifTrue: [ entriesToShow := categoriesWithSelectors anyOne ]
		ifFalse: [ 
			entriesToShow := OrderedCollection new.
			self 
				addPrioritizedCategories;
				addLeftCategories ].
						  			
	^entriesToShow 
	
	   ! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785501!
hasCollectedOnlyOneSelector
	
	^ categoriesWithSelectors size = 1 and: [ categoriesWithSelectors anyOne size = 1 ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785473!
addPrioritizedCategories

	self prioritizedCategories do: [ :aCategory | self addPrioritizedCategory: aCategory ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785334!
addedSelectors: selectors

	addedSelectorsFastSet addAll: selectors ! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785375!
addSelectorsMarkingPossibleInvalidOnesOf: aClass upTo: aSuperclassToExclude

	| currentClass |
	
	currentClass := aClass.
	
	[ currentClass ~= aSuperclassToExclude and: [ currentClass notNil ] and: [ self hasReachSelectorsLimit not ] ] whileTrue: [ 
		self addCategoriesAndSelectorsOf: currentClass.
		currentClass := currentClass superclass].
	 
! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785480!
addPrioritizedCategory: aCategory

	categoriesWithSelectors 
		at: aCategory 
		ifPresent: [ :selectors | 
			self addCategory: aCategory with: selectors.
			categoriesWithSelectors removeKey: aCategory ].
! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785325!
addUnaryAndBinarySelectorsOfAll: classes upTo: aSuperclassToExclude
	
	self selectUnaryAndBinarySelectorsWhile: [ self addSelectorsOfAll: classes upTo: aSuperclassToExclude ].
	! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785292!
addSelectorsOf: aClass upTo: aSuperclassToExclude

	self addSelectorsOfAll: (Array with: aClass) upTo: aSuperclassToExclude ! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785401!
prefixedSelectorsOf: aCategory in: aClassOrganization
	
	^ (aClassOrganization listAtCategoryNamed: aCategory) 
		select: [ :aSelector |  
			(aSelector beginsWith: prefix) 
				and: [ (selectorSelectionCondition value: aSelector) 
				and: [ (addedSelectorsFastSet includes: aSelector) not ]]].
! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785357!
addCategory: aCategory of: classOrganization

	| categorySelectors selectedSelectors |

	selectedSelectors := self prefixedSelectorsOf: aCategory in: classOrganization.
	selectedSelectors isEmpty ifFalse: [ 
		categorySelectors := categoriesWithSelectors at: aCategory ifAbsentPut: [ OrderedCollection new ].
		categorySelectors addAll: selectedSelectors.
		self addedSelectors: selectedSelectors.
		self addToPossibleInvalidIfCorrespond: selectedSelectors ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785264!
addKeywordSelectorsOf: aClass 
	
	self selectKeywordSelectorsWhile: [ self addSelectorsOf: aClass ]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785390!
addToPossibleInvalidIfCorrespond: selectedSelectors

	selectedSelectors do: [ :aSelector |
		(otherClasses allSatisfy: [ :otherClass | otherClass canUnderstand: aSelector ]) ifFalse: [ possibleInvalidSelectors add: aSelector ]]! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785340!
possibleInvalidSelectors
	
	^possibleInvalidSelectors! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785287!
addSelectorsOf: aClass

	self addSelectorsOf: aClass upTo: nil! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785316!
addUnaryAndBinarySelectorsOf: aClass upTo: aSuperclassToExclude
	
	self selectUnaryAndBinarySelectorsWhile: [ self addSelectorsOf: aClass upTo: aSuperclassToExclude ].
	! !
!AutoCompleterSelectorsCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785535!
categoryEntryHeader

	^ '-- '! !
!AutoCompleterSelectorsCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785521!
for: aPrefix

	^self for: aPrefix withSelectorsLimitedTo: SmalltalkCompleter entriesLimit! !
!AutoCompleterSelectorsCollector class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16785528!
for: aPrefix withSelectorsLimitedTo: aLimit

	^self new initializeFor: aPrefix withSelectorsLimitedTo: aLimit! !
!ClassNameCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16821109 overrides: 50603796!
morphClass
	^SmalltalkCompleterMorph! !
!ClassNameCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16821097 overrides: 50603955!
opensWithTab

	^true! !
!ClassNameCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16821101 overrides: 50603856!
computeEntries

	prefix := model actualContents string.
	entries := (Smalltalk classNames select: [ :aClassName | aClassName beginsWith: prefix ]) sort.
	! !
!ClassNameCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16821093!
canShowSelectorDocumentation

	^false! !
!DynamicTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16852107 overrides: 16952447!
documentationOf: aMethod

	^aMethod dynamicTypingAutoCompleterDocumentation! !
!DynamicTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16852100 overrides: 16952126!
computeMessageEntriesOfEnclosedExpressionReturn   

	self computeMessageEntriesForUnknowClass 
	
! !
!DynamicTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16852093 overrides: 16952120!
computeMessageEntriesOfCascadeReceiver   
	
	self computeMessageEntriesForUnknowClass
	
! !
!DynamicTypingSmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16852086 overrides: 16951994!
computeEntriesOfUnaryMessageReturnNamed: aSelector    
	
	self computeMessageEntriesForUnknowClass 
	! !
!DynamicTypingSmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16852120 overrides: 16952739!
isForCurrentTypeSystem

	^ Smalltalk isLiveTypingInstalled not! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952224!
lookForBinarySendRange

	| penultimate currentIndex currentRangeType |

	currentIndex := self lookForNoUnaryMessageSend.
	penultimate := allRanges at: currentIndex - 1 ifAbsent: [ SHRange nilObject ].

	currentRangeType := (allRanges at: currentIndex) rangeType.
	currentRangeType = #rightParenthesis ifTrue: [ 
		^self lookForBinarySelectorAfter: #leftParenthesis startingAt: currentIndex with: penultimate ].	
	currentRangeType = #rightBrace ifTrue: [
		^self lookForBinarySelectorAfter: #leftBrace startingAt: currentIndex with: penultimate ].	
	currentRangeType = #blockEnd ifTrue: [
		^self lookForBinarySelectorAfter: #blockStart startingAt: currentIndex with: penultimate ].	
	currentRangeType = #arrayEnd ifTrue: [
		^self lookForBinarySelectorAfterArrayStartStartingAt: currentIndex with: penultimate ].	

	^({#'$'. #symbol} includes: penultimate rangeType)
		ifTrue: [ allRanges at: currentIndex - 2 ifAbsent: [ SHRange nilObject ] ]
		ifFalse: [ penultimate ]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952479!
canComputeMessageEntriesFor: prevRange 

	^ prevRange rangeType notNil ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952208!
lookForBinarySelectorAfterArrayStartStartingAt: anIndex with: aCandidate
 
	| foundRange foundRangeIndex |
	
	foundRange := self lookForBinarySelectorAfter: #arrayStart startingAt: anIndex with: aCandidate.
	
	^foundRange rangeType = #symbol
		ifTrue: [ 
			foundRangeIndex := allRanges indexOf: foundRange.
			allRanges at: foundRangeIndex - 1 ifAbsent: [ aCandidate ]]
		ifFalse: [ aCandidate ]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952396!
computeMessageEntriesForUnknowClassAddingPossibleInvalidSelectorsTo: aCollection

	| selectorsToShow |
	selectorsToShow := OrderedCollection new.
	
	self class protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :selector :lastUsedTime |
				selectorsToShow := self add: selector and: lastUsedTime to: selectorsToShow.
				(Object canUnderstand: selector) ifFalse: [ aCollection add: selector ]]].
				
	selectorsToShow size < EntriesLimit ifTrue: [ selectorsToShow :=  self sortByLastUsedTime: selectorsToShow ].
	
	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)
	entries := selectorsToShow collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]
	"
	^ selectorsToShow collect: [ :selectorAndTime | selectorAndTime first ]
	
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952320!
computeMethodNamesFor: aContextClass

	canShowSelectorDocumentation := false.
	entries := self computeMethodNamesFor: aContextClass andMethodPrefix: prefix! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952508!
computeSymbols
	
	| prefixWithoutNumeral |
	
	canShowSelectorDocumentation := false.
	prefixWithoutNumeral := prefix allButFirst.
	entries := (Symbol allSymbolsSelect: [:aSymbol | aSymbol beginsWith: prefixWithoutNumeral ]) sorted.
	! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951968 overrides: 50603811!
isPossibleInvalidEntry: anEntry

	^possibleInvalidSelectors includes: anEntry ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952384!
computeMessageEntriesForUnknowClass

	selectorsClasses := #().
	possibleInvalidSelectors := IdentitySet new.
	canShowSelectorDocumentation := true.
	entries := self computeMessageEntriesForUnknowClassAddingPossibleInvalidSelectorsTo: possibleInvalidSelectors.! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952329!
computeMethodNamesFor: aContextClass andMethodPrefix: aMethodStartingWith

	| existing |
	existing := aContextClass selectors.
	^(aContextClass superclass allSelectors 
		select: [ :aSelector | (aSelector beginsWith: aMethodStartingWith) and: [(existing includes: aSelector) not] ] 
		thenCollect: [ :aSelector | aContextClass methodHeaderFor: aSelector ]) asSortedCollection! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951892 overrides: 50603856!
computeEntries

	| allSource source contextClass specificModel separator fragmentStart fragmentEnd done |

	specificModel := self textProviderOrModel.
	contextClass := self selectedClassOrMetaClassIn: specificModel.

	allSource := self allSource.
	(specificModel is: #CodeProvider)
		ifTrue: [source := allSource copyFrom: 1 to: position]
		ifFalse: [
			separator := String newLineString, String newLineString.
			fragmentStart := 1.
			done := false.
			[done] whileFalse: [
				fragmentEnd := allSource
					indexOfSubCollection: separator
					startingAt: fragmentStart
					ifAbsent: [allSource size].
				fragmentEnd >= position ifTrue: [
					source := allSource copyFrom: fragmentStart to: position.
					done := true ].
				fragmentStart := fragmentEnd+separator size ]].

	allRanges := self parse: source in: contextClass and: specificModel.
	currentRange := allRanges lastIfEmpty: [ ^entries := #() ].
	possibleInvalidSelectors := #().

	currentRange end = source size
		ifTrue: [ self computeEntriesOfMessageOrIdentifiersFor: source in: contextClass and: specificModel ]
	 	ifFalse: [ self computeMessageEntriesWithEmptyPrefixFor: source in: contextClass and: specificModel ].

	! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952519!
parse: source in: contextClass and: specificModel
	
	| isMethod |
	parser := SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: source.

	isMethod := (specificModel is: #Browser)
		ifTrue: [ specificModel isEditingClass not ]
		ifFalse: [ specificModel is: #CodeProvider ].
	parser parse: isMethod.

	^ parser rangesWithoutExcessCode.! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952132!
computeMessageEntriesWhenSendingMessageFor: allSource in: contextClass and: specificModel 
	
	allRanges removeLast.
	currentRange := allRanges lastIfEmpty: [ SHRange nilObject ].
	possibleBinarySendRange := self lookForBinarySendRange.
	
	^ (self canComputeMessageEntriesFor: currentRange) 
		ifTrue: [ self computeMessageEntriesFor: allSource in: contextClass and: specificModel ]
		ifFalse: [ self computeMessageEntriesForUnknowClass ]
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951957!
canShowSelectorDocumentation

	^canShowSelectorDocumentation ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952372!
add: selector and: lastUsedTime whenNotFullTo: selectorsToShow
			
	selectorsToShow add: { selector . lastUsedTime }.
	
	^selectorsToShow size = EntriesLimit 
		ifTrue: [ self sortByLastUsedTime: selectorsToShow ]
		ifFalse: [ selectorsToShow ]
	! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951942 overrides: 50603962!
selectedEntryFormatted

	| selectedEntry |
	
	selectedEntry := self entries at: menuMorph selected.
	^currentRange correspondsToSymbol
		ifTrue: [ '#', selectedEntry ]
		ifFalse: [ selectedEntry separateKeywords ]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952551!
selectorsClasses

	^selectorsClasses ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952192!
lookForBinarySelectorAfter: aStopToken startingAt: anIndex with: aCandidate

	| rangeAtCurrentIndex currentIndex |
	
	currentIndex := anIndex.
	[ rangeAtCurrentIndex := allRanges at: currentIndex.
	rangeAtCurrentIndex rangeType ~= aStopToken and: [ currentIndex > 1 ]] whileTrue: [ currentIndex := currentIndex - 1 ].

	^currentIndex > 1
		ifTrue: [ allRanges at: currentIndex - 1 ]
		ifFalse: [ aCandidate ].
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951977!
classOfLiteral: aLiteral in: aClass 
	
	| compilerClass |
	
	compilerClass := aClass ifNil: [ Compiler ] ifNotNil: [ aClass compilerClass ].
	
	^ (compilerClass evaluate: aLiteral) class ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952169!
computeMessageEntriesWithoutBinaryMessageForClass: aClass

	selectorsClasses := Array with: aClass.
	
	entries := self selectorsOf: aClass beginningWith: prefix.! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952456!
possibleInvalidSelectors
	
	^ possibleInvalidSelectors! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951962!
isCategoryEntry: anEntry

	^anEntry beginsWith: AutoCompleterSelectorsCollector categoryEntryHeader! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951994!
computeEntriesOfUnaryMessageReturnNamed: aSelector    
	
	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952485!
computeEntriesOfMessageOrIdentifiersFor: allSource in: contextClass and: specificModel

	prefix := allSource copyFrom: currentRange start to: currentRange end.
	
	currentRange correspondsToMessage ifTrue: [ 
		^self computeMessageEntriesWhenSendingMessageFor: allSource in: contextClass and: specificModel ].	
	(currentRange correspondsToPartialOrFullIdentifier: parser) ifTrue: [ ^self computeIdentifierEntries ].
	currentRange correspondsToMethodDefinition ifTrue: [ ^self computeMethodNamesFor: contextClass ].
	currentRange correspondsToSymbol ifTrue: [ ^self computeSymbols ].
	
	"If we don't know what to do, do nothing"
	entries := #() 
	! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952270!
selectorsOf: aClass beginningWith: aPrefix

	^ (AutoCompleterSelectorsCollector for: aPrefix) 
		addSelectorsOf: aClass;
		entriesToShow! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952287!
computeIdentifierEntries
	
	canShowSelectorDocumentation := false.
	entries := self computeIdentifierEntriesBeginningWith: prefix.! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952461 overrides: 50603796!
morphClass
	^SmalltalkCompleterMorph! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952465 overrides: 50603816!
handleLeftArrowKeystrokeBefore: kbEvent
	canShowSelectorDocumentation ifTrue: [
		menuMorph hideSelectorDocumentation ].
	^ true! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951986!
classOfLocalBindingNamed: aName in: aClass 
	
	^  (aClass localBindingOf: aName) ifNotNil: [ :aBinding | aBinding value class ]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952258!
lookForNoUnaryMessageSend
		
	| currentIndex currentRangeType |
	
	currentIndex := allRanges size.
	[ currentRangeType := (allRanges at: currentIndex) rangeType.
	currentRangeType = #unary and: [ currentIndex > 1 ]] whileTrue: [ currentIndex := currentIndex - 1 ].

	^currentIndex! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952120!
computeMessageEntriesOfCascadeReceiver   
	
	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951952 overrides: 50603822!
canSelect: anEntry

	^ (self isCategoryEntry: anEntry) not! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952126!
computeMessageEntriesOfEnclosedExpressionReturn   

	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952158!
computeMessageEntriesWithEmptyPrefixFor: allSource in: contextClass and: specificModel 
	
	possibleBinarySendRange := self lookForBinarySendRange.
	prefix := ''.

	self computeMessageEntriesFor: allSource in: contextClass and: specificModel .! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952472 overrides: 50603896!
handleRightArrowKeystrokeBefore: kbEvent
	canShowSelectorDocumentation ifTrue: [
		menuMorph showSelectorDocumentation ].
	^ true! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952111!
computeMessageEntriesForClassOrNil: aClassOrNil  

	aClassOrNil 
		ifNil: [ self computeMessageEntriesForUnknowClass ]
		ifNotNil: [ self computeMessageEntriesForClass: aClassOrNil ].
	
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952345!
add: selector and: lastUsedTime to: selectorsToShow

	^ selectorsToShow size < EntriesLimit
		ifTrue: [ self add: selector and: lastUsedTime whenNotFullTo: selectorsToShow ]
		ifFalse: [ self add: selector and: lastUsedTime whenFullTo: selectorsToShow ]	! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952178!
ifEmptyEntriesShowAllPrefixedSelectors

	entries isEmpty ifTrue: [ self computeMessageEntriesForUnknowClass ] ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952447!
documentationOf: aMethod

	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952278!
unaryAndBinarySelectorsOf: aClass beginningWith: aPrefix 

	^ (AutoCompleterSelectorsCollector for: aPrefix) 
		addUnaryAndBinarySelectorsOf: aClass;
		entriesToShow! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951973 overrides: 50603955!
opensWithTab

	^true! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952452!
allSource
	^model actualContents string! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952149!
computeMessageEntriesWithBinaryMessageForClass: aClass 

	selectorsClasses := Array with: aClass.
	
	entries := self unaryAndBinarySelectorsOf: aClass beginningWith: prefix.
		! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952427!
insert: selector and: lastUsedTime at: insertionIndex to: selectorsToShow

	insertionIndex <= EntriesLimit ifTrue: [ selectorsToShow insert: { selector . lastUsedTime } shiftingRightAt: insertionIndex ].
	
	^selectorsToShow ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952536!
selectedClassOrMetaClassIn: specificModel

	(specificModel is: #CodeProvider) ifTrue: [ ^ specificModel selectedClassOrMetaClass ].
	
	"I can not use #selectedClassOrMetaClass becuase it changes with the selection but when compiling to evaluate it assumes object as receiver - Hernan"
	^ (specificModel isKindOf: Inspector) ifTrue: [ specificModel objectClass ] ! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952185!
isPreviousMessageSendBinary

	^possibleBinarySendRange notNil and: [ possibleBinarySendRange rangeType = #binary ].

	! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 50475492!
changePositionTo: newPosition 
	
	position _ newPosition! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952099!
computeMessageEntriesForClass: aClass  

	self isPreviousMessageSendBinary
		ifTrue: [ self computeMessageEntriesWithBinaryMessageForClass: aClass ]
		ifFalse: [ self computeMessageEntriesWithoutBinaryMessageForClass: aClass ].
		
	self ifEmptyEntriesShowAllPrefixedSelectors! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952555!
textProviderOrModel

	^ (model is: #hasTextProvider) ifTrue: [ model textProvider ] ifFalse: [ model ].! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952357!
add: selector and: lastUsedTime whenFullTo: selectorsToShow

	selectorsToShow
		findBinaryIndex: [ :selectorAndTime | selectorAndTime second < lastUsedTime ifTrue: [ -1 ] ifFalse: [ 1 ]]
		do: [ :found | ]
		ifNone: [ :leftBound :rightBound | self insert: selector and: lastUsedTime at: rightBound to: selectorsToShow ].
		
	^selectorsToShow 
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952438!
sortByLastUsedTime: selectorsToShow

	^selectorsToShow asArray sort: [ :leftSelectorAndTime :rightSelectorAndTime | leftSelectorAndTime second > rightSelectorAndTime second ]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952295!
computeIdentifierEntriesBeginningWith: aPrefix
	"Use an aux Set to avoid duplicates, but keep the order given."

	| entriesSet lastTitle candidates |
	entriesSet := Set new.
	lastTitle := nil.
	
	candidates := Array streamContents: [ :strm |
		parser namesBeginningWith: aPrefix do: [ :identifier :kindOfIdentifierTitle |
			(entriesSet includes: identifier) ifFalse: [
				kindOfIdentifierTitle = lastTitle ifFalse: [
					strm nextPut: kindOfIdentifierTitle.
					lastTitle := kindOfIdentifierTitle ].
				entriesSet  add: identifier.
				strm nextPut: identifier ]]].
	entriesSet size = 1 ifTrue: [
		^ Array with: entriesSet anyOne ]
		ifFalse: [ ^ candidates ]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16951932 overrides: 50604056!
newCursorPosition: anEntry

	^currentRange correspondsToMethodDefinition
		ifTrue: [ anEntry size - 1]
		ifFalse: [ 
			currentRange correspondsToSymbol 
				ifTrue: [anEntry size + 1]
				ifFalse: [ anEntry indexOf: $ ]]! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 50541550!
computeMessageEntriesFor: allSource in: contextClass and: specificModel  
	
	| id rangeType |
	
	canShowSelectorDocumentation := true.
	id := allSource copyFrom: currentRange start to: currentRange end.
	rangeType := currentRange rangeType.

	rangeType == #globalVar
		ifTrue: [ ^self computeMessageEntriesForClass: (Smalltalk at: id asSymbol) class ].
	rangeType == #self
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass ].
	rangeType == #super
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass superclass ].
	rangeType == #true 
		ifTrue: [ ^self computeMessageEntriesForClass: True ].
	rangeType == #false
		ifTrue: [ ^self computeMessageEntriesForClass: False ].
	rangeType == #nil
		ifTrue: [ ^self computeMessageEntriesForClass: UndefinedObject ].
	rangeType == #character
		ifTrue: [ ^self computeMessageEntriesForClass: (id first asciiValue ifNotNil: [Character] ifNil: [UnicodeCodePoint]) ].
	rangeType == #number
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #string
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #symbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #stringSymbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #instVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofInstVarNamed: id inRange: currentRange ].
	rangeType == #methodArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id inRange: currentRange ].
	rangeType == #tempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id inRange: currentRange ].
	rangeType == #blockArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockArgNamed: id ].
	rangeType == #blockTempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockTempVarNamed: id ].
	rangeType == #workspaceVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (specificModel classOfWorkspaceVarNamed: id) ].
	rangeType == #thisContext
		ifTrue: [ ^self computeMessageEntriesForClass: (specificModel classOfThisContext) ]. 
	rangeType == #classVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #poolConstant
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	(rangeType beginsWith: #blockEnd)
		ifTrue: [ ^self computeMessageEntriesForClass: BlockClosure ].
	rangeType == #arrayEnd
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	(rangeType beginsWith: #rightBrace)
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #unary
		ifTrue: [ ^self computeEntriesOfUnaryMessageReturnNamed: id ].
	(rangeType beginsWith: #rightParenthesis)
		ifTrue: [ ^self computeMessageEntriesOfEnclosedExpressionReturn].
	rangeType == #cascadeSeparator
		ifTrue: [ ^self computeMessageEntriesOfCascadeReceiver]. 

	self computeMessageEntriesForUnknowClass 
	
	! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952739!
isForCurrentTypeSystem

	self subclassResponsibility ! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952602 overrides: 16916096!
initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	
	EntriesLimit := 100.
	
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented := Smalltalk allImplementedMessages.
		Selectors := Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue := SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue := SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i | | sym |
			sym := Smalltalk specialSelectorAt: i.
			(Selectors includesKey: sym)
				ifTrue: [ Selectors at: sym put: maxSortValue ]]]! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952670!
thatStartsCaseSensitive: prefix
	self protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :key :value | ^key ] ].
	^nil! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952753!
entriesLimit
	
	^EntriesLimit ! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952677!
protected: aBlock

	^(AccessLock ifNil: [ AccessLock := Mutex new ]) critical: aBlock! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952663!
isThereAnImplementorOf: aSymbol
	| answer |
	self protected: [
		answer := Selectors includesKey: aSymbol ].
	^answer! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952701!
methodAdded: aMethod selector: aSymbol inProtocol: aCategoryName class: aClass requestor: requestor

	self protected: [
		 self addSelector: aSymbol method: aMethod allImplemented: nil ]! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952568!
addSelector: aSymbol

	self protected: [
		Selectors at: aSymbol ifAbsentPut: 0 ].! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952683!
classRemoved: aClass fromCategory: aCategoryName

	self protected: [
		aClass selectorsDo: [ :selector |
			(Smalltalk isThereAnImplementorOf: selector exceptFor: { aClass . aClass class }) ifFalse: [
				Selectors removeKey: selector ifAbsent: nil ]].
		aClass class selectorsDo: [ :selector |
			(Smalltalk isThereAnImplementorOf: selector exceptFor: { aClass . aClass class }) ifFalse: [
				Selectors removeKey: selector ifAbsent: nil ]]]! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952711!
methodRemoved: aMethod selector: aSymbol inProtocol: protocol class: aClass

	self protected: [
		(Smalltalk isThereAnImplementorOf: aSymbol) not ifTrue: [
			Selectors removeKey: aSymbol ifAbsent: nil ]]! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952574!
addSelector: aSymbol method: aCompiledMethod allImplemented: implemented

	| sentValue value |
	self protected: [
		value := (ChangeSet notInstallOrTestRun or: [Smalltalk platformName ~= 'Win32'])
			ifTrue: [
				"Expensive and not worth doing in Windows with antivirus active, when installing large packages"
				aCompiledMethod dateSortingValue ]
			ifFalse: [ 0 ].
		Selectors at: aSymbol put: (value  max: (Selectors at: aSymbol ifAbsent: [0])).
		aCompiledMethod messages do: [ :sentMsg |
			((Selectors includesKey: sentMsg) or: [ 
				implemented
					ifNotNil: [ implemented includes: sentMsg ]
					ifNil: [ Smalltalk isThereAnImplementorOf: sentMsg ]])
						ifTrue: [
							sentValue := value max: (Selectors at: sentMsg ifAbsent: [0]).
							Selectors at: sentMsg put: sentValue ]]]! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952721 overrides: 50604084!
withModel: aStringHolder

	"Looks it its subclasses the right autocompleter depending on the Type System. If you do not have
	Live Typing installed you will see only one subclass but if Live Typing is intalled LiveTypeingSmalltalkCompleter
	subclass is added - Hernan"
	
	| smalltalkCompleterClass |
	
	smalltalkCompleterClass := self subclasses detect: [ :aSubclass | aSubclass isForCurrentTypeSystem ].
	
	^smalltalkCompleterClass new setModel: aStringHolder! !
!SmalltalkCompleter class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952744!
changeEntriesLimitTo: aNewLimit during: aBlock

	| previousLimit |
	
	previousLimit := EntriesLimit.
	EntriesLimit := aNewLimit.
	
	^aBlock ensure: [ EntriesLimit := previousLimit ]! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952855!
selectorDocumentationTextForAllI: aMethodsCollection

	| selectorDocumentationText implementors methodDocumentationSeparator |

	selectorDocumentationText := Text new.
	methodDocumentationSeparator := self methodDocumentationSeparator.
	implementors := aMethodsCollection asSortedCollection: [ :leftMethod :rightMethod | leftMethod methodClass classDepth <  rightMethod methodClass classDepth ].

	implementors
		do: [ :implementor | selectorDocumentationText := selectorDocumentationText append: (completer documentationOf: implementor)]
		separatedBy: [ selectorDocumentationText := selectorDocumentationText append: methodDocumentationSeparator ].

	^ selectorDocumentationText! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952783!
initializeSelectorDocumentation

	selectorDocumentation := TextModelMorph withText: ''.
	selectorDocumentation innerTextMorph
		acceptOnCR: false;
		crAction: [ self crPressedOnSelectorDocumentation ].

	selectorDocumentation
		wrapFlag: true;
		borderColor: Color black;
		borderWidth: 1;
		disableEditing;
		openInWorld
	! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952837!
selectorDocumentationText

	| selectedEntry selectorsClasses |

	selectedEntry := completer selectedEntry.
	(completer isCategoryEntry: selectedEntry) ifTrue: [ ^'' ].
	selectedEntry := selectedEntry asSymbol.
	selectorsClasses := completer selectorsClasses.

	^ selectorsClasses isEmpty
		ifTrue: [ self selectorDocumentationTextForAllImplementorsOf: selectedEntry ]
		ifFalse: [ self selectorDocumentationTextOf: selectedEntry forAll: selectorsClasses ].
	! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952949 overrides: 50604407!
stepAt: millisecondSinceLast

	self isShowingSelectorDocumentation ifTrue: [ ^self ].
	super stepAt: millisecondSinceLast! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952902!
showSelectorDocumentation

	| selectorDocumentationLocation selectorDocumentationExtent |

	selectorDocumentationLocation := self selectorDefaultDocumentationLocation.
	selectorDocumentationExtent := self selectorDocumentationExtent.
	selectorDocumentationLocation := self adjust: selectorDocumentationLocation ifOutOfScreenWith: selectorDocumentationExtent xOffset: extent x yOffset: self itemHeight negated.

	self setDefaultColors.

	self selectorDocumentation
		model: (TextModel withText: self selectorDocumentationText);
		morphPosition: selectorDocumentationLocation extent: selectorDocumentationExtent;
		wrapFlag: false;
		show.

	! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952769!
crPressedOnSelectorDocumentation

	self hideSelectorDocumentation.
	self activeHand newKeyboardFocus: completer textMorph ! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952926 overrides: 16906843!
delete

	selectorDocumentation ifNotNil: [
		selectorDocumentation delete.
		selectorDocumentation := nil ].

	super delete ! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952938 overrides: 50604454!
selected: aNumber
	"Set the value of selected"

	((aNumber between: 1 and: self entryCount) and: [ aNumber ~= selected ])
		ifTrue: [
			selected := aNumber.
			self isShowingSelectorDocumentation ifTrue: [ self showSelectorDocumentation ]]! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952880!
selectorDocumentationTextForAllImplementorsOf: selectedEntry

	^ self selectorDocumentationTextForAllI: (Smalltalk allImplementorsOf: selectedEntry).

	! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952776!
hideSelectorDocumentation

	selectorDocumentation ifNotNil: [ selectorDocumentation hide ].
	self stillActive ! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952832!
selectorDocumentationExtent

	^`600@250`! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952797!
isShowingSelectorDocumentation

	^selectorDocumentation notNil and: [ selectorDocumentation visible ]! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952825!
selectorDocumentation

	selectorDocumentation ifNil: [ self initializeSelectorDocumentation ].
	^selectorDocumentation ! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952814!
selectorDefaultDocumentationLocation

	| relativeSelected |

	relativeSelected := (self selected - self firstVisible) min: self itemsPerPage - 1 max: 0.

	^location externalizePosition: extent x@(relativeSelected * self itemHeight + 1).

	! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952804!
methodDocumentationSeparator

	^ Text
		string: String newLineString, '------------------------------------------------------------------------------------------------', String newLineString
		attribute: TextColor black.! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952933 overrides: 50604505!
resetMenu

	self hideSelectorDocumentation.
	super resetMenu! !
!SmalltalkCompleterMorph methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:21:44' prior: 16952888!
selectorDocumentationTextOf: selectedEntry forAll: selectorsClasses

	| methodsToShow |

	methodsToShow := selectorsClasses
		inject: IdentitySet new
		into: [ :methods :aClass |
			(aClass lookupSelector: selectedEntry) ifNotNil: [ :method | methods add: method ].
			methods ].

	^self selectorDocumentationTextForAllI: methodsToShow ! !
!Browser methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/12/2024 13:38:39' prior: 50541019!
typeInfoForTempVarNamed: aName inRange:aRange
	
	
	^self typeInfoForVarNamed: aName inRange: aRange ifNoContextFoundDo: [^currentCompiledMethod typeInfoOfVariableNamed: aName ifAbsent: [ nil ].].
! !
!Browser methodsFor: '*LiveTypingTypeChecker' stamp: 'JFGO 10/12/2024 13:38:43' prior: 50606171!
typeInfoForTempVarNamed: aName inRange:aRange
	
	^self typeInfoForVarNamed: aName inRange: aRange ifNoContextFoundDo: [^currentCompiledMethod typeInfoOfVariableNamed: aName ifAbsent: [ nil ].].
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798853!
newSystemCategoryNameIfNone: aNoneBlock

	| newName |
	
	newName := self
		request: 'New category name?'
		initialAnswer: self newSystemCategoryNameInitialAnswer.
	
	^newName isEmpty
		ifTrue: aNoneBlock 
		ifFalse: [newName asSymbol].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799006!
setSelectedSystemCategoryTreeItem: aSystemCategoryWrapper
	aSystemCategoryWrapper ifNotNil: [self setSelectedSystemCategory: aSystemCategoryWrapper withoutListWrapper]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50540972!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName inRange: aRange

	| typeInfo |
	
	typeInfo := currentCompiledMethod ifNotNil: [ self typeInfoForTempVarNamed: aName inRange:aRange].
		
	anAutocompleter computeMessageEntriesForTypeInfoOrNil: typeInfo.	
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798070!
addExtensionCategory
	"Present a choice package names and let the user enter a new category suffx.
	Take the suffix form the selected category."

	| packageNames packageNameIndex |
	
	selectedClassName ifNil: [ ^self ].

	packageNames := CodePackage installedPackages collect: [ :package |
		package packageName ] :: sorted.
	packageNames ifEmpty: [ ^ self ].
	
	packageNameIndex := PopUpMenu 
		withCaption: 'Which package to extend?'
		chooseFrom: packageNames.
	packageNameIndex = 0 ifTrue: [ ^ self ].

	self 
		request: 'Enter the category name'
		initialAnswer: 
			(String streamContents: [ :stream |
				stream
					nextPut: $*;
					nextPutAll: (packageNames at: packageNameIndex).
				selectedMessageCategory ifNotNil: [
					stream
						nextPut: $-;
						nextPutAll: selectedMessageCategory ] ])
		 verifying: [ :newCategoryName | 
			((newCategoryName at: 1) = $* or: [
				self confirm:
					"I know about with #withNewlines ..."
					`'The selected category does not start with an asterix (*).',
					String newLineString,
					'Do you want to use it anyway?'` ]) and: [
						packageNames includes:				(newCategoryName copyUpTo: $-) allButFirst :: or: [
							self confirm:
								`'The selected prefix does not match any package name.', 
								String newLineString,
								'Do you want to use it anyway?'` ] ] ]
		do: [ :newCategoryName | | oldMessageCategoryListIndex |
			oldMessageCategoryListIndex := self messageCategoryListIndex.
			self classOrMetaClassOrganizer
				addCategory: newCategoryName
				before: selectedMessageCategory.
			self changed: #messageCategoryList.
			self messageCategoryListIndex:
				(oldMessageCategoryListIndex = 0
					ifTrue: [ self classOrMetaClassOrganizer categories size + 1 ]
					ifFalse: [ oldMessageCategoryListIndex ]).
			self changed: #messageCategoryList ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798976!
selectedSystemCategory
	"Answer the name of the selected system category or nil."

	^selectedSystemCategory! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50525972!
askAutosaveTypeIfCancelled: aBlock

	| menuIndex options labels |

	options := {SingleFileSystemCategoryAutoSaver. MultiFileSystemCategoryAutoSaver}.
	labels := options collect: [ :autoSaverClass | autoSaverClass menuDescription].
	menuIndex := (PopUpMenu labelArray: labels) startUpWithCaption: 'Autosave Type'.
	
	^ menuIndex = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ options at: menuIndex ]
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799257!
isEditingNewClass

	^editSelection == #newClass ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50430414!
runPackageTestsWithCodeCoverage
	
	"Run all the tests in the package with code coverage.
	Only the compiled methods that do not belong to a TestCase class will be analyzed."
	
	| package testSuite codeCoverageAnalizer |
	
	selectedSystemCategory ifNil: [ ^ self ].
	
	package := CodePackage
		packageOfSystemCategory: selectedSystemCategory
		ifNone: [ ^ self inform: 'The selected system category does not belong to a package' ].
	
	testSuite := TestSuite forCodePackage: package.
	codeCoverageAnalizer := CodeCoverageAnalyzer
		toAnalyzeAll: package compiledMethodsInNonTestCaseClasses.
	
	ProgressiveCodeCoverageTestRunner
		run: (testSuite)
		analyzingCodeCoverageWith: (codeCoverageAnalizer)! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515575!
runDenotativeObjectMethodTest

	currentCompiledMethod selector isTestSelector 
		ifTrue: [ | suite |
			suite := TestSuite named: currentCompiledMethod methodClass soleInstance name, ' ', currentCompiledMethod selector asString.
			suite addTest: (DenotativeObjectTestCase for: currentCompiledMethod).
			(DenotativeObjectProgessiveTestRunner for: suite) value ]
		ifFalse: [ self send ].
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798778!
fileOutSystemCategory
	"Print a description of each class in the selected category onto a file 
	whose name is the category name followed by .st."

	selectedSystemCategory
		ifNotNil: [ systemOrganizer fileOutCategory: selectedSystemCategory ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798676!
metaClassIndicated
	"Answer the boolean flag that indicates which of the method dictionaries, 
	class or metaclass."

	^metaClassIndicated! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797729!
explainSpecial: string 
	"Answer a string explaining the code pane selection if it is displaying 
	one of the special edit functions."

	| classes whole lits reply |
	self isEditingClass
		ifTrue: 
			["Selector parts in class definition"
			string last = $: ifFalse: [^nil].
			lits := Array with:
				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.
			(whole := lits detect: [:each | (each keywords
					detect: [:frag | frag = string] ifNone: nil) notNil]
						ifNone: nil) notNil
				ifTrue: [reply := '"' , string , ' is one part of the message selector ' , whole , '.']
				ifFalse: [^nil].
			classes := Smalltalk allClassesImplementing: whole.
			classes := 'these classes ' , classes printString.
			^reply , '  It is defined in ' , classes , '."
Smalltalk browseAllImplementorsOf: #' , whole].

	editSelection == #editSystemCategories ifTrue: [^nil].
	editSelection == #editMessageCategories ifTrue: [^nil].
	^nil! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50504286!
browseActualSendersOf: aCompiledMethod 
	
	Smalltalk browseAllActualSendersOn: aCompiledMethod ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50526343!
changeNewLineEncode
	
	| index |
	
	selectedSystemCategory ifNil: [ ^ self]. 
	
	index := self selectEncodeToConvert.					
	(index between: 1 and: 3) ifTrue: [ self convertToEncode: index ].
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799146!
systemOrganizer: aSystemOrganizer
	"Initialize the receiver as a perspective on the system organizer, 
	aSystemOrganizer. Typically there is only one--the system variable 
	SystemOrganization."

	systemOrganizer := aSystemOrganizer.
	selectedSystemCategory := nil.
	selectedClassName := nil.
	selectedMessageCategory := nil.
	selectedMessage := nil.
	metaClassIndicated := false.
	self setClassOrganizer.
	self editSelection: #none.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797580!
classDefinitionText
	"return the text to display for the definition of the currently selected class"
	
	^self selectedClassOrMetaClass 
		ifNil: [''] 
 		ifNotNil: [ :theClass | theClass definition]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798003 overrides: 50588172!
selectedClass
	"Answer the class that is currently selected. Answer nil if no selection 
	exists."

	| name |
	(name := self selectedClassName) ifNil: [^ nil].
	^ Smalltalk at: name ifAbsent: nil! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798829!
moveSystemCategoryDown
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryDown: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797498!
editSelection
	^editSelection! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799199!
runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite := TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgressiveTestRunner for: suite) value ]
	
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798971!
indexIsOne: value
	"When used as a singleton list, can't change it"

	^ self! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798386!
rawMessageCategoryList

	^ selectedClassName
		ifNil: [ #() ]
		ifNotNil: [ self classOrMetaClassOrganizer categories ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797489!
doItReceiver
	"This class's classPool has been jimmied to be the classPool of the class 
	being browsed. A doIt in the code pane will let the user see the value of 
	the class variables."

	^ self selectedClass! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799075 overrides: 16932297!
initialize

	super initialize.
	self initializeListClassesHierachically! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799086!
labelString
	^self selectedClass ifNil: [ self defaultBrowserTitle ]
		ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797626!
createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage := aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ].
			(aClass canUnderstand: (setter := aName , ':') asSymbol) ifFalse: [
				newMessage := setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' := anObject'.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ]]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798742!
alphabetizeSystemCategories
	systemOrganizer sortCategories.
	self setSelectedSystemCategory: nil.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799044!
systemCategorySingleton

	^ selectedSystemCategory
		ifNil: [#()]
		ifNotNil: [Array with: selectedSystemCategory]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799243!
isEditingClass

	^self isEditingExistingClass or: [ self isEditingNewClass ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515508!
debug: aCompiledMethod receiver: anObject in: evalContext withResultDo: aBlock

	DenotativeObjectDebugger 
		openDebugging: [ | result |
			result := aCompiledMethod
				valueWithReceiver: anObject
				arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ]).
			aBlock value: result ]
		to: aCompiledMethod
		label: 'Debug it'.
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798281!
renameCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	| oldIndex oldName newName |
	selectedClassName ifNil: [^ self].
	selectedMessageCategory ifNil: [ ^self ].
	oldIndex := self messageCategoryListIndex.
	oldName := self selectedMessageCategoryName.
	newName := self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName := aString asSymbol.
			self classOrMetaClassOrganizer
				renameCategory: oldName
				to: newName.
			self classListIndex: self classListIndex.
			self messageCategoryListIndex: oldIndex.
			self changed: #messageCategoryList]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50430447!
runWithCodeCoverage: aTestSuite

	ProgressiveCodeCoverageTestRunner
		run: aTestSuite
		analyzingCodeCoverageWith: (CodeCoverageAnalyzerBuilder valueFrom: aTestSuite)
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797429!
contents: input notifying: aRequestor
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment).
	Answer the result of updating the source."

	| codeString theClass |
	codeString := input string.
	editSelection == #editSystemCategories ifTrue: [
		^ self changeSystemCategories: codeString ].
	self isEditingClass ifTrue: [
		[
			self defineClass: codeString notifying: aRequestor 
		] on: RecompilationFailure do: [ :ex |
			self inform: ex messageText.
			^ false].
		^ true].
	editSelection == #editComment
		ifTrue: [
			theClass := self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: codeString stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: codeString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: codeString notifying: aRequestor)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797934!
hierarchicalClassList

	"classNames are an arbitrary collection of classNames of the system.
	Reorder those class names so that they are sorted and indended by inheritance"

	| classes |

	"Creating the hierarchy is *really slow* for the full class list. Skip it for now."
	selectedSystemCategory = SystemOrganizer allCategory ifTrue: [^ self defaultClassList].		
	classes := self defaultClassList collect: [:sym | Smalltalk classNamed: sym].
	
	^ self
		flattenHierarchyTree: (self createHierarchyTreeOf: classes)
		on: OrderedCollection new
		indent: ''.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798789!
moveAllToOtherSystemCategory
	"If a class category is selected, prompt user for category to move to,
	create a Confirmer so the user can verify that all the classes in current category
 	should be moved to the selected category."
	| newSystemCategory |
	selectedSystemCategory ifNil: [ ^ self ].
	newSystemCategory := Smalltalk systemCategoryFromUserWithPrompt: 'Move classes to System Category...'.
	(newSystemCategory notNil and: [
		self classList notEmpty and: [ self confirm: 'Are you sure you want to
move classes from ' , selectedSystemCategory , ' 
to ' , newSystemCategory , '?' ]]) ifTrue: [
		"Safer this way (#classList will be a collection of strings with spaces and who knows what in the future.  So let's just get the classes we need directly)"
		(SystemOrganization classesAt: selectedSystemCategory) do: [ :eaClass |
			eaClass category: newSystemCategory ].
		self changed: #systemCategoryRoots ].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50504376!
hasNoActualSendersOrIsItself: aCompiledMethod 
	
	| realSendersCount allSenders posibleSenders realSenders |

	allSenders := Smalltalk allActualSendersOn: aCompiledMethod.
	realSenders := allSenders first.
	posibleSenders := allSenders second.
	realSendersCount := realSenders size.

	^posibleSenders isEmpty 
		and: [ realSendersCount = 0 
			or: [ realSendersCount = 1 
				and: [(realSenders first actualClass == aCompiledMethod methodClass and: [realSenders first methodSymbol == aCompiledMethod selector])]]]
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799231!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(SafelyRemoveClassApplier on: self of: aBehavior theNonMetaClass) value ].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50504410!
removeMethod: aCompiledMethod 

	aCompiledMethod methodClass removeSelector: aCompiledMethod selector.
	self
		messageListIndex: 0;
		changed: #messageList;
		setClassOrganizer.
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799180!
runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass := Smalltalk classNamed: selectedClassName.
		suite := TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgressiveTestRunner for: suite) value ]
	
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50526011!
systemCategoryAutosaveMenuLabel
	
	^(SystemCategoryAutoSaver hasAutosaverFor: self selectedSystemCategory)
		ifTrue: [ 'stop autosave' ]
		ifFalse: [ 'start autosave' ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798630!
classCommentIndicated
	"Answer true iff we're viewing the class comment."

	^ editSelection == #editComment 
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798488!
removeMessage
	"If a message is selected, create a Confirmer so the user can verify that  
	the currently selected message should be removed from the system. If 
	so,  
	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 
	confirmer is bypassed."
	| messageName confirmation |
	selectedMessage ifNil: [ ^self ].
	messageName := self selectedMessageName.
	confirmation := Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.
	confirmation = 3
		ifTrue: [^ self].
	self selectedClassOrMetaClass removeSelector: self selectedMessageName.
	self reformulateList.
	self changed: #messageList.
	self setClassOrganizer.
	"In case organization not cached"
	confirmation = 2
		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798012!
selectedClassName
	"Answer the name of the current class. Answer nil if no selection exists."

	^selectedClassName ifNotNil: [ 
		"I send #defaultClassList and no #classList because when showing classes hierarchically we should remove spaces to see
		if class name is in the list and that consumes more time - Hernan"
		(self defaultClassList includes: selectedClassName) ifTrue: [ selectedClassName ]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798864!
newSystemCategoryNameInitialAnswer
	"Make a suggestion for a new sytems category.
	
	Can be redefined in subclasses to provide something meore meaningfull."

	^ 'Category-Name'.
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50526004!
stopAutosave

	SystemCategoryAutoSaver stopAndRemoveAutosaverFor: selectedSystemCategory.
	self inform: 'Autosaver stopped.'! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50541009!
typeInfoForInstVarNamed: aName inRange:aRange withClass: aClass
	
	
	^self typeInfoForVarNamed: aName inRange: aRange ifNoContextFoundDo: [^aClass typeInfoOfInstanceVariableNamed: aName ifAbsent: [ nil ].].
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798706 overrides: 50588383!
selectedClassOrMetaClass
	"Answer the selected class or metaclass."

	| cls |
	self metaClassIndicated
		ifTrue: [^ (cls := self selectedClass) ifNil: [nil] ifNotNil: [cls class]]
		ifFalse: [^ self selectedClass]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50541029!
typeInfoForVarNamed: aName inRange:aRange ifNoContextFoundDo: aBlock
	
	
	| methodNode blockNodeContext variableNode |
	currentCompiledMethod ifNil:[^aBlock value].
	methodNode := currentCompiledMethod methodNode.
	blockNodeContext:=methodNode parseBlockNodeWhenBranchIsIn: aRange start ifAbsent:[^aBlock value].
		
	variableNode := methodNode variableNodeNamed: aName.
	^currentCompiledMethod typeInfoOfVariable: variableNode withNode: methodNode withinBlockNode: blockNodeContext.
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515522!
debugAndInspect
	
	self debugAndWithResultDo: [:result | result inspect ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797978!
recent
	"Let the user select from a list of recently visited classes.  11/96 stp.
	 12/96 di:  use class name, not classes themselves.
	 : dont fall into debugger in empty case"

	| className class recentList |
	recentList := self class recentClasses select: [:n | Smalltalk includesKey: n].
	recentList isEmpty ifTrue: [^ Smalltalk beep].
	className := (SelectionMenu selections: recentList) startUpMenu.
	className ifNil: [^ self].
	class := Smalltalk at: className.
	self setSelectedSystemCategory: class category.
	self selectClass: class! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797915!
flattenHierarchyTree: classHierarchy on: col indent: indent by: indentChars

	"Recursively add to col the names in classHierarchy indenting to show the hierarchical relationship. Use indentChars to do the indenting: spaces, tabs, etc."

	| plusIndent |

	plusIndent := indentChars.
	classHierarchy do: [:assoc |
		| class childs |
		class := assoc key.
		col add: indent , class name.
		childs := assoc value.
		self
			flattenHierarchyTree: childs
			on: col
			indent: indent , plusIndent
			by: indentChars].
	^ col! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798521!
messageList
	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."
	| classOrMetaClassOrganizer answer |
	classOrMetaClassOrganizer := self classOrMetaClassOrganizer.
	classOrMetaClassOrganizer isNil ifTrue: [ ^#() ].
	answer := (selectedMessageCategory isNil or: [ selectedMessageCategory == ClassOrganizer allCategory ])
		ifTrue: [classOrMetaClassOrganizer allMethodSelectors]
		ifFalse: [classOrMetaClassOrganizer listAtCategoryNamed: selectedMessageCategory].	
	answer isNil ifTrue: [
		selectedMessageCategory := nil.
		answer := #() ].
	"Sort message list with binary selectors first (otherwise some unicode binary selectors end up at the end of the list)."
	^answer sort: [:a :b| a isValidBinarySelector ifTrue: [b isValidBinarySelector ifTrue: [a < b] ifFalse: [true]] ifFalse: [b isValidBinarySelector ifTrue: [false] ifFalse: [a < b]]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799219!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(RenameClassApplier for: aBehavior theNonMetaClass) value ].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798426!
defineMessageFrom: aString notifying: aRequestor
	"Compile the expressions in aString. Notify aRequestor if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."
	| selectedMessageName selector category oldMessageList scarySelector |
	selectedMessageName := self selectedMessageName.
	oldMessageList := self messageList.
	 self metaClassIndicated ifTrue: [
		scarySelector := self selectedClassOrMetaClass parserClass selectorFrom: aString.
		((self selectedClassOrMetaClass includesSelector: scarySelector) not
			and: [Metaclass isScarySelector: scarySelector])
			ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"
					(self confirm: (scarySelector bold, ' is used in the existing class system.
Overriding it could cause serious problems.
Is this really what you want to do?'))
					ifFalse: [^nil]]].
	category := self selectedMessageCategoryName ifNotNil: [ :n | n asSymbol ].
	category == ClassOrganizer allCategory ifTrue: [
		"Current category for existing methods or if a method was selected,
		'as yet unclassified' (i.e. nil) for new methods when no previous method was selected."
		category := self categoryOfCurrentMethod ].
	selector := self selectedClassOrMetaClass
				compile: aString
				classified: category
				notifying: aRequestor.
	selector
		ifNil: [^ nil].
	selector ~~ selectedMessageName
		ifTrue: [
			category = ClassOrganizer nullCategory
				ifTrue: [self changed: #classSelectionChanged.
						self changed: #classList.
						self messageCategoryListIndex: 1].
			self setClassOrganizer.  "In case organization not cached"
			(oldMessageList includes: selector)
				ifFalse: [self changed: #messageList].
			self messageListIndex: (self messageList indexOf: selector)].
	^ selector! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50504395!
removeMessageCheckingActualSenders
	
	| confirmation |

	self currentCompiledMethod ifNotNil: [ :aCompiledMethod |
		confirmation := self confirmActualRemovalOf: aCompiledMethod.

		(confirmation = 1 or: [ confirmation = 2 ]) ifTrue: [self removeMethod: aCompiledMethod ].
		(confirmation = 2 or: [ confirmation = 3 ]) ifTrue: [self browseActualSendersOf: aCompiledMethod ]].

	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797589!
copyClass
	| originalClass originalName copysName newDefinition newMetaDefinition newClass |
	selectedClassName ifNil: [^ self].
	originalClass := self selectedClass.
	originalName := originalClass name.
	self request: 'New class name?'
		initialAnswer: originalName
		verifying: [:aString| aString notEmpty and: [aString ~= originalName]]
		do: [:aString|
			copysName := aString asSymbol.
			(Smalltalk includesKey: copysName)
				ifTrue: [self error: copysName , ' already exists'].
			newDefinition := originalClass definition
				copyReplaceAll: originalName printString
				with: copysName printString.
			newClass := Compiler evaluate: newDefinition logged: true.
			newMetaDefinition := originalClass class definition
				copyReplaceAll: originalClass class name
				with: newClass class name.
			Compiler evaluate: newMetaDefinition logged: true.
			newClass copyAllCategoriesFrom: originalClass.
			newClass class copyAllCategoriesFrom: originalClass class.
			originalClass hasComment ifTrue: [newClass comment: originalClass comment].
			self classListIndex: 0.
			self changed: #classList]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50540998!
typeCheckClass
	
	| typeChecker |
	
	typeChecker := self selectedClass ifNotNil: [ :aSelectedClass | 
		typeChecker := aSelectedClass typeChecker.
		(ProgressiveManyMethodTypeCheckRunner for: typeChecker showingResultsWith: aSelectedClass name) value. ]
	
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798353!
messageCategoryListIndex
	"Answer the index of the selected message category."


	selectedMessageCategory ifNil: [ ^0 ].
	^self messageCategoryList indexOf: selectedMessageCategory! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798888!
removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797537!
toggleBreakOnEntry
	"Install or uninstall a halt-on-entry breakpoint"

	| selectedMethod |
	self selectedClassOrMetaClass ifNil: [ ^self ].
	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.
	selectedMethod hasBreakpoint
		ifTrue:
			[ selectedMethod uninstall ]
		ifFalse:
			[ BreakingMethodWrapper on: selectedMethod :: install ].
	self
		changed: #messageList;
		changed: #annotation! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797869!
createHierarchyTreeOf: col

	"Create a tree from a flat collection of classes"

	| transformed |

	transformed := col collect: [:ea | 
		| childs indexes |
		childs := col select: [:class | class superclass = ea].
		indexes := childs collect: [:child | col indexOf: child].
		Association key: ea value: indexes].
	transformed copy do: [:ea |
		ea value: (ea value collect: [:idx | 
			| val |
			val := transformed at: idx.
			transformed at: idx put: nil.
			val])].
	^ transformed select: [:ea | ea notNil].
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798196!
changeMessageCategories: aString 
	"The characters in aString represent an edited version of the the message 
	categories for the selected class. Update this information in the system 
	and inform any dependents that the categories have been changed. This 
	message is invoked because the user had issued the categories command 
	and edited the message categories. Then the user issued the accept 
	command."

	self classOrMetaClassOrganizer changeFromString: aString.
	self changed: #clearUserEdits.
	self editClass.
	self classListIndex: self classListIndex.
	^ true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799014!
systemCategoryList
	"Answer the class categories modelled by the receiver."

	^systemOrganizer categories! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798982!
setSelectedSystemCategory: aString
	"Set the selected system category and update all other selections to be deselected."
	selectedSystemCategory := aString.
	selectedClassName := nil.
	selectedMessageCategory := nil.
	selectedMessage := nil.
	self editSelection: (aString isNil ifTrue: [#none] ifFalse: [#newClass]).
	metaClassIndicated := false.
	self setClassOrganizer.
	self changed: #selectedSystemCategory.
	self changed: #classList.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798362!
messageCategoryListIndex: anInteger
	"Set the selected message category to be the one indexed by anInteger."

	| index messageCategoryList |
	
	messageCategoryList := self messageCategoryList.
	index := messageCategoryList ifInBounds: anInteger ifNot: 0.

	selectedMessageCategory := index = 0 ifFalse: [messageCategoryList at: index ].
	selectedMessage := nil.
	self changed: #messageCategorySelectionChanged.
	self changed: #messageCategoryListIndex. "update my selection"
	self changed: #messageList.
	self editSelection: (index > 0
		ifTrue: [#newMessage]
		ifFalse: [self classListIndex > 0
			ifTrue: [#editClass]
			ifFalse: [#newClass]]).
	self acceptedContentsChanged.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799261 overrides: 50588472!
updateIfNeeded
	super updateIfNeeded.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50430386!
runClassTestsWithCodeCoverage
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		self runWithCodeCoverage: (TestSuite forClass: selectedClass) ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797898!
enableListClassesAlphabetically

	self listClassesHierarchically: false! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798558!
messageListIndex
	"Answer the index of the selected message selector into the currently 
	selected message category."

	selectedMessage ifNil: [ ^0 ].
	^self messageList indexOf: selectedMessage! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798668!
instanceMessagesIndicated
	"Answer whether the messages to be presented should come from the 
	class."

	^metaClassIndicated not and: [self classCommentIndicated not]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515491!
compile: aString receiver: receiver in: evalContext

	| methodNode |

	methodNode := [
		Compiler new
			compileNoPattern: aString
			in: receiver class
			context: evalContext
			notifying: nil
			ifFail: [ ^ nil ]]
				on: OutOfScopeNotification
				do: [ :ex | ex resume: true ].
				
	^ methodNode generate
	
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798957!
updateSystemCategories
	"The class categories were changed in another browser. The receiver must 
	reorganize its lists based on these changes."

	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799215 overrides: 50588530!
removeClass

	self safelyRemoveClass ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799050 overrides: 50588558!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	| type |
	
	self isModeStyleable ifFalse: [^false].
	type := self editSelection.
	(#(newMessage editMessage editClass newClass) includes: type) ifFalse:[^false].
	anSHTextStyler classOrMetaClass: ((#(editClass newClass) includes: type)  ifFalse:[
		self selectedClassOrMetaClass]).
	^true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798147!
categorizeUnderCategoryAt: aMessageCategoryListIndex selector: aSelectorToCategorize
	aMessageCategoryListIndex isNil ifTrue: [^ self categorizeUnderNewCategorySelector: aSelectorToCategorize].
	self selectedClassOrMetaClass ifNotNil: [ :class | | categorySelector |
		categorySelector := self messageCategoryList at: aMessageCategoryListIndex ifAbsent: [^self].
		categorySelector ~= Categorizer allCategory
			ifTrue: [
				class organization classify: aSelectorToCategorize under: categorySelector suppressIfDefault: false.
				self changed: #messageList]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799226!
renameGlobal
	
	(RenameGlobalApplier on: self for: '') value! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797501!
editSelection: aSelection
	"Set the editSelection as requested."

	editSelection := aSelection.
	self changed: #editSelection.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515546!
debugDenotativeObjectMethodTest

	currentCompiledMethod selector isTestSelector
		ifTrue: [ 
			| test |
			test := DenotativeObjectTestCase for: currentCompiledMethod.
			test runCaseAsFailure ]
		ifFalse: [ self debug ]
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797706!
editClass
	"Retrieve the description of the class definition."

	selectedClassName ifNil: [^ self].
	self messageCategoryListIndex: 0.
	self editSelection: #editClass.
	self acceptedContentsChanged.
	self changed: #classCommentText.
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797857!
classListIndexOf: aClassNameToFind

	"Answer the index of the aClassName selection."

	aClassNameToFind ifNil: [ ^0 ].
	^self classList findFirst: [ :showingClassName |
		"Works regardless of currently showing hierarchically or alphabetically."
		showingClassName afterBlanksEndsWith: aClassNameToFind  ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798644!
classOrMetaClassOrganizer
	"Answer the class organizer for the metaclass or class, depending on 
	which (instance or class) is indicated."

	self metaClassIndicated
		ifTrue: [^metaClassOrganizer]
		ifFalse: [^classOrganizer]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515609!
runDenotativeObjectTests

	self selectedClassOrMetaClass ifNotNil: [ :aDenotativeObject | | suite |
		suite := TestSuite named: 'Tests of ', aDenotativeObject soleInstance name asString.
		aDenotativeObject selectors do: [ :aSelector |
			aSelector isTestSelector ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aDenotativeObject>>aSelector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) value ]

	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50504292 overrides: 50597701!
computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName  

	"This will change when type info for block arguments will be supported - Hernan"

	"| typeInfo |
	
	typeInfo := currentCompiledMethod ifNotNil: [ currentCompiledMethod typeInfoOfVariableNamed: aName ifAbsent: [ nil ]].
		
	anAutocompleter computeMessageEntriesForTypeInfo: typeInfo."
	
	anAutocompleter computeMessageEntriesForTypeInfoOrNil: nil ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797655!
defineClass: defString notifying: aRequestor  
	"The receiver's textual content is a request to define a new class. The
	source code is defString. If any errors occur in compilation, notify
	aRequestor."
	| oldClass class newClassName defTokens keywdIx |
	oldClass := self selectedClassOrMetaClass.
	defTokens := defString findTokens: Character separators.
	keywdIx := defTokens findFirst: [ :x | x beginsWith: 'category' ].
	keywdIx := defTokens findFirst: [ :x | '*subclass*' match: x ].
	newClassName := (defTokens at: keywdIx+1) copyWithoutAll: '#()'.
	((oldClass isNil or: [ oldClass theNonMetaClass name asPlainString ~= newClassName ])
		and: [ Smalltalk includesKey: newClassName asSymbol ]) ifTrue: [
			"Attempting to define new class over existing one when
				not looking at the original one in this browser..."
			(self confirm: (newClassName bold , ' is an existing class in this system.
Redefining it might cause serious problems.
Is this really what you want to do?'))
				ifFalse: [ ^ false ]].
	"ar 8/29/1999: Use oldClass superclass for defining oldClass
	since oldClass superclass knows the definerClass of oldClass."
	oldClass ifNotNil: [ oldClass := oldClass superclass ].
	class := Compiler
				evaluate: defString
				notifying: aRequestor
				logged: true.
	(class isKindOf: Behavior)
		ifTrue: [
				self changed: #systemCategoryRoots.
				self changed: #classList.
				self changed: #clearUserEdits.
				self setClass: class selector: nil.
				"self clearUserEditFlag; editClass."
				^ true ]
		ifFalse: [ ^ false ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798728!
addSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	
	| newName |
	newName := self newSystemCategoryNameIfNone: [ ^self ].	
	systemOrganizer
		addCategory: newName
		before: selectedSystemCategory.
	self setSelectedSystemCategory: newName.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797762!
fileOutClass
	"Print a description of the selected class onto a file whose name is the 
	category name followed by .st."

	selectedClassName ifNotNil: [ self selectedClass fileOut ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50526019!
toggleSystemCategoryAutosave
	
	(SystemCategoryAutoSaver hasAutosaverFor: selectedSystemCategory) 
		ifTrue: [ self stopAutosave ]
		ifFalse: [ self autosaveCategory ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798966!
indexIsOne
	"When used as a singleton list, index is always one"
	^ 1! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50526385!
selectEncodeToConvert

	^(PopUpMenu 
		labelArray: {'LF (Cuis default)'. 'CR'. 'CRLF'. 'Cancel'}
		lines: #()
		icons: #(updateIcon updateIcon updateIcon cancelIcon) ) 
		startUpWithCaption: 'To which binary encode would you like to change the code?'.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797567!
classCommentText
	"return the text to display for the comment of the currently selected class"
	| theClass |
	theClass := self selectedClassOrMetaClass.
	^ Text
		initialFont: (Preferences at: #standardCodeFont)
		stringOrText:
			((theClass notNil and: [ theClass hasComment ])
				ifTrue: [ theClass comment ]
				ifFalse: [ '' ]).! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16797804!
classListIndex: anInteger 
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass classList |

	classList := self classList.
	canSelectClass := classList isInBounds: anInteger.
	selectedClassName := canSelectClass ifTrue: [	| newClassName |
		newClassName := classList at: anInteger ifAbsent: [ nil ].
		newClassName := newClassName ifNotNil: [newClassName withoutLeadingBlanks asSymbol].
		newClassName ].
	self setClassOrganizer.
	selectedMessage := nil.
	
	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent := self class recentClasses.
		className := self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].

	"Clear selectedMessageCategory if there is no match in the new list of categories"
	(self messageCategoryList indexOf: selectedMessageCategory) = 0 ifTrue: [
		selectedMessageCategory := nil].
		
	"We have to refresh the class list if somebody wants to select a class that does not exist anymore - Hernan"
	anInteger > classList size ifTrue: [ self changed: #classList ].
	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798140 overrides: 50588682!
canShowMultipleMessageCategories
	"Answer whether the receiver is capable of showing multiple message categories"

	^ true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515504!
debug
	
	self debugAndWithResultDo: [:result | ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16798654!
indicateClassMessages
	"Indicate that the message selection should come from the metaclass 
	messages."

	self metaClassIndicated: true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50515629!
sendAndInspect

	self sendAndWithResultDo: [ :result | result inspect ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 50606181!
typeInfoForTempVarNamed: aName inRange:aRange
	
	^self typeInfoForVarNamed: aName inRange: aRange ifNoContextFoundDo: [^currentCompiledMethod typeInfoOfVariableNamed: aName ifAbsent: [ nil ].].

! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:50' prior: 16799093 overrides: 50588719!
methodCategoryChanged
	self changed: #messageCategoryList.
	self changed: #messageList.
	self triggerEvent: #annotationChanged.
	self reformulateList! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797998!
selectClass: classNotMeta

	self classListIndex: (self classListIndexOf: classNotMeta name)! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797770!
makeNewSubclass

	self selectedClassOrMetaClass ifNil: [^ self].
	self editSelection: #newClass.
	self acceptedContentsChanged! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797888!
defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	selectedSystemCategory ifNil: [^ #()].
	^ systemOrganizer fullListAtCategoryNamed: selectedSystemCategory! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798749!
categorizeUnderCategory: systemCategoryName class: className
	systemCategoryName isNil ifTrue: [^ self].
	(Smalltalk at: className asSymbol ifAbsent: [^ self]) category: systemCategoryName! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504324 overrides: 50597660!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName  

	| typeInfo |
	
	typeInfo := self selectedClassOrMetaClass 
		ifNotNil: [ :selected |  selected typeInfoOfInstanceVariableNamed: aName ifAbsent: [ nil ] ].
		
	anAutocompleter computeMessageEntriesForTypeInfoOrNil: typeInfo ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504308 overrides: 50597673!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName  

	"This will change when type info for block arguments will be supported - Hernan"

	"| typeInfo |
	
	typeInfo := currentCompiledMethod ifNotNil: [ currentCompiledMethod typeInfoOfVariableNamed: aName ifAbsent: [ nil ]].
		
	anAutocompleter computeMessageEntriesForTypeInfo: typeInfo."
	
	anAutocompleter computeMessageEntriesForTypeInfoOrNil: nil ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50526352!
convertToEncode: encondeNumber 

	| categorySubclasses class newSourceCode sourceCode |
	
	categorySubclasses := SystemOrganization listAtCategoryNamed: selectedSystemCategory.
		
	categorySubclasses do: [:aClassName | 
		class := Smalltalk classNamed: aClassName.
		{ class. class class } do: [ :aClass | aClass selectors do: [:aMethod |
			sourceCode := (aClass compiledMethodAt: aMethod) sourceCode.
			encondeNumber = 1 ifTrue: [ newSourceCode := sourceCode withCuisLineEndings. ].
			encondeNumber = 2 ifTrue: [ newSourceCode := sourceCode withLineEndings: String crString. ].
			encondeNumber = 3 ifTrue: [ newSourceCode := sourceCode withLineEndings: String crlfString. ].
			aClass compile: newSourceCode ]]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798257!
removeMessageCategory
	"If a message category is selected, create a Confirmer so the user can 
	verify that the currently selected message category should be removed
 	from the system. If so, remove it."

	| messageCategoryName |
	selectedMessageCategory ifNil: [^ self].
	messageCategoryName := self selectedMessageCategoryName.
	(self messageList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this method category 
and all its methods?'])
		ifTrue: [
			self selectedClassOrMetaClass removeCategory: messageCategoryName.
			self messageCategoryListIndex: 0.
			self changed: #classSelectionChanged].
	self changed: #messageCategoryList.
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798047!
addCategory
	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"

	| oldIndex newName |

	selectedClassName ifNil: [ ^self ].
	
	oldIndex := self messageCategoryListIndex.
	newName := self newMethodCategoryNameIfNone: [ ^self ].
	
	self classOrMetaClassOrganizer
		addCategory: newName
		before: selectedMessageCategory.
	self changed: #messageCategoryList.
	self messageCategoryListIndex:
		(oldIndex = 0
			ifTrue: [self classOrMetaClassOrganizer categories size + 1]
			ifFalse: [oldIndex]).
	self changed: #messageCategoryList.
	
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798027!
compileMessage: aText notifying: aRequestor
	"Compile the code that was accepted by the user, placing the compiled method into an appropriate message category.  Return true if the compilation succeeded, else false."

	"If no category (not even the '-- all --' category) is selected, select one."
	self selectedMessageCategoryName ifNil: [
		self selectOriginalCategoryForCurrentMethod 	
			ifFalse: [ "Select the '--all--' category"
				self messageCategoryListIndex: 1]]. 

	^(self defineMessageFrom: aText notifying: aRequestor) notNil.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797792!
classList

	^ self listClassesHierarchically
		ifTrue: [self hierarchicalClassList]
		ifFalse: [self defaultClassList].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798758!
changeSystemCategories: aString 
	"Update the class categories by parsing the argument aString."

	systemOrganizer changeFromString: aString.
	self changed: #systemCategoryRoots.
	^ true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799208!
insertSuperclass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(InsertSuperclassApplier on: self for: aBehavior theNonMetaClass) value ].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50430396!
runMessageCategoryTestsWithCodeCoverage
	
	| testSuite |
	selectedMessageCategory ifNil: [ ^ self ].
	
	testSuite := TestSuite
		forMessageCategoryNamed: selectedMessageCategory
		of: (Smalltalk classNamed: selectedClassName)
		categorizedWith: classOrganizer.
	
	self runWithCodeCoverage: testSuite.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504336 overrides: 50597735!
computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName  

	| typeInfo |
	
	typeInfo := currentCompiledMethod ifNotNil: [ currentCompiledMethod typeInfoOfVariableNamed: aName ifAbsent: [ nil ]].
		
	anAutocompleter computeMessageEntriesForTypeInfoOrNil: typeInfo .
	
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798250!
removeEmptyCategories
	self selectedClassOrMetaClass organization removeEmptyCategories.
	self changed: #messageCategoryList
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799128!
setSelector: aSymbol
	"Make the receiver point at the given selector, in the currently chosen class"

	| aClass messageCatIndex |
	aSymbol ifNil: [^ self].
	(aClass := self selectedClassOrMetaClass) ifNil: [^ self].
	messageCatIndex := aClass organization numberOfCategoryOfElement: aSymbol.
	self messageCategoryListIndex: messageCatIndex + 1.
	messageCatIndex = 0 ifTrue: [^ self].
	self messageListIndex:
			((aClass organization listAtCategoryNumber: messageCatIndex)
					indexOf: aSymbol)! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799238 overrides: 50588821!
is: aSymbol

	^ aSymbol == #Browser or: [ super is: aSymbol ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799248!
isEditingExistingClass

	^editSelection == #editClass! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50430408!
runMethodTestWithCodeCoverage
	
	self runWithCodeCoverage: (TestSuite forCompiledMethod: currentCompiledMethod)! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798393!
selectOriginalCategoryForCurrentMethod
	"private - Select the message category for the current method. 
	 
	 Note:  This should only be called when somebody tries to save  
	 a method that they are modifying while ALL is selected. 
	 
	 Returns: true on success, false on failure."
	| aSymbol selectorName |
	aSymbol := self categoryOfCurrentMethod.
	selectorName := self selectedMessageName.
	(aSymbol notNil and: [aSymbol ~~ ClassOrganizer allCategory])
		ifTrue: [
			selectedMessageCategory := aSymbol.
			selectedMessage := selectorName.
			self changed: #messageCategorySelectionChanged.
			self changed: #messageCategoryListIndex.	"update my selection"
			self changed: #messageList.
			self changed: #messageListIndex.
			^ true].
	^ false! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798183 overrides: 50588868!
categoryOfCurrentMethod
	"Determine the method category associated with the receiver at the current moment, or nil if none"

	| category |
	^ super categoryOfCurrentMethod ifNil: [
		category := selectedMessageCategory.
		category == ClassOrganizer allCategory
			ifTrue: [nil]
			ifFalse: [category]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799162!
debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799080!
initializeListClassesHierachically

	listClassesHierarchically := self class listClassesHierarchically ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798683!
metaClassIndicated: trueOrFalse 
	"Indicate whether browsing instance or class messages."

	metaClassIndicated := trueOrFalse.
	self setClassOrganizer.
	selectedSystemCategory ifNotNil: [
		self editSelection: (selectedClassName
			ifNil: [metaClassIndicated
				ifTrue: [#none]
				ifFalse: [#newClass]]
			ifNotNil: [#editClass])].
	selectedMessageCategory := nil.
	selectedMessage := nil.
	self changed: #classSelectionChanged.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504444!
resetClassType
	
	| initializeWithInstances |
	
	self selectedClass ifNotNil: [ :aSelectedClass |
		initializeWithInstances := self confirm: 'Do you want to initialize instance variables types with current instances?'.
		initializeWithInstances 
			ifTrue: [ aSelectedClass initializeTypeInformationWithAllInstances ]
			ifFalse: [ aSelectedClass initializeTypeInformation ] ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798514!
removeMessageFromBrowser
	"Our list speaks the truth and can't have arbitrary things removed"

	^ self changed: #flash! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515527!
debugAndWithResultDo: aBlock
	
	| receiver context stringToEval method |
	
	receiver := self doItReceiver.
	context := self doItContext.
	stringToEval := self stringToEvalSending: self selectedMessageName to: receiver onCancel: [^self].
	[ method := self compile: stringToEval receiver: receiver in: context.
	method ifNotNil: [ self debug: method receiver: receiver in: context withResultDo: aBlock ]]
		on: SyntaxErrorNotification 
		do: [ :aSyntaxError | self inform: aSyntaxError messageText ]
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799101!
setClass: aBehavior selector: aSymbol
	"Set the state of a new, uninitialized Browser."

	| isMeta aClass messageCatIndex |
	aBehavior ifNil: [^ self].
	aBehavior isMeta
		ifTrue: [
			isMeta := true.
			aClass := aBehavior soleInstance]
		ifFalse: [
			isMeta := false.
			aClass := aBehavior].
	self setSelectedSystemCategory: aClass category.
	self selectClass: aClass.
	self metaClassIndicated: isMeta.
	aSymbol ifNil: [^ self].
	messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.
	self messageCategoryListIndex: (messageCatIndex > 0
		ifTrue: [messageCatIndex + 1]
		ifFalse: [0]).
	messageCatIndex = 0 ifTrue: [^ self].
	self messageListIndex: (
		(aBehavior organization listAtCategoryNumber: messageCatIndex)
			indexOf: aSymbol).! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515665!
stringToEvalSending: aSymbol to: aDenotativeObject onCancel: aCancelBlock

	| externalCollaborators |
	
	externalCollaborators := (aDenotativeObject class >> aSymbol) methodNode arguments collect: [ :anArgumentNode |
		StringRequestMorph request: 'Enter collaborator ', anArgumentNode name orCancel: [^aCancelBlock value] ].
	
	^String streamContents: [ :stream |
		stream 
			nextPutAll: aDenotativeObject name;
			space.
			
		aSymbol numArgs = 0
			ifTrue: [ stream nextPutAll: aSymbol ]
			ifFalse: [ 
				aSymbol keywords withIndexDo: [ :keyword :index |
					stream 
						nextPutAll: keyword;
						nextPutAll: ' (';
						nextPutAll: (externalCollaborators at: index);
						nextPutAll: ') ' ]]]
					
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798130!
alphabetizeMessageCategories
	selectedClassName ifNil: [^ false].
	self classOrMetaClassOrganizer sortCategories.
	self changed: #clearUserEdits.
	self editClass.
	self classListIndex: self classListIndex.
	^ true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797970!
originalSelectedClassName
	"Returns the selectedClassName no matter if it exits or not.
	It is used for refreshing the browser when renaming a class - Hernan"

	^selectedClassName! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50525988!
autosaveCategory

	| autosaveSubclass |
	
	autosaveSubclass := self askAutosaveTypeIfCancelled: [ ^self ].
		
	self
		request: 'Autosave interval (in seconds)'
		initialAnswer: '60'
		verifying: [:aString| aString size > 0 and: [aString allSatisfy: [:each| each isDigit]]]
		do: [	:interval | 
			autosaveSubclass startFor: selectedSystemCategory withDelayOf: interval asNumber.
			PopUpMenu inform: 'Autosaver started.' ]
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798715!
setClassOrganizer

	"Install whatever organization is appropriate"

	| theClass |

	classOrganizer := nil.
	metaClassOrganizer := nil.
	selectedClassName ifNil: [^ self].	
	theClass := self selectedClass ifNil: [ ^self ].
	classOrganizer := theClass organization.
	metaClassOrganizer := theClass class organization.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798322!
categorizeAllUncategorizedMethods
	"Categorize methods by looking in parent classes for a method category."

	| organizer organizers |
	organizer := self classOrMetaClassOrganizer.
	organizers := self selectedClassOrMetaClass withAllSuperclasses collect: [:ea | ea organization].
	(organizer listAtCategoryNamed: ClassOrganizer default) do: [:sel | | found |
		found := (organizers collect: [ :org | org categoryOfElement: sel])
			detect: [:ea | ea ~= ClassOrganizer default and: [ ea notNil]]
			ifNone: nil.
		found ifNotNil: [organizer classify: sel under: found]].

	self changed: #messageCategoryList! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798614 overrides: 50589061!
selectedMessageName
	"Answer the message selector of the currently selected message, if any. 
	Answer nil otherwise."
	^selectedMessage! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515590!
runDenotativeObjectSystemCategoryTests

	selectedSystemCategory ifNotNil: [ | suite classes |
		suite := TestSuite named: 'Tests of ', selectedSystemCategory.
		classes := systemOrganizer classesAt: selectedSystemCategory.
		classes notEmpty ifTrue: [
			classes do: [ :aClass |
				aClass class selectors do: [ :aSelector |
					aSelector isTestSelector ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aClass class>>aSelector)]]].
			(DenotativeObjectProgessiveTestRunner for: suite) value ]]
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798837!
moveSystemCategoryTop
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryTop: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798168!
categorizeUnderNewCategorySelector: aSelectorToCategorize

	self selectedClassOrMetaClass ifNotNil: [ :class | | newCategory |
		newCategory := self newMethodCategoryNameIfNone: [ ^self ].
		class organization 
			addCategory: newCategory;
			classify: aSelectorToCategorize under: newCategory suppressIfDefault: false.
			
		self changed: #messageCategoryList.
		self changed: #messageList]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797777!
plusButtonHit
	"Cycle among definition and comment."

	editSelection == #editComment
		ifTrue: [
			self editSelection: #editClass.
			selectedClassName ifNil: [ ^self ].
			self changed: #editComment.
			self acceptedContentsChanged.
			^ self].
	self editComment.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799020!
systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories := self systemCategoryList.
	subcategories := Dictionary new.
	categories do: [:each|
		name := (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollection new]) add: each].
	roots := OrderedCollection new.
	categories do: [:each|
		name := (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798845!
moveSystemCategoryUp
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryUp: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799192!
runMethodTest
	
	| suite |
	
	suite := TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) value 
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798942!
systemCategoryBrowser
	"Create a new system category browser with initial textual 
	contents set to aString."

	| newBrowser |
	selectedSystemCategory
		ifNotNil: [
			newBrowser := Browser new.
			newBrowser setSelectedSystemCategory: self selectedSystemCategory.
			newBrowser setClass: self selectedClassOrMetaClass selector: self selectedMessageName.
			^newBrowser].
	^nil! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515556!
runDenotativeObjectMessageCategoryTests

	selectedMessageCategory ifNotNil: [ | classlessObject suite |
		classlessObject := (Smalltalk classNamed: selectedClassName) class.
		suite := TestSuite named: 'Tests of ', selectedMessageCategory.
		(metaClassOrganizer listAtCategoryNamed: selectedMessageCategory) do: [ :selector |
			selector isTestSelector ifTrue: [ suite addTest: (DenotativeObjectTestCase for: classlessObject>>selector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) value ]

	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797508 overrides: 50589115!
annotation
	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."

	|  aSelector aClass |
	(aClass := self selectedClassOrMetaClass)
		ifNil: [
			self selectedSystemCategory ifNotNil: [ :sysCat |
				^self annotationForSystemCategory: sysCat ].
			^ ''].
	self editSelection == #editComment
		ifTrue: [^ self annotationForSelector: #Comment ofClass: aClass].
	self isEditingExistingClass 
		ifTrue: [^ self annotationForSelector: #Definition ofClass: aClass].
	(aSelector := self selectedMessageName)
		ifNil: [
			self selectedMessageCategoryName ifNotNil: [ :messageCategory |
				^self annotationForMessageCategory: messageCategory ofClass: aClass ].
			^ ''].
	^ self annotationForSelector: aSelector ofClass: aClass.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504347!
confirmActualRemovalOf: aCompiledMethod 
	
	^ (self hasNoActualSendersOrIsItself: aCompiledMethod)
		ifTrue: [self confirmRemovalWhenNoSenders ]
		ifFalse: [self confirmRemovalWhenHasSenders ].
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798344!
messageCategoryList
	"Answer the selected category of messages."
	^selectedClassName
		ifNil: [ #() ]
		ifNotNil: [ (Array with: ClassOrganizer allCategory), self rawMessageCategoryList ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798621!
selectedMessageName: aSelector
	"Make the given selector be the selected message name"

	| anIndex |
	anIndex := self messageList indexOf: aSelector.
	anIndex > 0 ifTrue:
		[self messageListIndex: anIndex]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799071!
defaultBrowserTitle
	^ 'System Browser'! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798217!
editMessageCategories
	"Indicate to the receiver and its dependents that the message categories of 
	the selected class have been changed."

	selectedClassName ifNotNil: [
			self messageCategoryListIndex: 0.
			self editSelection: #editMessageCategories.
			self changed: #editMessageCategories.
			self acceptedContentsChanged ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797903!
enableListClassesHierarchically

	self listClassesHierarchically: true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50526377!
createPackage

	selectedSystemCategory ifNotNil: [ :categoryName |
		CodePackage 
			named: categoryName 	
			createIfAbsent: true 
			registerIfNew: true ]
	 ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798595 overrides: 50589226!
selectedMessage
	"Answer a copy of the source code for the selected message."

	| class selector method |
	self showingDecompile ifTrue: [
		^ self decompiledSource ].

	class := self selectedClassOrMetaClass.
	selector := self selectedMessageName.
	method := class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"
	currentCompiledMethod := method.

	^ (self showingDocumentation
		ifFalse: [ self sourceStringPrettifiedAndDiffed ]
		ifTrue: [ self commentContents ])
			copy! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798873!
potentialClassNames
	"Answer the names of all the classes that could be viewed in this browser.  This hook is provided so that HierarchyBrowsers can indicate their restricted subset.  For generic Browsers, the entire list of classes known to Smalltalk is provided, though of course that really only is accurate in the case of full system browsers."

	^ Smalltalk classNames! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797798!
classListIndex
	"Answer the index of the current class selection."

	^self classListIndexOf: selectedClassName ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797908!
flattenHierarchyTree: classHierarchy on: col indent: indent

	^ self
		flattenHierarchyTree: classHierarchy
		on: col
		indent: indent
		by: '  '.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798636!
classMessagesIndicated
	"Answer whether the messages to be presented should come from the metaclass."

	^ self metaClassIndicated and: [self classCommentIndicated not]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797954!
listClassesHierarchically 

	"I check for nil to support migration on already opened browser when the change is loaded in image - Hernan"
	^listClassesHierarchically ifNil: [ self initializeListClassesHierachically]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798241!
newMethodCategoryNameIfNone: aNoneBlock
	
	^(MethodCategoriesPrompter 
		staringFrom: self selectedClassOrMetaClass 
		rejectingFirst: true) prompt: 'Add Category' ifNone: aNoneBlock! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515625!
send 

	self sendAndWithResultDo: [ :result | ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515634!
sendAndWithResultDo: aBlock
	
	| receiver context stringToEval method |
	
	receiver := self doItReceiver.
	context := self doItContext.
	stringToEval := self stringToEvalSending: self selectedMessageName to: receiver onCancel: [^self].
	
	[ method := self compile: stringToEval receiver: receiver in: context.
	method ifNotNil: [ 
		[| result |
		result := method
			valueWithReceiver: receiver
			arguments: (context ifNil: [ #() ] ifNotNil: [ { context } ]).
		aBlock value: result ]
			on: Error
			do: [ :anError |
				DenotativeObjectDebugger 
					openDebugging: [ | result |
						result := method
							valueWithReceiver: receiver
							arguments: (context ifNil: [ #() ] ifNotNil: [ { context } ]).
							aBlock value: result ]
					to: method
					label: 'Debug it']] fork. ]
		on: SyntaxErrorNotification 
		do: [ :aSyntaxError | self inform: aSyntaxError messageText ]
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797716!
editComment
	"Retrieve the description of the class comment."

	selectedClassName ifNil: [ ^self ].
	self messageCategoryListIndex: 0.
	metaClassIndicated := false.
	self editSelection: #editComment.
	self changed: #classSelectionChanged.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self acceptedContentsChanged
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797479 overrides: 50597629!
contentsSelection
	"Return the interval of text in the code pane to select when I set the pane's contents"

	^(selectedMessageCategory notNil and: [ selectedMessage isNil ])
		ifTrue: [ #all ]	"entire empty method template"
	
	"or null selection"! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798419 overrides: 50589287!
selectedMessageCategoryName
	"Answer the name of the selected message category, if any. Answer nil 
	otherwise."

	^selectedMessageCategory! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798767!
editSystemCategories
	"Retrieve the description of the class categories of the system organizer."

	self setSelectedSystemCategory: nil.
	self editSelection: #editSystemCategories.
	self changed: #editSystemCategories.
	self acceptedContentsChanged! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798821!
moveSystemCategoryBottom
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryBottom: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50540984!
typeCheckCategory

	| typeChecker |
	
	selectedSystemCategory ifNotNil: [ 
		typeChecker := ManyMethodsTypeCheckerDragon forAllClasses: (systemOrganizer allClassesAt: selectedSystemCategory).
		(ProgressiveManyMethodTypeCheckRunner for: typeChecker showingResultsWith: selectedSystemCategory name) value.
		]
	
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798661!
indicateInstanceMessages
	"Indicate that the message selection should come from the class (instance) 
	messages."

	self metaClassIndicated: false! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504418!
resetCategoryTypes
	
	| initializeWithInstances classes increment progressBar |
	
	selectedSystemCategory ifNotNil: [ 
		initializeWithInstances := self confirm: 'Do you want to initialize instance variables types with current instances?'.
		classes := systemOrganizer allClassesAt: selectedSystemCategory.
		classes size = 0 ifTrue: [ ^self ].
		progressBar := ProgressMorph label: 'Reseting types' subLabel: ''.
		progressBar openInWorld.
		increment := 1/classes size.
		[ classes do: [ :aClass | 
			progressBar subLabel: aClass name.
			initializeWithInstances 
				ifTrue: [ aClass initializeTypeInformationWithAllInstances ]
				ifFalse: [ aClass initializeTypeInformation ].
			progressBar incrDone: increment ].
		progressBar dismissMorph] fork ]
		! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797553!
newClassComment: aText
	"The user has just entered aText.
	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."
	| theClass |
	theClass := self selectedClassOrMetaClass theNonMetaClass.
	theClass ifNotNil: [
		theClass classComment: aText asPlainString ].
	self changed: #classCommentText.
	^ true! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798307!
showHomeCategory
	"Show the home category of the selected method.  This is only really useful if one is in a tool that supports the showing of categories.  Thus, it's good in browsers and hierarchy browsers but not in message-list browsers"

	| aSelector |
	(aSelector := self selectedMessageName) ifNotNil: [
		self selectOriginalCategoryForCurrentMethod.
		self selectedMessageName: aSelector]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798230!
fileOutMessageCategories
	"Print a description of the selected message category of the selected class 
	onto an external file."

	selectedMessageCategory ifNotNil: [
		self selectedClassOrMetaClass fileOutCategory:
			self selectedMessageCategoryName ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797963!
listClassesHierarchically: aBoolean

	listClassesHierarchically := aBoolean.
	
	self changed: #classList.
	self changed: #classListIndex.
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799252 overrides: 50589321!
isEditingMethod

	^editSelection = #editMessage or: [ editSelection = #newMessage ]
! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799171!
runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass := Smalltalk classNamed: aClassName.
		(ProgressiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50430439!
runSystemCategoryTestsWithCodeCoverage
	
	self runWithCodeCoverage: (TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer)
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50540959!
computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName inRange: aRange 
	| typeInfo |
	
	typeInfo := self selectedClassOrMetaClass 
		ifNotNil: [ :selected |  self typeInfoForInstVarNamed: aName inRange:aRange withClass: selected ].
		
	anAutocompleter computeMessageEntriesForTypeInfoOrNil: typeInfo ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16797376 overrides: 50589326!
acceptedStringOrText
	"Depending on the current selection, different information is retrieved.
	Answer a string description of that information. This information is the
	method of the currently selected class and message."

	| comment theClass latestCompiledMethod |
	latestCompiledMethod := currentCompiledMethod.
	currentCompiledMethod := nil.

	editSelection == #none ifTrue: [^ ''].
	editSelection == #editSystemCategories 
		ifTrue: [^ systemOrganizer printString].
	self isEditingNewClass ifTrue: [
		selectedSystemCategory ifNil: [ ^'' ].
		^ (theClass := self selectedClass)
			ifNil: [
				Class template: selectedSystemCategory]
			ifNotNil: [
				Class templateForSubclassOf: theClass category: selectedSystemCategory]].
	self isEditingExistingClass 
		ifTrue: [^ self classDefinitionText ].
	editSelection == #editComment 
		ifTrue: [
			(theClass := self selectedClass) ifNil: [^ ''].
			comment := theClass comment.
			currentCompiledMethod := theClass organization commentRemoteStr.
			^ comment isEmpty
				ifTrue: ['This class has not yet been commented.']
				ifFalse: [comment]].
	editSelection == #editMessageCategories 
		ifTrue: [^ self classOrMetaClassOrganizer printString].
	editSelection == #newMessage
		ifTrue: [
			^ (theClass := self selectedClassOrMetaClass) 
				ifNil: ['']
				ifNotNil: [theClass sourceCodeTemplate]].
	editSelection == #editMessage
		ifTrue: [
			self showingByteCodes ifTrue: [^ self selectedBytecodes].
			currentCompiledMethod := latestCompiledMethod.
			^ self selectedMessage].

	self error: 'Browser internal error: unknown edit selection.'! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504369!
confirmRemovalWhenNoSenders
	
	^ (self confirm: 'This message has no actual senders. Remove it anyway?') ifTrue: [1] ifFalse: [0]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798567!
messageListIndex: anInteger
	"Set the selected message selector to be the one indexed by anInteger."
	
	| index messageList |
	
	messageList := self messageList.
	index := messageList ifInBounds: anInteger ifNot: 0.

	selectedMessage := index = 0 ifFalse: [ (messageList at: index) string ].
	self editSelection: (index > 0
		ifTrue: [#editMessage]
		ifFalse: [self messageCategoryListIndex > 0
			ifTrue: [#newMessage]
			ifFalse: [self classListIndex > 0
				ifTrue: [#editClass]
				ifFalse: [#newClass]]]).
	self changed: #messageListIndex. "update my selection"
	self acceptedContentsChanged! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798588!
reformulateList
	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"

	self messageListIndex: 0! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16798908!
renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	| oldName newName |
	selectedSystemCategory ifNil: [^ self].  "no selection"
	oldName := selectedSystemCategory.
	newName := self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName := aString asSymbol.
			systemOrganizer renameSystemCategory: oldName to: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50504356!
confirmRemovalWhenHasSenders

	| menu |
	
	menu := PopUpMenu 
		labels: 'Remove it
Remove, then browse senders
Don''t remove, but show me those senders
Forget it -- do nothing -- sorry I asked'
		icons: #(acceptIcon acceptIcon cancelIcon cancelIcon).
			
	^menu startUpWithCaption: 'This message has real or posible sender(s)' ! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799276!
recentClasses
	RecentClasses ifNil: [
		RecentClasses := OrderedCollection new ].
	^RecentClasses! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799282 overrides: 16789356!
releaseClassCachedState
	"
	Browser releaseClassCachedState
	"
	RecentClasses := nil! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799294!
enableListClassesHierarchically
	
	^Preferences at: #listClassesHierarchically put: true! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799271 overrides: 16787772!
new

	^super new systemOrganizer: SystemOrganization! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799288!
disableListClassesHierarchically
	
	^Preferences at: #listClassesHierarchically put: false! !
!Browser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16799300!
listClassesHierarchically
	
	^Preferences at: #listClassesHierarchically! !
!ClassListBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16821080 overrides: 50606511!
labelString
	"Answer the label strilng to use on the browser"

	^ defaultTitle ifNil: [super labelString]! !
!ClassListBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16821070!
initForClassesNamed: nameList title: aTitle
	"Initialize the receiver for the class-name-list and title provided"

	self systemOrganizer: SystemOrganization.
	metaClassIndicated := false.
	defaultTitle := aTitle.
	classList := nameList copy! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875120 overrides: 16913865!
changed: sym
	sym == #classList ifTrue: [self updateAfterClassChange].
	super changed: sym! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875126 overrides: 50607568!
classListIndex: newIndex
	"Cause system organization to reflect appropriate category"

	| newClassName index |

	(classList isInBounds: newIndex) ifTrue: [
		newClassName := (classList at: newIndex) withoutLeadingBlanks.
		selectedSystemCategory := systemOrganizer categoryOfElement: newClassName].
	index := super classListIndex: newIndex.
	self changed: #systemCategorySingleton.
	^ index! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875146!
initAlphabeticListing
	| tab stab index |
	self systemOrganizer: SystemOrganization.
	metaClassIndicated := false.
	classList := Smalltalk classNames.! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875203 overrides: 50606556!
systemCategorySingleton

	| cls |
	cls := self selectedClass.
	^ cls ifNil: [Array new]
		ifNotNil: [Array with: cls category]! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875234!
assureSelectionsShow
	"This is a workaround for the fact that a hierarchy browser, when launched, often does not show the selected class.
	(jmv) Is this really needed?"

	| saveCatIndex saveMsgIndex |
	saveCatIndex := self messageCategoryListIndex.
	saveMsgIndex := self messageListIndex.
	self classListIndex: self classListIndex.
	self messageCategoryListIndex: saveCatIndex.
	self messageListIndex: saveMsgIndex! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875141 overrides: 50608366!
defaultBrowserTitle
	^ 'Hierarchy Browser'! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875186 overrides: 50607666!
selectClass: classNotMeta
	
	self classListIndex: (self classListIndexOf: classNotMeta name)! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875221 overrides: 50607116!
removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	self inform: 'Use a normal Browser, in which you can see 
the entire category you are trying to remove.'! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875178 overrides: 50608420!
potentialClassNames
	
	"Answer the names of all the classes that could be viewed in this browser"
	
	^ self classList collect: [:aName | aName withoutLeadingBlanks ]! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875192 overrides: 50606815!
selectedClassName
	"Answer the name of the class currently selected.   di
	  bug fix for the case where name cannot be found -- return nil rather than halt"

	| aName |
	
	aName := super selectedClassName.
	^ aName ifNotNil: [aName withoutLeadingBlanks asSymbol]! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875154!
initHierarchyForClass: aClassOrMetaClass
	| tab stab index nonMetaClass |
	centralClass := aClassOrMetaClass.
	nonMetaClass := aClassOrMetaClass theNonMetaClass.
	self systemOrganizer: SystemOrganization.
	metaClassIndicated := aClassOrMetaClass isMeta.
	classList := OrderedCollection new.
	tab := ''.
	nonMetaClass allSuperclasses reverseDo: 
		[:aClass | 
		classList add: tab , aClass name.
		tab := tab , '  '].
	index := classList size + 1.
	nonMetaClass allSubclassesWithLevelDo:
		[:aClass :level |
		stab := ''.  1 to: level do: [:i | stab := stab , '  '].
		classList add: tab , stab , aClass name]
	 	startingLevel: 0.
	self classListIndex: index! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875250 overrides: 50607823!
classList

	classList := classList select: [:each | Smalltalk includesKey: each withoutLeadingBlanks asSymbol].
	^ classList! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875210!
updateAfterClassChange
	"It is possible that some the classes comprising the hierarchy have changed, so reinitialize the entire browser."

	(centralClass notNil and: [centralClass isObsolete not])
		ifTrue: [self initHierarchyForClass: centralClass]! !
!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875270!
for: aClass selector: aSymbol
	"Open a new HierarchyBrowser on the given class"
	|  newBrowser |
	newBrowser := HierarchyBrowser new initHierarchyForClass: aClass.
	newBrowser setSelector: aSymbol.
	^newBrowser! !
!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16875263!
for: aClass
	"Open a new HierarchyBrowser on the given class"
	^HierarchyBrowser new initHierarchyForClass: aClass! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895358 overrides: 50608529!
contentsSelection
	"Return the interval of text in the search pane to select when I set the pane's contents"

	^ #all 		"all of it"! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895339!
selectorListIndex
	"Answer the selectorListIndex"

	selectedSelector ifNil: [ ^ 0 ].
	^self selectorList indexOf: selectedSelector! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895365 overrides: 16898623!
initialize
	super initialize.
	searchString := ''! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895369 overrides: 16898550!
labelString
	^ 'Message names containing "', searchString asLowercase, '"'! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895290!
searchString
	"Answer the current searchString"

	^ searchString! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895258!
computeSelectorListFromSearchString
	"Compute selector list from search string"
	| sorted |
	sorted := SortedCollection sortBlock: [ :x :y |
		x asLowercase <= y asLowercase ].
	(searchString findBetweenSubStrs: ';') do: [ :selPat | | raw n m |
		selPat notEmpty ifTrue: [
			(selPat first = $" and: [
				selPat last = $" and: [ selPat size > 2 ]])
				ifTrue: [
					Symbol
						hasInterned:
							(selPat
								copyFrom: 2
								to: selPat size - 1)
						ifTrue: [ :sym |
							sorted add: sym ]]
				ifFalse: [
					raw := ((n := selPat occurrencesOf: $*) > 0 | ((m := selPat occurrencesOf: $#) > 0) and: [ selPat size > (n + m) ])
						ifTrue: [ Symbol selectorsMatching: selPat ]
						ifFalse: [ Symbol selectorsContaining: selPat ].
					sorted addAll: raw ]]].
	selectorList := sorted asArray  select: [ :sym |
		(Smalltalk isThereAnImplementorOf: sym) or: [ Smalltalk isThereAReferenceTo: sym ]].
	^ selectorList.! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895306 overrides: 16897975!
messageList
	"Answer the receiver's message list, computing it if necessary. The way 
	to force a recomputation is to set the messageList to nil"
	messageList
		ifNil: [
			messageList := selectedSelector
				ifNil: [#()]
				ifNotNil: [
					Smalltalk allImplementorsOf: selectedSelector].
			self initializeMessageList: messageList.
			self messageListIndex: (messageList notEmpty
				ifTrue: [1]
				ifFalse: [0])
			].
	^ messageList! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895329!
selectorList
	"Answer the selectorList"

	selectorList ifNil: [
		self computeSelectorListFromSearchString.
		selectedSelector := selectorList isEmpty ifFalse: [ selectorList first ].
		messageList := nil ].
	^ selectorList! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895295!
searchString: aString
	"Take what the user typed and find all selectors containing it"

	searchString := aString asPlainString.
	self changed: #relabel.
	selectorList := nil.
	self changed: #selectorList.
	self changed: #messageList.
	^ true! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895374 overrides: 50588588!
editorClassFor: textGetter
	textGetter = #searchString ifTrue: [
		^SmalltalkEditor ].
	^super editorClassFor: textGetter! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895346!
selectorListIndex: anInteger 
	"Set the selectorListIndex as specified, and propagate consequences"

	selectedSelector := anInteger = 0 ifFalse: [ self selectorList at: anInteger ].
	anInteger = 0
		ifTrue: [^ self].
	messageList := nil.
	self changed: #selectorListIndex.
	self changed: #messageList! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895323 overrides: 16898037!
selectedMessageName
	"Answer the name of the currently selected message."
	^selectedSelector! !
!MessageNames methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16895381 overrides: 16898220!
selectedClassOrMetaClass
	"Answer the currently selected class (or metaclass).
	
	If no method is selected, try to interpret the selected message name
	as a class"
	
	^ super selectedClassOrMetaClass ifNil: [
		self selectedMessageName ifNotNil: [ :className | | mayBeClass |
			(mayBeClass := Smalltalk
				at: className ifAbsent: [^ nil ]) isBehavior
					ifTrue: [ mayBeClass ]
					ifFalse: [ mayBeClass class ] ] ].! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898161!
deleteFromMessageList: aMethodReference
	"Delete the given message from the receiver's message list"

	messageList := messageList copyWithout: aMethodReference! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898134!
sortBySelector
	"Sort the message-list by selector / class"
	
	messageList := messageList sort: [ :a :b |
		a methodSymbol == #Comment
			ifTrue: [ true ]
			ifFalse: [
				b methodSymbol == #Comment
					ifTrue: [ false ]
					ifFalse: [
						a methodSymbol = b methodSymbol
							ifTrue: [
								a classSymbol = b classSymbol
									ifTrue: [ a classIsMeta ]
									ifFalse: [ a classSymbol < b classSymbol ]]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
		].
	messageList do: [ :each | each prefixStringVersionWith: each methodSymbol ].
	self changed: #messageList! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898500 overrides: 50607622!
canShowMultipleMessageCategories
	"Answer whether the receiver is capable of showing multiple message categories"

	^ false! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898313!
filterToCurrentAuthor
	"Filter down only to messages with my initials as most recent author"

	| myInitials aMethod aTimeStamp |
	(myInitials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].
	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:			
				[aMethod := aClass compiledMethodAt: aSelector ifAbsent: nil.
				aMethod notNil and:
					[(aTimeStamp := aMethod timeStamp) notNil and:
						[aTimeStamp beginsWith: myInitials]]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16897951!
addMethodReference: aMethodReference
	"Append a aMethodReference to the list.  Select the new item."

	messageList add: aMethodReference.
	self changed: #messageList.
	self messageListIndex: messageList size! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16897969!
growable
	"Answer whether the receiver is capable of growing/shrinking dynamically"

	^ true! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898001!
removeMessageFromBrowserKeepingLabel

	selectedMessage ifNil: [ ^nil ].
	self deleteFromMessageList: self selection.
	self reformulateList.
! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898169 overrides: 50607658!
methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898203 overrides: 50606364!
metaClassIndicated
	"Answer the boolean flag that indicates whether
	this is a class method."

	^ self selectedClassOrMetaClass isMeta! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898087!
sortByClassName
	"Sort the message-list by class / selector"
	
	messageList := messageList sort: [ :a :b |
		a classSymbol = b classSymbol
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [
								a classIsMeta = b classIsMeta
									ifTrue: [ a methodSymbol < b methodSymbol ]
									ifFalse: [ a classIsMeta ]	]]]
			ifFalse: [ a classSymbol < b classSymbol ]
		].
	messageList do: [ :each | each removeStringVersionPrefix ].
	self changed: #messageList! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898566!
autoHighlightAllOccurrences
	"Should also highlight any and all occurrences of the string?"

	^ autoHighlightAllOccurrences.! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898463!
filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) notNil and:
							[aMethod hasLiteralThorough: aSymbol]]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16897960!
addMethodReference: aMethodReferenceToAdd ifIncluded: aBlockClosure

	(messageList includes: aMethodReferenceToAdd)
		ifTrue: aBlockClosure
		ifFalse: [ self addMethodReference: aMethodReferenceToAdd ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898210 overrides: 50606449!
selectedClass 
	"Return the base class for the current selection.  1/17/96 sw fixed up so that it doesn't fall into a debugger in a msg browser that has no message selected"

	^ self selectedClassOrMetaClass
		ifNotNil: [ :c | c theNonMetaClass]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898390!
filterToMessagesWithoutPriorVersions
	"Filter down only to messages which have no prior version stored"

	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:
				[(self class isPseudoSelector: aSelector) not and:
					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) <= 1]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898623 overrides: 50606505!
initialize

	super initialize.
	shouldAutoHighlight := false.! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898550 overrides: 50606511!
labelString
	^'Filtered: [',
		messageList size printString,
		']'.! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898588!
justDidAutoHighlight
	"Don't do autoHighlight unless accepted contents are updated."
	shouldAutoHighlight := false! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898579!
autoHighlightString: aString allOccurrences: aBoolean
	"Set the string to be automatically highlighted."

	shouldAutoHighlight := true.
	autoHighlightString := aString.
	autoHighlightAllOccurrences := aBoolean.! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898431!
filterToNotImplementorsOf
	"Filter the receiver's list down to only those items whose selector is NOT one solicited from the user."

	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector |
						aSelector ~~ aSymbol]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898363!
filterToMessagesInSourcesFile
	"Filter down only to messages whose source code resides in the .sources file."

	| cm |
	self filterFrom: [:aClass :aSelector |
		(aClass notNil and: [aSelector notNil]) and:
			[(self class isPseudoSelector: aSelector) not and:
				[(cm := aClass compiledMethodAt: aSelector ifAbsent: nil) notNil and:
					[cm fileIndex = 1]]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16897994 overrides: 50608015!
removeMessageFromBrowser
	"Remove the selected message from the browser."

	self removeMessageFromBrowserKeepingLabel.
	self changed: #relabel! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898507 overrides: 50606618!
contents: input notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| codeString category selector class oldSelector |
	codeString := input string.
	self okayToAccept ifFalse: [^ false].
	selectedMessage ifNil: [^ false].
	class := selectedMessage actualClass.
	oldSelector := selectedMessage methodSymbol.
	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue: [
		oldSelector == #Comment ifTrue: [
			class comment: codeString stamp: Utilities changeStamp.
			self triggerEvent: #annotationChanged.
 			self changed: #clearUserEdits.
			^ false].
		oldSelector == #Definition ifTrue: [
			Compiler
				evaluate: codeString
				notifying: aRequestor
				logged: true.
			self changed: #clearUserEdits.
 			^ false]].
	"Normal method accept"
	category := class organization categoryOfElement: oldSelector.
	selector := class compile: codeString
				classified: category
				notifying: aRequestor.
	selector
		ifNil: [^ false].
	selector == oldSelector ifFalse: [
		self reformulateListNoting: selector].
	shouldAutoHighlight := true.
	self triggerEvent: #annotationChanged.
	^ true! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898412!
filterToNotCurrentAuthor
	"Filter down only to messages not stamped with my initials"

	| myInitials aMethod aTimeStamp |
	(myInitials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].
	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:			
				[aMethod := aClass compiledMethodAt: aSelector ifAbsent: nil.
				aMethod notNil and:
					[(aTimeStamp := aMethod timeStamp) isNil or:
						[(aTimeStamp beginsWith: myInitials) not]]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898573!
autoHighlightString
	"Return the string to be automatically highlighted."

	^ autoHighlightString.! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898184 overrides: 50606788!
removeMessage
	"Remove the selected message from the system. 1/15/96 sw"
	| messageName confirmation |
	selectedMessage ifNil: [ ^self ].
	messageName := self selectedMessageName.
	confirmation := Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.
	confirmation = 3
		ifTrue: [^ self].
	self selectedClassOrMetaClass removeSelector: messageName.
	self deleteFromMessageList: self selection.
	self reformulateList.
	confirmation = 2
		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898293!
filterToAnyChangeSet
	"Filter down only to messages present in ANY change set"

	self filterFrom: [ :aClass :aSelector |
		ChangeSet doesAnyChangeSetHaveClass: aClass andSelector: aSelector ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898257!
selection
	"Answer the item in the list that is currently selected, or nil if no selection is present"

	^ selectedMessage! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898332!
filterToImplementorsOf
	"Filter the receiver's list down to only those items with a given selector."

	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector |
						aSelector == aSymbol]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898220 overrides: 50606858!
selectedClassOrMetaClass
	"Answer the currently selected class (or metaclass)."

	^selectedMessage ifNotNil: [ :methodReference | methodReference actualClass ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898037 overrides: 50608166!
selectedMessageName
	"Answer the name of the currently selected message."

	^selectedMessage ifNotNil: [ :methodReference | methodReference methodSymbol ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898491!
filterToUnsentMessages
	"Filter the receiver's list down to only those items which have no  
	senders"
	self filterFrom: [ :aClass :aSelector |
		(Smalltalk isThereAReferenceTo: aSelector) not ].! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898155!
sortReverse
	"Reverse the current sort order"
	messageList := messageList reversed .
	self changed: #messageList! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898346!
filterToMessagesInChangesFile
	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."

	| cm |
	self filterFrom:
		[:aClass :aSelector |
			aClass notNil and: [aSelector notNil and:
				[(self class isPseudoSelector: aSelector) not and:
					[(cm := aClass compiledMethodAt: aSelector ifAbsent: nil) notNil and:
					[cm fileIndex ~= 1]]]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898594!
messageSendsRangesOf: aSelector

	^ selectedMessage 
		ifNil: [ #() ]
		ifNotNil: [selectedMessage messageSendsRangesOf: aSelector ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16897975 overrides: 50606933!
messageList
	"Answer the current list of messages."

	^messageList! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898555!
reformulateListNoting: newSelector
	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"

	^ self reformulateList! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898008 overrides: 50608400!
selectedMessage
	"Answer the source method for the currently selected message."

	| class selector |
	selectedMessage ifNil: [^ 'Class vanished'].
	
	class := selectedMessage actualClass.
	selector := selectedMessage methodSymbol.
	selector ifNil: [ ^'prims'].

	selector first isUppercase ifTrue: [
		selector == #Comment ifTrue: [
			currentCompiledMethod := class organization commentRemoteStr.
			^ class comment ].
		selector == #Definition ifTrue: [
			^ class definition ].].

	(class notNil and: [ class includesSelector: selector]) ifFalse: [
		currentCompiledMethod := nil.
		^ 'Missing'].

	self showingDecompile ifTrue: [
		^ self decompiledSource ].

	currentCompiledMethod := class compiledMethodAt: selector ifAbsent: nil.
	self showingDocumentation ifTrue: [
		^ self commentContents ].

	^self sourceStringPrettifiedAndDiffed! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898302!
filterToCommentedMethods
	"Filter the receiver's list down to only those items which have comments"

	self filterFrom:
		[:aClass :aSelector |
			(aClass selectors includes: aSelector) and:
						[(aClass firstPrecodeCommentFor: aSelector) isEmptyOrNil not]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898446!
filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol |
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) isNil or:
							[(aMethod hasLiteralThorough: aSymbol) not]]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898045!
sortByClassHierarchy
	"Sort the message-list by class / selector. List classes in hierarchical order."
	
	| aClass bClass classes classesAndPositions i |

	classes := Set new.
	messageList do: [ :methodReference |
		methodReference actualClass ifNotNil: [ :actualClass | classes add: actualClass ]].
	classesAndPositions := Dictionary new.
	i := 1.
	Smalltalk hierarchySorted: classes do: [ :each |
		classesAndPositions at: each put: i.
		i := i + 1 ].
	
	messageList := messageList sort: [ :a :b |
		(a classSymbol = b classSymbol and: [ b classIsMeta = b classIsMeta ])
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
			ifFalse: [
				aClass := a actualClass.
				bClass := b actualClass.
				aClass isNil == bClass isNil
					ifTrue: [
						aClass isNil
							ifTrue: [a classSymbol < b classSymbol]
							ifFalse: [(classesAndPositions at: aClass) < (classesAndPositions at: bClass)]]
					ifFalse: [aClass isNil]]].
	messageList do: [ :each |
		each indentLevel:
			(each actualClass theNonMetaClass allSuperclasses select: [ :c |
				classesAndPositions includesKey: c ]) size ].
	self changed: #messageList.! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898403!
filterToNotAnyChangeSet
	"Filter down only to messages present in NO change set"

	self filterFrom: [ :aClass :aSelector |
		(ChangeSet doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898250!
initializeMessageList: anArray

	messageList := anArray.
	messageList isEmpty
		ifTrue: [ selectedMessage := nil ]
		ifFalse: [ self messageListIndex: 1 ]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898377!
filterToMessagesWithPriorVersions
	"Filter down only to messages which have at least one prior version"

	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:
				[(self class isPseudoSelector: aSelector) not and:
					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1]]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898228 overrides: 50608541!
selectedMessageCategoryName 
	"Answer the name of the selected message category or nil."
	"Ver si esta implementacion loca se usa. Si no se usa, eliminar todas (intentarlo!!)"
	selectedMessage ifNil: [ ^nil ].
	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898281!
filterFrom: aBlock
	"Filter the receiver's list down to only those items that satisfy aBlock, which takes a class an a selector as its arguments."
	
	self setFilteredList: (messageList select: [ :methodReference |
		aBlock
			value: methodReference actualClass
			value: methodReference methodSymbol ])! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898264!
setFilteredList: newList
	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"

	newList isEmpty
		ifTrue: [
			^ self inform: 'Nothing would be left in the list if you did that'].
	newList size = messageList size
		ifTrue: [
			^ self inform: 'That leaves the list unchanged'].
	self initializeMessageList: newList.
	self changed: #relabel! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898608 overrides: 50607319!
shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [ ^false ].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898480!
filterToUncommentedMethods
	"Filter the receiver's list down to only those items which lack comments"

	self filterFrom:
		[:aClass :aSelector |
			(aClass selectors includes: aSelector) and:
						[(aClass firstPrecodeCommentFor: aSelector) isEmptyOrNil]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898601 overrides: 50597714!
shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^shouldAutoHighlight! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898240 overrides: 50608704!
acceptedStringOrText
	"Answer the contents of the receiver"
	^selectedMessage
		ifNil: [
			currentCompiledMethod := nil.
			'']
		ifNotNil: [
			self showingByteCodes
				ifTrue: [ self selectedBytecodes ]
				ifFalse: [ self selectedMessage ]]! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898108!
sortByDate
	"Sort the message-list by date of time-stamp"

	| assocs aCompiledMethod aDate inOrder |
	assocs := messageList collect: [ :aRef |
		aDate := aRef methodSymbol == #Comment
			ifTrue: [
				aRef actualClass organization dateCommentLastSubmitted]
			ifFalse: [
				aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.
				aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].
		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"
	inOrder := assocs asArray sort: [ :a :b | a value < b value].

	inOrder do: [ :each | each key prefixStringVersionWith: each value yyyymmdd ].
	messageList := inOrder collect: [ :assoc | assoc key ].
	self changed: #messageList! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16897980 overrides: 50608765!
messageListIndex: anInteger

	"Set the index of the selected item to be anInteger."

	| list |
	
	list := self messageList.
	selectedMessage := (list isInBounds: anInteger) ifTrue: [ list at: anInteger ].
	shouldAutoHighlight := true.
	self changed: #messageListIndex.	 "update my selection"
	self editSelection: #editMessage.
	self acceptedContentsChanged! !
!MessageSet methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898174 overrides: 50608787!
reformulateList
	"The receiver's messageList has been changed; rebuild it"
	super reformulateList.
	self initializeMessageList: messageList.
	self changed: #messageList.
	self changed: #messageListIndex.
	self acceptedContentsChanged! !
!MessageSet class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898641!
isPseudoSelector: aSelector
	"Answer whether the given selector is a special marker"

	^ #(Comment Definition) statePointsTo: aSelector! !
!MessageSet class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16898634!
messageList: anArray 
	"Answer an instance of me with message list anArray."

	^self new initializeMessageList: anArray! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902223!
classIsMeta

	^classIsMeta! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902285!
prefixStringVersionWith: aString

	self removeStringVersionPrefix.
	stringVersion := '[', aString, '] - ', stringVersion.! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902423!
messageSendsRangesOf: aSentSelector

	| compiledMethod |
	
	compiledMethod := self compiledMethodIfAbsent: [ ^#() ].
	^compiledMethod messageSendsRangesOf: aSentSelector ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902258!
selector

	^methodSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902419!
methodClass

	^self actualClass ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507184!
liveTypingAutoCompleterDocumentation
	
	^self compiledMethod liveTypingAutoCompleterDocumentation! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507208!
sourceCodeRange
	
	^#()! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902431!
hasVariableBindingTo: aClass

	^(self compiledMethodIfAbsent: [ ^false ]) hasVariableBindingTo: aClass
! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902437!
isMessageListTitle

	^(self actualClass isKindOf: Object) and: [methodSymbol first = $_]
! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902354 overrides: 16913610!
= anotherMethodReference 
	"Answer whether the receiver and the argument represent the 
	same object."
	self == anotherMethodReference ifTrue: [ ^ true ].
	^ self species == anotherMethodReference species
		and: [self classSymbol == anotherMethodReference classSymbol]
		and: [self classIsMeta == anotherMethodReference classIsMeta]
		and: [self methodSymbol == anotherMethodReference methodSymbol]! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902244!
isValid
	"Answer whether the receiver represents a current selector or Comment"

	| aClass |
	(aClass := self actualClass) ifNil: [^ false].
	^ (aClass includesSelector: methodSymbol) or:
		[methodSymbol == #Comment]! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902369 overrides: 16913626!
hash
	"Answer a SmallInteger whose value is related to the receiver's  
	identity."
	^ (self species hash bitXor: self classSymbol hash)
		bitXor: self methodSymbol hash! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902209!
actualClassIfAbsent: anAbsentBlock 

	^Smalltalk 
		at: classSymbol 
		ifPresent: [ :actualClass |
			classIsMeta
				ifTrue: [ actualClass class ]
				ifFalse: [ actualClass ] ]
		ifAbsent: anAbsentBlock 
! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902406 overrides: 16914834!
printOn: aStream
	"Print the receiver on a stream"

	super printOn: aStream.
	aStream space.
	self printClassAndSelectorOn: aStream! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902269!
sourceCodeIfAbsent: aBlock

	| actualClass |

	actualClass := self actualClassIfAbsent: [ ^aBlock value ].
	^actualClass sourceCodeAt: methodSymbol ifAbsent: aBlock! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902303!
setClass: aClass methodSymbol: methodSym stringVersion: aString

	self
		setClassSymbol: aClass theNonMetaClass name
		classIsMeta: aClass isMeta
		methodSymbol: methodSym
		stringVersion: aString! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902330!
stringVersion

	^stringVersion! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902454!
notOptimizedMethodNode

	^self compiledMethod notOptimizedMethodNode! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507165!
doesOnlySurelySend: aCompiledMethod 
	
	^self compiledMethod doesOnlySurelySend: aCompiledMethod ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902218!
category
	^ self actualClass organization categoryOfElement: methodSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902397!
printClassAndSelectorOn: aStream
		
	aStream nextPutAll: classSymbol.
	classIsMeta ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: '>>#';
		nextPutAll: methodSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902254!
methodSymbol

	^methodSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507198!
rangesOf: aSentSelector whenSendTo: aReceiverTypes

	| compiledMethod |
	
	compiledMethod := self compiledMethodIfAbsent: [ ^#() ].
	^compiledMethod sureMessageSendsRangesOf: aSentSelector whenSendTo: aReceiverTypes
! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507171!
isAnnotatingTypes
	
	^self compiledMethod isAnnotatingTypes ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902377!
updateReferencesTo: oldClassName toBe: newClassName

	| src ts cm |
	src := self actualClass sourceCodeAt: methodSymbol.
	src := src copyReplaceAll: oldClassName with: newClassName.
	cm := self actualClass compiledMethodAt: methodSymbol.
	ts := cm timeStamp.
	ts = '' ifTrue: [ts := nil].
	self actualClass 
		compile: src
		classified: ClassOrganizer default
		withStamp: ts 
		notifying: nil.

	^true
! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902205!
actualClass 

	^self actualClassIfAbsent: [ nil ]! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507153!
actualSendersOf: aCompiledMethod 
	
	^self compiledMethod actualSendersOf: aCompiledMethod ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507176!
isPossibleSender

	^false! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507180!
isPrimitive
	
	^self compiledMethod isPrimitive ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902322!
setStandardClass: aClass methodSymbol: methodSym

	self
		setClass: aClass
		methodSymbol: methodSym
		stringVersion: aClass name , ' ' , methodSym! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902413!
dynamicTypingAutoCompleterDocumentation

	^self compiledMethod dynamicTypingAutoCompleterDocumentation ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902312!
setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 

	classSymbol := classSym asSymbol.
	classIsMeta := isMeta.
	methodSymbol := methodSym asSymbol.
	stringVersion := aString! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507190!
methodReference
	
	^self! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902227!
classSymbol

	^classSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507194!
primitive
	
	^self compiledMethod primitive! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902231!
compiledMethod
	^ self actualClass compiledMethodAt: methodSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902450!
methodNode
	
	^self compiledMethod methodNode! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902262!
sourceCode

	^ (self actualClassIfAbsent: [ self error: self class classDoesNotExistErrorMessage ]) 
		sourceCodeAt: methodSymbol! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507212!
stringVersion: aString

	stringVersion := aString ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507217!
typeCheck
	
	^self compiledMethod typeCheck ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902443!
referencesParameterAt: parameterIndex

	^(self compiledMethodIfAbsent: [ ^false ]) referencesParameterAt: parameterIndex ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902392 overrides: 16914685!
displayStringOrText
	"To be used in the UI"

	^stringVersion! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50507159!
classAndSelector

	^String streamContents: [:stream | self printClassAndSelectorOn: stream ]! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902334!
<= anotherMethodReference
	"By default, sort by class"

	^self classSymbol = anotherMethodReference classSymbol
		ifTrue: [
			self methodSymbol == #Comment
				ifTrue: [ true ]
				ifFalse: [
					anotherMethodReference methodSymbol == #Comment
						ifTrue: [ false ]
						ifFalse: [
							self classIsMeta = anotherMethodReference classIsMeta
								ifTrue: [ self methodSymbol < anotherMethodReference methodSymbol ]
								ifFalse: [ self classIsMeta ]	]]]
		ifFalse: [ self classSymbol < anotherMethodReference classSymbol ]! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902292!
removeStringVersionPrefix
	| i prefixCoda |
	prefixCoda := '] - '.
	i := stringVersion findString: prefixCoda.
	i = 0 ifFalse: [stringVersion := stringVersion copyFrom: i + prefixCoda size to: stringVersion size].
	stringVersion := stringVersion withoutLeadingBlanks! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 50515873!
recalculateStringVersionForDenotativeObject
	
	stringVersion := classSymbol asString,' ', methodSymbol ! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902277!
indentLevel: anInteger
	self removeStringVersionPrefix.
	stringVersion := (String streamContents: [:aStream| anInteger timesRepeat: [aStream nextPutAll: '    ']]), stringVersion! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902236!
compiledMethodIfAbsent: ifAbsentBlock

	^ self actualClass
		ifNil: ifAbsentBlock
		ifNotNil: [ :aClass | aClass compiledMethodAt: methodSymbol ifAbsent: ifAbsentBlock ] ! !
!MethodReference class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902471!
classSymbol: aClassName classIsMeta: isMeta methodSymbol: aSelector 
	
	^self new setClassSymbol: aClassName classIsMeta: isMeta methodSymbol: aSelector stringVersion: ''.! !
!MethodReference class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902487!
classDoesNotExistErrorMessage

	^'Class does not exist'! !
!MethodReference class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902480!
method: aCompiledMethod
	^self class: aCompiledMethod methodClass selector: aCompiledMethod selector! !
!MethodReference class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16902465!
class: aClass selector: aSelector
	^ self new setStandardClass: aClass methodSymbol: aSelector! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932678 overrides: 50609408!
initialize
	super initialize.
	exclude := OrderedCollection new! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932569 overrides: 50609294!
growable
	"Answer whether the receiver is subject to manual additions and deletions"

	^ false! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932575 overrides: 50609414!
labelString
	"Answer the string for the window title"
	
	^ 'Protocol for: ', baseClass name, ' up to: ', (selectedName ifNil: [ ProtoObject name asPlainString ])! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932670!
selectiveClassListIndex: anObject
	"Set the value of selectiveClassListIndex"

	selectiveClassListIndex := anObject.
	self protocolFor: selectiveClassListIndex
! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932583!
hierarchyForClass: aClass
	"Set the class hierarchy for the list pane"
	| tab |

	selectiveClassList := OrderedCollection new.
	tab := ''.
	aClass withAllSuperclasses reverse do: [:ea | 
		selectiveClassList add: tab , ea name.
		tab := tab , '  '].
	self classListIndex: 0! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932628!
onSubProtocolOf: aClass
	"Initialize with the entire protocol for the class, aClass,
		but excluding those inherited from Object."
	| selectors |
	selectors := Set new.
	(aClass withAllSuperclassesPreviousTo: Object)
		do: [ :each | selectors addAll: each selectors ].
	self
		initListFrom: selectors asArray sort
		highlighting: aClass.! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932656!
selectiveClassList
	"Answer the value of selectiveClassList"

	^ selectiveClassList! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932594!
initListFrom: selectorCollection highlighting: aClass 
	"Make up the messageList with items from aClass in boldface."
	| defClass item |

	messageList := OrderedCollection new.
	selectorCollection do: [ :selector |  
		defClass := aClass whichClassIncludesSelector: selector.
		item := selector, '     (' , defClass name , ')'.
		defClass == aClass ifTrue: [item := item asText allBold].
		messageList add: (
			MethodReference new
				setClass: defClass 
				methodSymbol: selector 
				stringVersion: item)].
	self hierarchyForClass: (baseClass := aClass)! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932641!
protocolFor: anIndex
	"Change the listed protocol"

	exclude := OrderedCollection new.
	anIndex > 0
		ifTrue: [
			selectedName := (selectiveClassList at: anIndex) withBlanksTrimmed.
			(1 to: anIndex - 1) do: [:ix |
				exclude addLast: (selectiveClassList at: ix) withBlanksTrimmed]]
		ifFalse: [
			selectedName := nil.
			].
	self on: baseClass.
	self changed: #relabel! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932662!
selectiveClassListIndex
	"Answer the value of selectiveClassListIndex"

	selectiveClassListIndex ifNil: [selectiveClassListIndex := 0].
	^ selectiveClassListIndex! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:51' prior: 16932614!
on: aClass
	"Initialize the protocol for the class, aClass."
	"Optionally, the upper part of the protocol is excluded."
	| selectors |
	
	selectors := Set new.
	aClass withAllSuperclasses do: [ :each |
		(exclude includes: each name) ifFalse: [selectors addAll: each selectors]].
	self
		initListFrom: selectors asArray sort
		highlighting: aClass! !
!ProtocolBrowser methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16932683 overrides: 50609600!
selectedClassOrMetaClass
	"Answer the class or metaclass that is currently selected. 
	Answer base if no selection exists."
	| className |
	className := (self selectiveClassListIndex = 0) 
					ifTrue:  [self selectiveClassList last]
					ifFalse:  [self selectiveClassList at: self selectiveClassListIndex].
	^ Smalltalk at: ((className findTokens: ' ') first asSymbol)! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16962412 overrides: 16892224!
canBeDragged
	^ false! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16962428 overrides: 16892216!
asString
	^ itemName! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16962422!
setItem: anObject name: aString model: aModel
	item := anObject.
	model := aModel.
	itemName := aString! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16962416 overrides: 16892248!
isAncestorOf: aString
	^ (item includes: $-) not and: [aString beginsWith: item, '-']! !
!SystemCategoryWrapper methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16962398 overrides: 16892228!
contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix := item, '-'.
	subcategories := OrderedCollection new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each allButFirst: prefix size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !
!SystemCategoryWrapper class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 13:38:52' prior: 16962438!
with: anObject name: aString model: aModel
	^ self new  setItem: anObject name: aString model: aModel! !

----QUIT----(12 October 2024 14:14:11) CuisUniversity-6169.image priorSource: 7852974!

----STARTUP---- (12 October 2024 16:07:45) as C:\Users\juli_\Tesis\TO_UPLOAD\windows64\CuisUniversity-6169.image!


!testRun: #ManyMethodsTypeCheckerDragonTest #test01ManyMethodsCanBeTypeChecked stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test02ClassesCanBeTypeChecked stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test04AlertsDetectIfNone stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test05AlertsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test07ErrorsDetectIfNone stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test10WarningsDetectIfNone stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test15HasErrorsOrWarnings stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test14TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test17TypeCastManyVariablesNestedRejectionsRejectsEachLevelCastedTypeForEachVariable stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/12/2024 16:08:07'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:08:08'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:08:08'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/12/2024 16:08:08'!
PASSED!

!testRun: #FlowGraphCreationTest #test01onVarToVarAssigmentAssignorFlowsToAssignee stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test02ThereIsAlwaysANodeForReturnValue stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test03onAssigmentToAssigmentAllVarsAreLinked stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test04onVarReturnItFlowsToReturnNode stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test05CanTrackAMethodThroughMessageSends stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test06TrackedMethodIsLinkedToVarsOnAssigment stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test07CanTrackMultipleMethodThroughMessageSends stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test08TrackedMethodsAreLinkedToVarsOnAssigment stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test09InstVarsAreAlwaysAddedToGraph stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #FlowGraphCreationTest #test10WhenVarIsConnectedToReturnValueItsNeighborsAreAlsoConnected stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test01CanAddAGenericType stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test02GenericsDoesNotRepeat stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test03GenericsCannotBeAlteredFromOuterScope stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test04CanSaveASelectorForAGeneric stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test05TracedMethodsCanBeRecovered stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test06TracedMethodsCantBeModifiedExternally stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test07ATracedMethodCanBeDeleted stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test08AGenericCanBeDeleted stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test09CanSaveAGetterSelectorForAGeneric stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test10GetterSelectorsCantBeModifiedExternally stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test11CanStoreAndRetrieveTracedMethodRefs stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test12CanStoreAndRetrieveMultipleTracedMethodRefs stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test13AnalysisCanBeInitializedRecursively stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test14RecursiveAnalysisHasRecursiveTracedMethods stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test15GraphsAreDeletedWhenAllAnalysisFinish stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test16CanStoreGenericTypeConstructors stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test17SaveASelectorForAGenericWithMultipleParams stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #GAStorageTest #test18AGetterMethodCanBeDeleted stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #InferenceTest #test01GenericClassesAreReplacedByGenericTypeInstances stamp: 'JFGO 10/12/2024 16:08:12'!
PASSED!

!testRun: #InferenceTest #test02GenericClassesAreMergedWithTheirGenericTypes stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test03LiteralCollectionOneLiteralElement stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test04LiteralCollectionLiteralElementsOfDifferentType stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test05LiteralCollectionElementsFromVariable stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test06LiteralCollectionElementsFromMethodCall stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test07LiteralCollectionElementsFromMethodCallWithArgumentsTypesFromContext stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test08LiteralCollectionElementsFromRecursiveMethod stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test09LiteralCollectionFlowingInMultipleVariables stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test10LiteralCollectionFlowingInMultipleVariablesArgumentInMethod stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test11LiteralCollectionFlowingInMultipleVariablesEachReceivingMessages stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test12LiteralCollectionFlowingInMultipleVariablesEachReceivingMessagesBeforeAndAfterAssigment stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test13LiteralCollectionFlowingInMultipleVariablesArgumentInMultipleMethod stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test14LiteralCollectionFlowingInMultipleVariablesMultipleArgumentsInMethod stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test15LiteralCollectionFlowingToNonSelfMethod stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test16LiteralCollectionFlowingToSuperMethod stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test17GenericTypeReturningParameterFromGetter stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test18MethodReturningGenericType stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test19InstanceVariableUsedOnlyWithinCurrentClass stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test20InstanceVariableExposedByGetterAssignToVariable stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test21InstanceVariableExposedByMultipleGettersAssignToVariable stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test22InstanceVariableMessageSendsToGetters stamp: 'JFGO 10/12/2024 16:08:13'!
PASSED!

!testRun: #InferenceTest #test23InstanceVariableGettersUsedAsArguments stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test24InstanceVariableFlowingToOtherVariables stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test25CollectionContainingAnotherCollection stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test26CollectionContainingMultipleCollections stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test27CollectionAssignedFromMethodCallAndNotUsedAfter stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test28ReturnResultOfMethodCall stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test29MethodCallOnMultipleClassesWithSameProtocol stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test30MethodCallInsideGenericClasses stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test31CascadeMessageSends stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test32ArgumentCollectsInfoFromCalls stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test33ArgumentCollectsInfoFromCallsAndCurrentMethod stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test34GenericTypeConstructorFromArguments stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test35GenericTypeConstructorFromArgumentParameters stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test36TraceReturnValueWhenMethodReturnsArgument stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test37AddingFromOtherCollectionParameters stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test38CollectionFromLiteralNode stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test39CollectionWithMultipleParameters stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test40GetterForGenericWithMultipleParameters stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test41ArgumentCollectsInfoFromCallsWithMultipleParameters stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test42ArgumentCollectsInfoFromCallsAndCurrentMethodWithMultipleParameters stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test43ReturnTypeOfSetterMethodIsLastArgument stamp: 'JFGO 10/12/2024 16:08:14'!
PASSED!

!testRun: #InferenceTest #test44CollectionIsDetectedWhenReturnedFromMethodAndAssignedToVariable stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #InferenceTest #test45ArgumentCollectsInfoCurrentMethodWithNoCallers stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test001SameType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test002DifferentType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test003SameHierarchy stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test004CommonSupertypeIsObject stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test005SameGeneric stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test006SameGenericDifferentOrder stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test007GenericsHandleSystemTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test008NestedGenerics stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test009GenericSupertypeWithSameGenerics stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test010GenericSupertypeWithCommonGenerics stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test011FixedAgainstGenericType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test012FixedAgainstGenericTypeInList stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test013GenericAgainstFixedTypeInList stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test014NestedGenerics stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test015NestedGenericsWithDifferentDepth stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test016EmptyTypeAgainstSelf stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test017EmptyTypeAgainstFixedType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test018EmptyTypeAgainstGenericType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test019UnionTypeCollectsTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test020UnionTypeAgainstSelf stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test021UnionTypeAgainstInnerElement stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test022ConvertionAccordingToReceiver stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test023ConvertionToArray stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test024EnumeratingClassTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test025EnumeratingLiveTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #LiveTypeTests #test026EnumeratingLiveAndClassTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test001EmptyRawTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test002AllClasses stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test003AnEmptyCollectionsContentType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test004ClassesAndCollectionsContentType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test005ACollectionsContentTypeWithTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test006SeveralCollectionsContentTypesWithTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test007CreateFixedType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test008CreateEmptyType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test009CreateGenericType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test010CreateGenericNestedType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test011CreateGenericNonEmptyType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #RawToLiveTypesAdapterTests #test012CreateGenericMultipleNestedType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test001TooltipForEmptyCollection stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test002TooltipForSingleItemCollection stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test003TooltipForTwoItemsWhenSupertypeIsObject stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test004TooltipForTwoItemsWithCommonSupertype stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test005TooltipForVariableWithCollectionAndSomeOtherType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test006TooltipForMergedCollections stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test007TooltipForSameCollectionsWithSameTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test008TooltipForSameCollectionsWithCommonSuperTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test009TooltipForSameCollectionsWithNoSuperTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test010TooltipForCommonSuperCollectionsWithCommonSuperTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test011TooltipForNestedCollections stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test012TooltipForCommonSuperCollectionsWithNoSuperTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test013TooltipForCommonSuperCollectionsRepeatedWithNoSuperTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test014TooltipForCommonSuperCollectionsWithEmptyCollections stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test015TooltipForCommonSuperCollectionsWithAnEmptyCollection stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test016TooltipForCommonSuperCollectionsAndNoCollection stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test017TooltipForCommonSuperTypeAndNoCommonType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test018TooltipForCommonSuperCollectionsAndNoCollection stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test019TooltipForNestedCollectionsOneOfThemEmpty stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test020TooltipForNestedCollectionsBothSameTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test021TooltipForNestedCollectionsEachNoCommonInnerType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test022TooltipForNestedCommonSuperCollectionsNoCommonInnerType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test023TooltipForNestedNoCommonSupertype stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test024TooltipForNestedRepeatedTypeDifferentInners stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test025TooltipForNestedCommonTypesAndIntruder stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test026TooltipForNestedCommontTypesWithTwoLevelIntruder stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test027TooltipForAwfullyComplexInnerCollections stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test028TooltipOnlyOneType stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test029TooltipCommonSuperTypeSingleClasses stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test030TooltipNoTypes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test031TooltipNoCommonSuperTypeSingleClasses stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TooltipTests #test032TooltipForCollectionWithTwoParameters stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeFlowGraphTest #test01IsCreatedEmpty stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeFlowGraphTest #test02AddingANodeIncreasesTheirCount stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeFlowGraphTest #test03AddingAnEdgeIncreasesTheirCount stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeFlowGraphTest #test04CannotLinkInexistantNodes stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeFlowGraphTest #test05CanAccessNodesButCantDirectlyAddToResult stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeFlowGraphTest #test06CheckingConnectionOnAssociatedUndirectedGraph stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test001Empty stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test002Fixed stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test003GenericSingleValue stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test004MultipleFixed stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test005GenericMultipleValues stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test006MultipleFixedWithNoCommonSupertype stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test007MultipleGenerics stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test008GenericEmptyValue stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test009MultipleGenericsEmptyValue stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #TypeNodeTests #test010EmptyAndFixed stamp: 'JFGO 10/12/2024 16:08:15'!
PASSED!

!testRun: #ActualImplementorsTest #test01WhenIsImplementedOnlyInRootReturnsThatImplementorOnly stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test02ReturnsImplementorsOfSuperclasses stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test03IfNotImplementedInRootOrSuperclassesDoesNotIncludeSubclassesImplementations stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test04IncludesSubclassesImplementations stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test05DoesNotIncludeImplementorsOfSubclassesNotDefinedInSuperclass stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test06DoesNotIncludeImplementorsOfSiblingsWhenNotDefinedInSuperclass stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test07ReturnsAllSubclassesImplementorsOfTheHighestImplementorClass stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test08highestClassImplementingSelectorReturnsHighgestClass stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualImplementorsTest #test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test01SurelyRecognizeTypeSenderWhenSentToInstanceVariable stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test02SurelyRecognizeTypeSenderWhenSentToTemporaryVariable stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test03SurelyRecognizeTypeSenderInACollaboration stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test04RecognizeTypeSendersToInstancesOfSubClasses stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test05RecognizeTypeSendersToLiteralTrue stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test06RecognizeTypeSendersToLiteralFalse stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test07RecognizeTypeSendersToThisContext stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test08RecognizeTypeSendersToSelf stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test09RecognizeTypeSendersToSuper stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test09_01 stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test10RecognizeTypeSendersToSelfOfMessageImplementedInSuperclass stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test11RecognizeTypeSendersToReturnsOfMessageSend stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test12RecognizeTypeSendersOfChainedMessageSends stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test13RecognizeTypeSendersToReturnOfMessageSendNoMatterThePrecedence stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test14RecognizeTypeSendersToClasses stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test15RecognizeTypeSendersToVariablesReferencingClasses stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test16RecognizeTypeSendersToAnyLiteral stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test17CanRecognizePossibleTypeSenders stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test18RecognizeTypeSendersWhenReturnTypeIsSelfType stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test19RecognizeTypeSendersWhenReturnTypeIsClassType stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test20SurelySendWhenReceiverTypeIsSuperclassOfImplementorType stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test21ActualSendersWorksWithCascadeMessageSends stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!testRun: #ActualSendersTest #test22ActualSendersDoesNotHangWhenReceiverIsTempVarInMethodWithoutTypes stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:12'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12' prior: 50611649!
m3 | x | self m1: 1. false ifTrue: [ x m1 ]! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:12'!
m1!

!testRun: #AddParameterWithActualScopeTest #test01DoesNotChangePossibleMessageSendWhenInstructedToDoSo stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:12'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:12'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12'!
m3 | x | self m1: 1 m3: 3. false ifTrue: [ x m1: 1 m3: 3 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12'!
m1: p1 m2: p2 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:12' prior: 50611690!
m3 | x | self m1: 1 m2: 2 m3: 3. false ifTrue: [ x m1: 1 m3: 3 ]! !

!methodRemoval: ClassToAddParameter #m1:m3: stamp: 'JFGO 10/12/2024 16:09:12'!
m1: p1 m3: p3!

!testRun: #AddParameterWithActualScopeTest #test01_01_DoesNotChangePossibleMessageSendWhenInstructedToDoSoWithKeywordMessages stamp: 'JFGO 10/12/2024 16:09:12'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:13'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:13'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:13'!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!testRun: #AddParameterWithActualScopeTest #test02CanNotAddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'JFGO 10/12/2024 16:09:13'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:13'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:13'!
m1: p1 m3: p3! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:13'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:13'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1 m3: 3! !

!testRun: #AddParameterWithActualScopeTest #test02_01_CanNotAddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsForKeywordMessage stamp: 'JFGO 10/12/2024 16:09:13'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:14'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:14'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:14'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:14'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:14'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:14'!
m3 | x | x := ClassOfSender new. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:14'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:14' prior: 50611840!
m3 | x | x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:14'!
m1!

!testRun: #AddParameterWithActualScopeTest #test03AddParameterWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'JFGO 10/12/2024 16:09:14'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:15'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15' prior: 50611899!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:15'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:15'!
m1!

!testRun: #AddParameterWithActualScopeTest #test04AddParameterWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'JFGO 10/12/2024 16:09:15'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:15'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:15' prior: 50611964!
m3 | x y | x := self. y := ClassOfSender new. x m1: 1. y m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:15'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:15'!
m1!

!testRun: #AddParameterWithActualScopeTest #test05AddParameterInDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'JFGO 10/12/2024 16:09:15'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:16'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:16'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:16'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:16'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:16'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:16'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:16'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:16'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:16'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:16' prior: 50612029!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1: 1. y m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:16'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:16'!
m1!

!testRun: #AddParameterWithActualScopeTest #test06AddParameterInDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'JFGO 10/12/2024 16:09:16'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:17'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:17'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:17'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17' prior: 50612083!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1 ]! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:17'!
m1!

!testRun: #AddParameterWithActualScopeTest #test07AddParameterToPossibleMessageSendIfInstructedToDoSo stamp: 'JFGO 10/12/2024 16:09:17'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:17'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:17'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:17'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:17' prior: 50612131!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:18'!
m1!

!testRun: #AddParameterWithActualScopeTest #test08AddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'JFGO 10/12/2024 16:09:18'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:18'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:18'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:18'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:18'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:18'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:18'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:18'!
m3 self m1. ClassOfSender new m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:18'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:18' prior: 50612191!
m3 self m1: 1. ClassOfSender new m1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:18'!
m1!

!testRun: #AddParameterWithActualScopeTest #test09AddParameterOnlyToValidMessageSendWhenMoreSendsInSameMethod stamp: 'JFGO 10/12/2024 16:09:18'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:19'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:20'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:20'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20'!
m3 |x| self m1. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20' prior: 50612237!
m3 |x| self m1: 1. x m1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'JFGO 10/12/2024 16:09:20'!
m1!

!testRun: #AddParameterWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenAddingParameterToMethodWithSureAndPossibleSenders stamp: 'JFGO 10/12/2024 16:09:20'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:20'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:20'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:20'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:20'!
m3 | x | x := self. x := ClassOfSender new. x m1; printString! !

!testRun: #AddParameterWithActualScopeTest #test11CanNotAddParameterWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'JFGO 10/12/2024 16:09:20'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:21'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:21'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'JFGO 10/12/2024 16:09:21'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:21'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:21'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:21'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:21'!
m3 self m1: 1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:21'!
m1: p1 m2: p2 ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:21' prior: 50612339!
m3 self m1: 1 m2: 2! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'JFGO 10/12/2024 16:09:21'!
m1: p1!

!testRun: #AddParameterWithActualScopeTest #test13AddLastParameterCorrectly stamp: 'JFGO 10/12/2024 16:09:21'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:22'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddParameter stamp: 'JFGO 10/12/2024 16:09:22'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AdditionalMethodStateTest #test01topBlockTempsMapReturnsTheTempsMapOfTheMethod stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test02MethodWithNoParametersNoTemporariesAreInitializedCorrectly stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test03MethodWithOnlyOneArgumentAreInitializedCorrectly stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test04rawTypesOfInvalidVariableNameEvaluatesIfAbsentBlock stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test05MethodWithOnlyOneTempTwoArgumentsAreInitializedCorrectly stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test06MethodWithRemoveVectorVariablesAreInitializedCorrectly stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test07RemoteVectorRawTypesIsNilWhenMethodHasNoVariableInRemoteVector stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test08VariableRawTypesIsNilWhenMethodHasNoVariableButHasInRemoteVector stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #AdditionalMethodStateTest #test09CanGetRawTypesWhenMethodHasNoVariableButHasInRemoteVector stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #ClosureVariablesTest #testOneArrayForTypesIsCreatedWhenAMethodHasNoClosures stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test01TypeConvertionForAClassReturnsSameClass stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test02TypeConvertionForSelfTypeReturnsReceiversType stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test03TypeConvertionForClassTypeReturnsReceiversTypeClass stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test04ClassMessageSendChainsClassType stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test05TypeConvertionForInstanceTypeReturnsMetaclassSoleInstance stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test06newTypeIsMetaclassSoleInstance stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test07InstanceTypeReturnsClassWhenIsKindOfOfBehaviorButNotMeta stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test08InstanceTypeErrorsWhenUsedWithNoBehavior stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #DynamicTypesTest #test09ClassTypeForMetamodelIsMetaclass stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test01TypeCollectionOfInstanceVariableDefinedInLeafClassDoesNotTraverseHierarchy stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test02TypeCollectionIncludesSubclasses stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test03TypeCollectionDoesNotIncludeSuperclassesAndSiblings stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test05TypeCollectionIncludesAllSubclasses stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test06IsNotMegamorphicIfTypesSizeIsLessToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test07IsMegamorphicIfTypesSizeIsEqualToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test08IsNotMegamorphicIfDoesNotFillRawTypesForLocalTypeInfo stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test09IsMegamorphicIfFillsRawTypesOfDefiningClassForLocalTypeInfo stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test10IsMegamorphicIfFillsRawTypesOfNotDefiningClassForLocalTypeInfo stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test11IsTypesEmptyOfNonLocalTypeInfoTakesCareOfHierarchy stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test12IsTypesEmptyForLocalTypeInfoOnlyCheckOnLocalRawTypes stamp: 'JFGO 10/12/2024 16:09:22'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/12/2024 16:09:22'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/12/2024 16:09:23'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #InstanceVariableTypeInfoTest #test13RemovingAClassRemovesItAndItsClassFromInstanceVariableRawTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test14InstVarAtPutKeepTypeInfo stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test01InstanceVariablesTypesIsInitializedWithAnArrayOfClassInstSize stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test02InitializeInstanceVariablesTypesWithAllInstancesStoreCurrentClassInstancesTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test03TypesOfDifferentInstVarsAreStoredCorrectly stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test04MoreThanOneTypeAreStoredCorrectlyInDifferentInstVars stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test05TypesAreStoredUpToInstVarTypesSize stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test06NoTypesAreStoredWhenInstVarTypesIsNil stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test07CommonSupertypeOfReturnsSupertypeOfStoredTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test08CommonSupertypeIfNoTypesEvaluatesAlternativeBlockWhenNoTypeHasBeenStore stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test09EvaluatesIfAbsentBlockWhenAskTypeInfoForNonExistingInstVar stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test01KeepTypesOfLocalTemporariesI stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test02KeepTypesOfRemoteTemporaries stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test03KeepTypesOfParameters stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test04KeepReturnTopTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test05KeepReturnConstantTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test06KeepReturnReceiverTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test07KeepReturnFromClosureTypes stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test08KeepReturnTypeWhenUnwind stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test09BlockReturnDoesNotAffectMethodReturn stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test10KeepTypesOfParametersWhenSendingValueWithArguments stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test11BlockWithParametersDoNotAffectMethodParameters stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test000_AutocompletesMessagesFor_GlobalVariables_WithSelectorsFromTheirClasses stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test001_AutocompletesMessagesFor_Self_WithSelectorsFromTheBrowsedClass stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test002_AutocompletesMessagesFor_Super_WithSelectorsFromTheBrowsedClass stamp: 'JFGO 10/12/2024 16:09:24'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test003_AutocompletesMessagesFor_Super_WithSelectorsForUnknownClassesWhenTheBrowsedClassDoesNotHaveASuperclass stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test004_AutocompletesMessagesFor_True_WithSelectorsFromTrue stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test005_AutocompletesMessagesFor_False_WithSelectorsFromFalse stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test006_AutocompletesMessagesFor_Nil_WithSelectorsFromUndefinedObject stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test007_AutocompletesMessagesFor_Characters_WithSelectorsFromCharacter stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test008_AutocompletesMessagesFor_Numbers_WithSelectorsFromTheirClass stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test009_AutocompletesMessagesFor_Strings_WithSelectorsFromString stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test010_AutocompletesMessagesFor_Symbols_WithSelectorsFromSymbol stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test011_AutocompletesMessagesFor_StringSymbol_WithSelectorsFromSymbol stamp: 'JFGO 10/12/2024 16:09:25'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test012_AutocompletesMessagesFor_InstanceVariables stamp: 'JFGO 10/12/2024 16:09:26'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test012_AutocompletesMessagesFor_InstanceVariables_WithSelectorsOfInstVarTypes stamp: 'JFGO 10/12/2024 16:09:26'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test013_AutocompletesMessagesFor_MethodArguments_WithSelectorsForUnknownClasses stamp: 'JFGO 10/12/2024 16:09:27'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test014_AutocompletesMessagesFor_TemporaryVariables_WithSelectorsForUnknownClasses stamp: 'JFGO 10/12/2024 16:09:28'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test014_AutocompletesMessagesFor_TemporaryVariables_WithSelectorsOfTempVarTypes stamp: 'JFGO 10/12/2024 16:09:28'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test015_AutocompletesMessagesFor_BlockArguments_WithSelectorsForUnknownClasses stamp: 'JFGO 10/12/2024 16:09:29'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test016_AutocompletesMessagesFor_BlockTemporaryVariables_WithSelectorsForUnknownClasses stamp: 'JFGO 10/12/2024 16:09:30'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test017_AutocompletesMessagesFor_NilWorkspaceVariables_WithSelectorsForUnknownClasses stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test017_AutocompletesMessagesFor_NonNilWorkspaceVariables_WithSelectorsFromTheirClasses stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test018_AutocompletesMessagesFor_ThisContext_WithSelectorsFromMethodContext stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test019_AutocompletesMessagesFor_ClassVariables_WithSelectorsFromTheirClasses stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test020_AutocompletesMessagesFor_PoolConstants_WithSelectorsFromTheirClasses stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test021_AutocompletesMessagesFor_BlockEndings_WithSelectorsFromBlockClosure stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test022_AutocompletesMessagesFor_ArrayEnds_WithSelectorsFromArray stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test023_AutocompletesMessagesFor_RightBraces_WithSelectorsFromArray stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test023_AutocompletingMessagesFor_UnaryMessages stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test024_AutocompletingMessagesFor_RightParenthesis stamp: 'JFGO 10/12/2024 16:09:31'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test025_AutocompletesMessagesFor_UnknownIdentifiers_WithSelectorsForUnknownClasses stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test026_AutocompletingMessagesFor_Cascade stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test027_AutocompletesEntriesFor_GlobalVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test028_AutocompletesEntriesFor_PoolConstants_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test029_AutocompletesEntriesFor_WorkspaceVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test030_AutocompletesEntriesFor_ClassVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test031_AutocompletesEntriesFor_InstanceVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test032_AutocompletesEntriesFor_MethodArguments_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test033_AutocompletesEntriesFor_TemporaryVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test034_AutocompletesEntriesFor_BlockArguments_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test035_AutocompletesEntriesFor_BlockTemporaryVariables_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test036_AutocompletesEntriesFor_IncompleteIdentifiers_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test037_AutocompletesEntriesFor_ReservedNames_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test038_DoesNotAutocompleteEntriesFor_UndefinedIdentifiers stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test039_AutocompletesEntriesFor_BinaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test040_AutocompletesEntriesFor_IncompleteBinaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test041_AutocompletesEntriesFor_UnaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test042_AutocompletesEntriesFor_IncompleteUnaryMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test043_AutocompletesEntriesFor_KeywordMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test044_AutocompletesEntriesFor_IncompleteKeywordMessages_WithIdentifiersBegginingWithThem stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test045_AutocompletesEntriesFor_patternUnary_containsExactlyTwoMethods stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test046_AutocompletesEntriesFor_patternUnary_notContainsAnyMethod stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test047_AutocompletesEntriesFor_patternUnary_doesNotAutocompleteMethodOfSameClass stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test048_AutocompletesEntriesFor_patternKeyword_containsExactlyOneMethod stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test049_AutocompletesEntriesFor_patternKeyword_notContainsAnyMethod stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test050_AutocompletesEntriesFor_patternKeyword_doesNotAutocompleteMethodOfSameClass stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test051_AutocompletesEntriesFor_patternBinary_containsExactlyOneMethod stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test052_AutocompletesEntriesFor_patternBinary_notContainsAnyMethod stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test053_AutocompletesEntriesFor_patternBinary_doestNotAutocompleteMethodOfSameClass stamp: 'JFGO 10/12/2024 16:09:32'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #testMessages stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ArrayWithArrayAndOtherObjects stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArray stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArrayOfArray stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArrayWithManyElements stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBinaryInParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlock stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlockOfBlock stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlockOfEvaluatedBlock stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndExpresionInParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndLiteralArray stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndMoreThanOneUnaryAfterExpresionInParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterBlock stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterBrace stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterCharacter stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterLiteralArray stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterStringSymbol stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterSymbol stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUnaryInProtoObject stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteKeywordAfterParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteKeywordAfterUnary stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteMessageAfterUnary stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryInParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryWithMoreThanOneUnary stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryWithOneUnary stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ClosedAndUnclosedParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ExpressionInManyParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ExpressionWithMoreThanOneParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_LFBeforeParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_SpaceBeforeParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnaryAfterExpresionInParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedArrayAfterClosedArray stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedBlockAfterBlock stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedDoubleParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_selfInProtoObject stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_ExpresionInParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_MoreThanOneUnaryMessage stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_OnlyRightParenthesis stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #MethodNotAnnotatingTypesTest #test01CanSignalItWithAMethod stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!testRun: #MethodNotAnnotatingTypesTest #test02IsResumable stamp: 'JFGO 10/12/2024 16:09:33'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/12/2024 16:09:33'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/12/2024 16:09:34'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test01RemovingAClassRemovesItFromMethodVariableRawTypesForParameter stamp: 'JFGO 10/12/2024 16:09:34'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/12/2024 16:09:34'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/12/2024 16:09:35'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test02RemovingAClassRemovesItsClassFromMethodVariableRawTypesForParameter stamp: 'JFGO 10/12/2024 16:09:35'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/12/2024 16:09:35'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/12/2024 16:09:35'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test03RemovingAClassRemovesItFromMethodVariablesRawTypes stamp: 'JFGO 10/12/2024 16:09:36'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/12/2024 16:09:36'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/12/2024 16:09:36'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test04RemovingAClassRemovesItFromMethodVariableRemoteVectorRawTypes stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test01ActualSendersIsEmpty stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test02CategoryIsNil stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test03CompiledMethodSignalsError stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test04CompiledMethodIfAbsentEvaluatesIfAbsentBlock stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test05doesOnlySurelySendReturnsFalse stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test06dynamicTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test07IsNotValid stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test08liveTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test09rangesOASentSelectorWhenSendToReceiverTypesIsEmpty stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test10FailsWhenAsItsSourceCode stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #NotImplementedMethodTest #test11StringVersionStartsWithNotImplemented stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!testRun: #PossibleSenderTest #test01StringVersionBeginsWithPossible stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:37'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:37'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:37'!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1 ]! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:37'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:37' prior: 50613207!
m3 | x | self m1. false ifTrue: [ x m1: 1 ]! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:37'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test01DoesNotChangePossibleMessageSendWhenInstructedToDoSo stamp: 'JFGO 10/12/2024 16:09:37'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:38'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:38'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:38'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:38'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:38'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:38'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!testRun: #RemoveParameterWithActualScopeTest #test02CanNotRemoveParameterWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'JFGO 10/12/2024 16:09:38'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:39'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:39'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:39'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:39'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:39'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:39'!
m3 | x | x := ClassOfSender new. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:39'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:39' prior: 50613307!
m3 | x | x := ClassOfSender new. x m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:39'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test03RemovesParameterWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'JFGO 10/12/2024 16:09:39'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:40'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:40'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:40'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:40'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:40'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:40'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:40'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:40'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:40'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:40' prior: 50613368!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:40'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/12/2024 16:09:40'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test04RemovesParameterWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'JFGO 10/12/2024 16:09:40'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:41'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:42'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:42'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:42'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:42'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:42'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:42'!
m3 | x y | x := self. y := ClassOfSender new. x m1: 1. y m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:42'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:42'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:42' prior: 50613435!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:42'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/12/2024 16:09:42'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test05RemovesParameterInDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'JFGO 10/12/2024 16:09:42'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:43'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:43'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:43'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:43'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:43'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:43'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:43'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1: 1. y m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:43'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:43'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:43' prior: 50613502!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:43'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/12/2024 16:09:43'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test06RemovesParameterInDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'JFGO 10/12/2024 16:09:43'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:44'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:44'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:44'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:44'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:44'!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1]! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:44'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:44' prior: 50613559!
m3 | x | self m1. false ifTrue: [ x m1]! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:44'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test07RemovesParameterToPossibleMessageSendIfInstructedToDoSo stamp: 'JFGO 10/12/2024 16:09:44'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:45'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:45'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:45'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:45'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:45'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:45'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:45' prior: 50613609!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!methodRemoval: ClassOfSender #m1: stamp: 'JFGO 10/12/2024 16:09:45'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test08RemovesParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'JFGO 10/12/2024 16:09:45'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:46'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:46'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:46'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:46'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:46'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:46'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:46'!
m3 self m1: 1. ClassOfSender new m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:46'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:46' prior: 50613671!
m3 self m1. ClassOfSender new m1: 1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:46'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test09RemovesParameterOnlyToValidMessageSendWhenMoreSendsInSameMethod stamp: 'JFGO 10/12/2024 16:09:47'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:47'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:48'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:48'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:48'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:48'!
m3 |x| self m1: 1. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:48'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:48' prior: 50613720!
m3 |x| self m1. x m1: 1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'JFGO 10/12/2024 16:09:48'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenRemovingParameterToMethodWithSureAndPossibleSenders stamp: 'JFGO 10/12/2024 16:09:48'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:49'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:49'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:49'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:49'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:49'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:49'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1; printString! !

!testRun: #RemoveParameterWithActualScopeTest #test11CanNotRemoveParameterWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'JFGO 10/12/2024 16:09:49'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:50'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:50'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveParameterWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'JFGO 10/12/2024 16:09:50'!
PASSED!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:50'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:50'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:50'!
m1: p1 m2: p2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:50'!
m3 self m1: 1 m2: 2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:50'!
m2: p2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:50' prior: 50613825!
m3 self m2: 2! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'JFGO 10/12/2024 16:09:50'!
m1: p1 m2: p2!

!testRun: #RemoveParameterWithActualScopeTest #test13RemovesOtherThanLastParameterCorrectly stamp: 'JFGO 10/12/2024 16:09:50'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:51'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveParameter stamp: 'JFGO 10/12/2024 16:09:52'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:52'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:52'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:52'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:52'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:52' prior: 50613872!
m3 | x | self m2. false ifTrue: [ x m1 ]! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:09:52'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test01DoesNotRenamesPossibleMessageSendWhenInstructedToDoSo stamp: 'JFGO 10/12/2024 16:09:52'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:09:53'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:53'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:53'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:53'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:53'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:53'!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!testRun: #RenameSelectorWithActualScopeTest #test02CanNotRenameWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'JFGO 10/12/2024 16:09:53'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:09:54'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:54'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:54'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:54'!
ClassToRenameSelector subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:54'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:54'!
m3 | x | x := ClassOfSender new. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:54'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:54' prior: 50613971!
m3 | x | x := ClassOfSender new. x m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:09:54'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test03RenamesWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'JFGO 10/12/2024 16:09:54'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:55'!
ClassToRenameSelector subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:09:55'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:55'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:55'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:55'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:55'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:55'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:55'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:55'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:55' prior: 50614031!
m3 | x | x := self. x := ClassOfSender new. x m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:09:55'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:55'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test04RenamesWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'JFGO 10/12/2024 16:09:55'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:09:56'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:57'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:57'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:57'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:57'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:57'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:57'!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:57'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:57'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:57' prior: 50614097!
m3 | x y | x := self. y := ClassOfSender new. x m2. y m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:09:57'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:57'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test05RenamesDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'JFGO 10/12/2024 16:09:57'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:09:58'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:58'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:58'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:58'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:58'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:58'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:58'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:58'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:58'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:58' prior: 50614163!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m2. y m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:09:58'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:09:58'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test06RenamesDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'JFGO 10/12/2024 16:09:58'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:09:59'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:09:59'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:09:59'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:59'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:59'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:59'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:09:59' prior: 50614219!
m3 | x | self m2. false ifTrue: [ x m2 ]! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:09:59'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test07RenamePossibleMessageSendIfInstructedToDoSo stamp: 'JFGO 10/12/2024 16:09:59'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:10:00'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:00'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:00'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:00'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:00'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:00'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:00' prior: 50614268!
m3 | x | x := self. x := ClassOfSender new. x m2! !

!methodRemoval: ClassOfSender #m1 stamp: 'JFGO 10/12/2024 16:10:00'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test08RenamesWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'JFGO 10/12/2024 16:10:00'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:10:01'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:10:01'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:02'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:02'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:02'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:02'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:02'!
m3 self m1. ClassOfSender new m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:02'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:02' prior: 50614330!
m3 self m2. ClassOfSender new m1! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:10:02'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test09RenamesOnlyValidMessageSendWhenMoreSendsInSameMethod stamp: 'JFGO 10/12/2024 16:10:02'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:10:02'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:10:03'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:03'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:03'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:03'!
m3 |x| self m1. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:03'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:03' prior: 50614377!
m3 |x| self m2. x m1! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'JFGO 10/12/2024 16:10:03'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenRenamingAMethodWithSureAndPossibleSenders stamp: 'JFGO 10/12/2024 16:10:03'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:10:04'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:04'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'JFGO 10/12/2024 16:10:04'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:04'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:04'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 16:10:04'!
m3 | x | x := self. x := ClassOfSender new. x m1; printString! !

!testRun: #RenameSelectorWithActualScopeTest #test11CanNotRenameWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'JFGO 10/12/2024 16:10:04'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'JFGO 10/12/2024 16:10:05'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'JFGO 10/12/2024 16:10:05'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameSelectorWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'JFGO 10/12/2024 16:10:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test01QuickReturnSelfMethodsReturnSelfTypeAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test02QuickReturnTrueMethodsReturnTrueReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test03QuickReturnFalseMethodsReturnFalseAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test04QuickReturnNilMethodsReturnUndefinedObjectAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test05QuickReturnMinusOneMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test06QuickReturnZeroMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test07QuickReturnOneMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test08QuickReturnTwoMethodsReturnSmallIntegerAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test09QuickReturnOfFirstInstanceVariableMethodsReturnInstanceVariableTypesAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test10QuickReturnOfSecondInstanceVariableMethodsReturnInstanceVariableTypesAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test11classMethodReturnsClassTypeAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test12newMethodReturnsInstanceTypeAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test13yourselfMethodReturnsSelfTypeAsReturnType stamp: 'JFGO 10/12/2024 16:10:06'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'JFGO 10/12/2024 16:10:06'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'JFGO 10/12/2024 16:10:06'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #ReturnTypeInfoTest #test14RemovingAClassRemovesItAndItsClassFromMethodReturnType stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #ReturnTypeInfoTest #test15ReturnTypesOfAbstractMethodsIncludesSubclassesImplementationsTypes stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #ReturnTypeInfoTest #test16ReturnTypesOfAbstractMethodWorksWhenNotImplementedInAllSubclasses stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test01IsEmptyWhenAllTypesAreNil stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test02StoresAddedTypes stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test03StoresSameTypeOnce stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test04StoresMoreThanOneTypeCorrectly stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test05DoesNotStoreTypesWhenContainerIsNil stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test06CommonSupertypeOfSiblingsClassesReturnsRightSuperclass stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test07CommonSupertypeOnSameHierarchyIsMostTopClass stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test08CommonSupertypeOnSameHierarchyIsNotAffectedByAddingOrder stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test09ObjectIsCommonSupertypeWhenClassesAreNotSiblings stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test10ProtoObjectIsCommonSupertypeWhenThereAreNoTypesStored stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test11ProtoObjectIsCommonSupertypeWhenCointainerIsNil stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test12CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenIsEmpty stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test13CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenContainerIsNil stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test14UndefinedObjectIsNotConsideredWhenLookingForCommonSupertype stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test15StoresTypesIsTrueWhenContainerIsNotNil stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test16StoresTypesIsFalseWhenContainerIsNil stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test17IsMegamorphicWhenContainerIsFull stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test18IsNotMegamorphicWhenContainerIsNotFull stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test19CommonSelectorsPreviousToSameOnlyTypeIsEmpty stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test20CommonSelectorsPreviousToSuperclassOfOnlyAddedTypeAreAddedTypeSelectors stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test21CommonSelectorsPreviousToSuperclassSuperclassOfOnlyAddedTypeAreAddedTypeUpToSuperclassSelectors stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test22CommonSelectorsPreviousToInvalidSuperclassRaisesError stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test23CommonSelectorsPreviousToSuperclassOfSiblingTypesAreSiblingsCommonSelectors stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test24CommonSelectorsPreviousToOnSameHierarchyReturnsCommonSuperclassesSelectors stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test25CommonSelectorsPreviousToAddedSSupertypeOnSameHierarchyIsEmpty stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test26CommonSelectorsPreviousToWhenNotStoringTypesIsEmpty stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test27CommonSelectorsPreviousToIfInvalidSupertypeEvaluatesInvalidBlock stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test28CommonSelectorsPreviousToIfInvalidSupertypeWithManyTypesEvaluatesInvalidBlock stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test29CommonSelectosGoesUpToIncludingProtoObject stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test30CommonSupertypeIfGenericEvaluatesIfGenericBlockForObject stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test31CommonSupertypeIfGenericEvaluatesIfGenericBlockForProtoObject stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test32WithCommonSupertypeDoIfGenericEvaluatesDoBlockWhenNoGenericSupertype stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test33WithCommonSupertypeDoIfGenericEvaluatesGenericBlockWhenGenericSupertype stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test34AddingATypeWhenNoMoreSpaceEvaluatesIsFullBlock stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test35TypeIsNotMoreInTypesWhenRemoved stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test36RemovingTypeWhenTypesIsEmptyEvaluatesIfAbsent stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test37RemovingNotIncludedTypeEvaluatesIfAbsent stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test38RemovingLastAddedTypeWorksAsExpected stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test39RemoveTypeSignalExceptionWhenTypeNotFound stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test40TypesDoEvaluatesBlockOnEachType stamp: 'JFGO 10/12/2024 16:10:07'!
PASSED!

ParseNodeVisitor subclass: #ParseNodeContextAdaptedVisitor
	instanceVariableNames: 'contextApplier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!

!classDefinition: #ParseNodeContextAdaptedVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 10/12/2024 16:15:31'!
ParseNodeVisitor subclass: #ParseNodeContextAdaptedVisitor
	instanceVariableNames: 'contextApplier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!
!ParseNodeContextAdaptedVisitor methodsFor: 'visiting' stamp: 'JFGO 10/12/2024 16:16:41'!
visitBlockNode
	self subclassResponsibility .! !
!ParseNodeContextAdaptedVisitor methodsFor: 'visiting' stamp: 'JFGO 10/12/2024 16:17:06' overrides: 16919312!
visitBlockNode: aBlockNode
	self subclassResponsibility .! !

!methodRemoval: ParseNodeContextAdaptedVisitor #visitBlockNode stamp: 'JFGO 10/12/2024 16:17:09'!
visitBlockNode
	self subclassResponsibility .!
!ParseNodeContextAdaptedVisitor methodsFor: 'visiting' stamp: 'JFGO 10/12/2024 16:17:23' overrides: 16919345!
visitMessageNode: aMessageNode
	self subclassResponsibility .! !
!ParseNodeContextAdaptedVisitor methodsFor: 'visiting' stamp: 'JFGO 10/12/2024 16:17:42'!
visitMessageNodeArguments:aMessageNode.
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock |  
		contextApplier shouldUpdateFor: aMessageNode visiting: argumentBlock 
			ifUpdated: 	[:newContext | 
				contextApplier:= newContext. 
				argumentBlock accept: self.
				self restorePreviousContext .
				] 
			ifNotUpdated:[ argumentBlock accept: self.				].
	].! !
!ParseNodeContextAdaptedVisitor methodsFor: 'context' stamp: 'JFGO 10/12/2024 16:17:59'!
restorePreviousContext
	contextApplier := contextApplier previous.! !

ParseNodeContextAdaptedVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod parseNode contextBlockNode methodNode types incompleteTypeInfoReasons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!

!classDefinition: #ContextAppliersMethodVisitor category: #'LiveTypingTypeChecker-ContextAppliers' stamp: 'JFGO 10/12/2024 16:18:35'!
ParseNodeContextAdaptedVisitor subclass: #ContextAppliersMethodVisitor
	instanceVariableNames: 'compiledMethod parseNode contextBlockNode methodNode types incompleteTypeInfoReasons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-ContextAppliers'!

!methodRemoval: ContextAppliersMethodVisitor #visitMessageNodeArguments: stamp: 'JFGO 10/12/2024 16:18:43'!
visitMessageNodeArguments:aMessageNode.
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock |  
		contextApplier shouldUpdateFor: aMessageNode visiting: argumentBlock 
			ifUpdated: 	[:newContext | 
				contextApplier:= newContext. 
				argumentBlock accept: self.
				self restorePreviousContext .
				] 
			ifNotUpdated:[ argumentBlock accept: self.				].
	].!

!methodRemoval: ContextAppliersMethodVisitor #restorePreviousContext stamp: 'JFGO 10/12/2024 16:18:55'!
restorePreviousContext
	contextApplier := contextApplier previous.!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/12/2024 16:19:02'!
ERROR!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:19:08'!
ERROR!
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 10/12/2024 16:19:58' prior: 50536875 overrides: 50614732!
visitBlockNode: aBlockNode
	
	(aBlockNode = contextBlockNode) ifTrue:[ | liveTypes |
		
		liveTypes:= contextApplier liveTypesFor: parseNode in: compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons .
		liveTypes classTypesDo: [:aClass | types add:aClass].
		types:= types asArray .
		^self.
	].
	
	
	! !

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:20:23'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/12/2024 16:20:31'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/12/2024 16:20:32'!
FAILURE!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:20:35'!
FAILURE!
!ParseNodeContextAdaptedVisitor methodsFor: 'visiting' stamp: 'JFGO 10/12/2024 16:21:08' prior: 50614732 overrides: 16919312!
visitBlockNode: aBlockNode
	super visitBlockNode: aBlockNode.! !
!ContextAppliersMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 9/23/2024 15:33:59' prior: 50615057 overrides: 50615325!
visitBlockNode: aBlockNode
	
	(aBlockNode = contextBlockNode) ifTrue:[ | liveTypes |
		
		liveTypes:= contextApplier liveTypesFor: parseNode in: compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons .
		liveTypes classTypesDo: [:aClass | types add:aClass].
		types:= types asArray .
		^self.
	].
	super visitBlockNode: aBlockNode.
	
	! !

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/12/2024 16:21:50'!
PASSED!

ParseNodeContextAdaptedVisitor subclass: #TypeCheckerDragonMethodVisitor
	instanceVariableNames: 'compiledMethod methodNode issues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-TypeCheckingDragon'!

!classDefinition: #TypeCheckerDragonMethodVisitor category: #'LiveTypingTypeChecker-TypeCheckingDragon' stamp: 'JFGO 10/12/2024 16:22:43'!
ParseNodeContextAdaptedVisitor subclass: #TypeCheckerDragonMethodVisitor
	instanceVariableNames: 'compiledMethod methodNode issues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'LiveTypingTypeChecker-TypeCheckingDragon'!

!methodRemoval: TypeCheckerDragonMethodVisitor #visitBlockNode: stamp: 'JFGO 10/12/2024 16:23:35'!
visitBlockNode: aBlockNode
	super visitBlockNode: aBlockNode.!

!methodRemoval: TypeCheckerDragonMethodVisitor #visitMessageNodeArguments: stamp: 'JFGO 10/12/2024 16:23:41'!
visitMessageNodeArguments: aMessageNode
	
	aMessageNode argumentsInEvaluationOrder do: [:argumentBlock |  
		contextApplier shouldUpdateFor: aMessageNode visiting: argumentBlock 	ifUpdated: 	[:newContext | 
				contextApplier:= newContext. 
				argumentBlock accept: self.
				self restorePreviousContext .
			] 
			ifNotUpdated:[ argumentBlock accept: self.				].
	].!

!methodRemoval: TypeCheckerDragonMethodVisitor #restorePreviousContext stamp: 'JFGO 10/12/2024 16:23:47'!
restorePreviousContext
	contextApplier := contextApplier previous.!

!testRun: #ManyMethodsTypeCheckerDragonTest #test01ManyMethodsCanBeTypeChecked stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test02ClassesCanBeTypeChecked stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test04AlertsDetectIfNone stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test05AlertsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test07ErrorsDetectIfNone stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test10WarningsDetectIfNone stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test15HasErrorsOrWarnings stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test14TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test17TypeCastManyVariablesNestedRejectionsRejectsEachLevelCastedTypeForEachVariable stamp: 'JFGO 10/12/2024 16:23:59'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test01ManyMethodsCanBeTypeChecked stamp: 'JFGO 10/12/2024 16:24:03'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test02ClassesCanBeTypeChecked stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test04AlertsDetectIfNone stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test05AlertsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test07ErrorsDetectIfNone stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test10WarningsDetectIfNone stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #ManyMethodsTypeCheckerDragonTest #test15HasErrorsOrWarnings stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test01MethodTypedCorrectlyDoesNotGenerateIssues stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test02MethodThatDontCheckTypesGeneratesIssue stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test03PrimitiveMethodsDontCheckTypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test04MethodWithMessageNotUnderstoodByReceiverGeneratesError stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test05MethodWithTypeErrorOnMessageReceiverGeneratesAlert stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test06MethodWithManyTypeErrorsOnMessageGeneratesManyAlerts stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test07MethodWithMessageWithNoReceiverTypeGeneratesAlert stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test08MethodWithMessageNotUnderstoodInArgumentsGeneratesAlerts stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test09MethodThatThrowsSpecificExceptionDoesNoGenerateAlerts stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test10MessageSentToMethodWithNoReturnTypeGeneratesIssue stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test11MethodWithCollectionItemsGeneratesAlertForBlockVariable stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test12MethodWithVariableManyTypesGeneratesAlertForEachUnsupportedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test13TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test14TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test15TypeCastIfTrueIfFalseCorrectlyAppliesAndRejectsCastedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test16TypeCastNestedRejectionsRejectsEachLevelCastedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #MethodTypeCheckerDragonTest #test17TypeCastManyVariablesNestedRejectionsRejectsEachLevelCastedTypeForEachVariable stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test01TypeCastIfTrueCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02TypeCastIfFalseReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test02_1TypeCastIfFalseReturnsAllTypesWhenBlockIsVariable stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test03TypeCastIfFalseNestedReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test04TypeCastIfFalseIfTrueReturnsTypesCorrectlyForEachBlock stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test05TypeCastIfTrueIfFalseReturnsAllTypesWhenVariableIsNotAffectedByCondition stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test06TypeCastIfTrueIfFalseOverDifferentNodesGivesRightContextToEach stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test07TypeCastAppliesCorrectlyToParseNodeClass stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test08TypeCastAppliesCorrectlyToMessageNodeSelector stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test09TypeCastAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test10TypeCastDistinctIfTrueReturnsAllTypesButRejected stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test11TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test12TypeCastNegatedIfFalseCorrectlyAppliesCastedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test13TypeCastDistinctAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test14TypeCastDistinctNegatedIfTrueReturnsCastedType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test15TypeCastDistinctNegatedAppliesCorrectlyWhenItBeginsWithClassInCondition stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16TypeCastManyNegationsCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_1TypeCastObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_2TypeCastObjectClassSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_3TypeCastObjectClassToUnexistentSymbolDontApplyContext stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_4TypeCastClassNameToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_5TypeCastClassSymbolToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_6TypeCastClassNameDistinctToObjectClassNameCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test16_7TypeCastObjectClassDistinctSymbolCastCorrectly stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test17BranchesAsMessageReceiverAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test18BranchesAsMessageArgumentAreCorrectlyCasted stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test19ObjectEqualsToLiteralIfFalseReturnsPreviousTypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test20ObjectEqualsToLiteralIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test21ObjectDistinctToLiteralCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test22LiteralEqualsToObjectIfTrueReturnsLiteralType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test23LiteralDistinctToObjectCastCorrectlyBothBranches stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test24WhenConditionIsNotCastingPreservePreviousTypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test25IsKindOfForChildTypesFixesType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test26IsKindOfCastingSupertypeKeepsSubtypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test27IsKindOfRejectingSupertypeExcludeAllSubtypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28IsIsTypeMessageCastType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test28_1IsIsTypeMessageReturnsOriginalTypesWhenSubclassesOfCastType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test29IsIsTypeMessageWhenRejectingTypeShouldFilter stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test30IsIsTypeMessageOnDIfferentVariableShouldntFilter stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test31IsIsTypeMessageOnDIfferentTypesShouldRemoveAll stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test32IsNilMessageIfTrueCastToNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test33ObjectEqualsToNilCastToNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test34ObjectEqualsToNilIfFalseRejectsNilType stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test35NilEqualsToObjectCastToNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test36ObjectDistinctToNilCastOnFalseRejectsOnTrue stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test37IsNilMessageIfFalseRejectsNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test38notNilMessageIfTrueRejectsNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test39NotNilMessageIfFalseCastToNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test40IfNilMessageCastToNil stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test41IfNotNilKeepsPreviousTypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test42DisjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test44NegatedDisjunctionRejectsCastedTypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test45ConjunctionOnDifferentTypesCollectsThemAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test46NegatedConjunctionAllowsAllPreviousTypes stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test47ManyDisjunctionCollectsEachOneAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test48ManyConjunctionCollectsCommonTypesAndRejectsRemaining stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!

!testRun: #TypesWithContextAppliersTest #test49ConjunctionOnlyOnOneSideAffectingContextIgnoreOtherside stamp: 'JFGO 10/12/2024 16:24:04'!
PASSED!
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 9/18/2024 18:42:09' prior: 50536816 overrides: 50614742!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverLiveType  |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverLiveType:=contextApplier receiverLiveTypesFor: aMessageNode in: compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
		
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverLiveType isEmptyType and: [ incompleteTypeInfo isEmpty])
		ifTrue: [issues add: (TypeCheckingDragonIncompleteInformation on: compiledMethod for: methodNode by: aMessageNode)]
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedIn: receiverLiveType ].
	
	self visitMessageNodeArguments:aMessageNode.! !
!TypeCheckerDragonMethodVisitor methodsFor: 'visiting' stamp: 'JFGO 9/18/2024 18:42:09' prior: 50616150 overrides: 50614742!
visitMessageNode: aMessageNode
	| incompleteTypeInfo receiverLiveType  |
	aMessageNode receiver accept: self.
	
	
	incompleteTypeInfo := OrderedCollection new. 
	receiverLiveType:=contextApplier receiverLiveTypesFor: aMessageNode in: compiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfo.
		
	incompleteTypeInfo do: [ :anIncompleteTypeInfoReason | anIncompleteTypeInfoReason addTo: self node: aMessageNode ].
	
	(receiverLiveType isEmptyType and: [ incompleteTypeInfo isEmpty])
		ifTrue: [issues add: (TypeCheckingDragonIncompleteInformation on: compiledMethod for: methodNode by: aMessageNode)]
		ifFalse: [ self checkMessageSentIn: aMessageNode isImplementedIn: receiverLiveType ].
	
	self visitMessageNodeArguments:aMessageNode.! !
Morphic view for MessageSet models. See category 'GUI building'.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 17:22:52' prior: 50534083!
initializeGenericClassesInfo

	LiveTyping initializeGenerics.
	
	"initialize generic info for supported generic types"
	{
		Array.
		Array2D.
		RunArray.
		RunNotArray.
		ShortRunArray.
		Heap.
		LinkedList.
		OrderedCollection.
		SortedCollection.
		Bag.
		IdentityBag.
		Set.
		IdentitySet.
		Dictionary.
		IdentityDictionary.
		OrderedDictionary.
		
		"the following classes only have very basic support"
		WeakArray.
		WeakKeyDictionary.
		WeakIdentityKeyDictionary.
		WeakRegistry.
		WeakSet.
		WeakIdentitySet.
		WeakValueDictionary.
	}
	do: [:aType | 
		aType initializeGeneric.	
	].! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 17:22:52' prior: 50534116 overrides: 16916096!
initialize

	Utilities informUser: 'Initializing live typing generics' during: [ self initializeLiveTypingGenerics ].! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 17:22:52' prior: 50534106!
runExamples

	"run examples so that live typing collects type info"
	
	GenericsExamples new runAllExamples.
	
	Observed initializeGeneric.
	ObservedExample new example.! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 17:22:52' prior: 50534060!
addClassVarsToLiveTyping

	| ltc storageVarName |
	ltc := LiveTyping class.
	storageVarName := 'genericsStorage'.
	(ltc definesInstanceVariableNamed: storageVarName) ifFalse: [
		ltc addInstVarName: storageVarName.
	].! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 17:22:52' prior: 50534070!
deleteOldLiveTypingMethods

	ParseNode allSubclassesDo: [:aSubClass | | classOrganization |
		classOrganization := aSubClass organization.
		(classOrganization categoryOfElement: #typesIn:addingIncompleteTypeInfoTo:)	 = '*LiveTyping' ifTrue:[
			aSubClass removeSelector: #typesIn:addingIncompleteTypeInfoTo:.
		].
	].
	! !
!LiveTypingGenerics class methodsFor: 'as yet unclassified' stamp: 'JFGO 10/12/2024 17:22:52' prior: 50534123!
initializeLiveTypingGenerics

	self addClassVarsToLiveTyping.
	self deleteOldLiveTypingMethods.
	self initializeGenericClassesInfo.
	self runExamples.
	! !
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!
This class was taken from previous work by alf & mtqp, 2021, and modified and extended as needed.!

----QUIT----(12 October 2024 17:24:11) CuisUniversity-6169.image priorSource: 8925160!